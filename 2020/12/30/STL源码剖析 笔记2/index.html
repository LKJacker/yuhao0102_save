<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="迭代器概念与traits编程技法迭代器是一种抽象的设计概念，现实程序语言中并没有直接对应于这个概念的实物。 迭代器设计思维——STL关键所在不论是泛型思维或STL的实际运用，迭代器都扮演这重要的角色。STL的中心思想在于：将数据容器和算法分开，彼此独立设计，最后再以一贴胶着剂将它们撮合在一起。容器和算法的泛型化，从技术的角度来看是并不困难，C++的class template和function t">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="STL 源码剖析 笔记2">
<meta property="og:url" content="http://yoursite.com/2020/12/30/STL源码剖析 笔记2/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="迭代器概念与traits编程技法迭代器是一种抽象的设计概念，现实程序语言中并没有直接对应于这个概念的实物。 迭代器设计思维——STL关键所在不论是泛型思维或STL的实际运用，迭代器都扮演这重要的角色。STL的中心思想在于：将数据容器和算法分开，彼此独立设计，最后再以一贴胶着剂将它们撮合在一起。容器和算法的泛型化，从技术的角度来看是并不困难，C++的class template和function t">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/1608959630.png">
<meta property="og:image" content="http://yoursite.com/img/1609574454.png">
<meta property="og:image" content="http://yoursite.com/2020/12/30/STL源码剖析%20笔记2/1609581571.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609589397.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609589884.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609590017.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609590056.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609590082.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609590834.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609591356.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609603712.png">
<meta property="og:image" content="http://yoursite.com/img/1609605134.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609605212.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609640774.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609641339.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609641622.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609641867.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609645158.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609645423.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609646609.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609646690.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609732832.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609733154.jpg">
<meta property="og:image" content="http://yoursite.com/img/20210104160923.png">
<meta property="og:image" content="http://yoursite.com/img/1609759644.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609762206.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609764727.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609765004.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609767703.jpg">
<meta property="og:image" content="http://yoursite.com/img/1609767737.jpg">
<meta property="og:updated_time" content="2021-01-04T14:09:49.669Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="STL 源码剖析 笔记2">
<meta name="twitter:description" content="迭代器概念与traits编程技法迭代器是一种抽象的设计概念，现实程序语言中并没有直接对应于这个概念的实物。 迭代器设计思维——STL关键所在不论是泛型思维或STL的实际运用，迭代器都扮演这重要的角色。STL的中心思想在于：将数据容器和算法分开，彼此独立设计，最后再以一贴胶着剂将它们撮合在一起。容器和算法的泛型化，从技术的角度来看是并不困难，C++的class template和function t">
<meta name="twitter:image" content="http://yoursite.com/img/1608959630.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/12/30/STL源码剖析 笔记2/">





  <title>STL 源码剖析 笔记2 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/30/STL源码剖析 笔记2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">STL 源码剖析 笔记2</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-30T09:13:00+08:00">
                2020-12-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="迭代器概念与traits编程技法"><a href="#迭代器概念与traits编程技法" class="headerlink" title="迭代器概念与traits编程技法"></a>迭代器概念与traits编程技法</h1><p>迭代器是一种抽象的设计概念，现实程序语言中并没有直接对应于这个概念的实物。</p>
<h2 id="迭代器设计思维——STL关键所在"><a href="#迭代器设计思维——STL关键所在" class="headerlink" title="迭代器设计思维——STL关键所在"></a>迭代器设计思维——STL关键所在</h2><p>不论是泛型思维或STL的实际运用，迭代器都扮演这重要的角色。STL的中心思想在于：将数据容器和算法分开，彼此独立设计，最后再以一贴胶着剂将它们撮合在一起。容器和算法的泛型化，从技术的角度来看是并不困难，C++的class template和function templates可分别达成目标。</p>
<p>以下是容器、算法、迭代器的合作展示，以算法<code>find()</code>为例，它接受两个迭代器和一个“搜索目标”：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">find</span>(<span class="title">InputIterator</span> <span class="title">first</span>,<span class="title">InputIterator</span> <span class="title">last</span>,<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span>(first=!last&amp;&amp;*first!=value)</span><br><span class="line">       ++first;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只要给出不同的迭代器，<code>find()</code>便能够对不同的容器进行直接操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> arraySize=<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> ia[arraySize]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivect(ia,ia+arraySize);</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ilist(ia,ia+arraySize);</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; ideque(ia,ia+arraySize);</span><br><span class="line">    <span class="comment">//注意算法和成员方法的区别</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it1=find(ivect.begin(),ivect.end(),<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span>(it1!=ivect.end())</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"4 found. "</span>&lt;&lt;*it1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"4 not found."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it2=find(ilist.begin(),ilist.end(),<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span>(it2==ilist.end())</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"6 not found. "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"6 found. "</span>&lt;&lt;*it2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it3=find(ideque.begin(),ideque.end(),<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(it3==ideque.end())</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"8 not found."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"8 found. "</span>&lt;&lt;*it3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的例子看来，迭代器似乎依附于在容器之下，是吗？有没有独立而泛用的迭代器？我们又该如何自行设计特殊的迭代器？</p>
<h2 id="迭代器是一种smart-pointer"><a href="#迭代器是一种smart-pointer" class="headerlink" title="迭代器是一种smart pointer"></a>迭代器是一种smart pointer</h2><p>迭代器是一种行为类似指针的对象，而指针的各种行为中最常见也最重要的便是内容提领（dereference）和成员访问（member access），因此，迭代器最重要的编程工作就是对<code>operator*</code>和<code>operator-&gt;</code>进行重载工作。关于这一点，C++标准库有一个<code>auto_ptr</code>可供我们参考。这是一个用来包含原生指针的对象，声名狼藉的内存泄露问题可借此获得解决。<code>auto_ptr</code>用法如下，和原生指针一模一样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; ps(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"jjhou"</span>));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*ps&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ps-&gt;size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//离开前不需要delete，auto_ptr会自动释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数第一行的意思是，以<code>new</code>动态配置一个初值为”jjhou”的string对象，并将所得的结果（一个原生指针）作为<code>auto_ptr&lt;string&gt;</code>对象的初值。注意，<code>auto_ptr</code>尖括号内放的是”原生指针所指对象“的型别，而不是原生指针的型别。</p>
<p><code>auto_ptr</code>的源代码在头文件<code>&lt;memory&gt;</code>中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:autoptr.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">auto_ptr</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit auto_ptr(T *p=0):pointee(p) &#123;&#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">auto_ptr</span>(<span class="title">auto_ptr</span>&lt;U&gt;&amp; <span class="title">rhs</span>):</span>pointee(rhs.release()) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">auto_ptr</span>() &#123;<span class="keyword">delete</span> pointee;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">auto_ptr</span>&lt;T&gt;&amp; <span class="title">operator</span>=(<span class="title">auto_ptr</span>&lt;U&gt; &amp;<span class="title">rhs</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>!=rhs) reset(ths.release());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *pointee;&#125;</span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> pointee;&#125;</span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> pointee;&#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *pointee;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>有了模仿对象，现在我们来为list（链表）设计一个迭代器，假设list及其节点的结构如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;//节点类</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ListItem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListItem(T value):_value(value), _next(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    <span class="function">T <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setNext</span><span class="params">(ListItem&lt;T&gt; *newNode)</span> </span>&#123;</span><br><span class="line">        _next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListItem* <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _next;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _value;</span><br><span class="line">    ListItem* _next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//单链表类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">List</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    List():_size(<span class="number">0</span>) &#123;</span><br><span class="line">        _front = _end = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert_front</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        ListItem&lt;T&gt; *newNode = <span class="keyword">new</span> ListItem&lt;T&gt;(value);</span><br><span class="line">        <span class="keyword">if</span>(_size == <span class="number">0</span>) &#123;</span><br><span class="line">            _end = _front = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            newNode -&gt; setNext(_front);</span><br><span class="line">            _front = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert_end</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        ListItem&lt;T&gt; *newNode = <span class="keyword">new</span> ListItem&lt;T&gt;(value);</span><br><span class="line">        <span class="keyword">if</span>(_size == <span class="number">0</span>) &#123;</span><br><span class="line">            _end = _front = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            _end -&gt; setNext(newNode);</span><br><span class="line">            _end = _end -&gt; getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ListItem&lt;T&gt;* temp = _front;</span><br><span class="line">        <span class="keyword">while</span>(temp != _end -&gt; getNext()) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, temp -&gt; value());</span><br><span class="line">            temp = temp -&gt; getNext(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, _size);</span><br><span class="line">    &#125;</span><br><span class="line">    ListItem&lt;T&gt;*front() &#123;</span><br><span class="line">        <span class="keyword">return</span> _front;</span><br><span class="line">    &#125;</span><br><span class="line">    ListItem&lt;T&gt;*back() &#123;</span><br><span class="line">        <span class="keyword">return</span> _end;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ListItem&lt;T&gt;* _end;</span><br><span class="line">    ListItem&lt;T&gt;* _front;</span><br><span class="line">    <span class="keyword">long</span> _size;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//迭代器类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Item</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">ListIter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Item* ptr;</span><br><span class="line">    </span><br><span class="line">    ListIter(Item* p = <span class="number">0</span>):ptr(p) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    Item&amp; <span class="keyword">operator</span>* () <span class="keyword">const</span> &#123;<span class="keyword">return</span> *ptr;&#125;</span><br><span class="line">    Item* <span class="keyword">operator</span> -&gt; () <span class="keyword">const</span> &#123;<span class="keyword">return</span> ptr;&#125;</span><br><span class="line">    </span><br><span class="line">    ListIter&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        ptr = ptr -&gt; getNext();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListIter <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        ListIter tmp = *<span class="keyword">this</span>;</span><br><span class="line">        ++*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> ListIter&amp; i)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr == i.ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> ListIter&amp; i)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ptr != i.ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ListIter&lt;ListItem&lt;<span class="keyword">int</span>&gt; &gt; find(ListIter&lt;ListItem&lt;<span class="keyword">int</span>&gt; &gt; &amp;begin, ListIter&lt;ListItem&lt;<span class="keyword">int</span>&gt; &gt; &amp;end, <span class="keyword">int</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    ListIter&lt;ListItem&lt;<span class="keyword">int</span>&gt; &gt; first = begin;</span><br><span class="line">    ListIter&lt;ListItem&lt;<span class="keyword">int</span>&gt; &gt; last = end;</span><br><span class="line">    <span class="keyword">while</span>( first != last -&gt; getNext())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(first -&gt; value() != value)</span><br><span class="line">        &#123;</span><br><span class="line">            first++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end -&gt; getNext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>并且加上测试程序：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>&gt; m_ListItor;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ListItor.insert_front(i);</span><br><span class="line">        m_ListItor.insert_end(i + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    m_ListItor.display();        <span class="comment">//5 4 3 2 1 0 2 3 4 5 6 7</span></span><br><span class="line">    </span><br><span class="line">    ListIter&lt;ListItem&lt;<span class="keyword">int</span>&gt; &gt; begin(m_ListItor.front());</span><br><span class="line">    ListIter&lt;ListItem&lt;<span class="keyword">int</span>&gt; &gt; end(m_ListItor.back());</span><br><span class="line">    ListIter&lt;ListItem&lt;<span class="keyword">int</span>&gt; &gt; iter;</span><br><span class="line">    </span><br><span class="line">    iter = find(begin, end, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(iter == end -&gt; getNext())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, <span class="string">"not found"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, iter -&gt; value());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    iter = find(begin, end, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(iter == end -&gt; getNext())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, <span class="string">"not found"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, iter -&gt; value());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上可以看出，为了完成一个针对List而设计的迭代器，我们必须暴露太多有关于<code>List</code>实现细节，在<code>main</code>函数中制作<code>begin()</code>和<code>end()</code>两个迭代器，我们暴露了<code>ListItem</code>，在<code>ListIter class</code>中为了达成operator++，我们暴露了<code>ListItem</code>的操作函数<code>getNext()</code>，如果不是为了迭代器，<code>ListItem</code>是要完全隐藏起来不曝光的。换句话说只有对<code>ListItem</code>的实现细节特别了解，才能设计出迭代器，既然这无法避免，干脆把迭代器的设计工作交给 List 的设计者，如此一来，所有实现细节反而不被使用者发现，这也是为什么 STL 的每一种容器都有自己专属的迭代器的原因。</p>
<h2 id="迭代器相应型别"><a href="#迭代器相应型别" class="headerlink" title="迭代器相应型别"></a>迭代器相应型别</h2><p>在算法运用迭代器的时候，很可能用到起相应型别（即迭代器所指之物的型别），但C++支持sizeof ，并无typeof。<strong>可以利用function template的参数推导机制</strong>。</p>
<ol>
<li>函数参数的情况<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">func_impl</span>(<span class="title">I</span> <span class="title">iter</span>,<span class="title">T</span> <span class="title">t</span>)&#123;</span></span><br><span class="line">    T tmp;<span class="comment">//这里解决了问题，T就是迭代器所指之物的类型</span></span><br><span class="line">　　<span class="comment">//…………</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">func</span>(<span class="title">I</span> <span class="title">iter</span>)&#123;</span></span><br><span class="line">    func_impl(iter,*iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    func(&amp;i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>我们以<code>func()</code>为对外接口，却把实际操作全部置于<code>func_impl()</code>之中。由于<code>func_impl()</code>是一个function template，一旦被调用，编译器会自动进行template参数推导，于是导出型别，顺利解决了问题。迭代器相应型别(associated types)不只是“迭代器所指对象的型别”一种而已。根据经验，最常用的相应型别有五种，然而并非任何情况下任何一种都可利用上述的template参数推导机制来取得，我们需要更全面的解法。</p>
<h2 id="Traits编程技法——STL源代码门钥"><a href="#Traits编程技法——STL源代码门钥" class="headerlink" title="Traits编程技法——STL源代码门钥"></a>Traits编程技法——STL源代码门钥</h2><p>迭代器所指对象的型别，称为该迭代器的value type，上述的参数型别推导技巧虽然可用于value，却非全面可用：万一value type必须用于函数的传回值，就束手无策了，毕竟函数的”template参数推导机制”推而导之的只是参数，无法推导函数的返回值类型。</p>
<p>声明内嵌类型是个好主意：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MyIter</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    T* ptr;</span><br><span class="line">    MyIter(T* p=<span class="number">0</span>):ptr(p)&#123;&#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">I</span>:</span>:value_type<span class="comment">//I::value_type编译器不知道代表一个型别或是一个成员函数或是一个数据成员，关键词typename用以告诉编译器这是一个型别</span></span><br><span class="line">func(I ite)&#123;</span><br><span class="line">    <span class="keyword">return</span> *ite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyIter&lt;<span class="keyword">int</span>&gt; ite(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">8</span>));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;func(ite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，<code>func()</code>的返回类型必须加上关键词，因为是一个template参数，在它被编译器具现化之前，编译器对此一无所悉，换句话说，编译器此时并不知道<code>MyIter&lt;T&gt;::value_type</code>代表的是一个型别或是一个member function或是一个data member。关键词的用意在于告诉编译器这是一个型别，如此才能顺利通过编译。但是并不是所有迭代器都是class，原生指针就不是，如果不是就无法为它定义内嵌型别，但STL（以及整个泛型思维）绝对必须接受原生指针作为一种迭代器，所以上面这样还不够。template partial speciahzation可以做到。</p>
<h3 id="Partial-Specialization（偏特化）的意义"><a href="#Partial-Specialization（偏特化）的意义" class="headerlink" title="Partial Specialization（偏特化）的意义"></a>Partial Specialization（偏特化）的意义</h3><p>如果class template 拥有一个以上的template参数，我们可以针对其中某个（或数个，但非全部）template参数进行特化工作。换句话说，我们可以在泛化设计中提供一个特化版本（也就是将泛化版本中的某些template参数赋予明确的指定）。例如，面对以下这么一个class template：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span> ... &#125;; <span class="comment">// 这个泛化版本允许接受T为任何类型</span></span><br></pre></td></tr></table></figure></p>
<p>我们便很容易接受它有一个形式如下的partial specialization<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&lt;T* &#123; ... &#125;; // 这个泛化版本允许接受T为原生指针的情况</span></span><br></pre></td></tr></table></figure></p>
<p>有了这项利器，我们便可以解决前述“内嵌型别”未能解决的问题。先前的问题是，原生指针并非class，因此无法为它们定义内嵌型别。现在，我们可以针对“迭代器之template参数为指针”者，设计特别版的迭代器。</p>
<p>下面这个class template专门用来“萃取”迭代器的特性，而value type正是迭代器的特性之一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span>	<span class="title">iterator_traits</span>//<span class="title">traits</span> 意为“特性”</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> I::vlue_type value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这个所谓的traits，其意义是，如果I定义自己的value type，那么通过这个traits的作用，萃取出来的value_type就是<code>I::value_type</code>。换句话说，如果I定义有自己的value type ，那个<code>func()</code>可以改写成这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">iteraotr_traits</span>&lt;T&gt;:</span>:value_type<span class="comment">//这一整行是函数返回值</span></span><br><span class="line">	func(T ite)</span><br><span class="line">&#123;    </span><br><span class="line">    <span class="keyword">return</span> *ite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但这除了多了一层间接性，好处是traits可以拥有特化版本。现在，我们令<code>iterator_traites</code>拥有一个partial specializations如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>于是，原生指针<code>int*</code>虽然不是一种class type ，亦可通过traits取其value type。这就解决了先前的问题。但是注意针对“指向常数对象的指针（pointer-to-const）”，下面这个式子得到什么结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iterator_traits&lt;<span class="keyword">const</span> <span class="keyword">int</span>*&gt;::value_type</span><br></pre></td></tr></table></figure></p>
<p>获得的是const int而非int。我们希望利用这种机制来声明一个暂时变量，使其型别与迭代器的value type相同，而现在，声明一个无法复制的暂时变量，没什么用！因此，如果迭代器是一个pointer-to-const，我们应该设法令其value type为一个non-const型别。只需要另外设计一个特化版本就可以解决问题：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt;&#123;</span><span class="comment">//偏特化版—当迭代器是一个pointer-to-const</span></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;<span class="comment">//萃取出来的型别应该是T，而非const T</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在，不论面对的是迭代器MyIter，或是原生指针<code>*int</code>或<code>const int*</code>，都可以通过traits取出正确的（我们所期望的）value type。</p>
<p>下图说明了traits所扮演的“特性萃取机”角色，萃取各个迭代器的特性。这里所谓的迭代器特性，指的是迭代器的相应型别。当然，若要这个“特性萃取机”traits嫩够有效运作，每一个迭代器必须遵守约定，自行以内嵌型别定义的方式定义出相应型别。这是一个约定，谁不遵守约定，谁就不能兼容STL这个大家庭。<br><img src="/img/1608959630.png" alt></p>
<p>根据经验，最常用到的迭代器相应型别有五种：<code>value type</code>，<code>difference type</code>，<code>pointer</code>，<code>reference</code>，iterator categoly`。如果你希望你所开发的容器能与STL水乳交融，一定要为你的容器的迭代器定义这五种相应型别。“特性萃取机”traits会很忠实地将其原汁原味榨取出来：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">temp1ate &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">itarator_traits</span> &#123;</span> </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::iterator_category iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type difference_type; </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer pointer; </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference;</span><br></pre></td></tr></table></figure></p>
<p><code>iterator_traits</code>必须针对传入的型别为pointer及pointer-to-const者，设计特化版本，稍后数节为你展示如何进行。</p>
<h3 id="迭代器相应型别之一：value-type"><a href="#迭代器相应型别之一：value-type" class="headerlink" title="迭代器相应型别之一：value type"></a>迭代器相应型别之一：value type</h3><p>所谓value type，是指<strong>迭代器所指对象的型别</strong>。任何一个打算与STL算法有完美搭配的class，都应该定义自己的value type内嵌型别，例如STL中的vector定义：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// nested type 定义</span></span><br><span class="line">  <span class="keyword">typedef</span> T                 value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type*       pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type*       iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp;       reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span>         s  ize_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>         difference_type;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="迭代器相应型别之二：difference-type"><a href="#迭代器相应型别之二：difference-type" class="headerlink" title="迭代器相应型别之二：difference type"></a>迭代器相应型别之二：difference type</h3><p>difference type用来表示两个迭代器之间的距离，因此它也可以用来表示一个容器的最大容量，因为对于连续空间的容器而言，头尾之间的距离就是其最大容量。如果一个泛型算法提供计数功能，例如STL的<code>count()</code>，其传回值就必须使用迭代器的diference type：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">iterator_traits</span>&lt;I&gt;:</span>:difference_type</span><br><span class="line">count (I first, I last, <span class="keyword">const</span> T&amp; value)&#123;</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;I&gt;::difference_type n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;first!=last;++first)</span><br><span class="line">        <span class="keyword">if</span>(*first == value)</span><br><span class="line">            ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>针对相应型别difference type，traits的如下两个特化版本，以C++内建的<code>ptrdiff_L</code>作为原生指针的difference type：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::difference_type difference_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对原生指针偏特化版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt; &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">typedef</span> ptrdiff_L difference_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对原生的pointer-to-const设计的偏特化版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt; &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在，任何时候我们需要任何迭代器I的difference type，可以：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> iterator_traits&lt;I&gt;::difference_type;</span><br></pre></td></tr></table></figure></p>
<h3 id="迭代器相应型别之三：reference-type"><a href="#迭代器相应型别之三：reference-type" class="headerlink" title="迭代器相应型别之三：reference type"></a>迭代器相应型别之三：reference type</h3><p>从“迭代器所指之物的内容是否允许改变”的角度观之，迭代器分为两种：<strong>不允许改变“所指对象之内容”者</strong>，称为constant iterators，例如<code>const int* pic</code>；<strong>允许改变“所指对象之内容”者</strong>，称为 mutable iterators，例如<code>int* pi</code>。 当我们对一个 mutable iterators做解引用时，获得的应该是个左值（lvalue） ,可以被赋值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* pi = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* pci = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">9</span>);</span><br><span class="line">*pi = <span class="number">7</span>;  <span class="comment">// 对mutable iterator及逆行操作，获得的是左值，允许赋值</span></span><br><span class="line">*pci = <span class="number">1</span>; <span class="comment">// 这个操作不被允许，pci是constant iterator，提领pci所得结果是个右值，不能赋值。</span></span><br></pre></td></tr></table></figure></p>
<p>在 C++中，<strong>函数如果要返回左值，都是以by reference的方式进行</strong>，所以当p是个mutable iterators时，如果其value type是T，那么<code>*p</code>的型别不应该是T，应该是<code>T&amp;</code>。将此道理扩充，如果p是一个 constant iterators，其value type是 T，那么<code>*p</code>的型别不应该是const T，而应该是<code>const T&amp;</code>。<code>*p</code>的型别，即所谓的reference type。 </p>
<h3 id="迭代器相应型别之四：pointer-type"><a href="#迭代器相应型别之四：pointer-type" class="headerlink" title="迭代器相应型别之四：pointer type"></a>迭代器相应型别之四：pointer type</h3><p>pointers和 references 在C++中有非常密切的关连。 如果“传回一个左值，令它代表p所指之物”是可能的，那么“传回一个左值，令它代表p所指之物的位址”也一定可以。 我们能够传回一个 pointer，指向迭代器所指之物。 </p>
<p>这些相应型别已在先前的ListIter class中出现过：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Item&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">Item* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> ptr; &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Item&amp;</code>便是ListIter的reference type而<code>Item*</code>便是其pointer type。</p>
<p>现在把reference type和pointer type这两个相应型别加入traits内：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::pointer   pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::reference reference;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对原生指针偏特化版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt; &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">typedef</span> T* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对原生的pointer-to-const设计的偏特化版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt; &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> T&amp; reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="迭代器相应型别之五：iterator-category"><a href="#迭代器相应型别之五：iterator-category" class="headerlink" title="迭代器相应型别之五：iterator_category"></a>迭代器相应型别之五：iterator_category</h3><p>最后一个（第五个）迭代器的相应型别会引发较大规模的写代码工程。在那之前，我必须先讨论迭代器的分类。</p>
<p>根据移动特性与施行操作，迭代器被分为五类：</p>
<ul>
<li>Input lterator：这种迭代器所指的对象，不允许外界改变。只读（read only）。</li>
<li>Output terator：唯写（write only）。</li>
<li>Forward lterator：允许“写入型”算法（例如<code>replace()</code>）在此种迭代器所形成的区间上进行读写操作。</li>
<li>Bidirectiona lterator：可双向移动。某些算法需要逆向走访某个迭代器区间（例如逆向拷贝某范围内的元素），可以使用Biairectional lterators。</li>
<li>Random Access lterator：前四种迭代器都只供应一部分指针算术能力（前三种支持<code>operator++</code>，第四种再加上<code>operator--</code>），第五种则涵盖所有指针算术能力，包括<code>p+n</code>，<code>p-n</code>，<code>p[n]</code>，<code>p1-p2</code>，<code>p1&lt;p2</code>。</li>
</ul>
<p>迭代器的分类与从属关系如下图所示：<br><img src="/img/1609574454.png" alt></p>
<p>设计算法时，如果可能，我们尽量针对上图中某种迭代器提供一个明确定义，并针对更强化的某种迭代器提供另一定义，这样才能在不同情况下提供最大效率。假设有个算法接受 Forward Iterator，你以 Random Access Iterator 喂给它，也可用，但是可用不一定最佳。</p>
<p>下面以<code>advanced()</code>函数为例，介绍各类迭代器的性能差异。该函数有两个参数，迭代器p和数值n，函数内部将p累进n次，下面有三个定义，一个针对Input iterator，一个针对Bidirectional iterator，另一个针对Random Access iterator。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>,<span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">advanced_II</span>(<span class="title">InputIterator</span>&amp; <span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//单向 逐一前进</span></span><br><span class="line">	<span class="keyword">while</span>(n--) ++i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">advanced_BI</span>(<span class="title">BidirectionalIterator</span>&amp; <span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//双向 逐一前进</span></span><br><span class="line">	<span class="keyword">if</span>(n&gt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">while</span>(n--) ++i;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">while</span>(n++) --i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">advanced_RAI</span>(<span class="title">RandomAccessIterator</span>&amp; <span class="title">i</span>,<span class="title">Distance</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//双向 跳跃前进</span></span><br><span class="line">	i += n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当程序调用<code>advance()</code>时，应该调用哪一份函数定义呢？通常会将三者合一，下面是一种做法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">advanced</span>(<span class="title">InputIterator</span>&amp; <span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span>(is_random_access_iterator(i))<span class="comment">//有待设计</span></span><br><span class="line">        advanced_RAI(i,n);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(is_bidirectional_iterator(i))<span class="comment">//有待设计</span></span><br><span class="line">        advanced_BI(i,n);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        advanced_II(i,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是上述处理方式，会在程序执行期间才能决定使用哪个处理函数，影响程序效率。最好能够在编译期就选择正确的版本，重载函数机制可以实现该目标。我们可以给<code>advanced()</code>添加第三个参数，即“迭代器类型”这个参数，然后利用traits萃取出迭代器的种类。下面五个classes，即代表五种迭代器类型：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这些classes只作为标记用，所以不需要任何成员。重新设计<code>__advance()</code>，然后利用第三参数重新定义上面的<code>advance()</code>函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">advanced</span>(<span class="title">InputIterator</span>&amp; <span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>, <span class="title">input_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//单向 逐一前进</span></span><br><span class="line">	<span class="keyword">while</span>(n--) ++i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//这是一个单纯的传递调用参数（triv forwarding function） 稍后讨论如何免除之</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>,<span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">advanced</span>(<span class="title">ForwardIterator</span>&amp; <span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>, <span class="title">forward_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//单纯的进行传递调用</span></span><br><span class="line">	advance(i,n,input_iterator_tag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">advanced</span>(<span class="title">BidirectionalIterator</span>&amp; <span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>, <span class="title">bidirectional_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//双向 逐一前进</span></span><br><span class="line">	<span class="keyword">if</span>(n&gt;=<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">while</span>(n--) ++i;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">while</span>(n++) --i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> __<span class="title">advanced</span>(<span class="title">RandomAccessIterator</span>&amp; <span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>, <span class="title">random_access_iterator_tag</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="comment">//双向 跳跃前进</span></span><br><span class="line">	i += n;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对外开放的上层接口，调用上述各个重载的<code>__advance()</code>。这一上层接口只需两个参数，当它准备将工作转给上述的<code>__advance()</code>时，才自行加上第三参数：迭代器类型。因此，这个上层函数必须有能力从它所获得的迭代器中推导出其类型——这份工作自然交给traits机制：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">advanced</span>(<span class="title">InputIterator</span>&amp; <span class="title">i</span>, <span class="title">Distance</span> <span class="title">n</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	__advance(i,n,iterator_traits&lt;InputIterator&gt;::iterator_categoty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>iterator_traits&lt;InputIterator&gt;::iterator_categoty()</code>将产生一个临时对象，其类别应该为前述5个迭代器类型之一。根据这个类别编译器决定调用哪个<code>__advance()</code>重载函数。</p>
<p>任何一个迭代器，其类型永远应该落在“该迭代器所隶属之各种类型中”，最强化的那个。同时，STL算法命名规则：<strong>以算法所能接受之最低阶迭代器类型，来为其迭代器型别参数命名</strong>，因此<code>advance()</code>中template参数名称为<code>InputIterator</code>。</p>
<h4 id="消除“单纯传递调用的函数”"><a href="#消除“单纯传递调用的函数”" class="headerlink" title="消除“单纯传递调用的函数”"></a>消除“单纯传递调用的函数”</h4><p>由于各个迭代器之间存在着继承关系，“传递调用”的行为模式自然存在，即如果不重载Forward Iterators或BidirectionalIterator时，统统都会传递调用InputIterator版的函数。</p>
<h2 id="std-iterator的保证"><a href="#std-iterator的保证" class="headerlink" title="std::iterator的保证"></a>std::iterator的保证</h2><p>任何迭代器都应该提供五个内嵌相应类别，以利于traits萃取。STL提供了一个iteratots class如下，如果每个新设计的迭代器都继承自它，则可以保证符合STL规范（即需要提供五个迭代器相应的类型）。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Category</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Distance</span> = <span class="title">ptrdiff_t</span>,</span></span><br><span class="line"><span class="class">          <span class="title">class</span> <span class="title">Pointer</span> = <span class="title">T</span>*, <span class="title">class</span> <span class="title">Reference</span> = <span class="title">T</span>&amp;&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> Category  iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> T         value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Distance  difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> Pointer   pointer;</span><br><span class="line">  <span class="keyword">typedef</span> Reference reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>iterator class 不含成员，纯粹只是类型定义，所以继承它不会造成任何负担。由于后三个参数都有默认值，新的迭代器只需提供前两个参数即可。</p>
<h2 id="SGI-STL的私房菜：-type-traits"><a href="#SGI-STL的私房菜：-type-traits" class="headerlink" title="SGI STL的私房菜：__type_traits"></a>SGI STL的私房菜：__type_traits</h2><p>traits编程技法很棒，适度弥补了 C++ 语言本身的不足。 STL只对迭代器加以规范，制定出<code>iterator_traits</code>这样的东西。 SGI 把这种技法进一步扩大到迭代器以外的世界，于是有了所谓的<code>__type_traits</code>。 </p>
<p><code>iterator_traits</code>负责萃取迭代器的特性， <code>__type_traits</code>则负责萃取型别（type）的特性。 型别特性是指：这个型别是否具备non-trivial defalt ctor ？是否具备 non-trivial copy ctor？是否具备 non-trivial assignment operator？是否具备 non-trivial dtor？如果答案是否定的，我们在对这个型别进行建构、解构、拷贝、赋值等动作时，就可以采用最有效率的措施，而采用内存直接处理动作如<code>malloc()</code>、<code>memcpy()</code>等等，获得最高效率。这对于大规模而动作频繁的容器，有着显著的效率提升！</p>
<p><code>type_traits</code>提供了一种机制，允许针对不同的型别属性，在编译时期完成函数派送决定，如果我们事先知道是否有trivial copy constructor，便能够帮助我们确定是否可以使用<code>memcpy()</code>或<code>memmove()</code>。</p>
<p>根据<code>iterator_traits</code>得来的经验，我们希望程序中可以这样运用<code>__type_traits&lt;T&gt;</code>，<code>T</code>代表任意型别：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__type_traits&lt;T&gt;::has_trivial_default_constructor</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_copy_constructor</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_assignment_operator</span><br><span class="line">__type_traits&lt;T&gt;::has_trivial_destructor</span><br><span class="line">__type_traits&lt;T&gt;::is_POD_type</span><br></pre></td></tr></table></figure></p>
<p>上述式子应该传回：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">true_type</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">false_type</span>&#123;</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>利用其响应结果进行类型推断。</p>
<p>为了达成上述五个式子，<code>__type_traits</code>应该定义一些<code>typedefs</code>，其值不是<code>_true_type</code>就是<code>_false_type</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">type_traits</span> &#123;</span> </span><br><span class="line">   <span class="keyword">typedef</span> __true_type     this_dummy_member_must_be_first;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_default_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_copy_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_assignment_operator;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_destructor;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    is_POD_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>SGI把所有内嵌型别都定义为<code>_false_type</code>为了定义出最保守的值，然后再针对每一个标量型别（scalar types)设计适当的<code>_type_traits</code>特化版本，这样就解决了问题。上述<code>_type_traits</code>可以接受任何型别的参数，五个typedefs将经由以下管道获得实值：</p>
<ul>
<li>一般具现体（gerera1 instantiation），内含对所有型别都必定有效的保守值。上述各个has_trivial_xxx型别都被定义为<code>_false_type</code>，就是对所有型别都必定有效的保守值。</li>
<li>经过声明的特化版本，例如<code>&lt;type_traits.h&gt;</code>内对所有C++标量型别（scalar types）提供了对应的特化声明。稍后展示</li>
<li>某些编译器会自动为所有型别提供适当的特化版本</li>
</ul>
<p>以下是<code>&lt;type_traits.h&gt;</code>对所有C++标量类型所定义的<code>__type_traits</code>特化版本：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">__STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;char&gt; &#123;</span></span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">__STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;int&gt; &#123;</span></span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 上述还有针对其他数据类型的定义</span></span><br><span class="line"><span class="comment">// 以下针对原生指针设计__type_traits偏特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">type_traits</span>&lt;T*&gt; &#123;</span></span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">   <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>前面第二章提到过的<code>uninitialized_fill_n</code>等函数就在实现中使用了<code>__type_traits</code>机制。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Size</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator</span> __<span class="title">uninitialized_fill_n</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">                                              <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> __uninitialized_fill_n(first, n, x, vaule_type(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数以x为蓝本，自迭代器first开始构造n个元素，首先以<code>value_type()</code>萃取出迭代器first的value_type，再利用<code>__type_traits</code>判断该类型是否为POD类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Size</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">T1</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator</span> __<span class="title">uninitialized_fill_n</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">                                              <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, <span class="title">T1</span>*) &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;T1&gt;::is_POD_type is_POD;</span><br><span class="line">  <span class="keyword">return</span> __uninitialized_fill_n_aux(first, n, x, is_POD());</span><br><span class="line">                                    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不是POD型别 就会派送（dispatch）到这里</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Size</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ForwardIterator</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_fill_n_aux</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, __<span class="title">false_type</span>) &#123;</span></span><br><span class="line">  ForwardIterator cur = first;</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++cur)</span><br><span class="line">      construct(&amp;*cur, x);<span class="comment">//需要逐个进行构造</span></span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是POD型别 就会派送到这里 下两行是源文件所附注解</span></span><br><span class="line"><span class="comment">//如果copy construction 等同于 assignment 而且有 trivival destructor</span></span><br><span class="line"><span class="comment">//以下就有效</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>, <span class="title">class</span> <span class="title">Size</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">ForwardIterator</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_fill_n_aux</span>(<span class="title">ForwardIterator</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>,</span></span><br><span class="line"><span class="class">                           <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">x</span>, __<span class="title">true_type</span>) &#123;</span></span><br><span class="line">  <span class="keyword">return</span> fill_n(first, n, x);	<span class="comment">//交由高阶函数执行 </span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//以下定义于&lt;stl_algobase.h&gt;中的fill_n()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">OutputIter</span>, <span class="title">class</span> _<span class="title">Size</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">OutputIter</span> <span class="title">fill_n</span>(<span class="title">OutputIter</span> <span class="title">first</span>, <span class="title">Size</span> <span class="title">n</span>, <span class="title">const</span> <span class="title">Tp</span>&amp; <span class="title">value</span>) &#123;</span></span><br><span class="line">  <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++first)</span><br><span class="line">    *first = value;</span><br><span class="line">  <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二个例子是<code>copy()</code>全局函数（泛型算法之一〕，这个函数有非常多的特化〔specialization）与强化（refinement）版本。最基本的想法是这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝一个数组，其元素为任意型别，视情况采用最有效率的拷贝手段 </span></span><br><span class="line"><span class="keyword">template</span> &lt;c1ass T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(T* source, T* destination, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    copy(source, destination, n, <span class="keyword">typename</span> __type_traits&lt;T&gt;:::has_trivial_copy_constructor());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝一个数组，其元素型别拥有non-trivial copy constructors</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">copy</span>(<span class="title">T</span>* <span class="title">source</span>, <span class="title">T</span>* <span class="title">destination</span>, <span class="title">int</span> <span class="title">n</span>, __<span class="title">false_type</span>) &#123;</span> ... &#125;</span><br><span class="line"><span class="comment">// 拷贝一个数组，其元素型别拥有trivial copy constructors</span></span><br><span class="line"><span class="comment">// 可借助memcpy()完成工作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">copy</span>(<span class="title">T</span>* <span class="title">source</span>, <span class="title">T</span>* <span class="title">destination</span>, <span class="title">int</span> <span class="title">n</span>, __<span class="title">true_type</span>) &#123;</span> ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上只是针对“函数参数为原生指针”的情况而做的设计。</p>
<p>如果你是SGI STL的用户，你可以在自己的程序中充分运用这个<code>__type_traits</code>，假设我自行定义了一个shape c1ass，<code>__type_traits</code>会对它产生什么效应呢？如果编译器够厉害，<code>__type_traits</code>针对shape萃取出来的每一个特性，其结果将取决于我的Shape是否有trivial default ctor，或triviai copy ctor，或trivial assignment operator, 或trivial dtor而定。但对大部分缺乏这种特异功能的编译器而言，<strong>type_traits针对Shape萃取出来的每一个特性都是`</strong>false_type<code>，即使shape是个POD型别。这样的结果当然过于保守、但是别无选择，除非我针对shape,自行设计一个</code>__type_traits`特化版本，明白地告诉编译器以下事实（举例）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">type_traits</span>&lt;Shape&gt; &#123;</span> </span><br><span class="line">   <span class="keyword">typedef</span> __true_type     has_trivial_default_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_copy_constructor;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_assignment_operator;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    has_trivial_destructor;</span><br><span class="line">   <span class="keyword">typedef</span> __false_type    is_POD_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>一个简单的判断标准是，如果class内含指针成员，并且对它进行动态内存配置，那么这个class就要实现出自己的non-trival-xxx。</p>
<h1 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h1><h2 id="容器的概观与分类"><a href="#容器的概观与分类" class="headerlink" title="容器的概观与分类"></a>容器的概观与分类</h2><p>容器，置物之所也。研究数据的特定排列方式，以利于搜寻或排序或其他特殊目的，这一专门学科称为数据结构。几乎可以说，任何特定的数据结构都是为了实现某种特定的算法。</p>
<p>SGI STL的各个容器（本图以内缩方式来表达基层与衍生层的关系）。<br><img src="1609581571.jpg" alt></p>
<p>这里所谓的<strong>衍生</strong>，并非派生关系，而是内含关系。例如，heap内含一个vector，priority-queue内含一个heap，stack和queue都内含一个deque，set/map/multiset/multimap都内含一个RB-tree，hash_set/hash_map/hash_multiset/hash_multimap都内含一个hashtabe。</p>
<h2 id="vector概述"><a href="#vector概述" class="headerlink" title="vector概述"></a>vector概述</h2><p>vector的数据安排以及操作方式，与array非常相似。两者的唯一差别在于空间的运用的灵活性。array是静态空间，一旦配置了就不能改变；vector的动态空间 ，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。vector的实现技术，关键在于对其大小的控制以及重新配置时的数据移动效率。</p>
<p>vector的内部定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator; <span class="comment">// SGI STL 空间配置器接口</span></span><br><span class="line">  iterator start;               <span class="comment">// 表示目前使用空间的头</span></span><br><span class="line">  iterator finish;              <span class="comment">// 表示目前使用空间的尾</span></span><br><span class="line">  iterator end_of_storage;      <span class="comment">// 表示目前可用空间的尾</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_aux</span><span class="params">(iterator position, <span class="keyword">const</span> T&amp; x)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123;           <span class="comment">// 释放空间</span></span><br><span class="line">    <span class="keyword">if</span> (start) data_allocator::deallocate(start, end_of_storage - start);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    start = allocate_and_fill(n, value);</span><br><span class="line">    finish = start + n;</span><br><span class="line">    end_of_storage = finish;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 各种迭代器</span></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reverse_iterator(end()); &#125;</span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> const_reverse_iterator(end()); &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> reverse_iterator(begin()); &#125;</span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> const_reverse_iterator(begin()); &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// size、max_size、capacity、empty</span></span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(end() - begin()); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(<span class="number">-1</span>) / <span class="keyword">sizeof</span>(T); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_type(end_of_storage - begin()); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> begin() == end(); &#125;</span><br><span class="line">  <span class="comment">// 重载 []</span></span><br><span class="line">  reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span> *(begin() + n); &#125;</span><br><span class="line">  const_reference <span class="keyword">operator</span>[](size_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(begin() + n); &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 构造函数，大都调用 fill_initialize</span></span><br><span class="line">  <span class="built_in">vector</span>() : start(<span class="number">0</span>), finish(<span class="number">0</span>), end_of_storage(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">vector</span>(size_type n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line">  <span class="built_in">vector</span>(<span class="keyword">int</span> n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line">  <span class="built_in">vector</span>(<span class="keyword">long</span> n, <span class="keyword">const</span> T&amp; value) &#123; fill_initialize(n, value); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(size_type n)</span> </span>&#123; fill_initialize(n, T()); &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 析构函数</span></span><br><span class="line">  ~<span class="built_in">vector</span>() &#123; </span><br><span class="line">    destroy(start, finish);</span><br><span class="line">    deallocate();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 首尾元素</span></span><br><span class="line">  <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *begin(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *begin(); &#125;</span><br><span class="line">  <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(end() - <span class="number">1</span>); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *(end() - <span class="number">1</span>); &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">      construct(finish, x);</span><br><span class="line">      ++finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      insert_aux(end(), x);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 插入操作</span></span><br><span class="line">  <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    size_type n = position - begin();</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage &amp;&amp; position == end()) &#123;</span><br><span class="line">      construct(finish, x);</span><br><span class="line">      ++finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      insert_aux(position, x);</span><br><span class="line">    <span class="keyword">return</span> begin() + n;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 删除最尾端元素</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    --finish;</span><br><span class="line">    destroy(finish);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//清除某位置上的元素</span></span><br><span class="line">  <span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position + <span class="number">1</span> != end())</span><br><span class="line">      copy(position + <span class="number">1</span>, finish, position); <span class="comment">// 后续元素往前移动</span></span><br><span class="line">    --finish;</span><br><span class="line">    destroy(finish);</span><br><span class="line">    <span class="keyword">return</span> position;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 清除迭代器所指定的区间的元素</span></span><br><span class="line">  <span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span> </span>&#123;</span><br><span class="line">    iterator i = copy(last, finish, first);</span><br><span class="line">    destroy(i, finish);</span><br><span class="line">    finish = finish - (last - first);</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 重新设置 vector 大小，若设置值 new_size 大于当前 size，在尾端插入 x</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type new_size, <span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (new_size &lt; size()) </span><br><span class="line">      erase(begin() + new_size, end());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      insert(end(), new_size - size(), x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type new_size)</span> </span>&#123; resize(new_size, T()); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; erase(begin(), end()); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// 配置空间并填满内容，其中__STL_TRY、__STL_UNWIND 为异常相关的宏，在 stl_config.h 中定义</span></span><br><span class="line">  <span class="function">iterator <span class="title">allocate_and_fill</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    iterator result = data_allocator::allocate(n);</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      uninitialized_fill_n(result, n, x);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(data_allocator::deallocate(result, n));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="vector-的迭代器"><a href="#vector-的迭代器" class="headerlink" title="vector 的迭代器"></a>vector 的迭代器</h3><p>vector 维护的是一个连续的线性空间，所以不论其元素型别如何，普通指针都可以作为 vector 的迭代器而满足所有必要条件，因为 vector 迭代器所需要的操作行为，如<code>operator*</code>，<code>operator-&gt;</code>，<code>operator++</code>，<code>operator–</code>，<code>operator+</code>，<code>operator-</code>，<code>operator+=</code>，<code>operator-=</code>，普通指针天生就具备。vector 支持随机存取，而普通指针正有这样的能力。所以，vector 提供的是 Random Access Iterators。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T             value_type;</span><br><span class="line">    <span class="keyword">typedef</span> value_type*   iterator;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据定义，如果客户端写出这样的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator ivite;</span><br><span class="line"><span class="built_in">vector</span>&lt;Shape&gt;::iterator svite;</span><br></pre></td></tr></table></figure></p>
<p>ivite 型别就是<code>int*</code>，svite 的型别就是<code>Shape*</code>。</p>
<h3 id="vector数据结构"><a href="#vector数据结构" class="headerlink" title="vector数据结构"></a>vector数据结构</h3><p>vector采用线性连续空间的数据结构。它以两个迭代器start和finish分别指向配置的来的连续空间中目前已被使用的范围，并以迭代器<code>end_of_storage</code>指向整块连续空间（含备用空间）的尾端:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span>&#123;</span>  </span><br><span class="line">...  </span><br><span class="line"><span class="keyword">protected</span> :  </span><br><span class="line">      iterator start ; <span class="comment">//表示目前使用空间的头  </span></span><br><span class="line">      iterator finish ; <span class="comment">// 表示目前使用空间的尾  </span></span><br><span class="line">      iterator end_of_storage ; <span class="comment">//表示目前可用空间的尾  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>为了降低空间配置时的速度成本，vector 实际配置的大小可能比客户端需求量更大一些，以备将来可能的扩充。这便是容量（capacity）的概念。添加新元素时，如果超出当时的容量，则容量会扩充至两倍，如果两倍容量仍不足，就扩充至足够大的容量。上述容量的扩张必须经历“重新配置、元素移动、释放空间”等过程。vector数据插入过程的示意图如下:<br><img src="/img/1609589397.jpg" alt></p>
<h3 id="vector构造与内存管理"><a href="#vector构造与内存管理" class="headerlink" title="vector构造与内存管理"></a>vector构造与内存管理</h3><p>vector缺省使用alloc作为空间配置器，并据此另外定义了一个data_allocator，为的是更方便以元素大小为配置单位：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;value_type,Alloc&gt; data_allocator;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>于是，<code>data_allocator::allocate(n)</code>表示配置n个元素空间。</p>
<p>vector提供许多constructors，其中一个允许我们指定空间大小及初值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>(size_type n, <span class="keyword">const</span> T&amp; value) &#123;</span><br><span class="line">    fill_initialize(n, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_initialize</span><span class="params">(n, value)</span> </span>&#123;</span><br><span class="line">    start = allocate_and_fill(n, value);</span><br><span class="line">    finish = start + n;</span><br><span class="line">    end_of_storage = finish;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置而后填充</span></span><br><span class="line"><span class="function">iterator <span class="title">allocate_and_fill</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    iterator result = data_allocator::allocate(n);</span><br><span class="line">    uninitialized_fill_n(result, n, x);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>uninitialized_fill_n()</code>会根据第一参数的类型决定使用算法<code>fill_n</code>或反复调用<code>construct()</code>完成任务。</p>
<p>当我们以<code>push_back()</code>将新元素插入vector尾端时，该函数先检查是否还有备用空间，如果有就直接在备用空间上构造元素，并调整迭代器finish，使vector变大。如果没有备用空间，就扩充空间（重新配置、移动数据、释放原空间）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">      construct(finish, x);</span><br><span class="line">      ++finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      insert_aux(end(), x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;  </span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">vector</span>&lt;T, Alloc&gt;:</span>:insert_aux(iterator position, <span class="keyword">const</span> T&amp;x)&#123;  </span><br><span class="line">      <span class="keyword">if</span> (finish != end_of_storage)&#123;<span class="comment">//还有备用空间  </span></span><br><span class="line">          construct(finish, *(finish - <span class="number">1</span>)); <span class="comment">//在备用空间起始处构造一个元素，以vector最后一个元素值为其初值  </span></span><br><span class="line">          ++finish; <span class="comment">//调整finish迭代器  </span></span><br><span class="line">          T x_copy = x;  </span><br><span class="line">          copy_backward(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>);  </span><br><span class="line">          *position = x_copy;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">else</span>&#123;<span class="comment">//没有备用空间  </span></span><br><span class="line">          <span class="keyword">const</span> size_type old_size = size();  </span><br><span class="line">          <span class="keyword">const</span> size_type new_size = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>;  </span><br><span class="line">          iterator new_start = data_allocator::allocate(new_size);  </span><br><span class="line">          iterator new_finish = new_start;  </span><br><span class="line">          <span class="keyword">try</span>&#123;  </span><br><span class="line">              new_finish = uninitialized_copy(start, position, new_start);<span class="comment">//将原vector的内容拷贝到新vector  </span></span><br><span class="line">              construct(new_finish, x);  </span><br><span class="line">              ++new_finish;  </span><br><span class="line">              new_finish = uninitialzed_copy(position, finish, new_finish);<span class="comment">//将安插点的原内容也拷贝过来  </span></span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="keyword">catch</span> (excetion e)&#123;  </span><br><span class="line">              destroy(new_start, new_finish);<span class="comment">//如果发生异常，析构移动的元素，释放新空间  </span></span><br><span class="line">              data_allocator::deallocate(new_start, new_size);</span><br><span class="line">              <span class="keyword">throw</span>;</span><br><span class="line">          &#125;<span class="comment">//析构并释放原空间  </span></span><br><span class="line">          destroy(begin(), end());  </span><br><span class="line">          deallocator();  </span><br><span class="line">          start = new_start; <span class="comment">//调整迭代器  </span></span><br><span class="line">          finish = new_finish;  </span><br><span class="line">          end_of_storage = new_start + new_size;<span class="comment">//调整迭代器  </span></span><br><span class="line">      &#125;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>补充：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator1</span>, <span class="title">class</span> <span class="title">BidirectionalIterator2</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">BidirectionalIterator2</span> <span class="title">copy_backward</span> ( <span class="title">BidirectionalIterator1</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                                         <span class="title">BidirectionalIterator1</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">                                         <span class="title">BidirectionalIterator2</span> <span class="title">result</span>)； </span></span><br><span class="line"><span class="class"> 参数:</span></span><br><span class="line">       first, last</span><br><span class="line">       指出被复制的元素的区间范围[first，last).</span><br><span class="line">       result</span><br><span class="line">       指出复制到目标区间的具体位置[result-(last-first),result)</span><br><span class="line"> 返回值：</span><br><span class="line">        返回一个迭代器，指出已被复制元素区间的起始位置</span><br></pre></td></tr></table></figure></p>
<p>所谓动态增加大小，并不是在原空间之后接续空间（因为无法包装原空间之后尚有可配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原来内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了。</p>
<h3 id="vector的元素操作"><a href="#vector的元素操作" class="headerlink" title="vector的元素操作"></a>vector的元素操作</h3><p><code>pop_back()</code>实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>&#123;</span><br><span class="line">      --finish;            <span class="comment">//将尾端标记往前移一格，表示放弃尾端元素</span></span><br><span class="line">      destory(finish);     <span class="comment">//finish原来指向容器尾部[strat,finish),--后指向最后一个元素，然后析构</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>erase()</code>实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清除[first,last]中的所有元素</span></span><br><span class="line"> <span class="function">iterator <span class="title">erase</span><span class="params">(iterator first,iterator last)</span></span>&#123;</span><br><span class="line">     iterator i=copy(last,finish,first);</span><br><span class="line">     destroy(i,finish);</span><br><span class="line">     finish=finish-(last-first);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//清除某个位置上的元素</span></span><br><span class="line"> <span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(position+<span class="number">1</span>!=end())</span><br><span class="line">         copoy(position+<span class="number">1</span>,finish,position);</span><br><span class="line">     --finish;</span><br><span class="line">     destory(finish);</span><br><span class="line">     <span class="keyword">return</span> position;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//清除所有元素</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;erase(begin(),end());&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1609589884.jpg" alt></p>
<p><code>copy()</code>函数具体实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InputIterator 版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">OutputIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">OutputIterator</span> __<span class="title">copy</span>(<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">OutputIterator</span> <span class="title">result</span>, <span class="title">input_iterator_tag</span>)&#123;</span></span><br><span class="line"><span class="comment">//如果只是 InputIterator 的话，以迭代器赞同与否，决定循环是否继续、速度慢</span></span><br><span class="line"><span class="keyword">for</span>( ; first != last; ++result, ++first)</span><br><span class="line">*result = *first;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( ; last != finish; ++first, ++last)</span><br><span class="line">*first = *last;  <span class="comment">//即将last开始的元素接到first后面</span></span><br></pre></td></tr></table></figure></p>
<p><code>insert()</code>实现，根据备用空间和插入元素的多少分为以下三种情况：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">vector</span>&lt;T, Alloc&gt;:</span>:insert(iterator position, size_type n, <span class="keyword">const</span> T&amp; x) &#123;</span><br><span class="line">  <span class="comment">// 当 n != 0 才进行以下所有操作</span></span><br><span class="line">  <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 备用空间大于等于新增元素个数</span></span><br><span class="line">    <span class="keyword">if</span> (size_type(end_of_storage - finish) &gt;= n) &#123;</span><br><span class="line">      T x_copy = x;</span><br><span class="line">      <span class="keyword">const</span> size_type elems_after = finish - position;</span><br><span class="line">      iterator old_finish = finish;</span><br><span class="line">      <span class="comment">// 针对插入点后现有元素与新增元素个数的数量采取不同的操作</span></span><br><span class="line">      <span class="comment">// 插入点后现有元素个数大于新增元素个数</span></span><br><span class="line">      <span class="keyword">if</span> (elems_after &gt; n) &#123;</span><br><span class="line">        uninitialized_copy(finish - n, finish, finish);</span><br><span class="line">        finish += n;</span><br><span class="line">        copy_backward(position, old_finish - n, old_finish);</span><br><span class="line">        fill(position, position + n, x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 插入点后现有元素个数小于等于新增元素个数</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        uninitialized_fill_n(finish, n - elems_after, x_copy);</span><br><span class="line">        finish += n - elems_after;</span><br><span class="line">        uninitialized_copy(position, old_finish, finish);</span><br><span class="line">        finish += elems_after;</span><br><span class="line">        fill(position, old_finish, x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 备用空间小于新增元素个数（必须配置额外的内存）</span></span><br><span class="line">      <span class="comment">// 首先决定新长度：旧长度的2倍，或者旧长度+新增元素个数</span></span><br><span class="line">      <span class="keyword">const</span> size_type old_size = size();        </span><br><span class="line">      <span class="keyword">const</span> size_type len = old_size + max(old_size, n);</span><br><span class="line">      <span class="comment">// 配置新的 vector 空间</span></span><br><span class="line">      iterator new_start = data_allocator::allocate(len);</span><br><span class="line">      iterator new_finish = new_start;</span><br><span class="line">      __STL_TRY &#123;</span><br><span class="line">        new_finish = uninitialized_copy(start, position, new_start);</span><br><span class="line">        new_finish = uninitialized_fill_n(new_finish, n, x);</span><br><span class="line">        new_finish = uninitialized_copy(position, finish, new_finish);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#         <span class="meta-keyword">ifdef</span>  __STL_USE_EXCEPTIONS </span></span><br><span class="line">      <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        <span class="comment">// 如有异常发生，实现 commit or rollback 语义</span></span><br><span class="line">        destroy(new_start, new_finish);</span><br><span class="line">        data_allocator::deallocate(new_start, len);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#         <span class="meta-keyword">endif</span> <span class="comment">/* __STL_USE_EXCEPTIONS */</span></span></span><br><span class="line">      <span class="comment">// 清除并释放旧的 vector</span></span><br><span class="line">      destroy(start, finish);</span><br><span class="line">      deallocate();</span><br><span class="line">      <span class="comment">// 调整迭代器</span></span><br><span class="line">      start = new_start;</span><br><span class="line">      finish = new_finish;</span><br><span class="line">      end_of_storage = new_start + len;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1609590017.jpg" alt><br><img src="/img/1609590056.jpg" alt><br><img src="/img/1609590082.jpg" alt></p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><h2 id="list概述"><a href="#list概述" class="headerlink" title="list概述"></a>list概述</h2><p>相比于vector的连续线性空间，list显得更为复杂；但list每次插入或删除一个元素时，就将配置或释放一个元素。因此，list对于空间的运用有绝对的精准，一点也不浪费。对于任何位置的插入或元素删除，list永远是常数时间。</p>
<h3 id="list的节点"><a href="#list的节点" class="headerlink" title="list的节点"></a>list的节点</h3><p>下面是STL list的节点结构，显然是一个双向链表。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_node</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer; </span><br><span class="line">	void_pointer prev; <span class="comment">//型别为void*,其实可设为__list_node&lt;T&gt;*</span></span><br><span class="line">	void_pointer next;</span><br><span class="line">	T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="list的迭代器"><a href="#list的迭代器" class="headerlink" title="list的迭代器"></a>list的迭代器</h3><p>list中的元素由于都是节点，不保证在存储空间中连续存在。list迭代器必须有能力指向list的节点，并有能力正确递增递减取值存取等操作。其迭代器递增时取用的是下一个节点，递减时取用上一个节点，取值时取的是节点的数据值，成员存取时取用的是节点的成员。</p>
<p>由于list是双向链表，迭代器必须具备前移、后移的能力，因此，list提供的是Bidirectional Iterators；list的插入和接合操作都不会导致原有迭代器失效，但vector的插入可能造成存储空间重新分配，导致原有的迭代器全部失效。甚至list的删除操作也只有指向被删除元素的那个迭代器失效，其他迭代器不受影响。<br><img src="/img/1609590834.jpg" alt></p>
<p>以下是list迭代器的设计：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, P&amp;, T*&gt; iterator;</span><br><span class="line">    <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt; self;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> bidirectionla_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">    link_type node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constrcutor</span></span><br><span class="line">    __list_iterator(link_type x) : node(x) &#123;&#125;</span><br><span class="line">    __list_iterator() &#123;&#125;</span><br><span class="line">    __list_iterator(<span class="keyword">const</span> iterator&amp; x) : node(x.node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node == x.node; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node != x.node; &#125;</span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line"></span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">    </span><br><span class="line">    self&amp; <span class="keyword">operator</span>++() &#123; <span class="comment">//运算符前置++的重载</span></span><br><span class="line">        node = (link_type)((*node).next);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; <span class="comment">//运算符后置++的重载</span></span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        ++*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>--() &#123; <span class="comment">//运算符前置--的重载</span></span><br><span class="line">        node = (link_type)((*node).prev);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123; <span class="comment">//运算符后置--的重载</span></span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        --*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="list的数据结构"><a href="#list的数据结构" class="headerlink" title="list的数据结构"></a>list的数据结构</h3><p>SGI list是一个双向链表，而且是一个环状双向链表:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt; //缺省使用<span class="title">alloc</span>为配置器:</span>w</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">	<span class="keyword">typedef</span>	__list_node&lt;T&gt; list_node ;</span><br><span class="line"><span class="keyword">public</span>  :</span><br><span class="line">	<span class="keyword">typedef</span>	list_node* link_type ;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">	link_type node ; <span class="comment">//只要一个指针，便可以表示整个环状双向链表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果让指针 node 指向刻意置于尾端的一个空白节点， node 便能符合 STL 对于“前闭后开”区间的要求，成为 last 迭代器。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取首元素，node是尾端的一个空节点</span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span>  </span>&#123;  <span class="keyword">return</span>  (link_type) ((*node).next); &#125;</span><br><span class="line"><span class="comment">//取尾元素的下一个，即node</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span>     </span>&#123;  <span class="keyword">return</span> node;  &#125;</span><br><span class="line"><span class="comment">//为空，说明只有node</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span>  </span>&#123;  <span class="keyword">return</span> node-&gt;next == node; &#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span>  <span class="keyword">const</span> </span>&#123;</span><br><span class="line">	size_type result = <span class="number">0</span>;</span><br><span class="line">	distance(begin(), end(), result);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span>    </span>&#123; <span class="keyword">return</span> *begin(); &#125;</span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span>    </span>&#123;  <span class="keyword">return</span> *(--end());  &#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1609591356.jpg" alt></p>
<h3 id="list的构造与内存管理"><a href="#list的构造与内存管理" class="headerlink" title="list的构造与内存管理"></a>list的构造与内存管理</h3><p>list采用<code>list_node_allocator</code>来配置节点空间，以下四个函数分别用来配置、释放、构造、销毁一个节点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt; //缺省使用<span class="title">alloc</span>为配置器:</span>w</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">	<span class="keyword">typedef</span>	__list_node&lt;T&gt; list_node ;</span><br><span class="line">    <span class="comment">//专属之空间配置器，每次配置一个节点大小</span></span><br><span class="line">	<span class="keyword">typedef</span>	simple_alloc&lt;list_node,Alloc&gt; list_node_allocator;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>list_node_allocator(n)</code>表示配置n个节点空间，配置、释放、构造、销毁。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置一个节点</span></span><br><span class="line"><span class="function">link_type <span class="title">get_node</span><span class="params">()</span> 	</span>&#123; <span class="keyword">return</span> list_node_allocator::allocate(); &#125;  </span><br><span class="line"><span class="comment">//释放一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span>	</span>&#123; list_node_deallocator::deallocate(p); &#125;</span><br><span class="line"><span class="comment">//产生一个节点，带有元素值</span></span><br><span class="line"><span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span>  </span>&#123;</span><br><span class="line">	link_type p = get_node();</span><br><span class="line">	construct(&amp;p-&gt;data, x);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//销毁一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span> </span>&#123;</span><br><span class="line">	destroy(&amp;p-&gt;data);</span><br><span class="line">	put_node(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>list提供了默认的构造函数，使得可以创建一个空list：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">list</span>()   &#123;  empty_initialize();  &#125;   <span class="comment">//默认构造函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">empty_initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		node = get_node();       <span class="comment">//配置一个节点空间</span></span><br><span class="line">		node-&gt;next = node;</span><br><span class="line">		node-&gt;prev = node;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们以<code>push_back()</code>将新元素插入list尾端时，此函数内部调用<code>insert()</code>，<code>insert()</code>是一个重载函数，最简单的一种如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> T&amp; x)</span></span>&#123;<span class="comment">//在迭代器position所指位置插入一个节点，内容为x</span></span><br><span class="line">	link_type tmp = create_node(x);</span><br><span class="line">	tmp-&gt;next = position.node;</span><br><span class="line">	tmp-&gt;prev = position.node-&gt;prev;</span><br><span class="line">	(link_type(position.node-&gt;prev))-&gt;next = tmp;</span><br><span class="line">    position.node-&gt;prev =tmp;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当连续插入5个节点之后，list的状态如图，如果希望在list内部的某处插入新节点，首先必须确定插入位置，例如希望在数据为3的节点处插入一个数据值为99的节点，可以：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ilite = find(li.begin, li.end(), <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (ilite != <span class="number">0</span>)</span><br><span class="line">    il.insert(ilite, <span class="number">99</span>);</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1609603712.png" alt></p>
<h3 id="list的元素操作"><a href="#list的元素操作" class="headerlink" title="list的元素操作"></a>list的元素操作</h3><p><code>push_front()</code>函数：将新元素插入于list头端，内部调用<code>insert()</code>函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> T&amp;x)</span>  </span>&#123; insert(begin(),x); &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>push_back()</code>函数：将新元素插入于list尾端，内部调用<code>insert()</code>函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span>   </span>&#123;  insert(end(),x); &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>erase()</code>函数：移除迭代器position所指节点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span></span>&#123;</span><br><span class="line">    link_type next_node=link_type(position.node-&gt;next);</span><br><span class="line">    link_type prev_node=link_type(position.node-&gt;prev);</span><br><span class="line">    prev_node-&gt;next=next_node;</span><br><span class="line">    next_node-&gt;prev=prev_node;</span><br><span class="line">    destroy_node(position.node);</span><br><span class="line">    <span class="keyword">return</span> iterator(next_node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>pop_front()</code>函数：移除头结点，内部调用<code>erase()</code>函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span>  </span>&#123;  erase(begin());  &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>pop_back()</code>函数：移除尾结点，内部调用<code>erase()</code>函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>&#123;</span><br><span class="line">    iterator i = end();</span><br><span class="line">    erase(--i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>clear()</code>函数：清除所有节点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;  </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:clear()  </span><br><span class="line">&#123;  </span><br><span class="line">  link_type cur = (link_type) node-&gt;next;<span class="comment">//node原来指向list的end,node-&gt;next为begin  </span></span><br><span class="line">  <span class="keyword">while</span> (cur != node)  </span><br><span class="line">  &#123;  </span><br><span class="line">    link_type tmp = cur;  </span><br><span class="line">    cur = (link_type) cur-&gt;next;  </span><br><span class="line">    destroy_node(tmp);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">// 恢复node原始状态  </span></span><br><span class="line">  node-&gt;next = node;  </span><br><span class="line">  node-&gt;prev = node;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>remove()</code>：将数值为value的所有元素移除<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:remove(<span class="keyword">const</span> T&amp; value) &#123;</span><br><span class="line">    iterator first = begin();</span><br><span class="line">    iterator last = end();</span><br><span class="line">    <span class="keyword">while</span>(first != end) &#123;</span><br><span class="line">        iterator next = first;</span><br><span class="line">        ++ next;</span><br><span class="line">        <span class="keyword">if</span> (*first == value) </span><br><span class="line">            erase(first);</span><br><span class="line">        first = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>transfer()</code>迁移函数：将[ frirst , last ) 内所有元素移动到position之前。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(iterator position, iterator first, iterator last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position != last) &#123;</span><br><span class="line">      (*(link_type((*last.node).prev))).next = position.node; <span class="comment">//(1)</span></span><br><span class="line">      (*(link_type((*first.node).prev))).next = last.node;    <span class="comment">//(2)</span></span><br><span class="line">      (*(link_type((*position.node).prev))).next = first.node;<span class="comment">//(3)</span></span><br><span class="line">      link_type tmp = link_type((*position.node).prev);       <span class="comment">//(4)</span></span><br><span class="line">      (*position.node).prev = (*last.node).prev;              <span class="comment">//(5)</span></span><br><span class="line">      (*last.node).prev = (*first.node).prev;                 <span class="comment">//(6)</span></span><br><span class="line">      (*first.node).prev = tmp;                               <span class="comment">//(7)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1609605134.jpg" alt></p>
<p>list公开提供的是所谓的接合操作splice，<code>splice</code>结合操作将连续范围的元素从一个list移动到另一个list的某个定点。<br><img src="/img/1609605212.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iv[<span class="number">5</span>] = &#123; <span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ilist2(iv,iv+<span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//目前，ilist的内容为 0 2 99 3 4</span></span><br><span class="line">ite = find(ilist.begin(),ilist.end(),<span class="number">99</span>);</span><br><span class="line">ilist.splice(ite,ilist2);  <span class="comment">// 0 2 5 6 7 8 9 99 3 4</span></span><br><span class="line">ilist.reverse();           <span class="comment">// 4 3 99 9 8 7 6 5 2 0</span></span><br><span class="line">ilist.sort();              <span class="comment">// 0 2 3 4 5 6 7 8 9 99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将链表x移动到position所指位置之前  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position, <span class="built_in">list</span>&amp; x)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (!x.empty())  </span><br><span class="line">        transfer(position, x.begin(), x.end());  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 将链表中i指向的内容移动到position之前  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position, <span class="built_in">list</span>&amp;, iterator i)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">     iterator j = i;  </span><br><span class="line">     ++j;  </span><br><span class="line">     <span class="keyword">if</span> (position == i || position == j) <span class="keyword">return</span>;  </span><br><span class="line">     transfer(position, i, j);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是<code>merge()</code>、<code>reverse()</code>、<code>sort()</code>的源代码，有了<code>transfer()</code>在手，这些操作都不难完成<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:merge(<span class="built_in">list</span>&lt;T, Alloc&gt;&amp; x) &#123;</span><br><span class="line">    iterator first1 = begin();</span><br><span class="line">    iterator last1 = end();</span><br><span class="line">    iterator first2 = x.begin();</span><br><span class="line">    iterator last2 = x.begin();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(first1 != last1 &amp;&amp; first2 != last2) </span><br><span class="line">        <span class="keyword">if</span> (*first2 &lt; *first1) &#123;</span><br><span class="line">            iterator next = first2;</span><br><span class="line">            transfer(first1, first2, ++next);</span><br><span class="line">            first2 = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++first1;</span><br><span class="line">    <span class="keyword">if</span> (first2 != last2)</span><br><span class="line">        transfer)last1, first2, last2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>reverse()</code>将<code>*this</code>的内容逆向重置<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:reverse() &#123;</span><br><span class="line">    <span class="comment">// 以下判断，如果是空链表，或仅有一个元素，就不操作</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next == node || size() == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    iteratro first = begin();</span><br><span class="line">    ++first;</span><br><span class="line">    <span class="keyword">while</span>(first != end()) &#123;</span><br><span class="line">        iterator old = first;</span><br><span class="line">        ++ first;</span><br><span class="line">        transfer(begin(), old, first);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>list不能使用STL算法sort()，必须使用自己的sort()：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">list</span>&lt;T, Alloc&gt;:</span>:sort() &#123;</span><br><span class="line">    <span class="comment">// 以下判断，如果是空链表，或仅有一个元素，就不操作</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next == node || size() == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">list</span>&lt;T, Alloc&gt; carry;</span><br><span class="line">    <span class="built_in">list</span>&lt;T, Alloc&gt; counter[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> fill = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!empty()) &#123;</span><br><span class="line">        carry.splice(carry.begin(), *<span class="keyword">this</span>, begin());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; fill &amp;&amp; !counter[i].empty()) &#123;</span><br><span class="line">            counter[i].merge(carry);</span><br><span class="line">            carry.swap(counter[i++]);</span><br><span class="line">        &#125;</span><br><span class="line">        carry.swap(counter[i]);</span><br><span class="line">        <span class="keyword">if</span> (i == fill)</span><br><span class="line">            ++ fill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; fill; i ++)</span><br><span class="line">        counter[i].merge(counter[i<span class="number">-1</span>]);</span><br><span class="line">    swap(counter[fill<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>deque（double-ended queue，双端队列）是一种具有队列和栈的性质的数据结构。相比于vector单向开口的连续线性空间而言，deque则是一种双向开口的连续线性空间，可以在头尾两端分别做元素的插入和删除操作。虽然vector从技术层面也可以对头部操作，但是效率极低。<br><img src="/img/1609640774.jpg" alt></p>
<p>deque与vector的最大差异在于：</p>
<ol>
<li>deque可以在常数时间内完成对头部元素的插入或删除操作；</li>
<li>deque没有容量的概念，它是动态地以分段连续空间组合而成，随时可以增加一段新的空间并链接起来。deque没有必要提供所谓的空间保留reserve功能。</li>
</ol>
<p>虽然deque也提供Random Access Iterator，但它的迭代器并不是普通指针，其复杂度和vector不同。除非必要我们应该选择vector而不是deque。对deque进行排序操作，为了得到最高效率，可先将deque复制一个vector，将vector排序后再复制回deque。</p>
<h3 id="deque的中控器"><a href="#deque的中控器" class="headerlink" title="deque的中控器"></a>deque的中控器</h3><p>deque由一段一段的定量连续空间构成。一旦有必要在dequer前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的接口。避开了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器架构。</p>
<p>deque采用一块所谓的map作为主控。这里所谓<strong>map是一小块连续空间</strong>，其中每个元素(此处称为一个节点，node)都是指针，指向另一段(较大的)连续线性空间，称为缓冲区。缓冲区才是deque的储存空间主体。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>, <span class="title">size_t</span> <span class="title">BufSiz</span> = 0&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="keyword">typedef</span>	T value_type ;</span><br><span class="line">	<span class="keyword">typedef</span>	value_type* pointer ;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">	<span class="comment">//元素的指针的指针(pointer of pointer of T)</span></span><br><span class="line">	<span class="keyword">typedef</span>	pointer* map_pointer ; <span class="comment">//其实就是T**</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">	map_pointer <span class="built_in">map</span> ; <span class="comment">//指向map,map是块连续空间，其内的每个元素</span></span><br><span class="line">					  <span class="comment">//都是一个指针(称为节点)，指向一块缓冲区</span></span><br><span class="line">	size_type map_size ;<span class="comment">//map内可容纳多少指针</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>map其实是一个<code>T**</code>，所指之物是另一个指针，指向类型为T的一块空间。<br><img src="/img/1609641339.jpg" alt></p>
<h3 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h3><p>deque是分段连续空间，维持“整体连续”假象的任务，落在迭代器的<code>operator++</code>和<code>operator--</code>两个运算子上。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">deque_iterator</span>&#123;</span> <span class="comment">//未继承std::iterator</span></span><br><span class="line">	<span class="keyword">typedef</span>	__deque_iterator&lt;T,T&amp;,T*,BufSize&gt;	iterator ;</span><br><span class="line">	<span class="keyword">typedef</span>	__deque_iterator&lt;T,<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T*,BufSize&gt;	const_iterator ;</span><br><span class="line">	<span class="function"><span class="keyword">static</span>	size_t	<span class="title">buffer_size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> __deque_buf_size(BufSize,<span class="keyword">sizeof</span>(T)) ;&#125; </span><br><span class="line"> </span><br><span class="line">	<span class="comment">//未继承std::iterator，所以必须自行撰写五个必要的迭代器相应型别</span></span><br><span class="line">	<span class="keyword">typedef</span>	random_access_iterator_tag	iterator_category ;</span><br><span class="line">	<span class="keyword">typedef</span>	T	value_type ;</span><br><span class="line">	<span class="keyword">typedef</span>	Ptr	pointer ;</span><br><span class="line">	<span class="keyword">typedef</span>	Ref	reference ;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">size_t</span>	size_type ;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">ptrdiff_t</span>	difference_type ;</span><br><span class="line">	<span class="keyword">typedef</span>	T**	map_pointer ;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">typedef</span>	__deque_iterator	self ;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//保持与容器的联结</span></span><br><span class="line">	T *cut ; <span class="comment">//此迭代器所指之缓冲区中的现行(current)元素</span></span><br><span class="line">	T *first ; <span class="comment">//此迭代器所指之缓冲区的头</span></span><br><span class="line">	T *last ;	<span class="comment">//此迭代器所指之缓冲区的尾(含备用空间)</span></span><br><span class="line">	map_pointer node ; <span class="comment">//指向管控中心</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中用来决定缓冲区大小的函数<code>buffer_size()</code>调用<code>__deque_buf_size()</code>，后者是一个全局函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果n不为0，传回n，表示buffer size由用户定义</span></span><br><span class="line"><span class="comment">// 如果n为0，表示buffer size使用默认值，那么</span></span><br><span class="line"><span class="comment">//   如果sz(元素大小，sizeof(value_type))小于512，传回512/sz</span></span><br><span class="line"><span class="comment">//   如果sz不小于512，传回1</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> sz)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="keyword">size_t</span>(<span class="number">512</span>/sz) : <span class="keyword">size_t</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1609641622.jpg" alt></p>
<p>假设现在我们产生1个<code>deque&lt;int&gt;</code>，并令其缓冲区大小为32，于是每个缓冲区可容纳<code>32/sizeof(int)=4</code>个元素：经过某些操作之后，deque拥有20个元素，那么其<code>begin()</code>和<code>end()</code>所传回的两个迭代器应该如图4-12所示。这两个迭代器事实上一直保持在deque内，名为start和finish，稍后在deque数据结构中便可看到。<br><img src="/img/1609641867.jpg" alt></p>
<p>20个元素需要<code>20/8=3</code>个缓冲区，所以map之内运用了三个节点。迭代器start内的cur指针当然指向缓冲区的第一个兀素，迭代器finish内的指针当然指向缓冲区的最后元素（的下一位置）。注意，最后1个缓冲区尚有备用空间。稍后如果有新元素要插入于尾端，可直接拿此备用空间来使用。</p>
<p>下面是deque迭代器的几个关键行为．由于迭代器内对各种指针运算都进行了重载操作，所以各种指针运算如加、减、前进、后退都不能直观视之。其中最关键的就是：一旦行进时遇到缓冲区边缘，要特别当心，视前进或后退而定，可能需要调用<code>set_node()</code>跳一个缓冲区。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span> </span>&#123;</span><br><span class="line">    node = new_node;</span><br><span class="line">    first = *new_node;</span><br><span class="line">    last = first + difference_type(buffer_size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下各个重载运算子是__deque_iterator&lt;&gt;成功运作的关踺</span></span><br><span class="line">reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *cur; &#125;</span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*(); &#125;</span><br><span class="line"></span><br><span class="line">difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> difference_type(buffer_size()) * (node - x.node - <span class="number">1</span>) + (cur - first) + (x.last - x.cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    ++ cur;  <span class="comment">//切换至下一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (cur == last) &#123; <span class="comment">// 如果已达所在缓冲区的尾端</span></span><br><span class="line">        set_node(node + <span class="number">1</span>); <span class="comment">//就切换至下一节点（亦即缓冲区）</span></span><br><span class="line">        cur = first;   <span class="comment">// 的第一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; </span><br><span class="line"><span class="comment">// 后置式标准写法</span></span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; operaeor--() &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == first) &#123; <span class="comment">// 如果已达所在缓冲区的头端，</span></span><br><span class="line">        set_node(node - <span class="number">1</span>); <span class="comment">// 就切涣至前一节点（亦即缓冲区）</span></span><br><span class="line">        cur = last; <span class="comment">// 的最后一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    -- cur; <span class="comment">//切换至前一个元素</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line"><span class="comment">// 后置标准写法</span></span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    -- *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下实现随机存取．迭代器可以直接跳跃n个距离</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>+=(difference_type n) &#123;</span><br><span class="line">    difference_type offset = n + (cur - first);</span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; difference_type(buffer_size()))</span><br><span class="line">        <span class="comment">// 目标位置在同一缓冲区内</span></span><br><span class="line">        cur += n;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 标的位不在同一缓冲区内</span></span><br><span class="line">        difference_type node_offset = offset &gt; <span class="number">0</span> ? offset/difference_type(buffer_size()) : -difference_type((-offset<span class="number">-1</span>)/buffer_size()) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 切换至正确的节点〈亦即缓冲区）</span></span><br><span class="line">        set_node(node + node_offset);</span><br><span class="line">        <span class="comment">// 切换至正确的元素</span></span><br><span class="line">        cur = first + (offset - node_offset * difference_type(buffer_size()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>+(difference_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp += n; <span class="comment">// 调用operator+=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">self&amp; <span class="keyword">operator</span>-=(difference_type n) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> += -n; &#125;</span><br><span class="line"><span class="comment">// 以上利用operator+= 来完成operator-=</span></span><br><span class="line"></span><br><span class="line">self <span class="keyword">operator</span>-(difference_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">    slef tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp -= n; <span class="comment">// 调用operator-=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下实现随机存取。迭代器可以直接跳跃n个距离</span></span><br><span class="line">reference <span class="keyword">operator</span>[] (difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125;</span><br><span class="line"><span class="comment">// 以上调用operator*, operator+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>== (<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur == x.cur; &#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!= (<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == x); &#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="deque的数据结构"><a href="#deque的数据结构" class="headerlink" title="deque的数据结构"></a>deque的数据结构</h3><p>deque除了维护一个指向map的指针外，也维护start，finish两个迭代器，分别指向第一缓冲区的第一个元素和最后缓冲区的最后一个元素(的下一个位置)。此外，也必须记住目前的map大小，因为一旦map提供的节点不足，就必须重新配置更大的一块map。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>, <span class="title">size_t</span> <span class="title">BufSiz</span> = 0&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="keyword">typedef</span>	T	value_type ;</span><br><span class="line">	<span class="keyword">typedef</span>	value_type*	pointer ;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">size_t</span>	size_type ;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="keyword">typedef</span>	__deque_iterator&lt;T,T&amp;,T*,BufSiz&gt; iterator ;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">	<span class="comment">//元素的指针的指针(pointer of pointer of T)</span></span><br><span class="line">	<span class="keyword">typedef</span>	pointer*	map_pointer ;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	iterator	start ; <span class="comment">//表现第一节点</span></span><br><span class="line">	iterator	finish ; <span class="comment">//表现最后一个节点</span></span><br><span class="line">	map_pointer	<span class="built_in">map</span> ; <span class="comment">//指向map,map是块连续空间，其每个元素都是个指针，指向一个节点(缓冲区)</span></span><br><span class="line">	size_type	map_size ; <span class="comment">//map内有多少指针</span></span><br><span class="line">	...</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure></p>
<h3 id="deque的构造与内存管理"><a href="#deque的构造与内存管理" class="headerlink" title="deque的构造与内存管理"></a>deque的构造与内存管理</h3><p>以程序实现来初步了解deque的构造和内存管理：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">alloc</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>, allocator&lt;<span class="keyword">int</span>&gt;&gt; ideq(<span class="number">20</span>, <span class="number">9</span>);</span><br><span class="line">	<span class="comment">//deque&lt;int,alloc,8&gt; ideq(20, 9);//在linux下不支持alloc</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size="</span> &lt;&lt; ideq.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ideq.size(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ideq[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        ideq.push_back(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ideq.size(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ideq[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size="</span> &lt;&lt; ideq.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    ideq.push_back(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ideq.size(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ideq[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size="</span> &lt;&lt; ideq.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    ideq.push_front(<span class="number">99</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ideq.size(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ideq[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size="</span> &lt;&lt; ideq.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    ideq.push_front(<span class="number">98</span>);</span><br><span class="line">    ideq.push_front(<span class="number">97</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ideq.size(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ideq[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size="</span> &lt;&lt; ideq.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>, allocator&lt;<span class="keyword">int</span>&gt;&gt;::iterator itr;</span><br><span class="line">    itr = find(ideq.begin(), ideq.end(), <span class="number">99</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *itr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *(itr._M_cur) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">————————————————————————————————————————————————————————————————————————————————</span><br><span class="line">[root@<span class="number">192</span> <span class="number">4</span>_STL_sequence_container]# ./<span class="number">4</span>_4_5_deque-test                         </span><br><span class="line">size=<span class="number">20</span></span><br><span class="line"><span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span></span><br><span class="line"><span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line">size=<span class="number">23</span></span><br><span class="line"><span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">size=<span class="number">24</span></span><br><span class="line"><span class="number">99</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">size=<span class="number">25</span></span><br><span class="line"><span class="number">97</span> <span class="number">98</span> <span class="number">99</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">size=<span class="number">27</span></span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="number">99</span></span><br></pre></td></tr></table></figure></p>
<p>一开始声明一个deque：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>, alloc, 32&gt; ideq(<span class="number">20</span>, <span class="number">9</span>);</span><br></pre></td></tr></table></figure></p>
<p>其缓冲区为32bytes，并令其保留20个元素空间，每个元素初值为9。现在，deque的情况如图4-12。</p>
<p>deque自行定义了2个专属的空间配置器：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 每次配置一个元素大小</span></span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line">    <span class="comment">// 每次配置一个指针大小</span></span><br><span class="line">    <span class="keyword">typedef</span> simple_alloc&lt;pointer, Alloc&gt; map_allocator;</span><br></pre></td></tr></table></figure></p>
<p>并提供一个constructor：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>(<span class="keyword">int</span> n,<span class="keyword">const</span> value_type&amp; value):start(),finish(),<span class="built_in">map</span>(<span class="number">0</span>),map_size(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    fill_initialize(n, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其内调用的<code>fill_initialize()</code>负责产生并安排好deque的结构，并将元素的初值设定妥当。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:fill_initialize(size_type n, <span class="keyword">const</span> value_type&amp; value) &#123; </span><br><span class="line">    <span class="comment">//负责产生并安排好deque的结构，并将元素的初值设定好</span></span><br><span class="line">    create_map_and_nodes(n); <span class="comment">//把deque的结构都安排好</span></span><br><span class="line">    map_pointer cur;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">        <span class="comment">//已经获得空间,为每个节点缓冲区设定初值</span></span><br><span class="line">        <span class="keyword">for</span>(cur = start.node; cur &lt; finish.node; ++cur) &#123;</span><br><span class="line">            uninitialized_fill(*cur, *cur+buffer_size(), value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一个节点的设定稍有不同（尾端可能有备用空间，不必设初值）</span></span><br><span class="line">        uninitialized_fill(finish.first, finish.cur, value);</span><br><span class="line">    &#125; <span class="keyword">catch</span>( ... ) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>create_map_and_nodes()</code>负责产生并安排好deque的结构：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:creat_map_and_nodes(size_type num_elements)</span><br><span class="line">&#123;   <span class="comment">//产生并安排好deque的结构</span></span><br><span class="line">    size_type num_nodes=num_elements/buffer_size()+<span class="number">1</span>; </span><br><span class="line">    <span class="comment">//一个map要管理几个节点，最少8个，最多是“所需节点数+2”，前后各预留一个，扩充时用</span></span><br><span class="line">    map_size=max(initial_map_size(),num_nodes+<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">map</span>=map_allocator::allocate(map_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下令nstart和finish指向map所拥有的全部节点的最中央区段</span></span><br><span class="line">    <span class="comment">// 保持在最中央，可使头尾两端的扩充能量一样大，每个节点对应一个缓冲区</span></span><br><span class="line">    map_pointer nstart=<span class="built_in">map</span>+(map_size-num_nodes)/<span class="number">2</span>;</span><br><span class="line">    map_pointer nfinish=nstart+num_nodes<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    map_pointer cur;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">        <span class="comment">// 为map的每个节点配置缓冲区，所有缓冲区加起来就是deque的可用空间</span></span><br><span class="line">        <span class="keyword">for</span>(cur=nstart; cur &lt;= nfinish; cur++)</span><br><span class="line">        &#123;</span><br><span class="line">            *cur=allocate_node();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为deque内的两个迭代器start和end设置正确内容</span></span><br><span class="line">    start.set_node(nstart);</span><br><span class="line">    finish.set_node(nfinish);</span><br><span class="line">    start.cur=start.first;</span><br><span class="line">    finish.cur=finish.first+num_elements%buffer_size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来范例程序为每个元素重新设置值。在尾端插入三个元素<br><img src="/img/1609645158.jpg" alt></p>
<h3 id="deque的元素操作"><a href="#deque的元素操作" class="headerlink" title="deque的元素操作"></a>deque的元素操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> value_type &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish.cur != finish.last - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        construct(finish.cur, t);</span><br><span class="line">        ++finish.cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//需要配置新的缓冲区</span></span><br><span class="line">    &#123;</span><br><span class="line">        push_back_aux(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果尾端只剩一个元素备用空间，<code>push_back()</code>调用<code>push_back_aux()</code>，先配置一块新的缓冲区，再设妥新元素内容，然后更改迭代器finish状态。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:push_back_aux(<span class="keyword">const</span> value_type &amp;t) <span class="comment">//只剩最后一个缓冲区的最后一个备用缓冲区</span></span><br><span class="line">&#123;                                       <span class="comment">//先配置一块新的缓冲区，再设新元素内容，更改迭代器finish的状态</span></span><br><span class="line">    value_type t_copy = t;</span><br><span class="line">    reserve_map_at_back();                <span class="comment">//若符合某种条件，则必须重换一个map</span></span><br><span class="line">    *(finish.node + <span class="number">1</span>) = allocate_node(); <span class="comment">//配置一新缓冲区</span></span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">        construct(finish.cur, t_copy);</span><br><span class="line">        finish.set_node(finish.node + <span class="number">1</span>);</span><br><span class="line">        finish.cur = finish.first;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(deallocate_node(*(finish.node + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在deque的状态如图：<br><img src="/img/1609645423.jpg" alt></p>
<p>接下来范例程序在deque的前端插入一个新元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ideq.push_front(<span class="number">99</span>);</span><br></pre></td></tr></table></figure></p>
<p><code>push_front()</code>的操作如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> value_type &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start.cur != start.first) &#123; <span class="comment">// 第一缓冲区尚有空间</span></span><br><span class="line">        construct(start.cur - <span class="number">1</span>, t); <span class="comment">// 直接在备用空间上构造元素</span></span><br><span class="line">        -- start.cur; <span class="comment">// 调整第一缓冲区的使用状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        push_front_aux(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:push_front_aux(<span class="keyword">const</span> value_type &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">    value_type t_copy = t;</span><br><span class="line">    reserve_map_at_front();</span><br><span class="line">    *(start.node - <span class="number">1</span>) = allocate_node();</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">        start.set_node(start.node - <span class="number">1</span>);</span><br><span class="line">        start.cur = start.last - <span class="number">1</span>;</span><br><span class="line">        construct(start.cur, t_copy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        start.set_node(start.node + <span class="number">1</span>);</span><br><span class="line">        start.cur = start.first;</span><br><span class="line">        deallocate_node(*(start.node - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始调用<code>reserve_map_at_front()</code>，判断是否需要扩充map，如果有则付诸行动。后续流程配置了一块新缓冲区，并直接将节点安置在现有的map中，设定新元素，改变迭代器的状态：<br><img src="/img/1609646609.jpg" alt></p>
<p>接下来插入两个新的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ideq.push_front(<span class="number">98</span>);</span><br><span class="line">ideq.push_front(<span class="number">97</span>);</span><br></pre></td></tr></table></figure></p>
<p>这一次，由于第一缓冲区有备用空间，<code>push_front()</code>可以在备用空间上构造新元素：<br><img src="/img/1609646690.jpg" alt></p>
<p><code>reserve_map_at_back()</code>和<code>reserve_map_at_front()</code>决定map是否需要整治：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve_map_at_back</span><span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes_to_add + <span class="number">1</span> &gt; map_size - (finish.node - <span class="built_in">map</span>)) <span class="comment">//map尾端的节点备用空间不足</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//换一个map（配置更大的，拷贝原来的，释放原来的）</span></span><br><span class="line">        reallocate_map(nodes_to_add, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve_map_at_front</span><span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes_to_add &gt; start.node - <span class="built_in">map</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        reallocate_map(nodes_to_add, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:reallocate_map(size_type node_to_add, <span class="keyword">bool</span> add_at_front) &#123;</span><br><span class="line">    size_type old_num_nodes = finish.node - start.node + <span class="number">1</span>;</span><br><span class="line">    size_type new_num_nodes = old_num_nodes + nodes_to_add;</span><br><span class="line"></span><br><span class="line">    map_pointer new_nstart;</span><br><span class="line">    <span class="keyword">if</span> (map_size &gt; <span class="number">2</span> * new_num_nodes) &#123;</span><br><span class="line">        new_nstart = <span class="built_in">map</span> + (map_size - new_num_nodes) / <span class="number">2</span> + (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (new_nstart &lt; start.node)</span><br><span class="line">            copy(start.node, finish.node+<span class="number">1</span>, new_nstart);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            copy_backward(start.node, finish.node+<span class="number">1</span>, new_nstart+old_num_nodes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        size_type new_map_size = <span class="built_in">map</span> + max(map_size, nodes_to_add) + <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//配置一块空间，准备给新map使用</span></span><br><span class="line">        map_pointer new_map = allocator::allocate(new_map_size);</span><br><span class="line">        new_nstart = new_map + (new_map_size - new_num_nodes) / <span class="number">2</span> + (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//把原nap内容拷贝过来</span></span><br><span class="line">        copy(start.node, finish.node+<span class="number">1</span>, new_nstart);</span><br><span class="line">        <span class="comment">// 释放原map</span></span><br><span class="line">        map_allocator::deallocate(<span class="built_in">map</span>, map_size);</span><br><span class="line">        <span class="comment">// 设定新的起始地址与大小</span></span><br><span class="line">        <span class="built_in">map</span> = new_map;</span><br><span class="line">        map_size = new_map_size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新设定迭代器start和finish</span></span><br><span class="line">    start.set_node(new_nstart);</span><br><span class="line">    finish.set_node(new_nstart + old_num_nodes - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>pop是将元素拿掉：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish.cur != finish.first)</span><br><span class="line">    &#123;</span><br><span class="line">        --finish.cur;</span><br><span class="line">        destroy(finish.cur); <span class="comment">//将最后元素析构,左开右闭</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//最后缓冲区没有任何元素</span></span><br><span class="line">        pop_back_aux(); <span class="comment">//这里将进行缓冲区的释放工作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back_aux</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;                                  <span class="comment">//finish.cur==finish.first 释放该缓冲区</span></span><br><span class="line">    deallocate_node(finish.first); <span class="comment">//释放最后一个缓冲区</span></span><br><span class="line">    finish.set_node(finish.node - <span class="number">1</span>);</span><br><span class="line">    finish.cur = finish.last - <span class="number">1</span>;</span><br><span class="line">    destroy(finish.cur); <span class="comment">//析构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start.cur != start.last - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        destroy(start.cur);</span><br><span class="line">        ++start.cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pop_front_aux();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_front_aux</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    destory(start.cur);</span><br><span class="line">    deallocate_node(start.last);</span><br><span class="line">    start.set_node(start.node + <span class="number">1</span>);</span><br><span class="line">    start.cur = start.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>clear用来清除整个deque。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (map_pointer node = start.node + <span class="number">1</span>; node &lt; finish.node; ++node)</span><br><span class="line">    &#123;</span><br><span class="line">        destory(*node, *node + buffer_size());            <span class="comment">//析构元素</span></span><br><span class="line">        data_allocator::deallocate(*node, buffer_size()); <span class="comment">//释放内存</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (start.node != finish.node) <span class="comment">//至少有两个缓冲区</span></span><br><span class="line">    &#123;</span><br><span class="line">        destroy(start.cur, start.last);</span><br><span class="line">        destroy(finish.first, finish.cur);</span><br><span class="line">        <span class="comment">//保留头缓冲区</span></span><br><span class="line">        data_allocator::deallocate(finish.first, buffer_size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        destroy(start.cur, finish.cur);</span><br><span class="line">    &#125;</span><br><span class="line">    finish = start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面这个例子是<code>clear()</code>，用来清除某个元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 清除pos所指的元素．pos为清除点</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator pos)</span> </span>&#123;</span><br><span class="line">    iterator next = pos;</span><br><span class="line">    ++next;</span><br><span class="line">    difference_type index = pos - start; <span class="comment">// 清除点之前的元素个数</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size() &gt;&gt; <span class="number">1</span>)) &#123;         <span class="comment">// 如果清除点之前的元素比较少，</span></span><br><span class="line">        copy_backward(start, pos, next); <span class="comment">// 就移动清除点之前的元素</span></span><br><span class="line">        pop_front();                     <span class="comment">// 移动完毕，最前一个元素冗余，去除之</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                               <span class="comment">// 清除点之后的元素比较少，</span></span><br><span class="line">        copy(next, finish, pos);         <span class="comment">// 就移动清除点之后的元素</span></span><br><span class="line">        pop_back();                      <span class="comment">// 移动完毕，最后一个元素冗余，去除之</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start + index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面这个例子是<code>erase()</code>，用来清除<code>[first, last]</code>区间内的所有元素：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;Class T, <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:eraee(iterator first, iterator last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (first == start &amp;&amp; last == finish) &#123;</span><br><span class="line">        clear();</span><br><span class="line">        <span class="keyword">return</span> finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        difference_type n = last - first;</span><br><span class="line">        difference_type elems_before = first - start;</span><br><span class="line">        <span class="keyword">if</span> (elems_before &lt; (size() - n) / <span class="number">2</span>) &#123;</span><br><span class="line">            copy_backward(start, first, last);</span><br><span class="line">            iterator new_start = start + n;</span><br><span class="line">            destroy(start, new_start);</span><br><span class="line">            <span class="comment">// 以下将冗余的缓冲区释放</span></span><br><span class="line">            <span class="keyword">for</span>(map_pointer cur = start.node; cur &lt; new_start.node; ++cur)</span><br><span class="line">                data_allocator::deallocate(*cur, buffer_size());</span><br><span class="line">            start = new_start; <span class="comment">//设定deque的新起点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            copy(last, finish, first);</span><br><span class="line">            iterator new_finish = finish - n;</span><br><span class="line">            destroy(new_finish, finish);</span><br><span class="line">            <span class="comment">// 以下将冗余的缓冲区释放</span></span><br><span class="line">            <span class="keyword">for</span>(map_pointer cur = new_finish.node + <span class="number">1</span>; cur &lt;= finish.node; ++cur)</span><br><span class="line">                data_allocator::deallocate(*cur, buffer_size());</span><br><span class="line">            finish = new_finish; <span class="comment">//设定deque的新尾点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start + elems_before;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后一个例子是insert。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position.cur == start.cur) &#123;</span><br><span class="line">        push_front(x);</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur) &#123;</span><br><span class="line">        push_back(x);</span><br><span class="line">        iterator tmp = finish;</span><br><span class="line">        -- tmp;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> insert_aux(position, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">deque</span>&lt;T, Alloc, BufSize&gt;:</span>:iterator</span><br><span class="line"><span class="built_in">deque</span>&lt;T, Alloc, BufSize&gt;::insert_aux(iterator pos, <span class="keyword">const</span> value_type&amp; x) &#123;</span><br><span class="line">    difference_type index = pos - start;</span><br><span class="line">    value_type x_copy = x;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; size() / <span class="number">2</span>) &#123;</span><br><span class="line">        push_front(front());</span><br><span class="line">        iterator front1 = start;</span><br><span class="line">        ++ front1;</span><br><span class="line">        iterator front2 = front1;</span><br><span class="line">        ++ front2;</span><br><span class="line">        pos = start + index;</span><br><span class="line">        iterator pos1 = pos;</span><br><span class="line">        ++ pos1;</span><br><span class="line">        copy(front2, pos1, front1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        push_back(back());</span><br><span class="line">        iterator back1 = finish;</span><br><span class="line">        -- back1;</span><br><span class="line">        iterator back2 = back1;</span><br><span class="line">        -- back2;</span><br><span class="line">        pos = start + index;</span><br><span class="line">        copy_backward(pos, back2, back1);</span><br><span class="line">    &#125;</span><br><span class="line">    *pos = x_copy;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><h3 id="stack概述"><a href="#stack概述" class="headerlink" title="stack概述"></a>stack概述</h3><p>stack是一种先进后出(First In Last Out,FILO)的数据结构，它只有一个出口。stack允许新增元素，移除元素、取得最顶端元素，但不允许有遍历行为。若以deque为底部结构并封闭其头端开口，便轻而易举地形成了一个stack。同时，也可以使用list作为底层实现，它也是具有双向开口的数据结构。由于stack系以底部容器完成其所有工作，而具有这种“修改某物接口，形成另一种风貌”之性质者，称为adapter(配接器)。因此，STL stack往往不被称为container，而被归类为container adapter。</p>
<p>因为stack的所有元素的进出都必须符合“先进后出”的条件，即只有stack顶端的元素，才会被外界取用，所以stack不提供走访功能，也不提供迭代器。</p>
<h3 id="stack-完整定义"><a href="#stack-完整定义" class="headerlink" title="stack 完整定义"></a>stack 完整定义</h3><p>SGI STL以deque作为缺省情况下的stack底部结构。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span> = <span class="title">deque</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">stack</span>&#123;</span></span><br><span class="line">    <span class="comment">// __STL_NULL_TMPL_ARGS展开为&lt;&gt;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS(<span class="keyword">const</span> <span class="built_in">stack</span>&amp; , <span class="keyword">const</span> <span class="built_in">stack</span>&amp;) ;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS(<span class="keyword">const</span> <span class="built_in">stack</span>&amp; , <span class="keyword">const</span> <span class="built_in">stack</span>&amp;) ;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">typename</span> Sequence::value_type value_type ;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">typename</span> Sequence::size_type size_type ;	</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">typename</span> Sequence::reference reference ;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">typename</span> Sequence::const_reference	const_reference ;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Sequence e ; <span class="comment">//底层容器</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="comment">//以下完全利用Sequence c 的操作，完成stack的操作</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.empty() ;&#125; </span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.size();&#125;</span><br><span class="line">	<span class="function">reference <span class="title">top</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.back();&#125;</span><br><span class="line">	<span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.back();&#125;</span><br><span class="line">	<span class="comment">//deque是两头可进出，stack是末端进，末端出。</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;c.push_back(x);&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;c.pop_back();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span>==(<span class="title">const</span> <span class="title">stack</span>&lt;T, Sequence&gt;&amp; <span class="title">x</span>, <span class="title">const</span> <span class="title">stack</span>&lt;T, Sequence&gt;&amp; <span class="title">y</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> x.c == y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span>&lt;(const stack&lt;T, Sequence&gt;&amp; x, const stack&lt;T, Sequence&gt;&amp; y)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    return x.c &lt; y.c;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="以list作为stack的底部容器"><a href="#以list作为stack的底部容器" class="headerlink" title="以list作为stack的底部容器"></a>以list作为stack的底部容器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; istack;</span><br><span class="line">    <span class="comment">//stack&lt;int&gt; istack; //缺省时使用deque</span></span><br><span class="line">    istack.push(<span class="number">1</span>);</span><br><span class="line">    istack.push(<span class="number">3</span>);</span><br><span class="line">    istack.push(<span class="number">5</span>);</span><br><span class="line">    istack.push(<span class="number">7</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; istack.size() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//4</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; istack.top() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//7</span></span><br><span class="line"> </span><br><span class="line">    istack.pop();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; istack.top() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//5</span></span><br><span class="line">    istack.pop();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; istack.top() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//3</span></span><br><span class="line">    istack.pop();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; istack.top() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; istack.size() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//1</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h3 id="queue概述"><a href="#queue概述" class="headerlink" title="queue概述"></a>queue概述</h3><p>queue是一种先进先出(First In First Out,FIFO)的数据结构，它有两个出口。queue允许新增元素、移除元素、从最底端加入元素、取得最顶端元素，但不允许遍历行为，也不提供迭代器。若以deque为底部结构并封闭其头端入口和尾部出口，便轻而易举地形成了一个queue。同时，也可以使用list作为底层实现，它也是具有双向开口的数据结构。因为queue的所有元素的进出都必须符合“先进先出”的条件，queue不提供走访功能，也不提供迭代器。</p>
<p>由于queue系以底部容器完成其所有工作，而具有这种“修改某物接口，形成另一种风貌”之性质者，称为adapter(配接器)。因此，STL queue往往不被称为container，而被归类为container adapter。</p>
<h3 id="queue-完整定义"><a href="#queue-完整定义" class="headerlink" title="queue 完整定义"></a>queue 完整定义</h3><p>SGI STL以deque作为缺省情况下的queue底部结构。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span> = <span class="title">deque</span>&lt;T&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">queue</span>&#123;</span></span><br><span class="line">    <span class="comment">// __STL_NULL_TMPL_ARGS展开为&lt;&gt;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS(<span class="keyword">const</span> <span class="built_in">queue</span>&amp; , <span class="keyword">const</span> <span class="built_in">queue</span>&amp;) ;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS(<span class="keyword">const</span> <span class="built_in">queue</span>&amp; , <span class="keyword">const</span> <span class="built_in">queue</span>&amp;) ;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">typename</span> Sequence::value_type value_type ;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">typename</span> Sequence::size_type size_type ;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">typename</span> Sequence::reference reference ;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">typename</span> Sequence::const_reference const_reference ;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line">	Sequence c ; <span class="comment">//底层容器</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="comment">//以下完全利用Sequence c的操作，完成queue的操作</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.empty();&#125;</span><br><span class="line">	<span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.size();&#125;</span><br><span class="line">	<span class="function">reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.front();&#125;</span><br><span class="line">	<span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.front();&#125;</span><br><span class="line">    <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> c.back();&#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.back();&#125;</span><br><span class="line">	<span class="comment">//deque是两头可进出，queue是末端进，前端出。</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type &amp;x)</span> </span>&#123;c.push_back(x) ;&#125; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;c.pop_front();&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span>==(<span class="title">const</span> <span class="title">queue</span>&lt;T, Sequence&gt;&amp; <span class="title">x</span>, <span class="title">const</span> <span class="title">queue</span>&lt;T, Sequence&gt;&amp; <span class="title">y</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> x.c == y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">operator</span>&lt;(const queue&lt;T, Sequence&gt;&amp; x, const queue&lt;T, Sequence&gt;&amp; y)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    return x.c &lt; y.c;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="以list作为queue的底部容器"><a href="#以list作为queue的底部容器" class="headerlink" title="以list作为queue的底部容器"></a>以list作为queue的底部容器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; iqueue;</span><br><span class="line">	<span class="comment">//queue&lt;int&gt; iqueue; //缺省时使用deque</span></span><br><span class="line">    iqueue.push(<span class="number">1</span>);</span><br><span class="line">    iqueue.push(<span class="number">3</span>);</span><br><span class="line">    iqueue.push(<span class="number">5</span>);</span><br><span class="line">    iqueue.push(<span class="number">7</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iqueue.size() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//4</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iqueue.front() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//1</span></span><br><span class="line"> </span><br><span class="line">    iqueue.pop();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iqueue.front() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//3</span></span><br><span class="line">    iqueue.pop();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iqueue.front() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//5</span></span><br><span class="line">    iqueue.pop();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iqueue.front() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//7</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iqueue.size() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//1</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="heap概述"><a href="#heap概述" class="headerlink" title="heap概述"></a>heap概述</h2><p>heap并不归属于STL容器组件，扮演priority queue的助手，binary max heap适合作为priority queue的底层机制，priority queue允许用户以任意次序将元素推入容器，但是取出是一定是优先权最高（数值最高）的元素先出来。binary heap是一种complete binary tree（完全二叉树），整棵binary tree除了最底层的叶子节点外是填满的，而最底层的叶子节点由左至右不得有空隙。</p>
<p>complete binary tree整棵树内没有任何节点漏洞，这就可以利用array来存储completebinary tree的所有节点，将array的#0元素保留，那么当complete binary tree的某个节点位于array的i处时，其左子节点必位于array的2i处，右子节点必位于array的2i+1处，父节点必位于i/2处。我们需要的是一个array和一组heap算法，array的缺点是无法动态改变大小，以vector代替array是更好的选择。</p>
<p>根据元素排列方式，heap分为max-heap和min-heap两种，前者每个节点的键值都大于或等于其子节点的值，后者每个节点的键值都小于或等于其子节点的值。max-heap中最大值在根节点，min-heap最小值在根节点。底层存储结构为vector或者array。STL 供应的是max-heap。heap的所有元素都必须遵循特别的排列规则，所以heap不提供遍历功能，也不提供迭代器。</p>
<h3 id="heap算法"><a href="#heap算法" class="headerlink" title="heap算法"></a>heap算法</h3><h4 id="push-heap算法"><a href="#push-heap算法" class="headerlink" title="push_heap算法"></a>push_heap算法</h4><p>push_heap算法：将新加入的元素放在最下层的叶节点，即vector的<code>end()</code>处，还需满足max-heap条件，执行所谓的percolate up(上溯)过程，即不断比较新节点和其父节点，如果键值比父节点大，就父子节点对换位置，最终将其放到合适的位置。举例如下：<br><img src="/img/1609732832.jpg" alt></p>
<p>下面是<code>push_heap</code>的实现细节，该函数接受两个迭代器，用来表达一个heap底部容器的头尾，并且新元素已经插入到底部容器的最尾端，如果不符合这两个条件，<code>push_heap</code>的执行结果不可预期。代码实现：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">inline</span> <span class="title">void</span> <span class="title">push_heap</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,<span class="title">RandomAccessIterator</span> <span class="title">last</span>)&#123;</span></span><br><span class="line">    <span class="comment">//这个函数被调用时，新元素已经放在底部容器的最尾端</span></span><br><span class="line">        _push_heap_aux(first,last,distance_type(first),value_type(first));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>,<span class="title">class</span> <span class="title">Distance</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">inline</span> <span class="title">void</span> _<span class="title">push_heap_aux</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,<span class="title">RandomAccessIterator</span> <span class="title">last</span>,<span class="title">Distance</span>*,<span class="title">T</span>*)</span></span><br><span class="line"><span class="class">    &#123;</span>_push_heap(first ,Distance((last-first)<span class="number">-1</span>),Distance(<span class="number">0</span>),T(*(last<span class="number">-1</span>)));&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一下这组push_back()不允许指定大小比较标准</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>,<span class="title">class</span> <span class="title">Distance</span>,<span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">     <span class="title">void</span> _<span class="title">push_heap</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,<span class="title">Distance</span> <span class="title">holeIndex</span>,<span class="title">Distance</span> <span class="title">topIndex</span>,<span class="title">T</span> <span class="title">value</span>)</span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        Distance parent=(holeIndex<span class="number">-1</span>)/<span class="number">2</span>;<span class="comment">//找出父节点</span></span><br><span class="line">        <span class="keyword">while</span>(holeIndex&gt;topIndex&amp;&amp;*(first+parent)&lt;value)&#123;</span><br><span class="line">        <span class="comment">//未到达顶端，父节点小于新值,使用&lt;,所以STL heap是个max_heap。</span></span><br><span class="line">             *(first+holeIndex)=*(first +parent)<span class="comment">//父值下移</span></span><br><span class="line">            holeIndex=parent;<span class="comment">//调整位置，向上提升至父节点</span></span><br><span class="line">            parent=(holeIndex<span class="number">-1</span>)/<span class="number">2</span>;<span class="comment">//找到新的父节点。</span></span><br><span class="line">        &#125;<span class="comment">//持续到顶端，或者满足heap的特性就停止了。</span></span><br><span class="line">         *(first+holeIndex)=value;<span class="comment">//找到它应该处于的位置，插入操作结束。</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="pop-heap"><a href="#pop-heap" class="headerlink" title="pop_heap"></a>pop_heap</h4><p>如图所示的是pop heap算法的实际操演情况。既然身为max-heap，最大值必然在根节点。pop操作取走根节点（其实是移至底部容器vector的最后一个元素）之后，为了满足complete binary tree的条件，必须将最下一层最右边的叶节点拿掉，现在我们的任务是为这个被拿掉的节点找一个适当的位置。</p>
<p>为满足max-heap的条件（每个节点的键值都大于或等于其子节点键值）, 我们执行一个所谓的percolate down（下溯）程序：将根节点（最大值被取走后，形成一个“洞”）填人上述那个失去生存空间的叶节点值，再将它拿来和其两个子节点比较键值（key），并与较大子节点对调位置、如此一直下放，直到这个“洞” 的键值大于左右两个子节点，或直到下放至叶节点为止：<br><img src="/img/1609733154.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;//提供首尾两个迭代器，否则结果不可预知。</span></span><br><span class="line"><span class="class">   <span class="title">inline</span> <span class="title">void</span> <span class="title">pop_heap</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">       __pop_heap_aux(first, last, value_type(first));</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">   <span class="title">inline</span> <span class="title">void</span> __<span class="title">pop_heap_aux</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">       <span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">T</span>*) &#123;</span></span><br><span class="line">       __pop_heap(first, last - <span class="number">1</span>, last - <span class="number">1</span>, T(*(last - <span class="number">1</span>)), distance_type(first));</span><br><span class="line">       <span class="comment">// pop动作的結果为底层容器的第一個元素。因此，首先设定欲调整值为尾值，然后將首值調至 </span></span><br><span class="line">       <span class="comment">// 尾节点（所以以上將迭代器result设为last-1）。然后重整 [first, last-1)，</span></span><br><span class="line">       <span class="comment">// 使之重新成一個合格的 heap。</span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class">   <span class="title">inline</span> <span class="title">void</span> __<span class="title">pop_heap</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>,</span></span><br><span class="line"><span class="class">       <span class="title">RandomAccessIterator</span> <span class="title">result</span>, <span class="title">T</span> <span class="title">value</span>, <span class="title">Distance</span>*) &#123;</span></span><br><span class="line">       *result = *first; <span class="comment">// 設定尾值为首值，于是尾值即是結果，</span></span><br><span class="line">       <span class="comment">// 可由调用底层容器之 pop_back() 取出尾值。</span></span><br><span class="line">       __adjust_heap(first, Distance(<span class="number">0</span>), Distance(last - first), value);</span><br><span class="line">       <span class="comment">// 以上欲重新調整 heap，洞号为 0，欲調整值为value。</span></span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">Distance</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">   <span class="title">void</span> __<span class="title">adjust_heap</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">Distance</span> <span class="title">holeIndex</span>,</span></span><br><span class="line"><span class="class">       <span class="title">Distance</span> <span class="title">len</span>, <span class="title">T</span> <span class="title">value</span>) &#123;</span></span><br><span class="line">       Distance topIndex = holeIndex;</span><br><span class="line">       Distance secondChild = <span class="number">2</span> * holeIndex + <span class="number">2</span>;    <span class="comment">// 洞节点之右子节点</span></span><br><span class="line">       <span class="keyword">while</span> (secondChild &lt; len) &#123;</span><br><span class="line">           <span class="comment">// 比较洞节点之左右兩个子值，然后以 secondChild 代表较大子节点。</span></span><br><span class="line">           <span class="keyword">if</span> (*(first + secondChild) &lt; *(first + (secondChild - <span class="number">1</span>)))</span><br><span class="line">               secondChild--;</span><br><span class="line">           <span class="comment">// Percolate down：令较大大子值为洞值，再令洞号下移至较大子节点处。</span></span><br><span class="line">           *(first + holeIndex) = *(first + secondChild);</span><br><span class="line">           holeIndex = secondChild;</span><br><span class="line">           <span class="comment">// 找出新洞节点的右子节点</span></span><br><span class="line">           secondChild = <span class="number">2</span> * (secondChild + <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">if</span> (secondChild == len) &#123; <span class="comment">// 沒有右子节点，只有左子节点</span></span><br><span class="line">           <span class="comment">// Percolate down：令左子值为洞值，再令洞号下移至左子节点处。</span></span><br><span class="line">           *(first + holeIndex) = *(first + (secondChild - <span class="number">1</span>));</span><br><span class="line">           holeIndex = secondChild - <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       <span class="comment">// 將欲调整值填入目前的洞号內。注意，此時肯定滿足次序特性。</span></span><br><span class="line">       <span class="comment">// 依侯捷之见，下面直接改為 *(first + holeIndex) = value; 应该可以。</span></span><br><span class="line">       __push_heap(first, holeIndex, topIndex, value);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//此时的最大元素只是被放置在了底部容器的尾端，并未被取走，所以要取值，可以使用底部容器提供的back()操作函数，如果要移除，使用pop_back().</span></span><br></pre></td></tr></table></figure>
<p>注意：pop_heap后，最大元素只是被置于底层容器的最尾部，尚未被取走。如果取值，可用back函数；如果移除，可用pop_back函数。 </p>
<h4 id="sort-heap"><a href="#sort-heap" class="headerlink" title="sort_heap"></a>sort_heap</h4><p>既然每次pop_heap都将最大值放到vector的末尾，那么如果每次都缩小pop_heap的参数范围（从后向前缩减一个与元素），那么最终得到的vector将是一个递增序列。<br><img src="/img/20210104160923.png" alt><br><img src="/img/1609759644.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下这个sort_heap()不允许指定「大小比较标准」</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">sort_heap</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">        <span class="comment">// 以下，每執行一次 pop_heap()，極值（在STL heap中為極大值）即被放在尾端。</span></span><br><span class="line">        <span class="comment">// 扣除尾端再執行一次 pop_heap()，次極值又被放在新尾端。一直下去，最後即得</span></span><br><span class="line">        <span class="comment">// 排序結果。</span></span><br><span class="line">        <span class="keyword">while</span> (last - first &gt; <span class="number">1</span>)</span><br><span class="line">            pop_heap(first, last--); <span class="comment">// 每執行 pop_heap() 一次，操作範圍即退縮一格。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap"></a>make_heap</h3><p>make_heap将一段现有的数据转化成一个heap，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 將 [first,last)排列为一个heap。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">make_heap</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>) &#123;</span></span><br><span class="line">        __make_heap(first, last, value_type(first), distance_type(first));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下這組 make_heap() 不允許指定「大小比較標準」。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> __<span class="title">make_heap</span>(<span class="title">RandomAccessIterator</span> <span class="title">first</span>, <span class="title">RandomAccessIterator</span> <span class="title">last</span>, <span class="title">T</span>*,</span></span><br><span class="line"><span class="class">        <span class="title">Distance</span>*) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> (last - first &lt; <span class="number">2</span>) <span class="keyword">return</span>;    <span class="comment">// 如果長度為 0 或 1，不必重新排列。</span></span><br><span class="line">        Distance len = last - first;</span><br><span class="line">        <span class="comment">// 找出第一個需要重排的子樹頭部，以 parent 標示出。由於任何葉節點都不需執行 </span></span><br><span class="line">        <span class="comment">// perlocate down，所以有以下計算。parent 命名不佳，名為 holeIndex 更好。</span></span><br><span class="line">        Distance parent = (len - <span class="number">2</span>) / <span class="number">2</span>;<span class="comment">//找出第一个有子节点的节点</span></span><br><span class="line">     </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 重排以 parent 為首的子樹。len 是為了讓 __adjust_heap() 判斷操作範圍</span></span><br><span class="line">            __adjust_heap(first, parent, len, T(*(first + parent)));<span class="comment">//下溯程序</span></span><br><span class="line">            <span class="keyword">if</span> (parent == <span class="number">0</span>) <span class="keyword">return</span>;    <span class="comment">// 排序到根節點，程序就結束。</span></span><br><span class="line">            parent--;                    <span class="comment">// （重排之子樹的）頭部向前一個節點，迭代过程，排序完一个就接着排序前一个。</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="heap测试实例"><a href="#heap测试实例" class="headerlink" title="heap测试实例"></a>heap测试实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// test heap (以vector完成)</span></span><br><span class="line">        <span class="keyword">int</span> ia[<span class="number">9</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(ia, ia + <span class="number">9</span>);</span><br><span class="line"> </span><br><span class="line">        make_heap(ivec.begin(), ivec.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ivec.size(); ++i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ivec[i] &lt;&lt; <span class="string">" "</span>;       <span class="comment">// 9 5 8 3 4 0 2 3 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">        ivec.push_back(<span class="number">7</span>);</span><br><span class="line">        push_heap(ivec.begin(), ivec.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ivec.size(); ++i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ivec[i] &lt;&lt; <span class="string">" "</span>;       <span class="comment">// 9 5 8 3 4 0 2 3 1 4</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">        pop_heap(ivec.begin(), ivec.end());</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ivec.back() &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">// 9</span></span><br><span class="line">        ivec.pop_back();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ivec.size(); ++i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ivec[i] &lt;&lt; <span class="string">" "</span>;     <span class="comment">// 8 7 4 3 5 0 2 3 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">        sort_heap(ivec.begin(), ivec.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ivec.size(); ++i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ivec[i] &lt;&lt; <span class="string">" "</span>;    <span class="comment">// 0 1 2 3 3 4 5 7 8 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// test heap (以array完成)</span></span><br><span class="line">        <span class="keyword">int</span> ia[<span class="number">9</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"> </span><br><span class="line">        make_heap(ia, ia+<span class="number">9</span>);</span><br><span class="line">        <span class="comment">// array无法动态改变大小，因此不可以对满载的 array做 push_heap()动作。</span></span><br><span class="line">        <span class="comment">//因为那得先在 array尾端增加㆒个元素。</span></span><br><span class="line"> </span><br><span class="line">        sort_heap(ia, ia+<span class="number">9</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ia[i] &lt;&lt; <span class="string">" "</span>;  <span class="comment">// 0 1 2 3 3 4 5 8 9</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">        make_heap(ia, ia+<span class="number">9</span>);</span><br><span class="line">        pop_heap(ia, ia+<span class="number">9</span>); </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ia[<span class="number">8</span>] &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">// 9</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// test heap (底层以 array完成) </span></span><br><span class="line">        <span class="keyword">int</span> ia[<span class="number">6</span>] = &#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>&#125;; </span><br><span class="line">        make_heap(ia, ia+<span class="number">6</span>); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">6</span>; ++i) </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ia[i] &lt;&lt; <span class="string">' '</span>;  <span class="comment">// 7 6 5 1 2 4</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="priority-queue概述"><a href="#priority-queue概述" class="headerlink" title="priority_queue概述"></a>priority_queue概述</h2><p>priority_queue是一个拥有权值观念的queue，它允许加入新元素，移除旧元素，审视元素值等功能．只允许在尾部加入元素，并从头部取出元素，除此之外别无其他存取元素的途径。priority_queue缺省情况下是以vector为底层容器，再加上<strong>max-heap处理规则</strong>，STL priority_queue往往不被归类为Container(容器)，而被归类为container adapter。priority_queue的所有元素，进出都有一定规则，只有queue顶端的元素，才有机会被外界取用。它不提供遍历功能，也不提供迭代器。<br><img src="/img/1609762206.jpg" alt></p>
<h3 id="priority-queue-完整定义"><a href="#priority-queue-完整定义" class="headerlink" title="priority_queue 完整定义"></a>priority_queue 完整定义</h3><p>priority_queue完全以底部容器为根据，再加上heap处理规则，所以实现很简单，缺省情况下是以vector为底部容器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Sequence</span> = <span class="title">vector</span>&lt;T&gt;,</span></span><br><span class="line"><span class="class">	<span class="title">class</span> <span class="title">Compare</span> = <span class="title">less</span>&lt;typename Sequence::value_type&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">priority_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	Sequence c;        <span class="comment">//底层容器</span></span><br><span class="line">	Compare comp; <span class="comment">//元素大小比较标准</span></span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    priority_queue() : c() &#123;&#125;</span><br><span class="line">    explicit priority_queue(const Compare&amp; x) : c() comp(x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="comment">//用到heap泛型算法作为其实现</span></span><br><span class="line">	<span class="comment">//定义一个priority_queue实则是一个建堆的过程</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="class">	<span class="title">priority_queue</span>( <span class="title">InputIterator</span> <span class="title">first</span>,  <span class="title">InputIterator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">Compare</span>&amp; <span class="title">x</span>)</span></span><br><span class="line"><span class="class">	  :</span> c (first, last), comp(x) &#123; </span><br><span class="line">        make_heap(c.begin(), c.end(), comp);</span><br><span class="line">    &#125;</span><br><span class="line">	priority_queue( InputIterator first,  InputIterator last)</span><br><span class="line">	  : c (first, last) &#123; </span><br><span class="line">        make_heap(c.begin(), c.end(), comp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> c.empty(); &#125;</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.size(); &#125;</span><br><span class="line">    <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.front(); &#125;</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span>  </span>&#123;</span><br><span class="line">		__STL_TRY &#123;</span><br><span class="line">		<span class="comment">//先利用底层容器的	push_back将新元素推入末端，再重排heap</span></span><br><span class="line">			c.push_back(x);</span><br><span class="line">			push_heap(c.begin(), c.end(), comp);</span><br><span class="line">		&#125;</span><br><span class="line">		__STL_UNWIND(c.clear());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">		__STL_TRY &#123;</span><br><span class="line">		<span class="comment">//先从heap内取出一个元素，并不是简单的弹出，而是重排heap，然后在以底层容器的pop_back取得被弹出的元素</span></span><br><span class="line">			pop_heap(c.begin(), c.end(), comp);</span><br><span class="line">			c.pop_back();</span><br><span class="line">		&#125;</span><br><span class="line">		__STL_UNWIND(c.clear());</span><br><span class="line"> 	&#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="priority-queue测试实例"><a href="#priority-queue测试实例" class="headerlink" title="priority_queue测试实例"></a>priority_queue测试实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// test priority queue</span></span><br><span class="line">    <span class="keyword">int</span> ia[<span class="number">9</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; ipq(ia, ia + <span class="number">9</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size="</span> &lt;&lt; ipq.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ipq.size(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ipq.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(!ipq.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ipq.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        ipq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">————————————————————————————————————————————————————————————————————</span><br><span class="line">[root@<span class="number">192</span> <span class="number">4</span>_STL_sequence_container]# ./<span class="number">4</span>_8_4_pqueue-test</span><br><span class="line">size=<span class="number">9</span></span><br><span class="line"><span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span> <span class="number">9</span></span><br><span class="line"><span class="number">9</span> <span class="number">8</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="slist概述"><a href="#slist概述" class="headerlink" title="slist概述"></a>slist概述</h2><p>SGI STL另提供一个单向链表slist。slist和list的主要差别在于，前者的迭代器属于单向的Forward Iterator，后者的迭代器属于双向的BidirectionalIterator。slist的功能自然也受到一些限制，不过单向链表所耗用的空间更小，某些操作更快，不失为一种选择。slist和list共同的特点是，插入删除等操作不会造成原有的迭代器失效。</p>
<p>根据STL的习惯，插入操作会将新元素插入于指定位置之前。作为单向链表，slist没有任何方便的方法可以回头定出前一个位置，因此它必须从头找起。为此，slist特别提供了<code>insert_after</code>和<code>erase_after</code>函数供灵活调用。</p>
<h3 id="slist的节点"><a href="#slist的节点" class="headerlink" title="slist的节点"></a>slist的节点</h3><p>slist节点和其迭代器的设计，运用了继承关系：<br><img src="/img/1609764727.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">slist_node_base</span> &#123;</span></span><br><span class="line">    __slist_node_base *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">slist_node</span> :</span> <span class="keyword">public</span> __slist_node_base</span><br><span class="line">&#123;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> __slist_node_base* __slist_make_link(__slist_node_base* prev_node, __slist_node_base* new_node) &#123;</span><br><span class="line">    <span class="comment">// 令new节点的下一节点为prev节点的下一节点</span></span><br><span class="line">    new_node-&gt;next = prev_node-&gt;next;</span><br><span class="line">    prev_node-&gt;next = new_node;</span><br><span class="line">    <span class="keyword">return</span> new_node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __slist_size(__slist_node_base* node) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; node != <span class="number">0</span>; node = node-&gt;next)</span><br><span class="line">        ++ result;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="slist的迭代器"><a href="#slist的迭代器" class="headerlink" title="slist的迭代器"></a>slist的迭代器</h3><p><img src="/img/1609765004.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单向链表的迭代器基本结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">slist_iterator_base</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> forward_iterator_tag iterator_category;</span><br><span class="line"></span><br><span class="line">    __slist_node_base* node;</span><br><span class="line">    __slist_iterator_base(__slist_node_base*x) : node(x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">incr</span><span class="params">()</span> </span>&#123;node = node-&gt;next;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> __slist_iterator_base&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node == x.node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> __slist_iterator_base&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> node != x.node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单向链表的迭代器结构</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">slist_iterator</span> :</span> <span class="keyword">public</span> __slist_iterator_base </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> __slist_iteratror&lt;T, T&amp;, T*&gt;  iterator;</span><br><span class="line">    <span class="keyword">typedef</span> __slist_iteratror&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;</span><br><span class="line">    <span class="keyword">typedef</span> __slist_iteratror&lt;T, Ref, Ptr&gt; self;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">    <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">    <span class="keyword">typedef</span> __slist_node&lt;T&gt; list_node;</span><br><span class="line"></span><br><span class="line">    __slist_iterator(list_node* x) : __slist_iterator_base(x) &#123;&#125;</span><br><span class="line">    <span class="comment">// 调用slist&lt;T&gt;::end()时会造成__slist_iterator(0)，于是调用上述函数</span></span><br><span class="line">    __slist_iterator() : __slist_iterator_base(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    __slist_iterator(<span class="keyword">const</span> iterator&amp; x) : __slist_iterator_base(x.node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> ((list_node*) node)-&gt;data; &#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"></span><br><span class="line">    self&amp; <span class="keyword">operator</span>++()</span><br><span class="line">    &#123;</span><br><span class="line">        incr();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        incr();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="slist的数据结构"><a href="#slist的数据结构" class="headerlink" title="slist的数据结构"></a>slist的数据结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span> = <span class="title">alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">slist</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="keyword">typedef</span>	T	value_type ;</span><br><span class="line">	<span class="keyword">typedef</span>	value_type*	pointer ; </span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">const</span>	value_type*	const_pointer ;</span><br><span class="line">	<span class="keyword">typedef</span>	value_type&amp;	reference ;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">const</span> value_type&amp; const_reference ;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">size_t</span>	size_type ;</span><br><span class="line">	<span class="keyword">typedef</span>	<span class="keyword">ptrdiff_t</span>	difference_type ;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="keyword">typedef</span>	__slist_iterator&lt;T,T&amp;,T*&gt;	iterator ;</span><br><span class="line">	<span class="keyword">typedef</span>	__slist_iterator&lt;T,<span class="keyword">const</span> T&amp;,<span class="keyword">const</span> T*&gt; const_iterator ;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">	<span class="keyword">typedef</span>	__slist_node&lt;T&gt;	list_node ;</span><br><span class="line">	<span class="keyword">typedef</span>	__slist_node_base	list_node_base ;</span><br><span class="line">	<span class="keyword">typedef</span>	__slist_iterator_base	iterator_base ;</span><br><span class="line">	<span class="keyword">typedef</span> simple_alloc&lt;list_node,Alloc&gt; list_node_allocator ;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">static</span>	list_node* <span class="title">create_node</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		list_node* node = list_node_allocator:;allocate() ; <span class="comment">//配置空间</span></span><br><span class="line">		__STL_TRY&#123;</span><br><span class="line">			construct(&amp;node-&gt;data,x) ;</span><br><span class="line">			node-&gt;next = <span class="number">0</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		__STL_UNWIND(list_node_allocator:;deallocate(node)) ;</span><br><span class="line">		<span class="keyword">return</span> node ;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy_node</span><span class="params">(list_node* node)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		destroy(&amp;node-&gt;data) ; <span class="comment">//将元素析构	</span></span><br><span class="line">		list_node_allocator::deallocate(node) ; <span class="comment">//释放空间</span></span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">	list_node_base head  ; <span class="comment">//头部。注意，它不是指针，是实物</span></span><br><span class="line">			</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	slist() &#123;head.next = <span class="number">0</span> ;&#125; </span><br><span class="line">	~slist()&#123;clear() ;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> iterator((list_node*)head.next) ;&#125;</span><br><span class="line">	<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> iteator(<span class="number">0</span>) ;&#125;</span><br><span class="line">	<span class="function">iterator <span class="title">size</span><span class="params">()</span> </span>&#123;<span class="keyword">const</span> __slist_size(head.next) ;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> head.next == <span class="number">0</span> ;&#125; </span><br><span class="line"> </span><br><span class="line">	<span class="comment">//两个slist互换：只要将head交换互指即可</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(slist &amp;L)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		list_node_base* tmp = head.next;</span><br><span class="line">		head.next = L.head.next ;</span><br><span class="line">		L.head.next = tmp ;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="comment">//取头部元素</span></span><br><span class="line">	<span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> ((list_node*)head.next)-&gt;data ;&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//从头部插入元素(新元素成为slist的第一个元素)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		__slist_make_link(&amp;head,create_node(x)) ;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//注意,没有push_back()</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//从头部取走元素(删除之)。修改head</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		list_node* node = (list_node*)head.next ;</span><br><span class="line">		head.next = node-&gt;next ;</span><br><span class="line">		destroy_node(node);</span><br><span class="line">	&#125;</span><br><span class="line">	.....</span><br><span class="line">&#125;  ;</span><br></pre></td></tr></table></figure>
<h3 id="slist的测试实例"><a href="#slist的测试实例" class="headerlink" title="slist的测试实例"></a>slist的测试实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: 4slist-test.cpp</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// mingw64没有这个库</span></span><br><span class="line"><span class="comment">//#include &lt;slist&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    slist&lt;<span class="keyword">int</span>&gt; islist;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size="</span> &lt;&lt; islist.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    islist.push_front(<span class="number">9</span>); </span><br><span class="line">    islist.push_front(<span class="number">1</span>); </span><br><span class="line">    islist.push_front(<span class="number">2</span>); </span><br><span class="line">    islist.push_front(<span class="number">3</span>); </span><br><span class="line">    islist.push_front(<span class="number">4</span>); </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size="</span> &lt;&lt; islist.size() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"> </span><br><span class="line">    slist&lt;<span class="keyword">int</span>&gt;::iterator ite =islist.begin(); </span><br><span class="line">    slist&lt;<span class="keyword">int</span>&gt;::iterator ite2=islist.end(); </span><br><span class="line">    <span class="keyword">for</span>(; ite != ite2; ++ite) </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *ite &lt;&lt; <span class="string">' '</span>;  <span class="comment">// 4 3 2 1 9</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"> </span><br><span class="line">    ite = find(islist.begin(), islist.end(), <span class="number">1</span>); <span class="comment">//使用STL的find函数，可以找到1之前的那个迭代器</span></span><br><span class="line">    <span class="keyword">if</span> (ite!=<span class="number">0</span>) </span><br><span class="line">        islist.insert(ite, <span class="number">99</span>); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"size="</span> &lt;&lt; islist.size() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// size=6</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *ite &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line">    ite =islist.begin(); </span><br><span class="line">    ite2=islist.end(); </span><br><span class="line">    <span class="keyword">for</span>(; ite != ite2; ++ite) </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *ite &lt;&lt; <span class="string">' '</span>; <span class="comment">// 4 3 2 99 1 9 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"> </span><br><span class="line">    ite = find(islist.begin(), islist.end(), <span class="number">3</span>); </span><br><span class="line">    <span class="keyword">if</span> (ite!=<span class="number">0</span>) </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *(islist.erase(ite)) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 2</span></span><br><span class="line"> </span><br><span class="line">    ite =islist.begin(); </span><br><span class="line">    ite2=islist.end(); </span><br><span class="line">    <span class="keyword">for</span>(; ite != ite2; ++ite) </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *ite &lt;&lt; <span class="string">' '</span>;    <span class="comment">// 4 2 99 1 9</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/1609767703.jpg" alt><br><img src="/img/1609767737.jpg" alt></p>
<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>insert函数的实现如下，<code>__slist_previous</code>函数可以根据头节点<code>_M_head</code>和位置节点<code>__pos</code>找到<code>__pos</code>之前的那个节点，然后调用<code>_M_insert_after</code>函数，实际调用<code>__slist_make_link</code>，在<code>__pos-1</code>节点后创建以<code>__x</code>为值的节点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">islist.insert(ite, <span class="number">99</span>); </span><br><span class="line"> </span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator __pos, <span class="keyword">const</span> value_type&amp; __x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> iterator(_M_insert_after(__slist_previous(&amp;<span class="keyword">this</span>-&gt;_M_head,</span><br><span class="line">                                                     __pos._M_node),</span><br><span class="line">                    __x));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">inline</span> _Slist_node_base* __slist_previous(_Slist_node_base* __head,</span><br><span class="line">                 <span class="keyword">const</span> _Slist_node_base* __node)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (__head &amp;&amp; __head-&gt;_M_next != __node)</span><br><span class="line">    __head = __head-&gt;_M_next;</span><br><span class="line">  <span class="keyword">return</span> __head;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">_Node* _M_insert_after(_Node_base* __pos, <span class="keyword">const</span> value_type&amp; __x) &#123;</span><br><span class="line">    <span class="keyword">return</span> (_Node*) (__slist_make_link(__pos, _M_create_node(__x)));</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/12/11/STL源码剖析 笔记1/" rel="next" title="STL 源码剖析 笔记1">
                <i class="fa fa-chevron-left"></i> STL 源码剖析 笔记1
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/01/06/STL源码剖析 笔记3/" rel="prev" title="STL 源码剖析 笔记3">
                STL 源码剖析 笔记3 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">290</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#迭代器概念与traits编程技法"><span class="nav-number">1.</span> <span class="nav-text">迭代器概念与traits编程技法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器设计思维——STL关键所在"><span class="nav-number">1.1.</span> <span class="nav-text">迭代器设计思维——STL关键所在</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器是一种smart-pointer"><span class="nav-number">1.2.</span> <span class="nav-text">迭代器是一种smart pointer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器相应型别"><span class="nav-number">1.3.</span> <span class="nav-text">迭代器相应型别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Traits编程技法——STL源代码门钥"><span class="nav-number">1.4.</span> <span class="nav-text">Traits编程技法——STL源代码门钥</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Partial-Specialization（偏特化）的意义"><span class="nav-number">1.4.1.</span> <span class="nav-text">Partial Specialization（偏特化）的意义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器相应型别之一：value-type"><span class="nav-number">1.4.2.</span> <span class="nav-text">迭代器相应型别之一：value type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器相应型别之二：difference-type"><span class="nav-number">1.4.3.</span> <span class="nav-text">迭代器相应型别之二：difference type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器相应型别之三：reference-type"><span class="nav-number">1.4.4.</span> <span class="nav-text">迭代器相应型别之三：reference type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器相应型别之四：pointer-type"><span class="nav-number">1.4.5.</span> <span class="nav-text">迭代器相应型别之四：pointer type</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器相应型别之五：iterator-category"><span class="nav-number">1.4.6.</span> <span class="nav-text">迭代器相应型别之五：iterator_category</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#消除“单纯传递调用的函数”"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">消除“单纯传递调用的函数”</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-iterator的保证"><span class="nav-number">1.5.</span> <span class="nav-text">std::iterator的保证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SGI-STL的私房菜：-type-traits"><span class="nav-number">1.6.</span> <span class="nav-text">SGI STL的私房菜：__type_traits</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#序列式容器"><span class="nav-number">2.</span> <span class="nav-text">序列式容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#容器的概观与分类"><span class="nav-number">2.1.</span> <span class="nav-text">容器的概观与分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vector概述"><span class="nav-number">2.2.</span> <span class="nav-text">vector概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vector-的迭代器"><span class="nav-number">2.2.1.</span> <span class="nav-text">vector 的迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector数据结构"><span class="nav-number">2.2.2.</span> <span class="nav-text">vector数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector构造与内存管理"><span class="nav-number">2.2.3.</span> <span class="nav-text">vector构造与内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#vector的元素操作"><span class="nav-number">2.2.4.</span> <span class="nav-text">vector的元素操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#list"><span class="nav-number">2.3.</span> <span class="nav-text">list</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#list概述"><span class="nav-number">2.4.</span> <span class="nav-text">list概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#list的节点"><span class="nav-number">2.4.1.</span> <span class="nav-text">list的节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list的迭代器"><span class="nav-number">2.4.2.</span> <span class="nav-text">list的迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list的数据结构"><span class="nav-number">2.4.3.</span> <span class="nav-text">list的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list的构造与内存管理"><span class="nav-number">2.4.4.</span> <span class="nav-text">list的构造与内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#list的元素操作"><span class="nav-number">2.4.5.</span> <span class="nav-text">list的元素操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#deque"><span class="nav-number">2.5.</span> <span class="nav-text">deque</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#deque的中控器"><span class="nav-number">2.5.1.</span> <span class="nav-text">deque的中控器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque的迭代器"><span class="nav-number">2.5.2.</span> <span class="nav-text">deque的迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque的数据结构"><span class="nav-number">2.5.3.</span> <span class="nav-text">deque的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque的构造与内存管理"><span class="nav-number">2.5.4.</span> <span class="nav-text">deque的构造与内存管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque的元素操作"><span class="nav-number">2.5.5.</span> <span class="nav-text">deque的元素操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stack"><span class="nav-number">2.6.</span> <span class="nav-text">stack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stack概述"><span class="nav-number">2.6.1.</span> <span class="nav-text">stack概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stack-完整定义"><span class="nav-number">2.6.2.</span> <span class="nav-text">stack 完整定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#以list作为stack的底部容器"><span class="nav-number">2.6.3.</span> <span class="nav-text">以list作为stack的底部容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#queue"><span class="nav-number">2.7.</span> <span class="nav-text">queue</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#queue概述"><span class="nav-number">2.7.1.</span> <span class="nav-text">queue概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#queue-完整定义"><span class="nav-number">2.7.2.</span> <span class="nav-text">queue 完整定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#以list作为queue的底部容器"><span class="nav-number">2.7.3.</span> <span class="nav-text">以list作为queue的底部容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#heap概述"><span class="nav-number">2.8.</span> <span class="nav-text">heap概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#heap算法"><span class="nav-number">2.8.1.</span> <span class="nav-text">heap算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#push-heap算法"><span class="nav-number">2.8.1.1.</span> <span class="nav-text">push_heap算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pop-heap"><span class="nav-number">2.8.1.2.</span> <span class="nav-text">pop_heap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sort-heap"><span class="nav-number">2.8.1.3.</span> <span class="nav-text">sort_heap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#make-heap"><span class="nav-number">2.8.2.</span> <span class="nav-text">make_heap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heap测试实例"><span class="nav-number">2.8.3.</span> <span class="nav-text">heap测试实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#priority-queue概述"><span class="nav-number">2.9.</span> <span class="nav-text">priority_queue概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#priority-queue-完整定义"><span class="nav-number">2.9.1.</span> <span class="nav-text">priority_queue 完整定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#priority-queue测试实例"><span class="nav-number">2.9.2.</span> <span class="nav-text">priority_queue测试实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#slist概述"><span class="nav-number">2.10.</span> <span class="nav-text">slist概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#slist的节点"><span class="nav-number">2.10.1.</span> <span class="nav-text">slist的节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slist的迭代器"><span class="nav-number">2.10.2.</span> <span class="nav-text">slist的迭代器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slist的数据结构"><span class="nav-number">2.10.3.</span> <span class="nav-text">slist的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#slist的测试实例"><span class="nav-number">2.10.4.</span> <span class="nav-text">slist的测试实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#insert"><span class="nav-number">2.10.5.</span> <span class="nav-text">insert</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
