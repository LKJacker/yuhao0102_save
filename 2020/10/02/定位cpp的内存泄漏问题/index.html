<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="用C/C++开发的程序执行效率很高，但却经常受到内存泄漏的困扰。本文提供一种通过wrap malloc查找memory leak的思路，依靠这个方法，笔者紧急解决了内存泄漏问题，避免项目流血上大促，该方法在日后工作中大放光彩，发现了项目中大量沉疴已久的内存泄漏问题。 什么是内存泄漏？动态申请的内存丢失引用，造成没有办法回收它（我知道杠jing要说进程退出前系统会统一回收），这便是内存泄漏。 Jav">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="通过wrap malloc定位CC++的内存泄漏问题">
<meta property="og:url" content="http://yoursite.com/2020/10/02/定位cpp的内存泄漏问题/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="用C/C++开发的程序执行效率很高，但却经常受到内存泄漏的困扰。本文提供一种通过wrap malloc查找memory leak的思路，依靠这个方法，笔者紧急解决了内存泄漏问题，避免项目流血上大促，该方法在日后工作中大放光彩，发现了项目中大量沉疴已久的内存泄漏问题。 什么是内存泄漏？动态申请的内存丢失引用，造成没有办法回收它（我知道杠jing要说进程退出前系统会统一回收），这便是内存泄漏。 Jav">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20210513112200.jpg">
<meta property="og:updated_time" content="2021-05-13T03:43:33.144Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="通过wrap malloc定位CC++的内存泄漏问题">
<meta name="twitter:description" content="用C/C++开发的程序执行效率很高，但却经常受到内存泄漏的困扰。本文提供一种通过wrap malloc查找memory leak的思路，依靠这个方法，笔者紧急解决了内存泄漏问题，避免项目流血上大促，该方法在日后工作中大放光彩，发现了项目中大量沉疴已久的内存泄漏问题。 什么是内存泄漏？动态申请的内存丢失引用，造成没有办法回收它（我知道杠jing要说进程退出前系统会统一回收），这便是内存泄漏。 Jav">
<meta name="twitter:image" content="http://yoursite.com/img/20210513112200.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/10/02/定位cpp的内存泄漏问题/">





  <title>通过wrap malloc定位CC++的内存泄漏问题 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/02/定位cpp的内存泄漏问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">通过wrap malloc定位CC++的内存泄漏问题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-02T14:48:00+08:00">
                2020-10-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>用C/C++开发的程序执行效率很高，但却经常受到内存泄漏的困扰。本文提供一种通过wrap malloc查找memory leak的思路，依靠这个方法，笔者紧急解决了内存泄漏问题，避免项目流血上大促，该方法在日后工作中大放光彩，发现了项目中大量沉疴已久的内存泄漏问题。</p>
<h1 id="什么是内存泄漏？"><a href="#什么是内存泄漏？" class="headerlink" title="什么是内存泄漏？"></a>什么是内存泄漏？</h1><p>动态申请的内存丢失引用，造成没有办法回收它（我知道杠jing要说进程退出前系统会统一回收），这便是内存泄漏。</p>
<p>Java等编程语言会自动管理内存回收，而C/C++需要显式的释放，有很多手段可以避免内存泄漏，比如RAII，比如智能指针（大多基于引用计数计数），比如内存池。</p>
<p>理论上，只要我们足够小心，在每次申请的时候，都牢记释放，那这个世界就清净了，但现实往往没有那么美好，比如抛异常了，释放内存的语句执行不到，又或者某菜鸟程序员不小心埋了一个雷，所以，我们必须直面真实的世界，那就是我们会遭遇内存泄漏。</p>
<h1 id="怎么查内存泄漏？"><a href="#怎么查内存泄漏？" class="headerlink" title="怎么查内存泄漏？"></a>怎么查内存泄漏？</h1><p>我们可以review代码，但从海量代码里找到隐藏的问题，这如同大海捞针，往往两手空空。</p>
<p>所以，我们需要借助工具，比如<code>valgrind</code>，但这些找内存泄漏的工具，往往对你使用动态内存的方式有某种期待，或者说约束，比如常驻内存的对象会被误报出来，然后真正有用的信息会掩盖在误报的汪洋大海里。很多时候，甚至<code>valgrind</code>根本解决不了日常项目中的问题。</p>
<p>所以很多著名的开源项目，为了能用<code>valgrind</code>跑，都费大力气，大幅修改源代码，从而使得项目符合<code>valgrind</code>的要求，满足这些要求，用<code>valgrind</code>跑完没有任何报警的项目叫<code>valgrind</code>干净。</p>
<p>既然这些玩意儿都中看不中用，所以，求人不如求己，还是得自力更生。</p>
<h1 id="什么是动态内存分配器？"><a href="#什么是动态内存分配器？" class="headerlink" title="什么是动态内存分配器？"></a>什么是动态内存分配器？</h1><p>动态内存分配器是介于kernel跟应用程序之间的一个函数库，glibc提供的动态内存分配器叫ptmalloc，它也是应用最广泛的动态内存分配器实现。</p>
<p>从kernel角度看，动态内存分配器属于应用程序层；而从应用程序的角度看，动态内存分配器属于系统层。</p>
<p>应用程序可以通过mmap系统直接向kernel申请动态内存，也可以通过动态内存分配器的malloc接口分配内存，而动态内存分配器会通过sbrk、mmap向kernel分配内存，所以应用程序通过free释放的内存，并不一定会真正返还给系统，它也有可能被动态内存分配器缓存起来。</p>
<p>google有自己的动态内存分配器tcmalloc，另外jemalloc也是著名的动态内存分配器，他们有不同的性能表现，也有不同的缓存和分配策略。你可以用它们替换linux系统glibc自带的ptmalloc。</p>
<h1 id="new-delete跟malloc-free的关系"><a href="#new-delete跟malloc-free的关系" class="headerlink" title="new/delete跟malloc/free的关系"></a>new/delete跟malloc/free的关系</h1><p>new是c++的用法，比如<code>Foo *f = new Foo</code>，其实它分为3步。</p>
<ol>
<li>通过<code>operator new()</code>分配<code>sizeof(Foo)</code>的内存，最终通过malloc分配。</li>
<li>在新分配的内存上构建Foo对象。</li>
<li>返回新构建的对象地址。</li>
</ol>
<p>new=分配内存+构造+返回，而delete则是等于析构+free。所以搞定malloc、free就是从根本上搞定动态内存分配。</p>
<h2 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h2><p>每次通过malloc返回的一块内存叫一个chunk，动态内存分配器是这样定义的，后面我们都这样称呼。</p>
<h2 id="wrap-malloc"><a href="#wrap-malloc" class="headerlink" title="wrap malloc"></a>wrap malloc</h2><p>gcc支持wrap，即通过传递<code>-Wl,--wrap,malloc</code>的方式，可以改变调用<code>malloc</code>的行为，把对<code>malloc</code>的调用链接到自定义的<code>__wrap_malloc(size_t)</code>函数，而我们可以在<code>__wrap_malloc(size_t)</code>函数的实现中通过<code>__real_malloc(size_t)</code>真正分配内存，而后我们可以做搞点小动作。</p>
<p>同样，我们可以<code>wrap free</code>。<code>malloc</code>跟<code>free</code>是配对的，当然也有其他相关API，比如<code>calloc</code>、<code>realloc</code>、<code>valloc</code>，但这根本上还是<code>malloc+free</code>，比如realloc就是malloc + free。</p>
<h1 id="怎么去定位内存泄漏呢？"><a href="#怎么去定位内存泄漏呢？" class="headerlink" title="怎么去定位内存泄漏呢？"></a>怎么去定位内存泄漏呢？</h1><p>我们会malloc各种不同size的chunk，也就是每种不同size的chunk会有不同数量，如果我们能够跟踪每种size的chunk数量，那就可以知道哪种size的chunk在泄漏。很简单，如果该size的chunk数量一直在增长，那它很可能泄漏。</p>
<p>光知道某种size的chunk泄漏了还不够，我们得知道是哪个调用路径上导致该size的chunk被分配，从而去检查是不是正确释放了。</p>
<h1 id="怎么跟踪到每种size的chunk数量？"><a href="#怎么跟踪到每种size的chunk数量？" class="headerlink" title="怎么跟踪到每种size的chunk数量？"></a>怎么跟踪到每种size的chunk数量？</h1><p>我们可以维护一个全局 <code>unsigned int malloc_map[1024 * 1024]</code>数组，该数组的下标就是chunk的size，<code>malloc_map[size]</code>的值就对应到该size的chunk分配量。</p>
<p>这等于维护了一个chunk size到chunk count的映射表，它足够快，而且它可以覆盖到0 ~ 1M大小的chunk的范围，它已经足够大了，试想一次分配一兆的块已经很恐怖了，可以覆盖到大部分场景。</p>
<p>那大于1M的块怎么办呢？我们可以通过log记录下来。</p>
<ul>
<li>在<code>__wrap_malloc</code>里，<code>++malloc_map[size]</code></li>
<li>在<code>__wrap_free</code>里，<code>--malloc_map[size]</code></li>
</ul>
<p>很简单，我们通过<code>malloc_map</code>记录了各size的chunk的分配量。</p>
<h1 id="如何知道释放的chunk的size？"><a href="#如何知道释放的chunk的size？" class="headerlink" title="如何知道释放的chunk的size？"></a>如何知道释放的chunk的size？</h1><p>不对，<code>free(void *p)</code>只有一个参数，我如何知道释放的chunk的size呢？怎么办？</p>
<p>我们通过在<code>__wrap_malloc(size_t)</code>的时候，分配8+size的chunk，也就是多分配8字节，开始的8字节存储该chunk的size，然后返回的是(char*)chunk + 8，也就是偏移8个字节返回给调用malloc的应用程序。</p>
<p>这样在free的时候，传入参数<code>void* p</code>，我们把p往前移动8个字节，解引用就能得到该chunk的大小，而该大小值就是前一步，在__wrap_malloc的时候设置的size。</p>
<p>好了，我们真正做到记录各size的chunk数量了，它就存在于<code>malloc_map[1M]</code>的数组中，假设64个字节的chunk一直在被分配，数量一直在增长，我们觉得该size的chunk很有可能泄漏，那怎么定位到是哪里调用过来的呢？</p>
<h1 id="如何记录调用链？"><a href="#如何记录调用链？" class="headerlink" title="如何记录调用链？"></a>如何记录调用链？</h1><p>我们可以维护一个toplist数组，该数组假设有10个元素，它保存的是chunk数最大的10种size，这个很容易做到，通过对malloc_map取top 10就行。</p>
<p>然后我们在<code>__wrap_malloc(size_t)</code>里，测试该size是不是toplist之一，如果是的话，那我们通过glibc的backtrace把调用堆栈dump到log文件里去。</p>
<p>注意：这里不能再分配内存，所以你只能使用backtrace，而不能使用backtrace_symbols，这样你只能得到调用堆栈的符号地址，而不是符号名。</p>
<h1 id="如何把符号地址转换成符号名，也就是对应到代码行呢？"><a href="#如何把符号地址转换成符号名，也就是对应到代码行呢？" class="headerlink" title="如何把符号地址转换成符号名，也就是对应到代码行呢？"></a>如何把符号地址转换成符号名，也就是对应到代码行呢？</h1><h2 id="addr2line"><a href="#addr2line" class="headerlink" title="addr2line"></a>addr2line</h2><p>addr2line工具可以做到，你可以追查到调用链，进而定位到内存泄漏的问题。</p>
<p>至此，你已经get到了整个核心思想。</p>
<p>当然，实际项目中，我们做的更多，我们不仅仅记录了toplist size，还记录了各size chunk的增量toplist，会记录大块的malloc/free，会wrap更多的API。</p>
<p>总结一下：通过wrap malloc/free + backtrace + addr2line，你就可以定位到内存泄漏了，恭喜大家。</p>
<h1 id="使用valgrind"><a href="#使用valgrind" class="headerlink" title="使用valgrind"></a>使用valgrind</h1><h2 id="valgrind是什么？"><a href="#valgrind是什么？" class="headerlink" title="valgrind是什么？"></a>valgrind是什么？</h2><p>Valgrind是一套Linux下，开放源代码（GPL V2）的仿真调试工具的集合。Valgrind由内核（core）以及基于内核的其他调试工具组成。内核类似于一个框架（framework），它模拟了一个CPU环境，并提供服务给其他工具；而其他工具则类似于插件 (plug-in)，利用内核提供的服务完成各种特定的内存调试任务。Valgrind的体系结构如下图所示：<br><img src="/img/20210513112200.jpg" alt></p>
<p>Valgrind包括如下一些工具：</p>
<ul>
<li>Memcheck。这是valgrind应用最广泛的工具，一个重量级的内存检查器，能够发现开发中绝大多数内存错误使用情况，比如：使用未初始化的内存，使用已经释放了的内存，内存访问越界等。这也是本文将重点介绍的部分。</li>
<li>Callgrind。它主要用来检查程序中函数调用过程中出现的问题。</li>
<li>Cachegrind。它主要用来检查程序中缓存使用出现的问题。</li>
<li>Helgrind。它主要用来检查多线程程序中出现的竞争问题。</li>
<li>Massif。它主要用来检查程序中堆栈使用中出现的问题。</li>
<li>Extension。可以利用core提供的功能，自己编写特定的内存调试工具</li>
</ul>
<p>一个典型的Linux C程序内存空间由如下几部分组成：</p>
<ul>
<li>代码段（.text）。这里存放的是CPU要执行的指令。代码段是可共享的，相同的代码在内存中只会有一个拷贝，同时这个段是只读的，防止程序由于错误而修改自身的指令。</li>
<li>初始化数据段（.data）。这里存放的是程序中需要明确赋初始值的变量，例如位于所有函数之外的全局变量：int val=”100”。需要强调的是，以上两段都是位于程序的可执行文件中，内核在调用exec函数启动该程序时从源程序文件中读入。</li>
<li>未初始化数据段（.bss）。位于这一段中的数据，内核在执行该程序前，将其初始化为0或者null。例如出现在任何函数之外的全局变量：int sum;</li>
<li>堆（Heap）。这个段用于在程序中进行动态内存申请，例如经常用到的malloc，new系列函数就是从这个段中申请内存。</li>
<li>栈（Stack）。函数中的局部变量以及在函数调用过程中产生的临时变量都保存在此段中。</li>
</ul>
<p>Memcheck 能够检测出内存问题，关键在于其建立了两个全局表。</p>
<ul>
<li>Valid-Value 表：<ul>
<li>对于进程的整个地址空间中的每一个字节(byte)，都有与之对应的 8 个 bits；对于 CPU 的每个寄存器，也有一个与之对应的 bit 向量。这些 bits 负责记录该字节或者寄存器值是否具有有效的、已初始化的值。</li>
</ul>
</li>
<li>Valid-Address 表</li>
<li>对于进程整个地址空间中的每一个字节(byte)，还有与之对应的 1 个 bit，负责记录该地址是否能够被读写。</li>
</ul>
<h2 id="检测原理"><a href="#检测原理" class="headerlink" title="检测原理"></a>检测原理</h2><p>当要读写内存中某个字节时，首先检查这个字节对应的 A bit。如果该A bit显示该位置是无效位置，memcheck 则报告读写错误。</p>
<p>内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节对应的 V bit 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 memcheck 会检查对应的V bits，如果该值尚未初始化，则会报告使用未初始化内存错误。</p>
<h2 id="Valgrind-使用"><a href="#Valgrind-使用" class="headerlink" title="Valgrind 使用"></a>Valgrind 使用</h2><p>用法: <code>valgrind [options] prog-and-args</code></p>
<ul>
<li><code>[options]</code>：常用选项，适用于所有Valgrind工具</li>
<li><code>-tool=&lt;name&gt;</code>：最常用的选项。运行 valgrind中名为toolname的工具。默认memcheck。</li>
<li><code>h –help</code>：显示帮助信息。</li>
<li><code>-version</code>：显示valgrind内核的版本，每个工具都有各自的版本。</li>
<li><code>q –quiet</code>：安静地运行，只打印错误信息。</li>
<li><code>v –verbose</code>：更详细的信息, 增加错误数统计。</li>
<li><code>-trace-children=no|yes</code>：跟踪子线程? <code>[no]</code></li>
<li><code>-track-fds=no|yes</code>：跟踪打开的文件描述？<code>[no]</code></li>
<li><code>-time-stamp=no|yes</code>：增加时间戳到LOG信息? <code>[no]</code></li>
<li><code>-log-fd=&lt;number&gt;</code>：输出LOG到描述符文件 <code>[2=stderr]</code></li>
<li><code>-log-file=&lt;file&gt;</code>：将输出的信息写入到filename.PID的文件里，PID是运行程序的进行ID</li>
<li><code>-log-file-exactly=&lt;file&gt;</code>：输出LOG信息到 file</li>
<li><code>-log-file-qualifier=&lt;VAR&gt;</code>：取得环境变量的值来做为输出信息的文件名。 <code>[none]</code></li>
<li><code>-log-socket=ipaddr:port</code>：输出LOG到socket ，ipaddr:port</li>
</ul>
<p>LOG信息输出</p>
<ul>
<li><code>-xml=yes</code>：将信息以xml格式输出，只有memcheck可用</li>
<li><code>-num-callers=&lt;number&gt; show &lt;number&gt;</code>：callers in stack traces <code>[12]</code></li>
<li><code>-error-limit=no|yes</code>：如果太多错误，则停止显示新错误? <code>[yes]</code></li>
<li><code>-error-exitcode=&lt;number&gt;</code>：如果发现错误则返回错误代码 <code>[0=disable]</code></li>
<li><code>-db-attach=no|</code>：当出现错误，valgrind会自动启动调试器gdb。<code>[no]</code></li>
<li><code>-db-command=&lt;command&gt;</code>：启动调试器的命令行选项 <code>[gdb -nw %f %p]</code></li>
</ul>
<p>适用于Memcheck工具的相关选项：</p>
<ul>
<li><code>-leak-check=no|summary|full</code>：要求对leak给出详细信息? <code>[summary]</code></li>
<li><code>-leak-resolution=low|med|high</code>：how much bt merging in leak check <code>[low]</code></li>
<li><code>-show-reachable=no|yes</code>：show reachable blocks in leak check? <code>[no]</code></li>
</ul>
<h1 id="Valgrind-使用举例（一）"><a href="#Valgrind-使用举例（一）" class="headerlink" title="Valgrind 使用举例（一）"></a>Valgrind 使用举例（一）</h1><p>下面是一段有问题的C程序代码test.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span>* x = <span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">   x[<span class="number">10</span>] = <span class="number">0</span>;  <span class="comment">//问题1: 数组下标越界</span></span><br><span class="line">&#125;                  <span class="comment">//问题2: 内存没有释放</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   f();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">valgrind --tool=memcheck --leak-check=full ./test</span><br></pre></td></tr></table></figure></p>
<p>问题分析：</p>
<ul>
<li>对于位于程序中不同段的变量，其初始值是不同的，全局变量和静态变量初始值为0，而局部变量和动态申请的变量，其初始值为随机值。如果程序使用了为随机值的变量，那么程序的行为就变得不可预期。</li>
</ul>
<h1 id="利用GCC编译选项Sanitizers快速定位内存错误"><a href="#利用GCC编译选项Sanitizers快速定位内存错误" class="headerlink" title="利用GCC编译选项Sanitizers快速定位内存错误"></a>利用GCC编译选项Sanitizers快速定位内存错误</h1><p>先从一个小例子开头</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> *<span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">delete</span> [] <span class="built_in">array</span>;</span><br><span class="line">  <span class="built_in">array</span>[argc]==<span class="number">1</span>;  <span class="comment">//can't detected</span></span><br><span class="line">  <span class="built_in">cout</span>&amp;lt;&amp;lt; <span class="string">"passed 1st"</span>&amp;lt;&amp;lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">array</span>[argc] = <span class="built_in">array</span>[argc];</span><br><span class="line">  <span class="built_in">cout</span>&amp;lt;&amp;lt; <span class="string">"passed 2nd"</span>&amp;lt;&amp;lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">array</span>[argc]=<span class="number">100</span>;  <span class="comment">// BOOM</span></span><br><span class="line">  <span class="built_in">cout</span>&amp;lt;&amp;lt;<span class="string">"passed 3rd"</span>&amp;lt;&amp;lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -g -O -fsanitize=address -o asan heap-use-after-free.cpp</span><br><span class="line">$ ./asan</span><br></pre></td></tr></table></figure>
<p>重点在这个<code>-fsanitize=address</code>选项上，不加它运行这段代码基本是不会报错的。</p>
<h1 id="Sanitizers简介"><a href="#Sanitizers简介" class="headerlink" title="Sanitizers简介"></a>Sanitizers简介</h1><p>Sanitizers是谷歌发起的开源工具集，包括了AddressSanitizer，MemorySanitizer，ThreadSanitizer，LeakSanitizer，Sanitizers项目本是LLVM项目的一部分，但GNU也将该系列工具加入到了自家的GCC编译器中。GCC从4.8版本开始支持Address和Thread Sanitizer，4.9版本开始支持Leak Sanitizer和UB Sanitizer，这些都是查找隐藏Bug的利器。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>原文</th>
<th>不上道的翻译</th>
</tr>
</thead>
<tbody>
<tr>
<td>Use after free (dangling pointer dereference)</td>
<td>为悬浮指针赋值</td>
</tr>
<tr>
<td>Heap buffer overflow</td>
<td>堆缓冲区溢出</td>
</tr>
<tr>
<td>Stack buffer overflow</td>
<td>栈缓冲区溢出</td>
</tr>
<tr>
<td>Global buffer overflow</td>
<td>全局缓冲区溢出</td>
</tr>
<tr>
<td>Use after return</td>
<td>通过返回值访问局部变量的内存</td>
</tr>
<tr>
<td>Use after scope</td>
<td>访问已经释放的局部变量的内存</td>
</tr>
<tr>
<td>Initialization order bugs</td>
<td>使用未初始化的内存</td>
</tr>
<tr>
<td>Memory leaks</td>
<td>内存泄漏</td>
</tr>
</tbody>
</table>
</div>
<p>Enable AddressSanitizer, a fast memory error detector. Memory access instructions are instrumented to detect out-of-bounds and use-after-free bugs. The option enables -fsanitize-address-use-after-scope. See <a href="https://github.com/google/sanitizers/wiki/AddressSanitizer" target="_blank" rel="noopener">https://github.com/google/sanitizers/wiki/AddressSanitizer</a> for more details. The run-time behavior can be influenced using the ASAN_OPTIONS environment variable. When set to help=1, the available options are shown at startup of the instrumented program. See <a href="https://github.com/google/sanitizers/wiki/AddressSanitizerFlags#run-time-flags" target="_blank" rel="noopener">https://github.com/google/sanitizers/wiki/AddressSanitizerFlags#run-time-flags</a> for a list of supported options. The option cannot be combined with -fsanitize=thread and/or -fcheck-pointer-bounds.</p>
<p><strong>-fsanitize=kernel-address</strong>：<br>Enable AddressSanitizer for Linux kernel. See <a href="https://github.com/google/kasan/wiki" target="_blank" rel="noopener">https://github.com/google/kasan/wiki</a> for more details. The option cannot be combined with -fcheck-pointer-bounds.</p>
<p><strong>-fsanitize=thread</strong>：<br>Enable ThreadSanitizer, a fast data race detector. Memory access instructions are instrumented to detect data race bugs. See <a href="https://github.com/google/sanitizers/wiki#threadsanitizer" target="_blank" rel="noopener">https://github.com/google/sanitizers/wiki#threadsanitizer</a> for more details. The run-time behavior can be influenced using the TSAN_OPTIONS environment variable; see <a href="https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags" target="_blank" rel="noopener">https://github.com/google/sanitizers/wiki/ThreadSanitizerFlags</a> for a list of supported options. The option cannot be combined with -fsanitize=address, -fsanitize=leak and/or -fcheck-pointer-bounds.</p>
<p>Note that sanitized atomic builtins cannot throw exceptions when operating on invalid memory addresses with non-call exceptions (-fnon-call-exceptions).</p>
<p><strong>-fsanitize=leak</strong>：<br>Enable LeakSanitizer, a memory leak detector. This option only matters for linking of executables and the executable is linked against a library that overrides malloc and other allocator functions. See <a href="https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer" target="_blank" rel="noopener">https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer</a> for more details. The run-time behavior can be influenced using the LSAN_OPTIONS environment variable. The option cannot be combined with -fsanitize=thread.</p>
<p><strong>-fsanitize=undefined</strong>：<br>Enable UndefinedBehaviorSanitizer, a fast undefined behavior detector. Various computations are instrumented to detect undefined behavior at runtime. Current suboptions are:</p>
<p><strong>-fsanitize=shift</strong>：<br>This option enables checking that the result of a shift operation is not undefined. Note that what exactly is considered undefined differs slightly between C and C++, as well as between ISO C90 and C99, etc. This option has two suboptions, -fsanitize=shift-base and -fsanitize=shift-exponent.</p>
<p><strong>-fsanitize=shift-exponent</strong>：<br>This option enables checking that the second argument of a shift operation is not negative and is smaller than the precision of the promoted first argument.</p>
<p><strong>-fsanitize=shift-base</strong>：<br>If the second argument of a shift operation is within range, check that the result of a shift operation is not undefined. Note that what exactly is considered undefined differs slightly between C and C++, as well as between ISO C90 and C99, etc.</p>
<p><strong>-fsanitize=integer-divide-by-zero</strong>：<br>Detect integer division by zero as well as INT_MIN / -1 division.</p>
<p><strong>-fsanitize=unreachable</strong>：<br>With this option, the compiler turns the <strong>builtin_unreachable call into a diagnostics message call instead. When reaching the </strong>builtin_unreachable call, the behavior is undefined.</p>
<p><strong>-fsanitize=vla-bound</strong>：<br>This option instructs the compiler to check that the size of a variable length array is positive.</p>
<p><strong>-fsanitize=null</strong>：<br>This option enables pointer checking. Particularly, the application built with this option turned on will issue an error message when it tries to dereference a NULL pointer, or if a reference (possibly an rvalue reference) is bound to a NULL pointer, or if a method is invoked on an object pointed by a NULL pointer.</p>
<p><strong>-fsanitize=return</strong>：<br>This option enables return statement checking. Programs built with this option turned on will issue an error message when the end of a non-void function is reached without actually returning a value. This option works in C++ only.</p>
<p><strong>-fsanitize=signed-integer-overflow</strong>：<br>This option enables signed integer overflow checking. We check that the result of +, *, and both unary and binary – does not overflow in the signed arithmetics. Note, integer promotion rules must be taken into account. That is, the following is not an overflow:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> <span class="keyword">char</span> a = SCHAR_MAX;</span><br><span class="line">a++;</span><br></pre></td></tr></table></figure></p>
<p><strong>-fsanitize=bounds</strong>：<br>This option enables instrumentation of array bounds. Various out of bounds accesses are detected. Flexible array members, flexible array member-like arrays, and initializers of variables with static storage are not instrumented. The option cannot be combined with -fcheck-pointer-bounds.</p>
<p><strong>-fsanitize=bounds-strict</strong>：<br>This option enables strict instrumentation of array bounds. Most out of bounds accesses are detected, including flexible array members and flexible array member-like arrays. Initializers of variables with static storage are not instrumented. The option cannot be combined with -fcheck-pointer-bounds.</p>
<p><strong>-fsanitize=alignment</strong>：<br>This option enables checking of alignment of pointers when they are dereferenced, or when a reference is bound to insufficiently aligned target, or when a method or constructor is invoked on insufficiently aligned object.</p>
<p><strong>-fsanitize=object-size</strong>：<br>This option enables instrumentation of memory references using the __builtin_object_size function. Various out of bounds pointer accesses are detected.</p>
<p><strong>-fsanitize=float-divide-by-zero</strong>：<br>Detect floating-point division by zero. Unlike other similar options, -fsanitize=float-divide-by-zero is not enabled by -fsanitize=undefined, since floating-point division by zero can be a legitimate way of obtaining infinities and NaNs.</p>
<p><strong>-fsanitize=float-cast-overflow</strong>：<br>This option enables floating-point type to integer conversion checking. We check that the result of the conversion does not overflow. Unlike other similar options, -fsanitize=float-cast-overflow is not enabled by -fsanitize=undefined. This option does not work well with FE_INVALID exceptions enabled.</p>
<p><strong>-fsanitize=nonnull-attribute</strong>：<br>This option enables instrumentation of calls, checking whether null values are not passed to arguments marked as requiring a non-null value by the nonnull function attribute.</p>
<p><strong>-fsanitize=returns-nonnull-attribute</strong>：<br>This option enables instrumentation of return statements in functions marked with returns_nonnull function attribute, to detect returning of null values from such functions.</p>
<p><strong>-fsanitize=bool</strong>：<br>This option enables instrumentation of loads from bool. If a value other than 0/1 is loaded, a run-time error is issued.</p>
<p><strong>-fsanitize=enum</strong>：<br>This option enables instrumentation of loads from an enum type. If a value outside the range of values for the enum type is loaded, a run-time error is issued.</p>
<p><strong>-fsanitize=vptr</strong>：<br>This option enables instrumentation of C++ member function calls, member accesses and some conversions between pointers to base and derived classes, to verify the referenced object has the correct dynamic type.</p>
<p>While -ftrapv causes traps for signed overflows to be emitted, -fsanitize=undefined gives a diagnostic message. This currently works only for the C family of languages.</p>
<p><strong>-fno-sanitize=all</strong>：<br>This option disables all previously enabled sanitizers. -fsanitize=all is not allowed, as some sanitizers cannot be used together.</p>
<p><strong>-fasan-shadow-offset=number</strong>：<br>This option forces GCC to use custom shadow offset in AddressSanitizer checks. It is useful for experimenting with different shadow memory layouts in Kernel AddressSanitizer.</p>
<p><strong>-fsanitize-sections=s1,s2,…</strong>：<br>Sanitize global variables in selected user-defined sections. si may contain wildcards.</p>
<p><strong>-fsanitize-recover[=opts]</strong>：<br>-fsanitize-recover= controls error recovery mode for sanitizers mentioned in comma-separated list of opts. Enabling this option for a sanitizer component causes it to attempt to continue running the program as if no error happened. This means multiple runtime errors can be reported in a single program run, and the exit code of the program may indicate success even when errors have been reported. The -fno-sanitize-recover= option can be used to alter this behavior: only the first detected error is reported and program then exits with a non-zero exit code.</p>
<p>Currently this feature only works for -fsanitize=undefined (and its suboptions except for -fsanitize=unreachable and -fsanitize=return), -fsanitize=float-cast-overflow, -fsanitize=float-divide-by-zero, -fsanitize=bounds-strict, -fsanitize=kernel-address and -fsanitize=address. For these sanitizers error recovery is turned on by default, except -fsanitize=address, for which this feature is experimental. -fsanitize-recover=all and -fno-sanitize-recover=all is also accepted, the former enables recovery for all sanitizers that support it, the latter disables recovery for all sanitizers that support it.</p>
<p>Even if a recovery mode is turned on the compiler side, it needs to be also enabled on the runtime library side, otherwise the failures are still fatal. The runtime library defaults to halt_on_error=0 for ThreadSanitizer and UndefinedBehaviorSanitizer, while default value for AddressSanitizer is halt_on_error=1. This can be overridden through setting the halt_on_error flag in the corresponding environment variable.</p>
<p>Syntax without an explicit opts parameter is deprecated. It is equivalent to specifying an opts list of:</p>
<p>undefined,float-cast-overflow,float-divide-by-zero,bounds-strict</p>
<p><strong>-fsanitize-address-use-after-scope</strong>：<br>Enable sanitization of local variables to detect use-after-scope bugs. The option sets -fstack-reuse to ‘none’.</p>
<p><strong>-fsanitize-undefined-trap-on-error</strong>：<br>The -fsanitize-undefined-trap-on-error option instructs the compiler to report undefined behavior using __builtin_trap rather than a libubsan library routine. The advantage of this is that the libubsan library is not needed and is not linked in, so this is usable even in freestanding environments.</p>
<p><strong>-fsanitize-coverage=trace-pc</strong>：<br>Enable coverage-guided fuzzing code instrumentation. Inserts a call to __sanitizer_cov_trace_pc into every basic block</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/09/23/深入理解Linux内核 笔记2/" rel="next" title="深入理解Linux内核5-7章">
                <i class="fa fa-chevron-left"></i> 深入理解Linux内核5-7章
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/10/02/从四个问题透析Linux下cpp编译链接/" rel="prev" title="从四个问题透析Linux下C++编译&链接">
                从四个问题透析Linux下C++编译&链接 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">353</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是内存泄漏？"><span class="nav-number">1.</span> <span class="nav-text">什么是内存泄漏？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#怎么查内存泄漏？"><span class="nav-number">2.</span> <span class="nav-text">怎么查内存泄漏？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是动态内存分配器？"><span class="nav-number">3.</span> <span class="nav-text">什么是动态内存分配器？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#new-delete跟malloc-free的关系"><span class="nav-number">4.</span> <span class="nav-text">new/delete跟malloc/free的关系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#chunk"><span class="nav-number">4.1.</span> <span class="nav-text">chunk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wrap-malloc"><span class="nav-number">4.2.</span> <span class="nav-text">wrap malloc</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#怎么去定位内存泄漏呢？"><span class="nav-number">5.</span> <span class="nav-text">怎么去定位内存泄漏呢？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#怎么跟踪到每种size的chunk数量？"><span class="nav-number">6.</span> <span class="nav-text">怎么跟踪到每种size的chunk数量？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何知道释放的chunk的size？"><span class="nav-number">7.</span> <span class="nav-text">如何知道释放的chunk的size？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何记录调用链？"><span class="nav-number">8.</span> <span class="nav-text">如何记录调用链？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何把符号地址转换成符号名，也就是对应到代码行呢？"><span class="nav-number">9.</span> <span class="nav-text">如何把符号地址转换成符号名，也就是对应到代码行呢？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#addr2line"><span class="nav-number">9.1.</span> <span class="nav-text">addr2line</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用valgrind"><span class="nav-number">10.</span> <span class="nav-text">使用valgrind</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#valgrind是什么？"><span class="nav-number">10.1.</span> <span class="nav-text">valgrind是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检测原理"><span class="nav-number">10.2.</span> <span class="nav-text">检测原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Valgrind-使用"><span class="nav-number">10.3.</span> <span class="nav-text">Valgrind 使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Valgrind-使用举例（一）"><span class="nav-number">11.</span> <span class="nav-text">Valgrind 使用举例（一）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#利用GCC编译选项Sanitizers快速定位内存错误"><span class="nav-number">12.</span> <span class="nav-text">利用GCC编译选项Sanitizers快速定位内存错误</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Sanitizers简介"><span class="nav-number">13.</span> <span class="nav-text">Sanitizers简介</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
