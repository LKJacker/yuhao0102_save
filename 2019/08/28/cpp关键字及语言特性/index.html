<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="decltype简介我们之前使用的typeid运算符来查询一个变量的类型，这种类型查询在运行时进行。RTTI机制为每一个类型产生一个type_info类型的数据，而typeid查询返回的变量相应type_info数据，通过name成员函数返回类型的名称。同时在C++11中typeid还提供了hash_code这个成员函数，用于返回类型的唯一哈希值。RTTI会导致运行时效率降低，且在泛型编程中，我们">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++关键字及语言特性">
<meta property="og:url" content="http://yoursite.com/2019/08/28/cpp关键字及语言特性/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="decltype简介我们之前使用的typeid运算符来查询一个变量的类型，这种类型查询在运行时进行。RTTI机制为每一个类型产生一个type_info类型的数据，而typeid查询返回的变量相应type_info数据，通过name成员函数返回类型的名称。同时在C++11中typeid还提供了hash_code这个成员函数，用于返回类型的唯一哈希值。RTTI会导致运行时效率降低，且在泛型编程中，我们">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20180912085909216.png">
<meta property="og:image" content="http://yoursite.com/img/909212-20160603234145961-1605510938.png">
<meta property="og:image" content="http://yoursite.com/img/909212-20160603235458727-271967874.png">
<meta property="og:image" content="http://yoursite.com/img/909212-20160604002208836-1075703850.png">
<meta property="og:image" content="http://yoursite.com/img/909212-20160604002803352-2018700987.png">
<meta property="og:image" content="http://yoursite.com/img/20160223191226316.jpg">
<meta property="og:image" content="http://yoursite.com/img/20160223201833669.jpg">
<meta property="og:image" content="http://yoursite.com/img/20160223203457456.jpg">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1352320/201803/1352320-20180323101344856-2115596576.png">
<meta property="og:image" content="http://yoursite.com/img/2012072014171977.jpg">
<meta property="og:image" content="http://yoursite.com/img/2012072014223353.jpg">
<meta property="og:image" content="http://yoursite.com/img/2012072014393253.jpg">
<meta property="og:image" content="http://yoursite.com/img/2012072014460755.jpg">
<meta property="og:updated_time" content="2022-01-06T03:36:15.753Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++关键字及语言特性">
<meta name="twitter:description" content="decltype简介我们之前使用的typeid运算符来查询一个变量的类型，这种类型查询在运行时进行。RTTI机制为每一个类型产生一个type_info类型的数据，而typeid查询返回的变量相应type_info数据，通过name成员函数返回类型的名称。同时在C++11中typeid还提供了hash_code这个成员函数，用于返回类型的唯一哈希值。RTTI会导致运行时效率降低，且在泛型编程中，我们">
<meta name="twitter:image" content="http://yoursite.com/img/20180912085909216.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/08/28/cpp关键字及语言特性/">





  <title>C++关键字及语言特性 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/cpp关键字及语言特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++关键字及语言特性</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-28T16:51:00+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="decltype简介"><a href="#decltype简介" class="headerlink" title="decltype简介"></a>decltype简介</h1><p>我们之前使用的typeid运算符来查询一个变量的类型，这种类型查询在运行时进行。RTTI机制为每一个类型产生一个type_info类型的数据，而typeid查询返回的变量相应type_info数据，通过name成员函数返回类型的名称。同时在C++11中typeid还提供了hash_code这个成员函数，用于返回类型的唯一哈希值。RTTI会导致运行时效率降低，且在泛型编程中，我们更需要的是编译时就要确定类型，RTTI并无法满足这样的要求。编译时类型推导的出现正是为了泛型编程，在非泛型编程中，我们的类型都是确定的，根本不需要再进行推导。</p>
<p>而编译时类型推导，除了我们说过的auto关键字，还有本文的decltype。</p>
<p>decltype与auto关键字一样，用于进行<strong>编译时类型推导</strong>，不过它与auto还是有一些区别的。decltype的类型推导并不是像auto一样是从变量声明的初始化表达式获得变量的类型，而是总是以一个普通表达式作为参数，返回该表达式的类型,而且decltype并不会对表达式进行求值。</p>
<h1 id="decltype用法"><a href="#decltype用法" class="headerlink" title="decltype用法"></a>decltype用法</h1><h2 id="推导出表达式类型"><a href="#推导出表达式类型" class="headerlink" title="推导出表达式类型"></a>推导出表达式类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = 4;</span><br><span class="line">decltype(i) a; //推导结果为int。a的类型为int。</span><br></pre></td></tr></table></figure>
<h2 id="与using-typedef合用，用于定义类型。"><a href="#与using-typedef合用，用于定义类型。" class="headerlink" title="与using/typedef合用，用于定义类型。"></a>与using/typedef合用，用于定义类型。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">using size_t = decltype(sizeof(0));//sizeof(a)的返回值为size_t类型</span><br><span class="line">using ptrdiff_t = decltype((int*)0 - (int*)0);</span><br><span class="line">using nullptr_t = decltype(nullptr);</span><br><span class="line">vector&lt;int &gt;vec;</span><br><span class="line"></span><br><span class="line">typedef decltype(vec.begin()) vectype;</span><br><span class="line">for (vectype i = vec.begin; i != vec.end(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样和auto一样，也提高了代码的可读性。</p>
<h2 id="重用匿名类型"><a href="#重用匿名类型" class="headerlink" title="重用匿名类型"></a>重用匿名类型</h2><p>在C++中，我们有时候会遇上一些匿名类型，如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> d ;</span><br><span class="line">    doubel b;</span><br><span class="line">&#125;anon_s;</span><br></pre></td></tr></table></figure></p>
<p>而借助decltype，我们可以重新使用这个匿名的结构体：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(anon_s) as ;<span class="comment">//定义了一个上面匿名的结构体</span></span><br></pre></td></tr></table></figure></p>
<h2 id="泛型编程中结合auto，用于追踪函数的返回值类型"><a href="#泛型编程中结合auto，用于追踪函数的返回值类型" class="headerlink" title="泛型编程中结合auto，用于追踪函数的返回值类型"></a>泛型编程中结合auto，用于追踪函数的返回值类型</h2><p>这也是decltype最大的用途了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tx, <span class="keyword">typename</span> _Ty&gt;</span><br><span class="line">auto multiply(_Tx x, _Ty y)-&gt;decltype(_Tx*_Ty)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="decltype推导四规则"><a href="#decltype推导四规则" class="headerlink" title="decltype推导四规则"></a>decltype推导四规则</h1><ol>
<li>如果e是一个没有带括号的标记符表达式或者类成员访问表达式，那么的decltype（e）就是e所命名的实体的类型。此外，如果e是一个被重载的函数，则会导致编译错误。</li>
<li>否则 ，假设e的类型是T，如果e是一个将亡值，那么decltype（e）为T&amp;&amp;</li>
<li>否则，假设e的类型是T，如果e是一个左值，那么decltype（e）为T&amp;。</li>
<li>否则，假设e的类型是T，则decltype（e）为T。</li>
</ol>
<p>标记符指的是除去关键字、字面量等编译器需要使用的标记之外的程序员自己定义的标记，而单个标记符对应的表达式即为标记符表达式。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">4</span>]</span><br></pre></td></tr></table></figure></p>
<p>则arr为一个标记符表达式，而arr[3]+0不是。</p>
<p>我们来看下面这段代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) a; <span class="comment">//a推导为int</span></span><br><span class="line"><span class="keyword">decltype</span>((i))b=i;<span class="comment">//b推导为int&amp;，必须为其初始化，否则编译错误</span></span><br></pre></td></tr></table></figure></p>
<p>仅仅为i加上了()，就导致类型推导结果的差异。这是因为，i是一个标记符表达式，根据推导规则1，类型被推导为int。而(i)为一个左值表达式，所以类型被推导为int&amp;。</p>
<p>通过下面这段代码可以对推导四个规则作进一步了解<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> *ptr = arr;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>&#123;</span> <span class="keyword">double</span> d; &#125;s ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Overloaded</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Overloaded</span><span class="params">(<span class="keyword">char</span>)</span></span>;<span class="comment">//重载的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;&amp; <span class="title">RvalRef</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">bool</span> <span class="title">Func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//规则一：推导为其类型</span></span><br><span class="line"><span class="keyword">decltype</span> (arr) var1; <span class="comment">//int 标记符表达式</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">decltype</span> (ptr) var2;<span class="comment">//int *  标记符表达式</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">decltype</span>(s.d) var3;<span class="comment">//doubel 成员访问表达式</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//decltype(Overloaded) var4;//重载函数。编译错误。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//规则二：将亡值。推导为类型的右值引用。</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">decltype</span> (RvalRef()) var5 = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//规则三：左值，推导为类型的引用。</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">decltype</span> ((i))var6 = i;     <span class="comment">//int&amp;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">decltype</span> (<span class="literal">true</span> ? i : i) var7 = i; <span class="comment">//int&amp;  条件表达式返回左值。</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">decltype</span> (++i) var8 = i; <span class="comment">//int&amp;  ++i返回i的左值。</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">decltype</span>(arr[<span class="number">5</span>]) var9 = i;<span class="comment">//int&amp;. []操作返回左值</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">decltype</span>(*ptr)var10 = i;<span class="comment">//int&amp; *操作返回左值</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">decltype</span>(<span class="string">"hello"</span>)var11 = <span class="string">"hello"</span>; <span class="comment">//const char(&amp;)[9]  字符串字面常量为左值，且为const左值。</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">//规则四：以上都不是，则推导为本类型</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">1</span>) var12;<span class="comment">//const int</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">decltype</span>(Func(<span class="number">1</span>)) var13=<span class="literal">true</span>;<span class="comment">//const bool</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">decltype</span>(i++) var14 = i;<span class="comment">//int i++返回右值</span></span><br></pre></td></tr></table></figure></p>
<p>这里需要提示的是，字符串字面值常量是个左值，且是const左值，而非字符串字面值常量则是个右值。<br>这么多规则，对于我们写代码的来说难免太难记了，特别是规则三。我们可以利用C++11标准库中添加的模板类is_lvalue_reference来判断表达式是否为左值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; is_lvalue_reference&lt;decltype(++i)&gt;::value &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>结果1表示为左值，结果为0为非右值。<br>同样的，也有is_rvalue_reference这样的模板类来判断decltype推断结果是否为右值。</p>
<h1 id="reverse函数"><a href="#reverse函数" class="headerlink" title="reverse函数"></a>reverse函数</h1><p>C++ &lt; algorithm &gt; 中定义的reverse函数用于反转在[first,last)范围内的顺序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">reverse</span> (<span class="title">BidirectionalIterator</span> <span class="title">first</span>,<span class="title">BidirectionalIterator</span> <span class="title">last</span>);</span></span><br></pre></td></tr></table></figure></p>
<p>例如，交换vector容器中元素的顺序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">reverse(v.begin(),v.end());<span class="comment">//v的值为5，4，3，2，1</span></span><br></pre></td></tr></table></figure></p>
<p>当然，你也可以通过它方便的反转string类的字符串<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str=<span class="string">"C++REVERSE"</span>;</span><br><span class="line">reverse(str.begin(),str.end());<span class="comment">//str结果为ESREVER++C</span></span><br></pre></td></tr></table></figure></p>
<p>该函数等价于通过调用iter_swap来交换元素位置<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">reverse</span> (<span class="title">BidirectionalIterator</span> <span class="title">first</span>, <span class="title">BidirectionalIterator</span> <span class="title">last</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span> ((first!=last)&amp;&amp;(first!=--last))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::iter_swap (first,last);</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="C-中constexpr作用"><a href="#C-中constexpr作用" class="headerlink" title="C++中constexpr作用"></a>C++中constexpr作用</h1><p>constexpr 是 C++ 11 标准新引入的关键字，不过在讲解其具体用法和功能之前，读者需要先搞清楚 C++ 常量表达式的含义。</p>
<p>所谓常量表达式，指的就是由多个（≥1）常量组成的表达式。换句话说，如果表达式中的成员都是常量，那么该表达式就是一个常量表达式。这也意味着，常量表达式一旦确定，其值将无法修改。</p>
<p>实际开发中，我们经常会用到常量表达式。以定义数组为例，数组的长度就必须是一个常量表达式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1)</span></span><br><span class="line"><span class="keyword">int</span> url[<span class="number">10</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 2)</span></span><br><span class="line"><span class="keyword">int</span> url[<span class="number">6</span> + <span class="number">4</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 3)</span></span><br><span class="line"><span class="keyword">int</span> length = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> url[length];<span class="comment">//错误，length是变量</span></span><br></pre></td></tr></table></figure></p>
<p>上述代码演示了 3 种定义 url 数组的方式，其中第 1、2 种定义 url 数组时，长度分别为 10 和 6+4，显然它们都是常量表达式，可以用于表示数组的长度；第 3 种 url 数组的长度为 length，它是变量而非常量，因此不是一个常量表达式，无法用于表示数组的长度。<br>常量表达式的应用场景还有很多，比如匿名枚举、switch-case 结构中的 case 表达式等，感兴趣的读者可自行编码测试，这里不再过多举例。</p>
<p>我们知道，C++ 程序的执行过程大致要经历编译、链接、运行这 3 个阶段。值得一提的是，常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果；而常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p>
<p>对于用 C++ 编写的程序，性能往往是永恒的追求。那么在实际开发中，如何才能判定一个表达式是否为常量表达式，进而获得在编译阶段即可执行的“特权”呢？除了人为判定外，C++11 标准还提供有 constexpr 关键字。</p>
<p>constexpr 关键字的功能是<strong>使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段</strong>。C++ 11 标准中，constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。<br>注意，获得在编译阶段计算出结果的能力，并不代表 constexpr 修饰的表达式一定会在程序编译阶段被执行，具体的计算时机还是编译器说了算。</p>
<h2 id="constexpr修饰普通变量"><a href="#constexpr修饰普通变量" class="headerlink" title="constexpr修饰普通变量"></a>constexpr修饰普通变量</h2><p>C++11 标准中，定义变量时可以用 constexpr 修饰，从而使该变量获得在编译阶段即可计算出结果的能力。</p>
<p>值得一提的是，使用 constexpr 修改普通变量时，变量必须经过初始化且初始值必须是一个常量表达式。举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> num = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> url[num] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    couts&lt;&lt; url[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p>读者可尝试将 constexpr 删除，此时编译器会提示“url[num] 定义中 num 不可用作常量”。</p>
<p>可以看到，程序第 6 行使用 constexpr 修饰 num 变量，同时将 “1+2+3” 这个常量表达式赋值给 num。由此，编译器就可以在编译时期对 num 这个表达式进行计算，因为 num 可以作为定义数组时的长度。</p>
<p>有读者可能发现，将此示例程序中的 constexpr 用 const 关键字替换也可以正常执行，这是因为 num 的定义同时满足“num 是 const 常量且使用常量表达式为其初始化”这 2 个条件，由此编译器会认定 num 是一个常量表达式。<br>注意，const 和 constexpr 并不相同，关于它们的区别，我们会在下一节做详细讲解。</p>
<p>另外需要重点提出的是，当常量表达式中包含浮点数时，考虑到程序编译和运行所在的系统环境可能不同，常量表达式在编译阶段和运行阶段计算出的结果精度很可能会受到影响，因此 C++11 标准规定，浮点常量表达式在编译阶段计算的精度要至少等于（或者高于）运行阶段计算出的精度。</p>
<h2 id="constexpr修饰函数"><a href="#constexpr修饰函数" class="headerlink" title="constexpr修饰函数"></a>constexpr修饰函数</h2><p>constexpr 还可以用于修饰函数的返回值，这样的函数又称为“常量表达式函数”。</p>
<p>注意，constexpr 并非可以修改任意函数的返回值。换句话说，一个函数要想成为常量表达式函数，必须满足如下 4 个条件。</p>
<p>1) 整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，只能包含一条 return 返回语句。</p>
<p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这个函数是无法通过编译的，因为该函数的返回值用 constexpr 修饰，但函数内部包含多条语句。</p>
<p>如下是正确的定义 display() 常量表达式函数的写法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以添加 using 执行、typedef 语句以及 static_assert 断言</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，display() 函数的返回值是用 constexpr 修饰的 int 类型值，且该函数的函数体中只包含一个 return 语句。</p>
<p>2) 该函数必须有返回值，即函数的返回值类型不能是 void。</p>
<p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>像上面这样定义的返回值类型为 void 的函数，不属于常量表达式函数。原因很简单，因为通过类似的函数根本无法获得一个常量。</p>
<p>3) 函数在使用之前，必须有对应的定义语句。我们知道，函数的使用分为“声明”和“定义”两部分，普通的函数调用只需要提前写好该函数的声明部分即可（函数的定义部分可以放在调用位置之后甚至其它文件中），但常量表达式函数在使用前，必须要有该函数的定义。</p>
<p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//普通函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="keyword">int</span> a[display(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//调用普通函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; noconst_dis(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序执行结果为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p>读者可自行将 display() 常量表达式函数的定义调整到 main() 函数之后，查看编译器的报错信息。</p>
<p>可以看到，普通函数在调用时，只需要保证调用位置之前有相应的声明即可；而常量表达式函数则不同，调用位置之前必须要有该函数的定义，否则会导致程序编译失败。</p>
<p>4) return 返回的表达式必须是常量表达式，举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="keyword">int</span> a[display(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该程序无法通过编译，编译器报“display(3) 的结果不是常量”的异常。</p>
<p>常量表达式函数的返回值必须是常量表达式的原因很简单，如果想在程序编译阶段获得某个函数返回的常量，则该函数的 return 语句中就不能包含程序运行阶段才能确定值的变量。</p>
<p>注意，在常量表达式函数的 return 语句中，不能包含赋值的操作（例如 return x=1 在常量表达式函数中不允许的）。另外，用 constexpr 修改函数时，函数本身也是支持递归的，感兴趣的读者可自行尝试编码测试。</p>
<h2 id="constexpr修饰类的构造函数"><a href="#constexpr修饰类的构造函数" class="headerlink" title="constexpr修饰类的构造函数"></a>constexpr修饰类的构造函数</h2><p>对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的。</p>
<p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">"zhangsan"</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mt.name &lt;&lt; <span class="string">" "</span> &lt;&lt; mt.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此程序是无法通过编译的，编译器会抛出“constexpr不能修饰自定义类型”的异常。</p>
<p>当我们想自定义一个可产生常量的类型时，正确的做法是在该类型的内部添加一个常量构造函数。例如，修改上面的错误示例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    constexpr myType(char *name,int age):name(name),age(age)&#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">"zhangsan"</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mt.name &lt;&lt; <span class="string">" "</span> &lt;&lt; mt.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序执行结果为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangsan <span class="number">10</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，在 myType 结构体中自定义有一个构造函数，借助此函数，用 constexpr 修饰的 myType 类型的 my 常量即可通过编译。</p>
<p>注意，constexpr 修饰类的构造函数时，要求该构造函数的函数体必须为空，且采用初始化列表的方式为各个成员赋值时，必须使用常量表达式。</p>
<p>前面提到，constexpr 可用于修饰函数，而类中的成员方法完全可以看做是“位于类这个命名空间中的函数”，所以 constexpr 也可以修饰类中的成员函数，只不过此函数必须满足前面提到的 4 个条件。</p>
<p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myType</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    constexpr myType(const char *name,int age):name(name),age(age)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">getname</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">"zhangsan"</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span> * name = mt.getname();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> age = mt.getage();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" "</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangsan 10</span><br></pre></td></tr></table></figure></p>
<p>注意，C++11 标准中，不支持用 constexpr 修饰带有 virtual 的成员方法。</p>
<h2 id="constexpr修饰模板函数"><a href="#constexpr修饰模板函数" class="headerlink" title="constexpr修饰模板函数"></a>constexpr修饰模板函数</h2><p>C++11 语法中，constexpr 可以修饰模板函数，但由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。</p>
<p>针对这种情况下，C++11 标准规定，如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。</p>
<p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模板函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">dispaly</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">stu</span>&#123;</span><span class="string">"zhangsan"</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="comment">//普通函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">ret</span> = <span class="title">dispaly</span>(<span class="title">stu</span>);</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret.name &lt;&lt; <span class="string">" "</span> &lt;&lt; ret.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//常量表达式函数</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> ret1 = dispaly(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zhangsan 10</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p>
<p>可以看到，示例程序中定义了一个模板函数 display()，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：</p>
<p>第 20 行代码处，当模板函数中以自定义结构体 myType 类型进行实例化时，由于该结构体中没有定义常量表达式构造函数，所以实例化后的函数不是常量表达式函数，此时 constexpr 是无效的；</p>
<p>第 23 行代码处，模板函数的类型 T 为 int 类型，实例化后的函数符合常量表达式函数的要求，所以该函数的返回值就是一个常量表达式。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// C++98/03</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Factorial</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Factorial</span>&lt;0&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">1</span> : n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C++14</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">factorial2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        result *= i;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(Factorial&lt;<span class="number">3</span>&gt;::value == <span class="number">6</span>, <span class="string">"error"</span>);</span><br><span class="line">    <span class="keyword">static_assert</span>(factorial(<span class="number">3</span>) == <span class="number">6</span>, <span class="string">"error"</span>);</span><br><span class="line">    <span class="keyword">static_assert</span>(factorial2(<span class="number">3</span>) == <span class="number">6</span>, <span class="string">"error"</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; factorial(n) &lt;&lt; factorial2(n) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//66</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明：</p>
<ul>
<li>以上代码演示了如何在编译期计算3的阶乘。</li>
<li>在C++11之前，在编译期进行数值计算必须使用模板元编程技巧。具体来说我们通常需要定义一个内含编译期常量value的类模板（也称作元函数）。这个类模板的定义至少需要分成两部分，分别用于处理一般情况和特殊情况。</li>
<li>代码示例中Factorial元函数的定义分为两部分：<ul>
<li>当模板参数大于0时，利用公式 N!=N*(N-1)! 递归调用自身来计算value的值。</li>
<li>当模板参数为0时，将value设为1这个特殊情况下的值。</li>
</ul>
</li>
<li>在C++11之后，编译期的数值计算可以通过使用constexpr声明并定义编译期函数来进行。相对于模板元编程，使用constexpr函数更贴近普通的C++程序，计算过程显得更为直接，意图也更明显。</li>
<li>但在C++11中constexpr函数所受到的限制较多，比如函数体通常只有一句return语句，函数体内既不能声明变量，也不能使用for语句之类的常规控制流语句。</li>
<li>如factorial函数所示，使用C++11在编译期计算阶乘仍然需要利用递归技巧。</li>
<li>C++14解除了对constexpr函数的大部分限制。在C++14的constexpr函数体内我们既可以声明变量，也可以使用goto和try之外大部分的控制流语句。</li>
<li>如factorial2函数所示，使用C++14在编译期计算阶乘只需利用for语句进行常规计算即可。</li>
<li>虽说constexpr函数所定义的是编译期的函数，但实际上在运行期constexpr函数也能被调用。事实上，如果使用编译期常量参数调用constexpr函数，我们就能够在编译期得到运算结果；而如果使用运行期变量参数调用constexpr函数，那么在运行期我们同样也能得到运算结果。</li>
<li>代码第32行所演示的是在运行期使用变量n调用constexpr函数的结果。</li>
<li>准确的说，constexpr函数是一种在编译期和运行期都能被调用并执行的函数。出于constexpr函数的这个特点，在C++11之后进行数值计算时，无论在编译期还是运行期我们都可以统一用一套代码来实现。编译期和运行期在数值计算这点上得到了部分统一。</li>
</ul>
<h1 id="const的用法"><a href="#const的用法" class="headerlink" title="const的用法"></a>const的用法</h1><p>const是不改变的。在C和C++中，我们使用关键字const来使程序元素保持不变。const关键字可以在C++程序的许多上下文中使用。它可以用于：变量、指针、函数参数和返回类型、类数据成员、类成员函数、对象。</p>
<ol>
<li>修饰变量，说明该变量不可以被改变；</li>
<li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li>
<li>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰成员函数，说明该成员函数内不能修改成员变量。</li>
</ol>
<p>下面的声明都是什么意思？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const int a; a是一个常整型数</span><br><span class="line">int const a; a是一个常整型数</span><br><span class="line">const int *a; a是一个指向常整型数的指针，整型数是不可修改的，但指针可以</span><br><span class="line">int * const a; a为指向整型数的常指针，指针指向的整型数可以修改，但指针是不可修改的</span><br><span class="line">int const * a const; a是一个指向常整型数的常指针，指针指向的整型数是不可修改的，同时指针也是不可修改的</span><br></pre></td></tr></table></figure></p>
<h2 id="const变量"><a href="#const变量" class="headerlink" title="const变量"></a>const变量</h2><p>如果你用const关键字做任何变量，你就不能改变它的值。同样，必须在声明的时候初始化常数变量。<br>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main</span><br><span class="line">&#123;</span><br><span class="line">    const int i = 10;</span><br><span class="line">    const int j = i + 10;     // works fine</span><br><span class="line">    i++;    // this leads to Compile time error   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，我们使 i 成为常量，因此如果我们试图改变它的值，我们将得到编译时错误。尽管我们可以用它来代替其他变量。</p>
<h2 id="指针与const关键字"><a href="#指针与const关键字" class="headerlink" title="指针与const关键字"></a>指针与const关键字</h2><p>指针也可以使用const关键字来声明。当我们使用const和指针时，我们可以用两种方式来做：可以把const应用到指针指向的地方，或者我们可以使指针本身成为一个常数。 </p>
<h3 id="指向const变量的指针："><a href="#指向const变量的指针：" class="headerlink" title="指向const变量的指针："></a>指向const变量的指针：</h3><p>意味着指针指向一个const变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int* u;</span><br></pre></td></tr></table></figure></p>
<p>这里，表示u是一个指针，可以指向const int类型变量。指针指向的内容不可改变。简称左定值，因为const位于*号的左边。</p>
<p>我们也可以这样写，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char const* v;</span><br></pre></td></tr></table></figure></p>
<p>表示v是指向const类型的char的指针。<br>指向const变量的指针非常有用，因为它可以用来使任何字符串或数组不可变</p>
<h3 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h3><p>为了使指针保持不变，我们必须把const关键字放到右边。对于const指针p其指向的内存地址不能够被改变，但其内容可以改变。简称，右定向。因为const位于*号的右边。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x = 1;</span><br><span class="line">int* const w = &amp;x;</span><br></pre></td></tr></table></figure></p>
<p>里，w是一个指针，它是const，指向一个int，现在我们不能改变指针，这意味着它总是指向变量x但是可以改变它指向的值，通过改变x的值。</p>
<p>当你想要一个可以在值中改变但不会在内存中移动的存储器时，常量指针指向一个变量是很有用的。因为指针总是指向相同的内存位置，因为它是用const关键字定义的，但是那个内存位置的值可以被更改。<br><strong>左定值，右定向，const修饰不变量</strong></p>
<h2 id="const函数参数和返回类型"><a href="#const函数参数和返回类型" class="headerlink" title="const函数参数和返回类型"></a>const函数参数和返回类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i++;    <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意几个要点：</p>
<p>①对于内置数据类型，返回const或非const值，不会有任何影响。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">h</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> j = h();</span><br><span class="line">    <span class="keyword">int</span> k = h();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>j和k都将被赋值为1。不会出现错误。</p>
<p>②对于用户定义的数据类型，返回const，将阻止它的修改。此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。const 修饰返回的指针或者引用，是否返回一个指向 const 的指针，取决于我们想让用户干什么。</p>
<p>③在程序执行时创建的临时对象总是const类型。值传递的 const 修饰传递，一般这种情况不需要 const 修饰，因为函数会自动产生临时变量复制实参值。<br>当 const 参数为指针时，可以防止指针被意外篡改。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cpf</span><span class="params">(<span class="keyword">int</span> *<span class="keyword">const</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*a&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    *a = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line">    Cpf(&amp;a);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a; <span class="comment">// a 为 9</span></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取 const 外加引用传递的方法。并且对于一般的 int、double 等内置类型，我们不采用引用的传递方式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test()&#123;&#125;</span><br><span class="line">    Test(<span class="keyword">int</span> _m):_cm(_m)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_cm</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> _cm;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _cm;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cmf</span><span class="params">(<span class="keyword">const</span> Test&amp; _tt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;_tt.get_cm();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line">    Cmf(t);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>④如果一个函数有一个非const参数，它在发出调用时不能传递const参数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t</span><span class="params">(<span class="keyword">int</span>*)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// function logic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们把一个const int参数传递给函数t，会出现错误。</p>
<p>⑤但是，一个具有const类型参数的函数，可以传递一个const类型参数以及一个非const参数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// function logic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数可以有一个int，也可以有const int类型参数。</p>
<h3 id="const修饰函数返回值"><a href="#const修饰函数返回值" class="headerlink" title="const修饰函数返回值"></a>const修饰函数返回值</h3><p>(1)指针传递</p>
<p>如果返回const data,non-const pointer，返回值也必须赋给const data,non-const pointer。因为指针指向的数据是常量不能修改。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="title">mallocA</span><span class="params">()</span></span>&#123;  <span class="comment">///const data,non-const pointer</span></span><br><span class="line">    <span class="keyword">int</span> *a=<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *a = mallocA();</span><br><span class="line">    <span class="comment">///int *b = mallocA();  ///编译错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(2)值传递</p>
<p>如果函数返回值采用“值传递方式”，由于函数会把返回值复制到外部临时的存储单元中，加const 修饰没有任何价值。所以，对于值传递来说，加const没有太多意义。</p>
<p>所以：</p>
<ul>
<li>不要把函数<code>int GetInt(void)</code>写成<code>const int GetInt(void)</code>。</li>
<li>不要把函数<code>A GetA(void)</code>写成<code>const A GetA(void)</code>，其中A 为用户自定义的数据类型。</li>
</ul>
<h2 id="将类数据成员定义为const"><a href="#将类数据成员定义为const" class="headerlink" title="将类数据成员定义为const"></a>将类数据成员定义为const</h2><p>这些是类中的数据变量，使用const关键字定义。它们在声明期间未初始化。它们的初始化在构造函数中完成。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Test (<span class="keyword">int</span> x) : i(x)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Test <span class="title">s</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个程序中，i 是一个常量数据成员，在每个对象中它的独立副本将会出现，因此它使用构造函数对每个对象进行初始化。一旦初始化，它的值就不能改变</p>
<h2 id="把类对象定义为const"><a href="#把类对象定义为const" class="headerlink" title="把类对象定义为const"></a>把类对象定义为const</h2><p>当一个对象被声明或使用const关键字创建时，它的数据成员在对象的生命周期中永远不会被改变。</p>
<p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const class_name object;</span><br></pre></td></tr></table></figure></p>
<p>  例如，如果在上面定义的类测试中，我们想要定义一个常数对象，我们可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Test r(30);</span><br></pre></td></tr></table></figure></p>
<h2 id="将类的成员函数定义为const"><a href="#将类的成员函数定义为const" class="headerlink" title="将类的成员函数定义为const"></a>将类的成员函数定义为const</h2><p>const成员函数决不会修改对象中的数据成员。注意：const关键字不能与static关键字同时使用，因为static关键字修饰静态成员函数，静态成员函数不含有this指针，即不能实例化，const成员函数必须具体到某一实例。</p>
<p>如果有个成员函数想修改对象中的某一个成员怎么办？这时我们可以使用mutable关键字修饰这个成员，mutable的意思也是易变的，容易改变的意思，被mutable关键字修饰的成员可以处于不断变化中。</p>
<p>const成员函数不能调用非const成员函数，因为非const成员函数可以会修改成员变量。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">    Point(<span class="keyword">int</span> _x):x(_x)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testConstFunction</span><span class="params">(<span class="keyword">int</span> _x)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">///错误，在const成员函数中，不能修改任何类成员变量</span></span><br><span class="line">        x=_x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">///错误，const成员函数不能调用非onst成员函数，因为非const成员函数可以会修改成员变量</span></span><br><span class="line">        modify_x(_x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify_x</span><span class="params">(<span class="keyword">int</span> _x)</span></span>&#123;</span><br><span class="line">        x=_x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return_type function_name() const;</span><br></pre></td></tr></table></figure></p>
<p>const对象和const成员函数的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StarWars</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    StarWars(<span class="keyword">int</span> x)    <span class="comment">// constructor</span></span><br><span class="line">    &#123; </span><br><span class="line">        i = x; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">falcon</span><span class="params">()</span> <span class="keyword">const</span>  <span class="comment">// constant function</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            can do anything but will not</span></span><br><span class="line"><span class="comment">            modify any data members</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Falcon has left the Base"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gamma</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        i++; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">StarWars <span class="title">objOne</span><span class="params">(<span class="number">10</span>)</span></span>;        <span class="comment">// non const object</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> StarWars <span class="title">objTwo</span><span class="params">(<span class="number">20</span>)</span></span>;      <span class="comment">// const object</span></span><br><span class="line"> </span><br><span class="line">    objOne.falcon();     <span class="comment">// No error</span></span><br><span class="line">    objTwo.falcon();     <span class="comment">// No error</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; objOne.i &lt;&lt; objTwo.i;</span><br><span class="line"> </span><br><span class="line">    objOne.gamma();     <span class="comment">// No error</span></span><br><span class="line">    objTwo.gamma();     <span class="comment">// Compile time error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Falcon has left the Base</span><br><span class="line">Falcon has left the Base</span><br><span class="line">10 20</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们可以看到，const成员函数永远不会改变类的数据成员，并且它可以与const和非const对象一起使用。但是const对象不能与试图改变其数据成员的成员函数一起使用。</p>
<h2 id="关于const的疑问："><a href="#关于const的疑问：" class="headerlink" title="关于const的疑问："></a>关于const的疑问：</h2><p>const常量的判别标准：</p>
<ol>
<li>只有字面量初始化的const常量才会进入符号表</li>
<li>使用其他变量初始化的const常量仍然是只读变量</li>
<li>被volatile修饰的const常量不会进入符号表</li>
</ol>
<p>注意：</p>
<ol>
<li>const引用的类型与初始化变量的类型相同时：初始化变量成为只读变量</li>
<li>const引用的类型与初始化变量的类型不相同时：初生成一个新的只读变量</li>
</ol>
<p>Example:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">1</span>; <span class="comment">//字面量初始化，此时x为常量，进入符号表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x; <span class="comment">//rx代表只读变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>&amp; nrx = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(rx); <span class="comment">//去掉rx的只读属性</span></span><br><span class="line">    </span><br><span class="line">    nrx = <span class="number">5</span>;  <span class="comment">//改变了nrx内存空间的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x = %d\n"</span>, x); <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"rx = %d\n"</span>, rx);  <span class="comment">//  5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"nrx = %d\n"</span>, nrx);  <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;x = %p\n"</span>, &amp;x);  <span class="comment">// &amp;x = 002CFD80</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;rx = %p\n"</span>, &amp;rx);  <span class="comment">// &amp;x = 002CFD80</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;nrx = %p\n"</span>, &amp;nrx);  <span class="comment">// &amp;x = 002CFD80</span></span><br><span class="line">    <span class="comment">//输出的地址相同，说明了x、rx、nrx代表同样的内存空间</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">const</span> <span class="keyword">int</span> y = <span class="number">2</span>;<span class="comment">//volatile代表易变的</span></span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;y);</span><br><span class="line">    </span><br><span class="line">    *p = <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"y = %d\n"</span>, y);  <span class="comment">//y = 6</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p = %p\n"</span>, p);  <span class="comment">//p = 001BF928</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//判别是否是常量是编译器在编译时能不能确认它的值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> z = y;</span><br><span class="line">    </span><br><span class="line">    p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;z);</span><br><span class="line">    </span><br><span class="line">    *p = <span class="number">7</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"z = %d\n"</span>, z); <span class="comment">// z = 7</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p = %p\n"</span>, p); <span class="comment">//p = 001BF910</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'c'</span>; </span><br><span class="line">    <span class="keyword">char</span>&amp; rc = c;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; trc = c;</span><br><span class="line">    </span><br><span class="line">    rc = <span class="string">'a'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c = %c\n"</span>, c); <span class="comment">// c = a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"rc = %c\n"</span>, rc);<span class="comment">// rc = a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"trc = %c\n"</span>, trc);<span class="comment">//trc = c</span></span><br><span class="line">    <span class="comment">//变量c是char类型，而trc是int类型，所以生成了一个新的只读变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><img src="/img/20180912085909216.png" alt></p>
<h2 id="const与-define的区别："><a href="#const与-define的区别：" class="headerlink" title="const与#define的区别："></a>const与#define的区别：</h2><ul>
<li>const定义的常量是变量带类型，而#define定义的只是个常数不带类型；</li>
<li>define只在预处理阶段起作用，简单的文本替换，而const在编译、链接过程中起作用；</li>
<li>define只是简单的字符串替换没有类型检查。而const是有数据类型的，是要进行判断的，可以避免一些低级错误；</li>
<li>define预处理后，占用代码段空间，const占用数据段空间；</li>
<li>const不能重定义，而define可以通过#undef取消某个符号的定义，进行重定义；</li>
<li>define独特功能，比如可以用来防止文件重复引用。</li>
</ul>
<h1 id="宏定义-define的理解与资料整理"><a href="#宏定义-define的理解与资料整理" class="headerlink" title="宏定义#define的理解与资料整理"></a>宏定义#define的理解与资料整理</h1><h2 id="利用define来定义-数值宏常量"><a href="#利用define来定义-数值宏常量" class="headerlink" title="利用define来定义 数值宏常量"></a>利用define来定义 数值宏常量</h2><p><code>#define</code>宏定义是个演技非常高超的替身演员，但也会经常耍大牌的，所以我们用它要慎之又慎。它可以出现在代码的任何地方，从本行宏定义开始，以后的代码就就都认识这个宏了；也可以把任何东西定义成宏。因为编译器会在预编译的时候用真身替换替身，而在我们的代码里面却又用常常用替身来帮忙。</p>
<p>看例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.141592654</span></span><br></pre></td></tr></table></figure></p>
<p>在此后的代码中你尽可以使用PI 来代替3.141592654，而且你最好就这么做。不然的话，如果我要把PI 的精度再提高一些，你是否愿意一个一个的去修改这串数呢？你能保证不漏不出错？而使用PI 的话，我们却只需要修改一次（这是十分高效的）。</p>
<p>这种情况还不是最要命的，我们再看一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_POWEROFF  -1</span></span><br></pre></td></tr></table></figure></p>
<p>如果你在代码里不用ERROR_POWEROFF 这个宏而用-1，尤其在函数返回错误代码的时候（往往一个开发一个系统需要定义很多错误代码）。肯怕上帝都无法知道-1 表示的是什么意思吧。这个-1，我们一般称为“魔鬼数”，上帝遇到它也会发狂的。所以，我奉劝你代码里一定不要出现“魔鬼数”。(这里是从代码可读性的角度进行考虑！)</p>
<p>但是我们利用define来定义数值类型的数据，一般只是用来定义  常量 ，如果 要定义一些变量，则可以使用c语言中const这个关键字。</p>
<p>我们已经讨论了const 这个关键字，我们知道const 修饰的数据是有类型的，而define 宏定义的数据没有类型。为了安全，我建议你以后在定义一些宏常数的时候用const代替，编译器会给const 修饰的只读变量做类型校验，减少错误的可能。</p>
<p>但一定要注意const修饰的不是常量而是readonly 的变量，const 修饰的只读变量不能用来作为定义数组的维数，也不能放在case 关键字后面。</p>
<h2 id="利用define来定义-字符串宏常量"><a href="#利用define来定义-字符串宏常量" class="headerlink" title="利用define来定义 字符串宏常量"></a>利用define来定义 字符串宏常量</h2><p>除了定义宏常数之外，经常还用来定义字符串，尤其是路径：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENG_PATH_1 E:\English\listen_to_this\listen_to_this_3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENG_PATH_2 “E:\English\listen_to_this\listen_to_this_3”</span></span><br></pre></td></tr></table></figure></p>
<p>噢，到底哪一个正确呢？如果路径太长，一行写下来比较别扭怎么办？用反斜杠接续符 ‘\’ 啊：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENG_PATH_3 E:\English\listen_to_this\listen\_to_this_3</span></span><br></pre></td></tr></table></figure></p>
<p>还没发现问题？这里用了4 个反斜杠，到底哪个是接续符？回去看看接续符反斜杠。</p>
<p>反斜杠作为接续符时，在本行其后面不能再有任何字符，空格都不行。所以，只有最后一个反斜杠才是接续符。至于A)和B)，那要看你怎么用了，既然define 宏只是简单的替换，那给ENG_PATH_1 加上双引号不就成了：“ENG_PATH_1”。</p>
<p>但是请注意：有的系统里规定路径的要用双反斜杠“\\”,比如（这是正确的版本）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENG_PATH_4 E:\\English\\listen_to_this\\listen_to_this_3</span></span><br></pre></td></tr></table></figure></p>
<h2 id="用define-宏定义注释符号"><a href="#用define-宏定义注释符号" class="headerlink" title="用define 宏定义注释符号"></a>用define 宏定义注释符号</h2><p>上面对define 的使用都很简单，再看看下面的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BSC <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BMC <span class="comment">/*</span></span></span><br><span class="line"><span class="meta"><span class="comment">#define EMC */</span></span></span><br><span class="line">BSC my single-line comment</span><br><span class="line">BMC my multi-line comment EMC</span><br></pre></td></tr></table></figure></p>
<p>D)和E)都错误，为什么呢？因为注释先于预处理指令被处理,当这两行被展开成//…或/<em>…</em>/时,注释已处理完毕,此时再出现//…或/<em>…</em>/自然错误。</p>
<p>因此,试图用宏开始或结束一段注释是不行的。</p>
<h2 id="用define-宏定义表达式"><a href="#用define-宏定义表达式" class="headerlink" title="用define 宏定义表达式"></a>用define 宏定义表达式</h2><p>这些都好理解，下面来点有“技术含量”的，定义一年有多少秒：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC_A_YEAR 60*60*24*365</span></span><br></pre></td></tr></table></figure></p>
<p>这个定义没错吧？很遗憾，很有可能错了，至少不可靠。你有没有考虑在16 位系统下把这样一个数赋给整型变量的时候可能会发生溢出？一年有多少秒也不可能是负数吧。</p>
<p>改一下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEC_A_YEAR (60*60*24*365)UL</span></span><br></pre></td></tr></table></figure></p>
<p>又出现一个问题，这里的括号到底需不需要呢？继续看一个例子，定义一个宏函数，求x 的平方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define SQR (x) x * x</span><br></pre></td></tr></table></figure></p>
<p>对不对？试试：假设x 的值为10，<code>SQR (x)</code>被替换后变成10*10。没有问题。</p>
<p>再试试：假设x 的值是个表达式10+1，<code>SQR (x)</code>被替换后变成<code>10+1*10+1</code>。问题来了，这并不是我想要得到的。怎么办？括号括起来不就完了？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQR (x) ((x)*(x))</span></span><br></pre></td></tr></table></figure></p>
<p>最外层的括号最好也别省了，看例子，求两个数的和：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUM (x) (x)+(x)</span></span><br></pre></td></tr></table></figure></p>
<p>如果x 的值是个表达式<code>5*3</code>,而代码又写成这样：<code>SUM (x)* SUM (x)</code>。替换后变成：<code>(5*3)+(5*3)*(5*3)+(5*3)</code>。又错了！所以最外层的括号最好也别省了。我说过define是个演技高超的替身演员，但也经常耍大牌。要搞定它其实很简单，别吝啬括号就行了。</p>
<p>注意这一点：宏函数被调用时是以实参代换形参。而不是“值传送”。</p>
<h2 id="宏定义中的空格"><a href="#宏定义中的空格" class="headerlink" title="宏定义中的空格"></a>宏定义中的空格</h2><p>另外还有一个问题需要引起注意，看下面例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUM (x) (x)+(x)</span></span><br></pre></td></tr></table></figure></p>
<p>编译器认为这是定义了一个宏：SUM，其代表的是(x) (x)+(x)。</p>
<p>为什么会这样呢？其关键问题还是在于SUM 后面的这个空格。所以在定义宏的时候一定要注意什么时候该用空格，什么时候不该用空格。这个空格仅仅在定义的时候有效，在使用这个宏函数的时候，空格会被编译器忽略掉。也就是说，上一节定义好的宏函数SUM(x)在使用的时候在SUM 和(x)之间留有空格是没问题的。比如：SUM(3)和SUM (3)的意思是一样的。</p>
<h2 id="undef"><a href="#undef" class="headerlink" title="undef"></a>undef</h2><p><code>#undef</code>是用来撤销宏定义的，用法如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.141592654</span></span><br><span class="line">…</span><br><span class="line"><span class="comment">// code</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> PI</span></span><br><span class="line"><span class="comment">//下面的代码就不能用PI 了，它已经被撤销了宏定义。</span></span><br></pre></td></tr></table></figure></p>
<p>写好C语言，漂亮的宏定义很重要，使用宏定义可以防止出错，提高可移植性，可读性，方便性 等等。下面列举一些成熟软件中常用得宏定义：</p>
<p>防止一个头文件被重复包含<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COMDEF_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMDEF_H</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//头文件内容</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>重新定义一些类型<br>防止由于各种平台和编译器的不同，而产生的类型字节数差异，方便移植。这里已经不是#define的范畴了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> boolean; <span class="comment">/* Boolean value type. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> uint32; <span class="comment">/* Unsigned 32 bit value */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> uint16; <span class="comment">/* Unsigned 16 bit value */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uint8; <span class="comment">/* Unsigned 8 bit value */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">long</span> <span class="keyword">int</span> int32; <span class="comment">/* Signed 32 bit value */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">short</span> int16; <span class="comment">/* Signed 16 bit value */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span> int8; <span class="comment">/* Signed 8 bit value */</span></span><br><span class="line"><span class="comment">//下面的不建议使用</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> byte; <span class="comment">/* Unsigned 8 bit value type. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> word; <span class="comment">/* Unsinged 16 bit value type. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> dword; <span class="comment">/* Unsigned 32 bit value type. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> uint1; <span class="comment">/* Unsigned 8 bit value type. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> uint2; <span class="comment">/* Unsigned 16 bit value type. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> uint4; <span class="comment">/* Unsigned 32 bit value type. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span> int1; <span class="comment">/* Signed 8 bit value type. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">short</span> int2; <span class="comment">/* Signed 16 bit value type. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">int</span> int4; <span class="comment">/* Signed 32 bit value type. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">long</span> sint31; <span class="comment">/* Signed 32 bit value */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">short</span> sint15; <span class="comment">/* Signed 16 bit value */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">signed</span> <span class="keyword">char</span> sint7; <span class="comment">/* Signed 8 bit value */</span></span><br></pre></td></tr></table></figure></p>
<p>得到指定地址上的一个字节或字<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_B( x ) ( *( (byte *) (x) ) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_W( x ) ( *( (word *) (x) ) )</span></span><br></pre></td></tr></table></figure></p>
<p>求最大值和最小值<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX( x, y ) ( ((x) &gt; (y)) ? (x) : (y) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN( x, y ) ( ((x) &lt; (y)) ? (x) : (y) )</span></span><br></pre></td></tr></table></figure></p>
<p>得到一个field在结构体(struct)中的偏移量<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FPOS( type, field ) \</span></span><br><span class="line"><span class="comment">/*lint -e545 */</span> ( (dword) &amp;(( type *) <span class="number">0</span>)-&gt; field ) <span class="comment">/*lint +e545 */</span></span><br></pre></td></tr></table></figure></p>
<p>得到一个结构体中field所占用的字节数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSIZ( type, field ) sizeof( ((type *) 0)-&gt;field )</span></span><br></pre></td></tr></table></figure></p>
<p>按照LSB格式把两个字节转化为一个Word<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLIPW( ray ) ( (((word) (ray)[0]) * 256) + (ray)[1] )</span></span><br></pre></td></tr></table></figure></p>
<p>按照LSB格式把一个Word转化为两个字节<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLOPW( ray, val ) \</span></span><br><span class="line">(ray)[<span class="number">0</span>] = ((val) / <span class="number">256</span>); \</span><br><span class="line">(ray)[<span class="number">1</span>] = ((val) &amp; <span class="number">0xFF</span>)</span><br></pre></td></tr></table></figure></p>
<p>得到一个变量的地址（word宽度）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B_PTR( var ) ( (byte *) (void *) &amp;(var) )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W_PTR( var ) ( (word *) (void *) &amp;(var) )</span></span><br></pre></td></tr></table></figure></p>
<p>得到一个字的高位和低位字节<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORD_LO(xxx) ((byte) ((word)(xxx) &amp; 255))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORD_HI(xxx) ((byte) ((word)(xxx) &gt;&gt; 8))</span></span><br></pre></td></tr></table></figure></p>
<p>返回一个比X大的最接近的8的倍数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define RND8( x ) ((((x) + 7) / 8 ) * 8 )</span><br></pre></td></tr></table></figure></p>
<p>将一个字母转换为大写<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UPCASE( c ) ( ((c) &gt;= <span class="meta-string">'a'</span> &amp;&amp; (c) &lt;= <span class="meta-string">'z'</span>) ? ((c) - 0x20) : (c) )</span></span><br></pre></td></tr></table></figure></p>
<p>判断字符是不是10进值的数字<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECCHK( c ) ((c) &gt;= <span class="meta-string">'0'</span> &amp;&amp; (c) &lt;= <span class="meta-string">'9'</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>判断字符是不是16进值的数字<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEXCHK( c ) ( ((c) &gt;= <span class="meta-string">'0'</span> &amp;&amp; (c) &lt;= <span class="meta-string">'9'</span>) ||\</span></span><br><span class="line">((c) &gt;= <span class="string">'A'</span> &amp;&amp; (c) &lt;= <span class="string">'F'</span>) ||\</span><br><span class="line">((c) &gt;= <span class="string">'a'</span> &amp;&amp; (c) &lt;= <span class="string">'f'</span>) )</span><br></pre></td></tr></table></figure></p>
<p>防止溢出的一个方法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INC_SAT( val ) (val = ((val)+1 &gt; (val)) ? (val)+1 : (val))</span></span><br></pre></td></tr></table></figure></p>
<p>返回数组元素的个数<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARR_SIZE( a ) ( sizeof( (a) ) / sizeof( (a[0]) ) )</span></span><br></pre></td></tr></table></figure></p>
<p>返回一个无符号数n尾的值MOD_BY_POWER_OF_TWO(X,n)=X%(2^n)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD_BY_POWER_OF_TWO( val, mod_by ) \</span></span><br><span class="line">( (dword)(val) &amp; (dword)((mod_by)<span class="number">-1</span>) )</span><br></pre></td></tr></table></figure></p>
<p>对于IO空间映射在存储空间的结构，输入输出处理<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inp(port) (*((volatile byte *) (port)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inpw(port) (*((volatile word *) (port)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inpdw(port) (*((volatile dword *)(port)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> outp(port, val) (*((volatile byte *) (port)) = ((byte) (val)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> outpw(port, val) (*((volatile word *) (port)) = ((word) (val)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> outpdw(port, val) (*((volatile dword *) (port)) = ((dword) (val)))</span></span><br></pre></td></tr></table></figure></p>
<p>使用一些宏跟踪调试<br>ANSI标准说明了五个预定义的宏名。它们是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__LINE__</span><br><span class="line">__FILE__</span><br><span class="line">__DATE__</span><br><span class="line">__TIME__</span><br><span class="line">__STDC__</span><br></pre></td></tr></table></figure></p>
<p>可以定义宏，例如:</p>
<p>当定义了_DEBUG，输出数据信息和所在文件所在行<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUGMSG(msg,date) printf(msg);printf(“%d%d%d”,date,_LINE_,_FILE_)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUGMSG(msg,date)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>宏定义防止使用错误，用小括号包含。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(a,b) （a+b)</span></span><br></pre></td></tr></table></figure></p>
<p>用do{}while(0)语句包含多语句防止错误，例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DO(a,b) a+b;\</span></span><br><span class="line">a++;</span><br></pre></td></tr></table></figure></p>
<p>应用时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(….)</span><br><span class="line">DO(a,b); <span class="comment">//产生错误</span></span><br><span class="line"><span class="keyword">else</span></span><br></pre></td></tr></table></figure></p>
<p>解决方法: 代码就只会执行一次。和直接加花括号有什么区别呢。哦对，不能随便在程序中，任意加｛｝，组成代码块的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DO(a,b) do&#123;a+b;\</span></span><br><span class="line">a++;&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a>new 操作符</h1><p>当你写这种代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Memory Management"</span>);</span><br></pre></td></tr></table></figure></p>
<p>你使用的new是new操作符。这个操作符就象sizeof一样是语言内置的。你不能改变它的含义，它的功能总是一样的。它要完毕的功能分成两部分。第一部分是分配足够的内存以便容纳所需类型的对象。第二部分是它调用构造函数初始化内存中的对象。new操作符总是做这两件事情，你不能以不论什么方式改变它的行为。</p>
<h2 id="operator-new"><a href="#operator-new" class="headerlink" title="operator new"></a>operator new</h2><p>你所能改变的是怎样为对象分配内存。</p>
<p>new操作符调用一个函数来完毕必需的内存分配，你可以重写或重载这个函数来改变它的行为。new操作符为分配内存所调用函数的名字是operator new。</p>
<p>函数operator new 通常这样声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>返回值类型是<code>void*</code>，由于这个函数返回一个未经处理（raw）的指针。未初始化的内存。參数size_t确定分配多少内存。</p>
<p>你能添加额外的參数重载函数operator new，可是第一个參数类型必须是size_t。</p>
<p>你一般不会直接调用operator new，可是一旦这么做。你能够象调用其他函数一样调用它：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *rawMemory = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(<span class="built_in">string</span>));</span><br></pre></td></tr></table></figure></p>
<p>操作符operator new将返回一个指针，指向一块足够容纳一个string类型对象的内存。就象malloc一样，operator new的职责仅仅是分配内存。</p>
<p>它对构造函数一无所知。operator new所了解的是内存分配。把operator new 返回的未经处理的指针传递给一个对象是new操作符的工作。当你的编译器遇见这种语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Memory Management"</span>);</span><br></pre></td></tr></table></figure></p>
<p>它生成的代码或多或少与以下的代码相似：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *memory = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(<span class="built_in">string</span>)); <span class="comment">// 得到未经处理的内存，为String对象</span></span><br><span class="line">call <span class="built_in">string</span>::<span class="built_in">string</span>(<span class="string">"Memory Management"</span>) </span><br><span class="line">on *memory; <span class="comment">// 内存中的对象</span></span><br><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">static_cast</span>&lt;<span class="built_in">string</span>*&gt;(memory); <span class="comment">// 使ps指针指向新的对象</span></span><br></pre></td></tr></table></figure></p>
<p>注意第二步包括了构造函数的调用，你做为一个程序猿被禁止这样去做。你的编译器则没有这个约束，它能够做它想做的一切。</p>
<p>因此假设你想建立一个堆对象就必须用new操作符。不能直接调用构造函数来初始化对象。（总结：operator new是用来分配内存的函数，为new操作符调用。能够被重载（有限制））</p>
<h2 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h2><p>有时你确实想直接调用构造函数。在一个已存在的对象上调用构造函数是没有意义的，由于构造函数用来初始化对象。而一个对象只能在给它初值时被初始化一次。</p>
<p>可是有时你有一些已经被分配可是尚未处理的的(raw)内存，你须要在这些内存中构造一个对象。你能够使用一个特殊的operator new ，它被称为placement new。</p>
<p>以下的样例是placement new怎样使用，考虑一下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">　<span class="keyword">public</span>:</span><br><span class="line">　　Widget(<span class="keyword">int</span> widgetSize);</span><br><span class="line">　　...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget * <span class="title">constructWidgetInBuffer</span><span class="params">(<span class="keyword">void</span> *buffer,<span class="keyword">int</span> widgetSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　<span class="keyword">return</span> <span class="keyword">new</span> (buffer) Widget(widgetSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数返回一个指针。指向一个Widget对象，对象在转递给函数的buffer里分配。<br>当程序使用共享内存或memory-mapped I/O时这个函数可能实用，由于在这样程序里对象必须被放置在一个确定地址上或一块被例程分配的内存里。</p>
<p>在constructWidgetInBuffer里面。返回的表达式是：<code>new (buffer) Widget(widgetSize)</code></p>
<p>这初看上去有些陌生，可是它是new操作符的一个使用方法，须要使用一个额外的变量（buffer）。当new操作符隐含调用operator new函数时。把这个变量传递给它。被调用的operator new函数除了带有强制的參数size_t外，还必须接受void*指针參数。指向构造对象占用的内存空间。这个operator new就是placement new，它看上去象这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">void</span> *location)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　<span class="keyword">return</span> location;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这可能比你期望的要简单，可是这就是placement new须要做的事情。毕竟operator new的目的是为对象分配内存然后返回指向该内存的指针。在使用placement new的情况下，调用者已经获得了指向内存的指针。由于调用者知道对象应该放在哪里。placement new必须做的就是返回转递给它的指针。。</p>
<p>（总结：placement new是一种特殊的operator new，作用于一块已分配但未处理或未初始化的raw内存）</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>让我们从placement new回来片刻，看看new操作符（new operator）与operator new的关系，（new操作符调用operator new）你想在堆上建立一个对象，应该用new操作符。它既分配内存又为对象调用构造函数。假设你只想分配内存，就应该调用operator new函数；它不会调用构造函数。假设你想定制自己的在堆对象被建立时的内存分配过程，你应该写你自己的operator new函数。然后使用new操作符，new操作符会调用你定制的operator new。假设你想在一块已经获得指针的内存里建立一个对象。应该用placement new。</p>
<h2 id="Deletion-and-Memory-Deallocation"><a href="#Deletion-and-Memory-Deallocation" class="headerlink" title="Deletion and Memory Deallocation"></a>Deletion and Memory Deallocation</h2><p>为了避免内存泄漏，每一个动态内存分配必须与一个等同相反的deallocation相应。</p>
<p>函数operator delete与delete操作符的关系与operator new与new操作符的关系一样。当你看到这些代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ps; <span class="comment">// 使用delete 操作符</span></span><br></pre></td></tr></table></figure></p>
<p>你的编译器会生成代码来析构对象并释放对象占有的内存。</p>
<p>Operator delete用来释放内存。它被这样声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *memoryToBeDeallocated)</span></span>;</span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">因此， <span class="keyword">delete</span> ps;  导致编译器生成类似于这种代码：</span><br><span class="line">```C++</span><br><span class="line">ps-&gt;~<span class="built_in">string</span>(); <span class="comment">// call the object's dtor</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ps)</span></span>; <span class="comment">// deallocate the memory the object occupied</span></span><br></pre></td></tr></table></figure></p>
<p>这有一个隐含的意思是假设你仅仅想处理未被初始化的内存，你应该绕过new和delete操作符，而调用operator new 获得内存和operator delete释放内存给系统：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *buffer = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="number">50</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>)); <span class="comment">// 分配足够的内存以容纳50个char</span></span><br><span class="line"><span class="comment">//没有调用构造函数</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(buffer)</span></span>; <span class="comment">// 释放内存</span></span><br><span class="line"><span class="comment">// 没有调用析构函数</span></span><br></pre></td></tr></table></figure></p>
<p>这与在C中调用malloc和free等同。</p>
<p>假设你用placement new在内存中建立对象，你应该避免在该内存中用delete操作符。</p>
<p>由于delete操作符调用operator delete来释放内存，可是包括对象的内存最初不是被operator new分配的。placement new仅仅是返回转递给它的指针。谁知道这个指针来自何方？而你应该显式调用对象的析构函数来解除构造函数的影响：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在共享内存中分配和释放内存的函数 void * mallocShared(size_t size);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeShared</span><span class="params">(<span class="keyword">void</span> *memory)</span></span>;</span><br><span class="line"><span class="keyword">void</span> *sharedMemory = mallocShared(<span class="keyword">sizeof</span>(Widget));</span><br><span class="line">Widget *pw = <span class="comment">// 如上所看到的,</span></span><br><span class="line">constructWidgetInBuffer(sharedMemory, <span class="number">10</span>); <span class="comment">// 使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// placement new </span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> pw; <span class="comment">// 结果不确定! 共享内存来自</span></span><br><span class="line"><span class="comment">// mallocShared, 而不是operator new</span></span><br><span class="line">pw-&gt;~Widget(); <span class="comment">// 正确。 析构 pw指向的Widget，</span></span><br><span class="line"><span class="comment">// 可是没有释放</span></span><br><span class="line"><span class="comment">//包括Widget的内存</span></span><br><span class="line">freeShared(pw); <span class="comment">// 正确。 释放pw指向的共享内存</span></span><br><span class="line"><span class="comment">// 可是没有调用析构函数</span></span><br></pre></td></tr></table></figure></p>
<p>如上例所看到的，假设传递给placement new的raw内存是自己动态分配的（通过一些不经常使用的方法），假设你希望避免内存泄漏，你必须释放它。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>如何分配数组？会发生什么？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>]; <span class="comment">// allocate an array of objects</span></span><br></pre></td></tr></table></figure></p>
<p>被使用的new仍然是new操作符，可是建立数组时new操作符的行为与单个对象建立有少许不同。<br>第一是内存不再用operator new分配，取代以等同的数组分配函数，叫做operator new[]（常常被称为array new）。</p>
<p>它与operator new一样能被重载。</p>
<p>在这种编译器下定制数组内存分配是困难的。由于它须要重写全局operator new。这可不是一个能轻易接受的任务。</p>
<p>缺省情况下，全局operator new处理程序中全部的动态内存分配，所以它行为的不论什么改变都将有深入和普遍的影响。并且全局operator new有一个正常的签名（normal signature）。</p>
<p>第二个不同是new操作符调用构造函数的数量。对于数组，在数组里的每个对象的构造函数都必须被调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>]; <span class="comment">// 调用operator new[]为10个string对象分配内存,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后对每一个数组元素调用string对象的缺省构造函数。</span></span><br></pre></td></tr></table></figure></p>
<p>相同当delete操作符用于数组时，它为每一个数组元素调用析构函数，然后调用operator delete来释放内存。</p>
<p>就象你能替换或重载operator delete一样，你也替换或重载operator delete[]。</p>
<h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><p>首先说一下内存的五个区：</p>
<ul>
<li>栈(stack)：由编译器自动分配释放，存放函数的参数值，局部变量的值（除static），其操作方式类似于数据结构中的栈。</li>
<li>堆(heap)：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆(优先队列)是两回事，分配方式倒是类似于链表。</li>
<li>全局区(静态区)：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域(BSS)，程序结束后由系统释放。</li>
<li>文字常量区：常量字符串就是放在这里的，如char str[]=”hello”，程序结束后由系统释放，区别const修饰的变量。</li>
<li>程序代码区：存放函数体的二进制代码。</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li>
<li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li>
<li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li>
<li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li>
</ol>
<ul>
<li>在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。</li>
<li>在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。</li>
<li>在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用</li>
<li>类内的static成员变量属于整个类所拥有，不能在类内进行定义，只能在类的作用域内进行定义</li>
<li>类内的static成员函数属于整个类所拥有，不能包含this指针，只能调用static成员函数</li>
</ul>
<h2 id="全局变量和static变量的区别"><a href="#全局变量和static变量的区别" class="headerlink" title="全局变量和static变量的区别"></a>全局变量和static变量的区别</h2><ul>
<li>全局变量（外部变量）的说明之前再冠以static就构成了静态的全局变量。<ul>
<li>全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。</li>
<li>这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个原文件组成时，非静态的全局变量在各个源文件中都是有效的。</li>
<li>而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。</li>
</ul>
</li>
<li>static全局变量与普通的全局变量的区别是static全局变量只初始化一次，防止在其他文件单元被引用。</li>
</ul>
<p>static函数与普通的函数作用域不同。尽在本文件中。只在当前源文件中使用的函数应该说明为内部函数（static），内部函数应该在当前源文件中说明和定义。</p>
<p>对于可在当前源文件以外使用的函数应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。static函数与普通函数最主要区别是static函数在内存中只有一份，普通静态函数在每个被调用中维持一份拷贝程序的局部变量存在于（堆栈）中，全局变量存在于（静态区）中，动态申请数据存在于（堆）</p>
<h2 id="static-变量"><a href="#static-变量" class="headerlink" title="static 变量"></a>static 变量</h2><p>静态局部变量保存在全局数据区(静态区)，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。</p>
<ul>
<li>static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;</li>
<li>static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；</li>
<li>static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝</li>
</ul>
<h2 id="static-成员变量"><a href="#static-成员变量" class="headerlink" title="static 成员变量"></a>static 成员变量</h2><p>定义必须在类定义体的外部，在类的内部只是声明，声明必须加static，定义不需要。static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明static变量，任何声明都不可初始化，如extern外部变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义static成员变量，可初始化</span></span><br><span class="line"><span class="keyword">int</span> A::a = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 私有静态成员变量，不能直接用类名调用或者对象调用，只能在类内调用</span></span><br><span class="line"><span class="keyword">int</span> A::b = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>跟类相关的，跟具体的类的对象无关，为所有实例所共享，某个类的实例修改了该静态成员变量，其修改值为该类的其它所有实例所见。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明static变量，任何声明都不可初始化，如extern外部变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义static成员变量，可初始化</span></span><br><span class="line"><span class="keyword">int</span> A::a = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 私有静态成员变量，不能直接用类名调用或者对象调用，只能在类内调用</span></span><br><span class="line"><span class="keyword">int</span> A::b = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// new 两个个实例（对象）</span></span><br><span class="line">    A * instanceA = <span class="keyword">new</span> A();</span><br><span class="line">    A * instanceB = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="comment">// 改变值,均输出1</span></span><br><span class="line">    instanceA-&gt;a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; A::a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; instanceA-&gt;getAValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; instanceB-&gt;getAValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="static-函数"><a href="#static-函数" class="headerlink" title="static 函数"></a>static 函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">// 声明</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>,a);</span><br><span class="line">    printHello();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【编译】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ a.cpp b.cpp -o ab.exe</span><br></pre></td></tr></table></figure></p>
<p>【输出】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 5</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p>
<p>如果在a.cpp中的int a = 5;定义前面加上static修饰，那么再次去编译，就会b.cpp报未定义错误。如果在a.cpp中的void printHello()函数前加static修饰，再次去编译，一样会报未定义错误。很明显，所有未加static修饰的函数和全局变量具有全局可见性，其他的源文件也能够访问。static修饰函数和变量这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏。这有点类似于C++中的名字空间。</p>
<h2 id="static-成员函数"><a href="#static-成员函数" class="headerlink" title="static 成员函数"></a>static 成员函数</h2><p>同样的和成员变量一样，跟类相关的，跟具体的类的对象无关，可以通过类名来调用。static成员函数里面不能访问非静态成员变量，也不能调用非静态成员函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printStr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 错误，静态成员函数不能调用非静态成员函数</span></span><br><span class="line">        printStr();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>静态成员函数没有this隐含指针修饰，存在一种情况，用const修饰类的成员函数(写在函数的最后，不是前面，前面是返回值为常量)，表示该函数不能修改该类的状态，如不能在改函数里修改成员变量(除去mutable修饰的外)，因为该函数存在一个隐式的this<em>，const修饰后为const this</em>，但是当static修饰成员函数的时候是没有this指针的，所以不能同时用static和const修饰同一个成员函数，不过可以修饰同一个成员变量。</p>
<p>static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；</p>
<p>虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual</p>
<h1 id="vector和set使用sort方法进行排序"><a href="#vector和set使用sort方法进行排序" class="headerlink" title="vector和set使用sort方法进行排序"></a>vector和set使用sort方法进行排序</h1><p>C++中vector和set都是非常方便的容器，</p>
<p>sort方法是algorithm头文件里的一个标准函数，能进行高效的排序，默认是按元素从小到大排序</p>
<p>将sort方法用到vector和set中能实现多种符合自己需求的排序</p>
<p>首先sort方法可以对静态的数组进行排序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">9</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">100</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    sort(a, a +<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><img src="/img/909212-20160603234145961-1605510938.png" alt="结果"></p>
<p>这里可以看到是sort(a,a+10)，但是数组a一共只有9个元素，为什么是a+10而不是a+9呢？</p>
<p>因为sort方法实际上最后一位地址对应的数是不取的，</p>
<p>而且vector，set，map这些容器的end()取出来的值实际上并不是最后一个值，而end的前一个才是最后一个值！</p>
<p>需要用prev(xxx.end())，才能取出容器中最后一个元素。</p>
<h2 id="对vector使用sort函数"><a href="#对vector使用sort函数" class="headerlink" title="对vector使用sort函数"></a>对vector使用sort函数</h2><p>第一种情形：基本类型，如<code>vector&lt;int&gt;</code>，<code>vector&lt;double&gt;</code>，<code>vector&lt;string&gt;</code>也是可以的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> score;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; score;</span><br><span class="line">        a.push_back(score);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt;" a.end()"&lt;&lt; *a.end() &lt;&lt; endl;       执行这句话会报错！</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" prev(a.end)"</span> &lt;&lt; *prev(a.end()) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sort(a.begin(), a.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = a.begin(); it != a.end(); it++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/909212-20160603235458727-271967874.png" alt></p>
<p>看到了吗，实际上end的前一个指针指向的元素才是插入时的最后一个值！</p>
<p>排序后从小大大。</p>
<p>第二种情形：用自定义的结构体进行sort算法，</p>
<p>这时候需要自己定义个比较函数，因为sort算法是基于容器中的元素是可以两两比较的，然后从小到大排序，所以要自定义怎么样才是小于（’&lt;’）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//自定义“小于”</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> student &amp;a, <span class="keyword">const</span> student &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.score &lt; b.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;student&gt; vectorStudents;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--)&#123;</span><br><span class="line">        student oneStudent;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">int</span> score;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; name &gt;&gt; score;</span><br><span class="line">        <span class="built_in">strcpy</span>(oneStudent.name, name.c_str());</span><br><span class="line">        oneStudent.score = score;</span><br><span class="line">        vectorStudents.push_back(oneStudent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"===========排序前================"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;student&gt;::iterator it = vectorStudents.begin(); it != vectorStudents.end(); it++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"name: "</span> &lt;&lt; it-&gt;name &lt;&lt; <span class="string">" score: "</span> &lt;&lt; it-&gt;score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(vectorStudents.begin(),vectorStudents.end(),comp);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"===========排序后================"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;student&gt;::iterator it = vectorStudents.begin(); it != vectorStudents.end(); it++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"name: "</span> &lt;&lt; it-&gt;name &lt;&lt; <span class="string">" score: "</span> &lt;&lt; it-&gt;score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/909212-20160604002208836-1075703850.png" alt></p>
<p>对于set做类似的操作。</p>
<p>set是一个集合，内部的元素不会重复，同时它会自动进行排序，也是从小到大</p>
<p>而且set的insert方法没有insert(a,cmp)这种重载，所以如果要把结构体插入set中，我们就要重载’&lt;’运算符。</p>
<p>set方法在插入的时候也是从小到大的，那么我们重载一下&lt;运算符让它从大到小排序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//自定义“小于”</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> student &amp;a, <span class="keyword">const</span> student &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.score &lt; b.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> student &amp; stu1,<span class="keyword">const</span> student &amp;stu2)&#123;</span><br><span class="line">    <span class="keyword">return</span> stu1.score &gt; stu2.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//vector&lt;student&gt; vectorStudents;</span></span><br><span class="line">    <span class="built_in">set</span>&lt;student&gt; setStudents;</span><br><span class="line">    <span class="comment">//int n = 5;</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--)&#123;</span><br><span class="line">        student oneStudent;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">int</span> score;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; name &gt;&gt; score;</span><br><span class="line">        <span class="built_in">strcpy</span>(oneStudent.name, name.c_str());</span><br><span class="line">        oneStudent.score = score;</span><br><span class="line">        setStudents.insert(oneStudent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"===========排序前================"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">set</span>&lt;student&gt;::iterator it = setStudents.begin(); it != setStudents.end(); it++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"name: "</span> &lt;&lt; it-&gt;name &lt;&lt; <span class="string">" score: "</span> &lt;&lt; it-&gt;score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sort(setStudents.begin(), setStudents.end(), comp);</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "===========排序后================" &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//for (set&lt;student&gt;::iterator it = setStudents.begin(); it != setStudents.end(); it++)&#123;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; "name: " &lt;&lt; it-&gt;name &lt;&lt; " score: " &lt;&lt; it-&gt;score &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/909212-20160604002803352-2018700987.png" alt></p>
<h1 id="restrict与GCC的编译优化"><a href="#restrict与GCC的编译优化" class="headerlink" title="restrict与GCC的编译优化"></a>restrict与GCC的编译优化</h1><p><code>restrict</code>是C99标准中新添加的关键字，对于从C89标准开始起步学习C语言的同学来说，第一次看到restrict还是相当陌生的。简单说来，restrict关键字是编程者对编译器所做的一个“承诺”：使用restrict修饰过的指针，它所指向的内容只能经由该指针（或从该指针继承而来的指针，如通过该指针赋值或做指针运算而得到的其他指针）修改，而不会被其他不相干的指针所修改。</p>
<p>有了编程者的承诺，编译器便可以对一些通过指针的运算进行大胆的优化了。</p>
<p>观察编译器优化的最好办法当然是查看编译后的汇编代码。Wikipedia上有一个很好的例子，测试环境：Ubuntu 11.04 (x86-64) + Linux 2.6.38  + gcc 4.5.2。测试代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RES</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multi_add</span><span class="params">(<span class="keyword">int</span>* <span class="keyword">restrict</span> p1, <span class="keyword">int</span>* <span class="keyword">restrict</span> p2, <span class="keyword">int</span>* <span class="keyword">restrict</span> pi)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">else</span></span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multi_add</span><span class="params">(<span class="keyword">int</span>* p1, <span class="keyword">int</span>* p2, <span class="keyword">int</span>* pi)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="meta-keyword">endif</span></span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *p1 += *pi;</span><br><span class="line">    *p2 += *pi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> inc = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// increase both a and b by 1</span></span><br><span class="line">    multi_add(&amp;a, &amp;b, &amp;inc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the result</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d\n"</span>, a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>multi_add函数的功能很简单，将p1和p2指针所指向的内容都加上pi指针的内容。为了测试方便，使用了条件编译指令：如果定义RES宏，则使用带restrict的函数声明。</p>
<p>分别编译出两个版本的程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc restrict.c -o without_restrict</span><br><span class="line">gcc restrict.c -o with_restrict -DRES --std=c99</span><br></pre></td></tr></table></figure></p>
<p>使用objdump查看目标文件的汇编代码(-d选项表示disassemble)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d without_restrict</span><br></pre></td></tr></table></figure></p>
<p>PS：gcc默认使用的是AT&amp;T汇编，与很多同学在初次学习汇编时接触的Intel x86汇编有些不同</p>
<p>除了表示上的细微符号差别，最大的区别是src/dest的顺序，两者恰好相反：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intel : mov  eax  2      （先dest后src）</span><br><span class="line"></span><br><span class="line">AT&amp;T  : mov  %2   %eax   （先src后dest）</span><br></pre></td></tr></table></figure></p>
<p>然而这次的结果让人失望：两个版本的程序拥有一模一样的multi_add函数，汇编代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">push   %rbp</span><br><span class="line">mov    %rsp,%rbp</span><br><span class="line">mov    %rdi,-0x8(%rbp)</span><br><span class="line">mov    %rsi,-0x10(%rbp)</span><br><span class="line">mov    %rdx,-0x18(%rbp)</span><br><span class="line">mov    -0x8(%rbp),%rax</span><br><span class="line">mov    (%rax),%edx</span><br><span class="line">mov    -0x18(%rbp),%rax</span><br><span class="line">mov    (%rax),%eax</span><br><span class="line">add    %eax,%edx</span><br><span class="line">mov    -0x8(%rbp),%rax</span><br><span class="line">mov    %edx,(%rax)</span><br><span class="line">mov    -0x10(%rbp),%rax</span><br><span class="line">mov    (%rax),%edx</span><br><span class="line">mov    -0x18(%rbp),%rax</span><br><span class="line">mov    (%rax),%eax</span><br><span class="line">add    %eax,%edx</span><br><span class="line">mov    -0x10(%rbp),%rax</span><br><span class="line">mov    %edx,(%rax)</span><br><span class="line">leaveq </span><br><span class="line">retq</span><br></pre></td></tr></table></figure></p>
<p>其中寄存器rdi存放p1的地址，rsi存放p2的地址，rdx存放的是pi的地址。大段的汇编代码，无非是将寄存器中的内容mov到栈上的临时变量上，再把临时变量的值mov进寄存器进行加法运算。</p>
<p>难道restrict关键字没有任何作用？我怀疑很可能是编辑器优化程度不够。这次，使用-O1重新编译源代码并反汇编，终于观察到差别：</p>
<p>未使用restrict的版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov (%rdx), %eax</span><br><span class="line">add %eax,  (%rdi)</span><br><span class="line">mov (%rdx), %eax</span><br><span class="line">add %eax,  (%rsi)</span><br></pre></td></tr></table></figure></p>
<p>使用了restrict的版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov (%rdx), %eax</span><br><span class="line">add %eax,  (%rdi)</span><br><span class="line">add %eax,  (%rsi)</span><br></pre></td></tr></table></figure></p>
<p>可以看出，-O1的编译优化还是很给力的，所有运算直接在寄存器中进行，不再蛋疼地先mov进栈变量，再mov进寄存器进行add运算（在这个简单的例子中，确实没有必要）。</p>
<p>最大的区别在于将rdx寄存器间接引用的值mov进eax的语句只在一开始执行了1次。可以理解，当程序员“承诺”这些指针都是相互独立不再干扰时，pi指针的内容在函数范围内可以视之为常量，只需要load进寄存器一次。</p>
<p>而没有restrict关键字时，即使程序中没有对pi的内容进行操作，编译器仍然不能保证pi的内容在函数范围内是常量：因为有pointer aliasing的可能，即p1和p2指向的内容和pi相关（简单情况：p1和pi实际是同一个指针）。</p>
<p>需要注意的是，restrict是程序员给出的“承诺“，编译器没有指针的合法使用进行检查的职责，也没有这样的能力。</p>
<p>事实上，打开restrict关键字，如果这样调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multi_add(&amp;a, &amp;b, &amp;a);</span><br></pre></td></tr></table></figure></p>
<p>编译器不会报错。（事实上编译期完全有能力检查出简单alias的pointer）</p>
<p>而使用不同的编译优化级别（不优化，-O1， -O2），则产生了相当不同的结果。</p>
<ul>
<li>不优化   : <code>a = 2, b = 4</code></li>
<li>-O1      : <code>a = 2, b = 3</code></li>
<li>-O2以上: <code>a = 2, b = 4</code></li>
</ul>
<p>前面已经提到，没有开启-O选项时，gcc没有对restrict关键字进行优化（至少在这个例子中），所以应当是正确的行为（尽管此行为可能与编写<code>multi_add</code>函数的初衷不符合）</p>
<p>在O1下，restrict被优化，pi的值一开始即被缓存，所以产生了a和b都增加了1的结果</p>
<p>那么为什么O2以上，行为又开始变得正确了呢？</p>
<p>继续反汇编代码，发现-O2以上时，multi_add函数本身代码保持不变（确实在O1已经优化的相当简洁了），但main函数已经面目全非了：调用<code>multi_add</code>的代码已经改变，准确地说：</p>
<blockquote>
<p>multi_add函数已经不再被main调用了</p>
</blockquote>
<p>这里不再列出相关的汇编代码，因为这里的优化策略是相当复杂的。在这个例子中，由于a和b都是常量，a和b的值直接在编译期被算了出来，并放入寄存器中进行后续printf的调用。</p>
<p>可以看出，restrict确实是优化的利器。但是如果不仔细使用，它还是相当危险的，甚至能够导致在不同的优化级别下，出现完全不同的程序行为。</p>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><h2 id="why-volatile"><a href="#why-volatile" class="headerlink" title="why volatile"></a>why volatile</h2><p>volatile 关键词，最早出现于20世纪70年代，被用于处理 MMIO(Memory-mapped I/O) 带来的问题。在引入 MMIO 之后，一块内存地址既有可能是真正的内存，也有可能是映射的一个I/O端口。因此，读/写一个内存地址，既有可能是真正地操作内存，也有可能是读/写一个I/O设备。</p>
<p>那么 MMIO 为什么需要引入 volatile 关键词呢？我们结合下面这段示例代码进行解释：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *p = FunB();</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> b;</span><br><span class="line"> </span><br><span class="line">a = *p;     <span class="comment">// 语句1</span></span><br><span class="line">b = *p;     <span class="comment">// 语句2</span></span><br><span class="line"> </span><br><span class="line">*p = a;     <span class="comment">// 语句3</span></span><br><span class="line">*p = b;     <span class="comment">// 语句4</span></span><br></pre></td></tr></table></figure></p>
<p>在上述代码片段中，指针p既有可能指向一个内存地址，也有可能指向一个I/O设备。如果指针p指向的是I/O设备，那么语句1和语句2中的变量a和变量b，就会接收到I/O设备的连续两个字节。但是，指针p也有可能指向内存地址，这种情况下，编译器就会进行语句优化，编译器的优化策略会判断变量a和变量b同时从同一个内存地址读取数据，因此在执行完语句1之后，直接将变量a赋值给变量b。对于指针p指向I/O设备的这种情况，就需要防止编译器进行此优化，即不能假设指针b指向的内容不变（对应 volatile 的易变性特性）。</p>
<p>同样，语句3和语句4也有类似的问题，编译器发现将变量a和b同时赋值给指针p是无意义的，因此可能会优化语句3中的赋值操作，而仅仅保留语句4。对于指针p指向I/O设备的情况，也需要防止编译器将类似的写操作给优化消失了（对应 volatile 的不可优化特性）。</p>
<p>对于I/O设备，编译器不能随意交互指令的顺序，因为指令顺序一变，写入I/O设备的内容也就发生变化了（对应 volatile 的顺序性）。</p>
<p>为了满足 MMIO 的这三点需求，就有了 volatile 关键字。</p>
<h2 id="IN-C-C"><a href="#IN-C-C" class="headerlink" title="IN C/C++"></a>IN C/C++</h2><p>在C/C++语言中，使用 volatile 关键字声明的变量（或对象）通常具有与优化、多线程相关的特殊属性。通常，volatile 关键字用来阻止（伪）编译器对其认为的、无法“被代码本身”改变的代码（变量或对象）进行优化。如在C/C++中，volatile 关键字可以用来提醒编译器使用 volatile 声明的变量随时有可能改变，因此编译器在代码编译时就不会对该变量进行某些激进的优化，故而编译生成的程序在每次存储或读取该变量时，都会直接从内存地址中读取数据。相反，如果该变量没有使用 volatile 关键字进行声明，则编译器可能会优化读取和存储操作，可能暂时使用寄存器中该变量的值，而如果这个变量由别的程序（线程）更新了的话，就会出现（内存中与寄存器中的）变量值不一致的现象。</p>
<p>定义为volatile的变量是说这变量可能会被意想不到地改变，即在你程序运行过程中一直会变，你希望这个值被正确的处理，每次从内存中去读这个值，而不是因编译器优化从缓存的地方读取，比如读取缓存在寄存器中的数值，从而保证volatile变量被正确的读取。</p>
<p>在单任务的环境中，一个函数体内部，如果在两次读取变量的值之间的语句没有对变量的值进行修改，那么编译器就会设法对可执行代码进行优化。由于访问寄存器的速度要快过RAM（从RAM中读取变量的值到寄存器），以后只要变量的值没有改变，就一直从寄存器中读取变量的值，而不对RAM进行访问。</p>
<p>而在多任务环境中，虽然在一个函数体内部，在两次读取变量之间没有对变量的值进行修改，但是该变量仍然有可能被其他的程序（如中断程序、另外的线程等）所修改。如果这时还是从寄存器而不是从RAM中读取，就会出现被修改了的变量值不能得到及时反应的问题。</p>
<p> 因为访问寄存器要比访问内存单元快的多,所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。当要求使用volatile声明变量值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。精确地说就是，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用valatile，则编译器将对所声明的语句进行优化。（简洁的说就是：volatile关键词影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错。加了volatile修饰的变量，编译器将不对其相关代码执行优化，而是生成对应代码直接存取原始内存地址）。</p>
<p> 一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。一般说来，volatile用在如下的几个地方：</p>
<ol>
<li>并行设备的硬件寄存器（如：状态寄存器）</li>
<li>中断服务程序中修改的供其它程序检测的变量需要加volatile；</li>
<li>多任务环境下各任务间共享的标志应该加volatile；</li>
<li>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义；</li>
</ol>
<p>在C/C++语言中，使用 volatile 关键字声明的变量具有三种特性：易变的、不可优化的、顺序执行的。下面分别对这三种特性进行介绍。</p>
<h2 id="易变的"><a href="#易变的" class="headerlink" title="易变的"></a>易变的</h2><p>volatile 在词典中的主要释义就是“易变的”。</p>
<p>在 C/C++ 语言中，volatile 的易变性体现在：假设有读、写两条语句，依次对同一个 volatile 变量进行操作，那么后一条的读操作不会直接使用前一条的写操作对应的 volatile 变量的寄存器内容，而是重新从内存中读取该 volatile 变量的值。</p>
<p>上述描述的（部分）示例代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> nNum = <span class="number">0</span>;  <span class="comment">// 将nNum声明为volatile</span></span><br><span class="line"><span class="keyword">int</span> nSum = <span class="number">0</span>;</span><br><span class="line">nNum = FunA();      <span class="comment">// nNum被写入的新内容，其值会缓存在寄存器中</span></span><br><span class="line">nSum = nNum + <span class="number">1</span>;    <span class="comment">// 此处会从内存（而非寄存器）中读取nNum的值</span></span><br></pre></td></tr></table></figure></p>
<h2 id="不可优化的"><a href="#不可优化的" class="headerlink" title="不可优化的"></a>不可优化的</h2><p>在 C/C++ 语言中，volatile 的第二个特性是“不可优化性”。volatile 会告诉编译器，不要对 volatile 声明的变量进行各种激进的优化（甚至将变量直接消除），从而保证程序员写在代码中的指令一定会被执行。</p>
<p>上述描述的（部分）示例代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> nNum;  <span class="comment">// 将nNum声明为volatile</span></span><br><span class="line">nNum = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"nNum is: %d"</span>, nNum);</span><br></pre></td></tr></table></figure></p>
<p>在上述代码中，如果变量 nNum 没有声明为 volatile 类型，则编译器在编译过程中就会对其进行优化，直接使用常量“1”进行替换（这样优化之后，生成的汇编代码很简介，执行时效率很高）。而当我们使用 volatile 进行声明后，编译器则不会对其进行优化，nNum 变量仍旧存在，编译器会将该变量从内存中取出，放入寄存器之中，然后再调用 printf() 函数进行打印。</p>
<h2 id="顺序执行的"><a href="#顺序执行的" class="headerlink" title="顺序执行的"></a>顺序执行的</h2><p>在 C/C++ 语言中，volatile 的第三个特性是“顺序执行特性”，即能够保证 volatile 变量间的顺序性，不会被编译器进行乱序优化。</p>
<p>说明：C/C++ 编译器最基本优化原理：保证一段程序的输出，在优化前后无变化。</p>
<p>为了对本特性进行深入了解，下面以两个变量（nNum1 和 nNum2）为例（既然存在“顺序执行”，那描述对象必然大于一个），结合如下示例代码，介绍 volatile 的顺序执行特性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nNum1;</span><br><span class="line"><span class="keyword">int</span> nNum2;</span><br><span class="line">nNum2 = nNum1 + <span class="number">1</span>;    <span class="comment">// 语句1</span></span><br><span class="line">nNum1 = <span class="number">10</span>;           <span class="comment">// 语句2</span></span><br></pre></td></tr></table></figure></p>
<p>在上述代码中：</p>
<ul>
<li>当 nNum1 和 nNum2 都没有使用 volatile 关键字进行修饰时，编译器会对“语句1”和“语句2”的执行顺序进行优化：即先执行“语句2”、再执行“语句1”；</li>
<li>当 nNum2 使用 volatile 关键字进行修饰时，编译器也可能会对“语句1”和“语句2”的执行顺序进行优化：即先执行“语句2”、再执行“语句1”；</li>
<li>当 nNum1 和 nNum2 都使用 volatile 关键字进行修饰时，编译器不会对“语句1”和“语句2”的执行顺序进行优化：即先执行“语句1”、再执行“语句2”；</li>
</ul>
<p>说明：上述论述可通过观察代码的生成的汇编代码进行验证。</p>
<h2 id="volatile与多线程语义"><a href="#volatile与多线程语义" class="headerlink" title="volatile与多线程语义"></a>volatile与多线程语义</h2><p>对于多线程编程而言，在临界区内部，可以通过互斥锁（mutex）保证只有一个线程可以访问该临界区的内容，因此临界区内的变量不需要是 volatile 的；而在临界区外部，被多个线程访问的变量应声明为 volatile 的，这也符合了 volatile 的原意：防止编译器缓存（cache）了被多个线程并发用到的变量。</p>
<p>不过，需要注意的是，由于 volatile 关键字的“顺序执行特性”并非会完全保证语句的顺序执行（如 volatile 变量与非volatile 变量之间的操作；又如一些 CPU 也会对语句的执行顺序进行优化），因此导致了对 volatile 变量的操作并不是原子的，也不能用来为线程建立严格的 happens-before 关系。</p>
<p>对于上述描述，示例代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nNum1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">thread1()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line"> </span><br><span class="line">    nNum1 = <span class="number">666</span>;  <span class="comment">// 语句1</span></span><br><span class="line">    flag = <span class="literal">true</span>;  <span class="comment">// 语句2</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">thread2()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span> == flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 语句3：按照程序设计的预想，此处的nNum1的值应为666，并据此进行逻辑设计</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述代码中，我们的设计思路是先执行 thread1() 中的“语句1”、“语句2”、再执行 thread2() 中的“语句3”，不过实际上程序的执行结果未必如此。根据 volatile 的“顺序性”，非 volatile 变量 nNum1 和 volatile 变量 flag 的执行顺序，可能会被编译器（或 CPU）进行乱序优化，最终导致thread1中的“语句2”先于“语句1”执行，当“语句2”执行完成但“语句1”尚未执行时，此时 thread2 中的判断语句“if (true == flag)”是成立的，但实际上 nNum1 尚未进行赋值为666（语句1尚未执行），所以在判断语句中针对 nNum1 为666的前提下进行的相关操作，就会有问题了。</p>
<p>这是一个在多线程编程中，使用 volatile 不容易发现的问题。</p>
<p>实际上，上述多线程代码想实现的就是一个 happens-before 语义，即保证 thread1 代码块中的所有代码，一定要在 thread2 代码块的第一条代码之前完成。使用互斥锁（mutex）可以保证 happens-before 语义。但是，在 C/C++ 中的 volatile 关键词不能保证这个语义，也就意味着在多线程环境下使用 C/C++ 的 volatile 关键词，如果不够细心，就可能会出现上述问题。</p>
<p>说明：由于 Java 语言的 volatile 关键字支持 Acquire、Release 语义，因此 Java 语言的 volatile 能够用来构建 happens-before 语义。也就是说，前面提到的 C/C++ 中 volatile 在多线程下使用出现的问题，在 Java 语言中是不存在的。</p>
<h2 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h2><p>volatile只保证其“可见性”，不保证其“原子性”。</p>
<p>执行count++;这条语句由3条指令组成：</p>
<ol>
<li>将 count 的值从内存加载到 cpu 的某个 寄存器r；</li>
<li>将 寄存器r 的值 +1，结果存放在 寄存器s；</li>
<li>将 寄存器s 中的值写回内存。</li>
</ol>
<p>所以，如果有多个线程同时在执行 count++，在某个线程执行完第（3）步之前，其它线程是看不到它的执行结果的。（这里有疑惑：线程同时执行count++，为了保证其原子性，为何不加mutex lock？而是寻求volatile?）</p>
<p>在没有volatile的时候，执行完count++，执行结果其实是写到CPU缓存中，没有马上写回到内存中，后续在某些情况下（比如CPU缓存不够用）再将CPU缓存中的值flush到内存。因为没有存到内存里，其他线程是不能及时看到执行结果的。</p>
<p>在有volatile的时候，执行完count++，执行结果写入缓存中，并同时写入内存中，所以可以保证其它线程马上看到执行的结果。</p>
<p>但是，volatile 并没有保证原子性，在某个线程执行（1）（2）（3）的时候，volatile 并没有锁定 count 的值，也就是并不能阻塞其他线程也执行（1）（2）（3）。可能有两个线程同时执行（1），所以（2）计算出来一样的结果，然后（3）存回的也是同一个值。<br>考虑下面一段代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> some_int = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">while</span>(some_int == <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//your code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为编译器认为some_int没被改变过，一直是100。但是在多线程时，如果执行完第一行，但是还没执行到第三行时，另一个线程修改了some_int，while就不能进入循环了。加了volatile后，阻止了编译器优化，每次读到some_int会从内存中读取，而不是本线程的寄存去（当然这会损失效率）。这就是volatile的作用。</p>
<p>一句话总结：volatile保证线程能读到最新的数据，因为是从内存中读取，且存入内存中。而不是线程各自的寄存器中读写。</p>
<h1 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h1><p>内联函数和普通函数相比可以加快程序运行的速度，因为不需要中断调用，在编译的时候内联函数可以直接嵌入到目标代码中。</p>
<ul>
<li>相当于把内联函数里面的内容写在调用内联函数处；</li>
<li>相当于不用执行进入函数的步骤，直接执行函数体；</li>
<li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li>
<li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li>
<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li>
<li>作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明1（加 inline，建议使用）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明2（不加 inline）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span> </span>&#123;<span class="comment">/****/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内定义，隐式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;         <span class="comment">// 隐式内联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义，需要显式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> A::doA() &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   <span class="comment">// 需要显式内联</span></span><br></pre></td></tr></table></figure>
<p>编译器对 inline 函数的处理步骤</p>
<ol>
<li>将 inline 函数体复制到 inline 函数调用点处； </li>
<li>为所用 inline 函数中的局部变量分配内存空间； </li>
<li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； </li>
<li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li>
</ol>
<p>优点</p>
<ol>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>
<li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 </li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li>
<li>内联函数在运行时可调试，而宏定义不可以。</li>
</ol>
<p>缺点</p>
<ol>
<li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li>
</ol>
<h2 id="内联函数和宏定义的区别"><a href="#内联函数和宏定义的区别" class="headerlink" title="内联函数和宏定义的区别"></a>内联函数和宏定义的区别</h2><p>内联函数以代码复杂为代价，它以省去函数调用的开销来提高执行效率。所以一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义；另一方面每一处内联函数的调用都要复制代码，消耗更多的内存空间，因此以下情况不宜使用内联函数：</p>
<ul>
<li>函数体内的代码比较长，将导致内存消耗代价</li>
<li>函数体内有循环，函数执行时间要比函数调用开销大</li>
</ul>
<h2 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h2><ul>
<li>内联函数在编译时展开，宏在预编译时展开</li>
<li>内联函数直接嵌入到目标代码中，宏是简单的做文本替换</li>
<li>内联函数有类型、语法判断等功能，而宏没有</li>
<li>内联函数是函数，宏不是</li>
<li>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义</li>
<li>内联函数代码是被放到符号表中，使用时像宏一样展开，没有调用的开销，效率很高；</li>
<li>在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。</li>
<li>内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员，进而提升效率。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。</li>
</ul>
<h1 id="union"><a href="#union" class="headerlink" title="union"></a>union</h1><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p>
<ul>
<li>默认访问控制符为 public</li>
<li>可以含有构造函数、析构函数</li>
<li>不能含有引用类型的成员</li>
<li>不能继承自其他类，不能作为基类</li>
<li>不能含有虚函数</li>
<li>匿名 union 在定义所在作用域可直接访问 union 成员</li>
<li>匿名 union 不能包含 protected 成员或 private 成员</li>
<li>全局匿名联合必须是静态（static）的</li>
</ul>
<p>C++11 标准规定，任何非引用类型都可以成为联合体的数据成员，这种联合体也被称为非受限联合体。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">bool</span> g, <span class="keyword">int</span> a): gender(g), age(a) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> gender;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> T&#123;</span><br><span class="line">    Student s;  <span class="comment">// 含有非POD类型的成员，gcc-5.1.0  版本报错</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，因为 Student 类带有自定义的构造函数，所以是一个非 POD 类型的，这导致编译器报错。这种规定只是 C++ 为了兼容C语言而制定，然而在长期的编程实践中发现，这种规定是没有必要的。</p>
<h2 id="C-11-允许非-POD-类型"><a href="#C-11-允许非-POD-类型" class="headerlink" title="C++11 允许非 POD 类型"></a>C++11 允许非 POD 类型</h2><p>C++98 不允许联合体的成员是非 POD 类型，但是 C++11 取消了这种限制。POD 是英文 Plain Old Data 的缩写，用来描述一个类型的属性。POD 类型一般具有以下几种特征（包括 class、union 和 struct等）：</p>
<ul>
<li>没有用户自定义的构造函数、析构函数、拷贝构造函数和移动构造函数。</li>
<li>不能包含虚函数和虚基类。</li>
<li>非静态成员必须声明为 public。</li>
<li>类中的第一个非静态成员的类型与其基类不同</li>
<li>在类或者结构体继承时，满足以下两种情况之一： <ul>
<li>派生类中有非静态成员，且只有一个仅包含静态成员的基类；</li>
<li>基类有非静态成员，而派生类没有非静态成员。</li>
</ul>
</li>
<li>所有非静态数据成员均和其基类也符合上述规则（递归定义），也就是说 POD 类型不能包含非 POD 类型的数据。</li>
<li>此外，所有兼容C语言的数据类型都是 POD 类型（struct、union 等不能违背上述规则）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> :</span> B1 &#123; B1 b; &#125;;</span><br></pre></td></tr></table></figure>
<p>class B2 的第一个非静态成员 b 是基类类型，所以它不是 POD 类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> &#123;</span> <span class="keyword">static</span> <span class="keyword">int</span> n; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> :</span> B1 &#123; <span class="keyword">int</span> n1; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B3</span> :</span> B2 &#123; <span class="keyword">static</span> <span class="keyword">int</span> n2; &#125;;</span><br></pre></td></tr></table></figure>
<p>对于 B2，派生类 B2 中有非静态成员，且只有一个仅包含静态成员的基类 B1，所以它是 POD 类型。对于 B3，基类 B2 有非静态成员，而派生类 B3 没有非静态成员，所以它也是 POD 类型。</p>
<h2 id="C-11-允许联合体有静态成员"><a href="#C-11-允许联合体有静态成员" class="headerlink" title="C++11 允许联合体有静态成员"></a>C++11 允许联合体有静态成员</h2><p>C++11 删除了联合体不允许拥有静态成员的限制。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> U &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，静态成员变量只能在联合体内定义，却不能在联合体外使用，这使得该规则很没用。</p>
<h2 id="非受限联合体的赋值注意事项"><a href="#非受限联合体的赋值注意事项" class="headerlink" title="非受限联合体的赋值注意事项"></a>非受限联合体的赋值注意事项</h2><p>C++11 规定，如果非受限联合体内有一个非 POD 的成员，而该成员拥有自定义的构造函数，那么这个非受限联合体的默认构造函数将被编译器删除；其他的特殊成员函数，例如默认拷贝构造函数、拷贝赋值操作符以及析构函数等，也将被删除。</p>
<p>这条规则可能导致对象构造失败，请看下面的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">union</span> U &#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;   <span class="comment">// 构造失败，因为 U 的构造函数被删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中，因为 string 类拥有自定义的构造函数，所以 U 的构造函数被删除；定义 U 的类型变量 u 需要调用默认构造函数，所以 u 也就无法定义成功。</p>
<p>解决上面问题的一般需要用到 placement new，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">union</span> U &#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    U() &#123; <span class="keyword">new</span>(&amp;s) <span class="built_in">string</span>; &#125;</span><br><span class="line">    ~U() &#123; s.~<span class="built_in">string</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造时，采用<code>placement new</code>将 s 构造在其地址 &amp;s 上，这里<code>placement new</code>的唯一作用只是调用了一下 string 类的构造函数。注意，在析构时还需要调用 string 类的析构函数。</p>
<h2 id="非受限联合体的匿名声明和“枚举式类”"><a href="#非受限联合体的匿名声明和“枚举式类”" class="headerlink" title="非受限联合体的匿名声明和“枚举式类”"></a>非受限联合体的匿名声明和“枚举式类”</h2><p>匿名联合体是指不具名的联合体（也即没有名字的联合体），一般定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> U&#123;</span><br><span class="line">    <span class="keyword">union</span> &#123; <span class="keyword">int</span> x; &#125;;  <span class="comment">//此联合体为匿名联合体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，联合体 U 内定义了一个不具名的联合体，该联合体包含一个 int 类型的成员变量，我们称这个联合体为匿名联合体。</p>
<p>同样的，非受限联合体也可以匿名，而当非受限的匿名联合体运用于类的声明时，这样的类被称为“枚举式类”。示例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">bool</span> g, <span class="keyword">int</span> a): gender(g), age(a)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> gender;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> Type &#123; STUDENT, NATIVE, FOREIGENR &#125;;</span><br><span class="line">    Singer(<span class="keyword">bool</span> g, <span class="keyword">int</span> a) : s(g, a) &#123; t = STUDENT; &#125;</span><br><span class="line">    Singer(<span class="keyword">int</span> i) : id(i) &#123; t = NATIVE; &#125;</span><br><span class="line">    Singer(<span class="keyword">const</span> <span class="keyword">char</span>* n, <span class="keyword">int</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = (s &gt; <span class="number">9</span>) ? <span class="number">9</span> : s;</span><br><span class="line">        <span class="built_in">memcpy</span>(name , n, size);</span><br><span class="line">        name[s] = <span class="string">'\0'</span>;</span><br><span class="line">        t = FOREIGENR;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Singer()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type t;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Student s;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singer(<span class="literal">true</span>, <span class="number">13</span>);</span><br><span class="line">    Singer(<span class="number">310217</span>);</span><br><span class="line">    Singer(<span class="string">"J Michael"</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中使用了一个匿名非受限联合体，它作为类 Singer 的“变长成员”来使用，这样的变长成员给类的编写带来了更大的灵活性，这是 C++98 标准中无法达到的。</p>
<h1 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h1><p>断言，是宏，而非函数。<code>assert</code>宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p>
<p><code>assert()</code>会对表达式expression进行检测：</p>
<ul>
<li>如果expression的结果为 0（条件不成立），那么断言失败，表明程序出错，<code>assert()</code>会向标准输出设备（一般是显示器）打印一条错误信息，并调用 abort() 函数终止程序的执行。</li>
<li>如果expression的结果为非 0（条件成立），那么断言成功，表明程序正确，<code>assert()</code>不进行任何操作。</li>
</ul>
<p>参数：</p>
<ul>
<li>expression：要检测的表达式。如果表达式的值为 0，那么断言失败，程序终止执行；如果表达式的值为非 0，那么断言成功，assert() 不进行任何操作。</li>
</ul>
<h2 id="assert-的用法和机制"><a href="#assert-的用法和机制" class="headerlink" title="assert() 的用法和机制"></a>assert() 的用法和机制</h2><p><code>assert()</code>的用法很简单，我们只要传入一个表达式，它会计算这个表达式的结果：如果表达式的结果为“假”，<code>assert()</code>会打印出断言失败的信息，并调用<code>abort()</code>函数终止程序的执行；如果表达式的结果为“真”，<code>assert()</code>就什么也不做，程序继续往后执行。</p>
<p>下面是一个具体的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n, result;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n);</span><br><span class="line">    assert(n != <span class="number">0</span>);  <span class="comment">//写作 assert(n) 更加简洁</span></span><br><span class="line">    result = m / n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"result = %d\n"</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="NDEBUG-宏"><a href="#NDEBUG-宏" class="headerlink" title="NDEBUG 宏"></a>NDEBUG 宏</h2><p>如果查看<code>&lt;assert.h&gt;</code>头文件的源码，会发现<code>assert()</code>被定义为下面的样子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assert(e) ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assert(e)  \</span></span><br><span class="line">    ((<span class="keyword">void</span>) ((e) ? ((<span class="keyword">void</span>)<span class="number">0</span>) : __assert (#e, __FILE__, __LINE__)))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>这意味着，一旦定义了NDEBUG宏，<code>assert()</code>就无效了。</p>
<p><code>NDEBUG</code>是”No Debug“的意思，也即“非调试”。有的编译器（例如 Visual Studio）在发布（Release）模式下会定义 NDEBUG 宏，在调试（Debug）模式下不会定义定义这个宏；有的编译器（例如 Xcode）在发布模式和调试模式下都不会定义 NDEBUG 宏，这样当我们以发布模式编译程序时，就必须自己在编译参数中增加<code>NDEBUG</code>宏，或者在包含<code>&lt;assert.h&gt;</code>头文件之前定义<code>NDEBUG</code>宏。</p>
<p>调试模式是程序员在测试代码期间使用的编译模式，发布模式是将程序提供给用户时使用的编译模式。在发布模式下，我们不应该再依赖<code>assert()</code>宏，因为程序一旦出错，<code>assert()</code>会抛出一段用户看不懂的提示信息，并毫无预警地终止程序执行，这样会严重影响软件的用户体验，所以在发布模式下应该让<code>assert()</code>失效。</p>
<p>修改上面的代码，在包含<code>&lt;assert.h&gt;</code>之前定义<code>NDEBUG</code>宏：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n, result;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n);</span><br><span class="line">    assert(n);</span><br><span class="line">    result = m / n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"result = %d\n"</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当以发布模式编译这段代码时，<code>assert()</code>就会失效。如果希望继续以调试模式编译这段代码，去掉<code>NDEBUG</code>宏即可。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>使用<code>assert()</code>时，被检测的表达式最好不要太复杂，以下面的代码为例：<code>assert( expression1 &amp;&amp; expression2 &amp;&amp; expression3);</code></p>
<p>当发生错误时，<code>assert()</code>只会告诉我们<code>expression1 &amp;&amp; expression2 &amp;&amp; expression3</code>整个表达式为不成立，但是这个大的表达式还包含了三个小的表达式，并且它们之间是&amp;&amp;运算，任何一个小表达式为不成立都会导致整个表达式为不成立，这样我们就无法推断到底是expression1有问题，还是expression2或者expression3有问题，从而给排错带来麻烦。</p>
<p>这里我们应该遵循使用<code>assert()</code>的一个原则：每次断言只能检验一个表达式。根据这个原则，上面的代码应改为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assert(expression1);</span><br><span class="line">assert(expression2);</span><br><span class="line">assert(expression3);</span><br></pre></td></tr></table></figure></p>
<p>如此，一旦程序出错，我们就知道是哪个小的表达式断言失败了，从而快速定位到有问题的代码。</p>
<p>使用<code>assert()</code>的另外一个注意事项是：不要用会改变环境的语句作为断言的表达式。请看下面的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= <span class="number">110</span>)&#123;</span><br><span class="line">        assert(++i &lt;= <span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"我是第%d行\n"</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 Debug 模式下运行，程序循环到第 101 次时，i 的值为 100，++i &lt;= 100不再成立，断言失败，程序终止运行。</p>
<p>在 Release 模式下运行，编译参数中设置了<code>NDEBUG</code>宏（如果编译器没有默认设置，那么需要你自己来设置），<code>assert()</code>会失效，<code>++i &lt;= 100</code>这个表达式也不起作用了，<code>while()</code>无法终止，成为一个死循环。</p>
<p>定义了<code>NDEBUG</code>宏后，<code>assert(++i &lt;= 100)</code>会被替换为<code>((void)0)</code>。</p>
<h1 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h1><h2 id="pair类型的定义和初始化"><a href="#pair类型的定义和初始化" class="headerlink" title="pair类型的定义和初始化"></a>pair类型的定义和初始化</h2><p>pair类型是在有文件utility中定义的，pair类型包含了两个数据值，通常有以下的一些定义和初始化的一些方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;T1, T2&gt; p;</span><br><span class="line">pair&lt;T1, T2&gt; p(v1, v2);</span><br><span class="line">make_pair(v1, v2)</span><br></pre></td></tr></table></figure></p>
<p>上述第一种方法是定义了一个空的pair对象p，第二种方法是定义了包含初始值为v1和v2的pair对象p。第三种方法是以v1和v2值创建的一个新的pair对象。</p>
<h2 id="pair对象的一些操作"><a href="#pair对象的一些操作" class="headerlink" title="pair对象的一些操作"></a>pair对象的一些操作</h2><p>除此之外，pair对象还有一些方法，如取出pair对象中的每一个成员的值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.first</span><br><span class="line">p.second</span><br></pre></td></tr></table></figure></p>
<p>一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; p1(<span class="number">0</span>, <span class="string">"Hello"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d, %s\n"</span>, p1.first, p1.second.c_str());</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; p2 = make_pair(<span class="number">1</span>, <span class="string">"World"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d, %s\n"</span>, p2.first, p2.second.c_str());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>标准库map类型是一种以键-值(key-value)存储的数据类型。</p>
<ul>
<li>第一个可以称为关键字(key)，每个关键字只能在map中出现一次；</li>
<li>第二个可能称为该关键字的值(value)；</li>
</ul>
<p>map以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。在map内部所有的数据都是有序的。</p>
<p>以下分别从以下的几个方面总结：</p>
<ul>
<li>map对象的定义和初始化</li>
<li>map对象的基本操作，主要包括添加元素，遍历等</li>
</ul>
<h2 id="map对象的定义和初始化"><a href="#map对象的定义和初始化" class="headerlink" title="map对象的定义和初始化"></a>map对象的定义和初始化</h2><p>map是键-值对的组合，有以下的一些定义的方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;k, v&gt; m;</span><br><span class="line"><span class="built_in">map</span>&lt;k, v&gt; m(m2);</span><br><span class="line"><span class="built_in">map</span>&lt;k, v&gt; m(b, e);</span><br></pre></td></tr></table></figure></p>
<p>上述第一种方法定义了一个名为m的空的map对象；第二种方法创建了m2的副本m；第三种方法创建了map对象m，并且存储迭代器b和e范围内的所有元素的副本。</p>
<p>map的value_type是存储元素的键以及值的pair类型，键为const。</p>
<p>使用map得包含map类所在的头文件<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  //注意，STL头文件没有扩展名.h</span></span></span><br></pre></td></tr></table></figure></p>
<p>map对象是模板类，需要关键字和存储对象两个模板参数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>:<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; personnel;</span><br></pre></td></tr></table></figure></p>
<p>这样就定义了一个用int作为索引,并拥有相关联的指向string的指针.</p>
<p>为了使用方便，可以对模板类进行一下类型定义，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> aap&lt;<span class="keyword">int</span>,CString&gt; UDT_MAP_INT_CSTRING;</span><br></pre></td></tr></table></figure></p>
<p>map共提供了6个构造函数，这块涉及到内存分配器这些东西，略过不表，在下面我们将接触到一些map的构造方法，这里要说下的就是，我们通常用如下方法构造一个map：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</span><br></pre></td></tr></table></figure></p>
<h2 id="map中元素的插入"><a href="#map中元素的插入" class="headerlink" title="map中元素的插入"></a>map中元素的插入</h2><p>在map中元素有两种插入方法：</p>
<ul>
<li>使用下标</li>
<li>使用insert函数</li>
</ul>
<blockquote>
<p>在map中使用下标访问不存在的元素将导致在map容器中添加一个新的元素。</p>
</blockquote>
<p>insert函数的插入方法主要有如下：</p>
<ul>
<li><code>m.insert(e)</code></li>
<li><code>m.insert(beg, end)</code></li>
<li><code>m.insert(iter, e)</code></li>
</ul>
<p>上述的e一个value_type类型的值。beg和end标记的是迭代器的开始和结束。</p>
<p>两种插入方法如下面的例子所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line">            mp[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">            mp.insert(make_pair(i, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = mp.begin(); it != mp.end(); it++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d--&gt;%d\n"</span>, it-&gt;first, it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个map对象</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第一种 用insert函數插入pair</span></span><br><span class="line">mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">000</span>, <span class="string">"student_zero"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第二种 用insert函数插入value_type数据</span></span><br><span class="line">mapStudent.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type(<span class="number">001</span>, <span class="string">"student_one"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第三种 用"array"方式插入</span></span><br><span class="line">mapStudent[<span class="number">123</span>] = <span class="string">"student_first"</span>;</span><br><span class="line">mapStudent[<span class="number">456</span>] = <span class="string">"student_second"</span>;</span><br></pre></td></tr></table></figure>
<p>以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是不能在插入数据的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapStudent.insert(map&lt;int, string&gt;::value_type (001, &quot;student_one&quot;));</span><br><span class="line">mapStudent.insert(map&lt;int, string&gt;::value_type (001, &quot;student_two&quot;));</span><br></pre></td></tr></table></figure></p>
<h2 id="map中元素的查找和读取"><a href="#map中元素的查找和读取" class="headerlink" title="map中元素的查找和读取"></a>map中元素的查找和读取</h2><p>注意：上述采用下标的方法读取map中元素时，若map中不存在该元素，则会在map中插入。</p>
<p>因此，若只是查找该元素是否存在，可以使用函数count(k)，该函数返回的是k出现的次数；若是想取得key对应的值，可以使用函数find(k)，该函数返回的是指向该元素的迭代器。</p>
<p>上述的两个函数的使用如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">            mp.insert(make_pair(i, i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mp.count(<span class="number">0</span>))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"yes!\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"no!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it_find;</span><br><span class="line">    it_find = mp.find(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (it_find != mp.end())&#123;</span><br><span class="line">            it_find-&gt;second = <span class="number">20</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"no!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = mp.begin(); it != mp.end(); it++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d-&gt;%d\n"</span>, it-&gt;first, it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="从map中删除元素"><a href="#从map中删除元素" class="headerlink" title="从map中删除元素"></a>从map中删除元素</h2><p>从map中删除元素的函数是erase()，该函数有如下的三种形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m.erase(k)</span><br><span class="line">m.erase(p)</span><br><span class="line">m.erase(b, e)</span><br></pre></td></tr></table></figure></p>
<p>第一种方法删除的是m中键为k的元素，返回的是删除的元素的个数；第二种方法删除的是迭代器p指向的元素，返回的是void；第三种方法删除的是迭代器b和迭代器e范围内的元素，返回void。</p>
<p>如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">        mp.insert(make_pair(i, i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mp.erase(<span class="number">0</span>);</span><br><span class="line">    mp.erase(mp.begin());</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = mp.begin(); it != mp.end(); it++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d-&gt;%d\n"</span>, it-&gt;first, it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="map的基本操作函数："><a href="#map的基本操作函数：" class="headerlink" title="map的基本操作函数："></a>map的基本操作函数：</h2><p>C++ maps是一种关联式容器，包含“关键字/值”对</p>
<ul>
<li><code>begin()</code>   返回指向map头部的迭代器</li>
<li><code>clear()</code>   删除所有元素</li>
<li><code>count()</code>   返回指定元素出现的次数</li>
<li><code>empty()</code>   如果map为空则返回true</li>
<li><code>end()</code>   返回指向map末尾的迭代器</li>
<li><code>equal_range()</code>   返回特殊条目的迭代器对</li>
<li><code>erase()</code>   删除一个元素</li>
<li><code>find()</code>   查找一个元素</li>
<li><code>get_allocator()</code>   返回map的配置器</li>
<li><code>insert()</code>   插入元素</li>
<li><code>key_comp()</code>   返回比较元素key的函数</li>
<li><code>lower_bound()</code>   返回键值&gt;=给定元素的第一个位置</li>
<li><code>max_size()</code>   返回可以容纳的最大元素个数</li>
<li><code>rbegin()</code>   返回一个指向map尾部的逆向迭代器</li>
<li><code>rend()</code>   返回一个指向map头部的逆向迭代器</li>
<li><code>size()</code>   返回map中元素的个数</li>
<li><code>swap()</code>   交换两个map</li>
<li><code>upper_bound()</code>   返回键值&gt;给定元素的第一个位置</li>
<li><code>value_comp()</code>   返回比较元素value的函数</li>
</ul>
<h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
<th>复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>size()</td>
<td>返回栈的元素数</td>
<td>O(1)</td>
</tr>
<tr>
<td>top()</td>
<td>返回栈顶的元素</td>
<td>O(1)</td>
</tr>
<tr>
<td>pop()</td>
<td>从栈中取出并删除元素</td>
<td>O(1)</td>
</tr>
<tr>
<td>push(x)</td>
<td>向栈中添加元素x</td>
<td>O(1)</td>
</tr>
<tr>
<td>empty()</td>
<td>在栈为空时返回true</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
</div>
<p>贴一些代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    S.push(<span class="number">3</span>);</span><br><span class="line">    S.push(<span class="number">7</span>);</span><br><span class="line">    S.push(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; S.size() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; S.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    S.pop();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; S.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    S.pop();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; S.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    S.push(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; S.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    S.pop();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; S.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="queues"><a href="#queues" class="headerlink" title="queues"></a>queues</h1><p>C++队列是一种容器适配器，它给予程序员一种先进先出(FIFO)的数据结构。</p>
<ol>
<li>back() 返回一个引用，指向最后一个元素</li>
<li>empty() 如果队列空则返回真</li>
<li>front() 返回第一个元素</li>
<li>pop() 删除第一个元素</li>
<li>push() 在末尾加入一个元素</li>
<li>size() 返回队列中元素的个数</li>
</ol>
<p>队列可以用线性表(list)或双向队列(deque)来实现(注意vector container 不能用来实现queue，因为vector 没有成员函数pop_front!)：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; q1</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&gt; q2</span><br></pre></td></tr></table></figure></p>
<p>其成员函数有“判空(empty)” 、“尺寸(Size)” 、“首元(front)” 、“尾元(backt)” 、“加入队列(push)” 、“弹出队列(pop)”等操作。</p>
<p>例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">4</span>);</span><br><span class="line">    q.push(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,q.front());</span><br><span class="line">    q.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Priority-Queues"><a href="#Priority-Queues" class="headerlink" title="Priority Queues"></a>Priority Queues</h1><p>C++优先队列类似队列，但是在这个数据结构中的元素按照一定的断言排列有序。</p>
<ol>
<li><code>empty()</code>如果优先队列为空，则返回真</li>
<li><code>pop()</code>删除第一个元素</li>
<li><code>push()</code>加入一个元素</li>
<li><code>size()</code>返回优先队列中拥有的元素的个数</li>
<li><code>top()</code>返回优先队列中有最高优先级的元素</li>
</ol>
<p>优先级队列可以用向量(vector)或双向队列(deque)来实现(注意list container 不能用来实现queue，因为list 的迭代器不是任意存取iterator，而pop 中用到堆排序时是要求randomaccess iterator 的!)：</p>
<ul>
<li><code>priority_queue&lt;vector&lt;int&gt;, less&lt;int&gt;&gt; pq1</code>; 使用递增less<int>函数对象排序</int></li>
<li><code>priority_queue&lt;deque&lt;int&gt;, greater&lt;int&gt;&gt; pq2</code>; 使用递减greater<int>函数对象排序</int></li>
<li>其成员函数有“判空(empty)” 、“尺寸(Size)” 、“栈顶元素(top)” 、“压栈(push)” 、“弹栈(pop)”等。</li>
</ul>
<p>priority_queue模版类有三个模版参数，元素类型，容器类型，比较算子。其中后两个都可以省略，默认容器为vector，默认算子为less，即小的往前排，大的往后排（出队时序列尾的元素出队）。</p>
<p>初学者在使用priority_queue时，最困难的可能就是如何定义比较算子了。如果是基本数据类型，或已定义了比较运算符的类，可以直接用STL的less算子和greater算子——默认为使用less算子，即小的往前排，大的先出队。如果要定义自己的比较算子，方法有多种，这里介绍其中的一种：重载比较运算符。优先队列试图将两个元素x和y代入比较运算符(对less算子，调用x<y，对greater算子，调用x>y)，若结果为真，则x排在y前面，y将先于x出队，反之，则将y排在x前面，x将先出队。</y，对greater算子，调用x></p>
<p>例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y, z; </span><br><span class="line">    T(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c):x(a), y(b), z(c)</span><br><span class="line">    &#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> T &amp;t1, <span class="keyword">const</span> T &amp;t2) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t1.z &lt; t2.z; <span class="comment">// 按照z的顺序来决定t1和t2的顺序</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    priority_queue&lt;T&gt; q; </span><br><span class="line">    q.push(T(<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>)); </span><br><span class="line">    q.push(T(<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>)); </span><br><span class="line">    q.push(T(<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>)); </span><br><span class="line">    q.push(T(<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>)); </span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) </span><br><span class="line">    &#123; </span><br><span class="line">        T t = q.top(); </span><br><span class="line">        q.pop(); </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; t.x &lt;&lt; <span class="string">" "</span> &lt;&lt; t.y &lt;&lt; <span class="string">" "</span> &lt;&lt; t.z &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果为(注意是按照z的顺序从大到小出队的)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3 6 </span><br><span class="line">2 2 5 </span><br><span class="line">1 5 4 </span><br><span class="line">4 4 3</span><br></pre></td></tr></table></figure></p>
<p>再看一个按照z的顺序从小到大出队的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">int</span> x, y, z; </span><br><span class="line">    T(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c):x(a), y(b), z(c) </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> T &amp;t1, <span class="keyword">const</span> T &amp;t2) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> t1.z &gt; t2.z; </span><br><span class="line">&#125; </span><br><span class="line">main() </span><br><span class="line">&#123; </span><br><span class="line">    priority_queue&lt;T, <span class="built_in">vector</span>&lt;T&gt;, greater&lt;T&gt; &gt; q; </span><br><span class="line">    q.push(T(<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>)); </span><br><span class="line">    q.push(T(<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>)); </span><br><span class="line">    q.push(T(<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>)); </span><br><span class="line">    q.push(T(<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>)); </span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) </span><br><span class="line">    &#123; </span><br><span class="line">        T t = q.top(); </span><br><span class="line">        q.pop(); </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; t.x &lt;&lt; <span class="string">" "</span> &lt;&lt; t.y &lt;&lt; <span class="string">" "</span> &lt;&lt; t.z &lt;&lt;  <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 4 3 </span><br><span class="line">1 5 4 </span><br><span class="line">2 2 5 </span><br><span class="line">3 3 6</span><br></pre></td></tr></table></figure></p>
<h1 id="vector的内部实现原理及基本用法"><a href="#vector的内部实现原理及基本用法" class="headerlink" title="vector的内部实现原理及基本用法"></a>vector的内部实现原理及基本用法</h1><p>本文基于STL vector源代码，但是不考虑分配器allocator，迭代器iterator，异常处理try/catch等内容，同时对_Ucopy（）、 _Umove（）、 _Ufill（）函数也不会过度分析。</p>
<h2 id="vector的定义"><a href="#vector的定义" class="headerlink" title="vector的定义"></a>vector的定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> _<span class="title">Ax</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">class</span> <span class="title">vector</span></span></span><br><span class="line"><span class="class">        :</span> <span class="keyword">public</span> _Vector_val&lt;_Ty, _Ax&gt;</span><br><span class="line">&#123;   <span class="comment">// varying size array of values</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/********/</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    pointer _Myfirst;   <span class="comment">// pointer to beginning of array</span></span><br><span class="line">    pointer _Mylast;    <span class="comment">// pointer to current end of sequence</span></span><br><span class="line">    pointer _Myend; <span class="comment">// pointer to end of array</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>简单理解，就是vector是利用上述三个指针来表示的，基本示意图如下：<br><img src="/img/20160223191226316.jpg" alt></p>
<p>两个关键大小： </p>
<ul>
<li>大小：<code>size=_Mylast - _Myfirst;</code></li>
<li>容量：<code>capacity=_Myend - _Myfirst;</code> </li>
</ul>
<p>分别对应于resize()、reserve()两个函数。size表示vector中已有元素的个数，容量表示vector最多可存储的元素的个数；为了降低二次分配时的成本，vector实际配置的大小可能比客户需求的更大一些，以备将来扩充，这就是容量的概念。即capacity&gt;=size，当等于时，容器此时已满，若再要加入新的元素时，就要重新进行内存分配，整个vector的数据都要移动到新内存。二次分配成本较高，在实际操作时，应尽量预留一定空间，避免二次分配。</p>
<h2 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h2><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>vector的构造函数主要有以下几种：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>() : _Mybase()</span><br><span class="line">    &#123;   <span class="comment">// construct empty vector</span></span><br><span class="line">    _Buy(<span class="number">0</span>);</span><br><span class="line">    &#125;       </span><br><span class="line">explicit vector(size_type _Count) : _Mybase()</span><br><span class="line">    &#123;   <span class="comment">// construct from _Count * _Ty()</span></span><br><span class="line">    _Construct_n(_Count, _Ty());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">vector</span>(size_type _Count, <span class="keyword">const</span> _Ty&amp; _Val) : _Mybase()</span><br><span class="line">    &#123;   <span class="comment">// construct from _Count * _Val</span></span><br><span class="line">    _Construct_n(_Count, _Val);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">const</span> _Myt&amp; _Right) : _Mybase(_Right._Alval)</span><br><span class="line">    &#123;   <span class="comment">// construct by copying _Right</span></span><br><span class="line">    <span class="keyword">if</span> (_Buy(_Right.size()))</span><br><span class="line">        _Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>vector优异性能的秘诀之一，就是配置比其所容纳的元素所需更多的内存，一般在使用vector之前，就先预留足够空间，以避免二次分配，这样可以使vector的性能达到最佳。因此元素个数_Count是个远比元素值 _Val重要的参数，因此当构造一个vector时，首要参数一定是元素个数。<br>由上各构造函数可知，基本上所有构造函数都是基于_Construct _n() 的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> _Buy(size_type _Capacity)</span><br><span class="line">&#123;   <span class="comment">// allocate array with _Capacity elements</span></span><br><span class="line">    _Myfirst = <span class="number">0</span>, _Mylast = <span class="number">0</span>, _Myend = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (_Capacity == <span class="number">0</span>)    <span class="comment">//_Count为0时，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        &#123;   <span class="comment">// nonempty array, allocate storage</span></span><br><span class="line">        _Myfirst = <span class="keyword">this</span>-&gt;_Alval.allocate(_Capacity);  <span class="comment">//分配内存，并更新成员变量</span></span><br><span class="line">        _Mylast = _Myfirst;</span><br><span class="line">        _Myend = _Myfirst + _Capacity;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _Construct_n(size_type _Count, <span class="keyword">const</span> _Ty&amp; _Val)</span><br><span class="line">&#123;   <span class="comment">// 构造含有_Count个值为_Val的元素的容器</span></span><br><span class="line">    <span class="keyword">if</span> (_Buy(_Count))</span><br><span class="line">        _Mylast = _Ufill(_Myfirst, _Count, _Val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就完成了vector容器的构造了。</p>
<h3 id="析构"><a href="#析构" class="headerlink" title="析构"></a>析构</h3><p>vector的析构函数很简单，就是先销毁所有已存在的元素，然后释放所有内存<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _Tidy()</span><br><span class="line">&#123;   <span class="comment">// free all storage</span></span><br><span class="line">    <span class="keyword">if</span> (_Myfirst != <span class="number">0</span>)</span><br><span class="line">    &#123;   <span class="comment">// something to free, destroy and deallocate it</span></span><br><span class="line">        _Destroy(_Myfirst, _Mylast);</span><br><span class="line">        <span class="keyword">this</span>-&gt;_Alval.deallocate(_Myfirst, _Myend - _Myfirst);</span><br><span class="line">    &#125;</span><br><span class="line">    _Myfirst = <span class="number">0</span>, _Mylast = <span class="number">0</span>, _Myend = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="插入和删除元素"><a href="#插入和删除元素" class="headerlink" title="插入和删除元素"></a>插入和删除元素</h2><p>vector的插入和删除元素是通过<code>push_back ()</code>、<code>pop_back()</code>两个接口来实现的，他们的内部实现也非常简单<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> _Ty&amp; _Val)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// insert element at end</span></span><br><span class="line">    <span class="keyword">if</span> (size() &lt; capacity())</span><br><span class="line">        _Mylast = _Ufill(_Mylast, <span class="number">1</span>, _Val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        insert(end(), _Val);    <span class="comment">//空间不足时，就会触发内存的二次分配</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// erase element at end</span></span><br><span class="line">    <span class="keyword">if</span> (!empty())</span><br><span class="line">    &#123;   <span class="comment">// erase last element</span></span><br><span class="line">        _Destroy(_Mylast - <span class="number">1</span>, _Mylast);</span><br><span class="line">        --_Mylast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="其他接口"><a href="#其他接口" class="headerlink" title="其他接口"></a>其他接口</h2><p><code>reserve()</code>操作。之前提到过reserve（Count） 函数主要是预留Count大小的空间，对应的是容器的容量，目的是保证<code>(_Myend - _Myfirst)&gt;=Count</code>。只有当空间不足时，才会操作，即重新分配一块内存，将原有元素拷贝到新内存，并销毁原有内存<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve</span><span class="params">(size_type _Count)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// determine new minimum length of allocated storage</span></span><br><span class="line">    <span class="keyword">if</span> (capacity() &lt; _Count)</span><br><span class="line">    &#123;   <span class="comment">// not enough room, reallocate</span></span><br><span class="line">        pointer _Ptr = <span class="keyword">this</span>-&gt;_Alval.allocate(_Count);</span><br><span class="line">        _Umove(begin(), end(), _Ptr);</span><br><span class="line">        size_type _Size = size();</span><br><span class="line">        <span class="keyword">if</span> (_Myfirst != <span class="number">0</span>)</span><br><span class="line">        &#123;   <span class="comment">// destroy and deallocate old array</span></span><br><span class="line">            _Destroy(_Myfirst, _Mylast);</span><br><span class="line">            <span class="keyword">this</span>-&gt;_Alval.deallocate(_Myfirst, _Myend - _Myfirst);</span><br><span class="line">        &#125;</span><br><span class="line">        _Myend = _Ptr + _Count;</span><br><span class="line">        _Mylast = _Ptr + _Size;</span><br><span class="line">        _Myfirst = _Ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>resize()</code>操作。resize（Count） 函数主要是用于改变size的，也就是改变vector的大小，最终改变的是（_Mylast - _Myfirst）的值，当size &lt; Count时,就插入元素，当size &gt;Count时，就擦除元素。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type _Newsize, _Ty _Val)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// determine new length, padding with _Val elements as needed</span></span><br><span class="line">    <span class="keyword">if</span> (size() &lt; _Newsize)</span><br><span class="line">        _Insert_n(end(), _Newsize - size(), _Val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (_Newsize &lt; size())</span><br><span class="line">        erase(begin() + _Newsize, end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>_Insert_n()</code>操作。<code>resize()</code>操作和<code>insert()</code>操作都会利用到<code>_Insert_n()</code>这个函数，这个函数非常重要，也比其他函数稍微复杂一点。虽然<code>_Insert_n(_where, _Count, _Val )</code>函数比较长，但是操作都非常简单，主要可以分为以下几种情况：</p>
<ol>
<li>_Count == 0，不需要插入，直接返回</li>
<li>max_size() - size() &lt; _Count，超过系统设置的最大容量，会溢出，造成Xlen（）异常</li>
<li>_Capacity &lt; size() + _Count，vector的容量不足以插入Count个元素，需要进行二次分配，扩大vector的容量。 在VS下，vector容量会扩大50%，即 _Capacity = _Capacity + _Capacity / 2;<br>若仍不足，则 _Capacity = size() + _Count;</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_Capacity &lt; size() + _Count)</span><br><span class="line">    &#123;   <span class="comment">// not enough room, reallocate</span></span><br><span class="line">    _Capacity = max_size() - _Capacity / <span class="number">2</span> &lt; _Capacity</span><br><span class="line">        ? <span class="number">0</span> : _Capacity + _Capacity / <span class="number">2</span>;    <span class="comment">// try to grow by 50%</span></span><br><span class="line">    <span class="keyword">if</span> (_Capacity &lt; size() + _Count)</span><br><span class="line">        _Capacity = size() + _Count;</span><br><span class="line">    pointer _Newvec = <span class="keyword">this</span>-&gt;_Alval.allocate(_Capacity);</span><br><span class="line">    pointer _Ptr = _Newvec;</span><br><span class="line">    _Ptr = _Umove(_Myfirst, _VEC_ITER_BASE(_Where),_Newvec);    <span class="comment">// copy prefix</span></span><br><span class="line">    _Ptr = _Ufill(_Ptr, _Count, _Val);  <span class="comment">// add new stuff</span></span><br><span class="line">    _Umove(_VEC_ITER_BASE(_Where), _Mylast, _Ptr);  <span class="comment">// copy suffix</span></span><br><span class="line">    <span class="comment">//内存释放与变量更新</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这种情况下，数据从原始容器移动到新分配内存时是从前到后移动的<br><img src="/img/20160223201833669.jpg" alt></p>
<ol>
<li>空间足够，且被插入元素的位置比较靠近_Mylast,即已有元素的尾部</li>
</ol>
<p>这种情况下不需要再次进行内存分配，且数据是从后往前操作的。首先是将where~last向后移动，为待插入数据预留Count大小的空间，然后从_Mylast处开始填充，然后将从where处开始填充剩余元素<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((size_type)(_Mylast - _VEC_ITER_BASE(_Where)) &lt; _Count)</span><br><span class="line">&#123;   <span class="comment">// new stuff spills off end</span></span><br><span class="line">    _Umove(_VEC_ITER_BASE(_Where), _Mylast, _VEC_ITER_BASE(_Where) + _Count);   <span class="comment">// copy suffix</span></span><br><span class="line">    _Ufill(_Mylast, _Count - (_Mylast - _VEC_ITER_BASE(_Where)), _Val);  <span class="comment">// insert new stuff off end</span></span><br><span class="line">    _Mylast += _Count;</span><br><span class="line">    <span class="built_in">std</span>::fill(_VEC_ITER_BASE(_Where), _Mylast - _Count, _Val);  <span class="comment">// insert up to old end</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>空间足够，但插入的位置比较靠前<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;   <span class="comment">// new stuff can all be assigned</span></span><br><span class="line">_Ty _Tmp = _Val;    <span class="comment">// in case _Val is in sequence</span></span><br><span class="line"></span><br><span class="line">pointer _Oldend = _Mylast;</span><br><span class="line">_Mylast = _Umove(_Oldend - _Count, _Oldend, _Mylast);   <span class="comment">// copy suffix</span></span><br><span class="line">_STDEXT _Unchecked_move_backward(_VEC_ITER_BASE(_Where), _Oldend - _Count, _Oldend);   <span class="comment">// copy hole</span></span><br><span class="line"><span class="built_in">std</span>::fill(_VEC_ITER_BASE(_Where), _VEC_ITER_BASE(_Where) + _Count, _Tmp);  <span class="comment">// insert into hole</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>erase()</code>操作<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator _First_arg,</span></span></span><br><span class="line"><span class="function"><span class="params">    const_iterator _Last_arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// erase [_First, _Last)</span></span><br><span class="line">    iterator _First = _Make_iter(_First_arg);</span><br><span class="line">    iterator _Last = _Make_iter(_Last_arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_First != _Last)</span><br><span class="line">        &#123;   <span class="comment">// worth doing, copy down over hole</span></span><br><span class="line">        pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,</span><br><span class="line">            _VEC_ITER_BASE(_First));</span><br><span class="line"></span><br><span class="line">        _Destroy(_Ptr, _Mylast);</span><br><span class="line">        _Mylast = _Ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> (_First);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主要操作就是将后半部分的有效元素向前拷贝，并将后面空间的无效元素析构，并更新_Mylast变量<br><img src="/img/20160223203457456.jpg" alt></p>
<p><code>assign()</code>操作最终都会调用到下面的函数，主要操作是首先擦除容器中已有的全部元素，在从头开始插入Count个Val元素<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _Assign_n(size_type _Count, <span class="keyword">const</span> _Ty&amp; _Val)</span><br><span class="line">    &#123;   <span class="comment">// assign _Count * _Val</span></span><br><span class="line">    _Ty _Tmp = _Val;    <span class="comment">// in case _Val is in sequence</span></span><br><span class="line">    erase(begin(), end());</span><br><span class="line">    insert(begin(), _Count, _Tmp);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>在经过上述对vector内部实现的分析后，再来理解相应接口就变得简单得多。vector对外接口主要可以分为：</p>
<p>构造、析构：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Elem&gt; c</span><br><span class="line"><span class="built_in">vector</span> &lt;Elem&gt; c1(c2)</span><br><span class="line"><span class="built_in">vector</span> &lt;Elem&gt; c(n)</span><br><span class="line"><span class="built_in">vector</span> &lt;Elem&gt; c(n, elem)</span><br><span class="line"><span class="built_in">vector</span> &lt;Elem&gt; c(beg,end)</span><br><span class="line">c.~ <span class="built_in">vector</span> &lt;Elem&gt;()</span><br></pre></td></tr></table></figure></p>
<p>插入、删除、赋值<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c.push_back(elem)</span><br><span class="line">c.pop_back()</span><br><span class="line">c.insert(pos,elem)</span><br><span class="line">c.insert(pos,n,elem)</span><br><span class="line">c.insert(pos,beg,end)</span><br><span class="line">c.erase(pos)</span><br><span class="line">c.erase(beg,end)</span><br><span class="line">c.clear()</span><br><span class="line">c.assign(beg,end)</span><br><span class="line">c.assign(n,elem)</span><br></pre></td></tr></table></figure></p>
<p>大小相关<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c.capacity()</span><br><span class="line">c.max_size()</span><br><span class="line">c.resize(num)</span><br><span class="line">c.reserve()</span><br><span class="line">c.size()</span><br></pre></td></tr></table></figure></p>
<p>获取迭代器<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.begin()</span><br><span class="line">c.end()</span><br><span class="line">c.rbegin()</span><br><span class="line">c.rend()</span><br></pre></td></tr></table></figure></p>
<p>获取数据<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span>[]</span><br><span class="line">c.at(idx)</span><br><span class="line">c.front()</span><br><span class="line">c.back()</span><br></pre></td></tr></table></figure></p>
<h1 id="size-t"><a href="#size-t" class="headerlink" title="size_t"></a>size_t</h1><p>在标准C库中的许多函数使用的参数或者返回值都是表示的用字节表示的对象大小，比如说<code>malloc(n)</code>函数的参数n指明了需要申请的空间大小，还有<code>memcpy(s1, s2, n)</code>的最后一个参数，表明需要复制的内存大小，<code>strlen(s)</code>函数的返回值表明了以’\0’结尾的字符串的长度（不包括’\0’），其返回值并不是该字符串的实际长度，因为要去掉’\0’。</p>
<p>或许你会认为这些参数或者返回值应该被申明为int类型（或者long或者unsigned），但是事实上并不是。C标准中将他们定义为size_t。标准中记载malloc的申明应该出现在，定义为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>memcpy和strlen的申明应该出现在中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *s1, <span class="keyword">void</span> <span class="keyword">const</span> *s2, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">char</span> <span class="keyword">const</span> *s);</span><br></pre></td></tr></table></figure></p>
<p>size_t还经常出现在C++标准库中，此外，C++库中经常会使用一个相似的类型size_type，用的可能比size_t还要多。</p>
<h2 id="可移植性问题"><a href="#可移植性问题" class="headerlink" title="可移植性问题"></a>可移植性问题</h2><p>回忆memcpy(s1, s2, n)函数，它将s2指向地址开始的n个字节拷贝到s2指向的地址，返回s1，这个函数可以拷贝任何数据类型，所以参数和返回值的类型应该为可以指向任何类型的void<em>，同时，&gt;源地址不应该被改变，所以第二个参数s2类型应该为`const void</em>`，这些都不是问题。真正的问题在于我们如何申明第三个参数，它代表了源对象的大小，我相信大部分程序员都会选择int：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *s1, <span class="keyword">void</span> <span class="keyword">const</span> *s2, <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>使用int类型在大部分情况下都是可以的，但是我们可以使用unsigned int代替它让第三个参数表示的范围更大。在大部分机器上，unsigned int的最大值要比int的最大值大两倍。使用unsigned int修饰第三个参数的代价与int是相同的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *s1, <span class="keyword">void</span> <span class="keyword">const</span> *s2, <span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这样似乎没有问题了，unsigned int可以表示最大类型的对象大小了，这种情况只有在整形和指针类型具有相同大小的情况下，比如说在IP16中，整形和指针都占2个字节（16位），而在IP32上面，整形和指针都占4个字节（32位）。</p>
<h2 id="使用size-t"><a href="#使用size-t" class="headerlink" title="使用size_t"></a>使用size_t</h2><p>size_t是一种数据相关的无符号类型，它被设计得足够大以便能够内存中任意对象的大小。在C++中，设计 size_t 就是为了适应多个平台的。ize_t的引入增强了程序在不同平台上的可移植性。</p>
<p>size_t的定义在<code>&lt;stddef.h&gt;</code>,<code>&lt;stdio.h&gt;</code>,<code>&lt;stdlib.h&gt;</code>,<code>&lt;string.h&gt;</code>, <code>&lt;time.h&gt;</code>和<code>&lt;wchar.h&gt;</code>这些标准C头文件中，也出现在相应的C++头文件, 等等中，你应该在你的头文件中至少包含一个这样的头文件在使用size_t之前。包含以上任何C头文件（由C或C++编译的程序）表明将size_t作为全局关键字。根据定义，size_t是sizeof关键字（注：sizeof是关键字，并非运算符）运算结果的类型。所以，应当通过适当的方式声明n来完成赋值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="keyword">sizeof</span>(thing);</span><br></pre></td></tr></table></figure></p>
<p>考虑到可移植性和程序效率，n应该被申明为size_t类型。类似的，下面的foo函数的参数也应当被申明为sizeof：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="keyword">sizeof</span>(thing));</span><br></pre></td></tr></table></figure></p>
<p>参数中带有size_t的函数通常会含有局部变量用来对数组的大小或者索引进行计算，在这种情况下，size_t是个不错的选择。</p>
<p>size_t的大小并非像很多网上描述的那样，其大小是由系统的位数决定的。size_t的大小是由你生成的程序类型决定的，只是生成的程序类型与系统的类型有一定关系。32bits的程序既可以在64bits的系统上运行，也可以在32bits的系统上运行。但是64bits的程序只能在64bits的系统上运行。然而我们编译的程序一般是32bits的，因此size_t的大小也就变成了4个字节。</p>
<h1 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h1><p>struct/class/union内存对齐原则有四个：</p>
<ol>
<li>数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员&gt;有子成员，比如说是数组，结构体等）的整数倍开始(比如int在32位机为４字节，则要从4的整数倍地址开始存储),基本类型不包括struct/class/uinon。</li>
<li>结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部”最宽基本类型成员”的整数倍地址开始存储.(struct a里存有struct b，b里有char,int ,double等元素，那b应该从8的整数倍开始存储.)。</li>
<li>收尾工作:结构体的总大小,也就是sizeof的结果，必须是其内部最大成员的”最宽基本类型成员”的整数倍.不足的要补齐.(基本类型不包括struct/class/uinon)。</li>
<li>sizeof(union)，以结构里面size最大元素为union的size，因为在某一时刻，union只有一个成员真正存储于该地址。</li>
</ol>
<p>实例解释：下面以class为代表<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">No. <span class="number">1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(Data) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">No. <span class="number">2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">double</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(Data) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>显然程序No.1 输出的结果为 8， No.2 输出的结果为 16。No.1最大的数据成员是4bytes，1+4=5，补齐为4的倍数，也就是8。而No.2为8bytes，1+8=9，补齐为8的倍数，也就是16。</p>
<p>内存对齐的主要作用是：</p>
<ol>
<li>平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</li>
<li>性能原因：经过内存对齐后，CPU的内存访问速度大大提升。具体原因稍后解释。</li>
</ol>
<h1 id="strlen和sizeof区别？"><a href="#strlen和sizeof区别？" class="headerlink" title="strlen和sizeof区别？"></a>strlen和sizeof区别？</h1><p>sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。</p>
<p>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是’\0’的字符串。</p>
<p>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;   </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"name"</span>;</span><br><span class="line">    <span class="keyword">sizeof</span>(str); <span class="comment">// 取的是指针str的长度，是8</span></span><br><span class="line">    <span class="built_in">strlen</span>(str); <span class="comment">// 取的是这个字符串的长度，不包含结尾的 \0。大小是4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数组在内存中是连续存放的，开辟一块连续的内存空间；数组所占存储空间：sizeof（数组名）；数组大小：sizeof(数组名)/sizeof(数组元素数据类型)；用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。</p>
<h1 id="OFFSETOF"><a href="#OFFSETOF" class="headerlink" title="OFFSETOF"></a>OFFSETOF</h1><p>OFFSETOF(s, m)的宏定义，s是结构类型，m是s的成员，求m在s中的偏移量。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSETOF（s, m） size_t（&amp;((s*)0)-&gt;m）</span></span><br></pre></td></tr></table></figure></p>
<h1 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h1><p>sizeof一个类求大小（注意成员变量，函数，虚函数，继承等等对大小的影响）以下运行环境都是一般的，在32位编译环境中。</p>
<p>基本数据类型的sizeof<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">char</span>)&lt;&lt;<span class="built_in">endl</span>;                     结果是<span class="number">1</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="built_in">endl</span>;                        结果是<span class="number">4</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>)&lt;&lt;<span class="built_in">endl</span>; 结果是<span class="number">4</span> </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">int</span>)&lt;&lt;<span class="built_in">endl</span>;                结果是<span class="number">4</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">short</span> <span class="keyword">int</span>)&lt;&lt;<span class="built_in">endl</span>;               结果是<span class="number">2</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">float</span>)&lt;&lt;<span class="built_in">endl</span>;                     结果是<span class="number">4</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">double</span>)&lt;&lt;<span class="built_in">endl</span>;                 结果是<span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p>指针变量的sizeof<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *pc =<span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">sizeof</span>( pc ); <span class="comment">// 结果为4</span></span><br><span class="line"><span class="keyword">sizeof</span>(*pc);     <span class="comment">// 结果为1</span></span><br><span class="line"><span class="keyword">int</span> *pi;</span><br><span class="line"><span class="keyword">sizeof</span>( pi ); <span class="comment">//结果为4</span></span><br><span class="line"><span class="keyword">sizeof</span>(*pi);     <span class="comment">//结果为4</span></span><br><span class="line"><span class="keyword">char</span> **ppc = &amp;pc;  </span><br><span class="line"><span class="keyword">sizeof</span>( ppc ); <span class="comment">// 结果为4   </span></span><br><span class="line"><span class="keyword">sizeof</span>( *ppc ); <span class="comment">// 结果为4     </span></span><br><span class="line"><span class="keyword">sizeof</span>( **ppc ); <span class="comment">// 结果为1</span></span><br><span class="line"><span class="keyword">void</span> (*pf)();<span class="comment">// 函数指针</span></span><br><span class="line"><span class="keyword">sizeof</span>( pf );<span class="comment">// 结果为4</span></span><br></pre></td></tr></table></figure></p>
<p>数组的sizeof数组的sizeof值等于数组所占用的内存字节数，如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">int</span> a2[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">sizeof</span>( a1 ); <span class="comment">// 结果为4，字符 末尾还存在一个NULL终止符</span></span><br><span class="line"><span class="keyword">sizeof</span>( a2 ); <span class="comment">// 结果为3*4=12（依赖于int）</span></span><br></pre></td></tr></table></figure></p>
<p>写到这里，提一问，下面的c3，c4值应该是多少呢<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">(<span class="keyword">char</span> a3[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c3 = <span class="keyword">sizeof</span>( a3 ); <span class="comment">// c3 == 4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo4</span><span class="params">(<span class="keyword">char</span> a4[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c4 = <span class="keyword">sizeof</span>( a4 ); <span class="comment">// c4 == 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也许当你试图回答c4的值时已经意识到c3答错了，是的，c3!=3。这里函数参数a3已不再是数组类型，而是蜕变成指针，相当于<code>char* a3</code>，为什么仔细想想就不难明白，我们调用函数foo1时，程序会在栈上分配一个大小为3的数组吗不会！数组是“传址”的，调用者只需将实参的地址传递过去，所以a3自然为指针类型<code>char*</code>，c3的值也就为4。</p>
<p>结构体的sizeof<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">double</span> dda1;</span><br><span class="line">	<span class="keyword">char</span> dda;</span><br><span class="line">	<span class="keyword">int</span> type</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>结果为16，为上面的结构分配空间的时候，VC根据成员变量出现的顺序和对齐方式，先为第一个成员dda1分配空间，其起始地址跟结构的起始地址相同（刚好偏移量0刚好为sizeof(double)的倍数），该成员变量占用<code>sizeof(double)=8</code>个字节；接下来为第二个成员dda分配空间，这时下一个可以分配的地址对于结构的起始地址的偏移量为8，是<code>sizeof(char)</code>的倍数，所以把dda存放在偏移量为8的地方满足对齐方式，该成员变量占用<code>sizeof(char)=1</code>个字节；接下来为第三个成员type分配空间，这时下一个可以分配的地址对于结构的起始地址的偏移量为9，不是<code>sizeof(int)=4</code>的倍数，为了满足对齐方式对偏移量的约束问题，VC自动填充3个字节（这三个字节没有放什么东西），这时下一个可以分配的地址对于结构的起始地址的偏移量为12，刚好是<code>sizeof(int)=4</code>的倍数，所以把type存放在偏移量为12的地方，该成员变量占用<code>sizeof(int)=4</code>个字节；这时整个结构的成员变量已经都分配了空间，总的占用的空间大小为：8+1+3+4=16，刚好为结构的字节边界数（即结构中占用最大空间的类型所占用的字节数<code>sizeof(double)=8</code>）的倍数，所以没有空缺的字节需要填充。</p>
<p>含位域结构体的sizeof<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BF1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> f1 : <span class="number">3</span>;</span><br><span class="line"><span class="keyword">char</span> f2 : <span class="number">4</span>;</span><br><span class="line"><span class="keyword">char</span> f3 : <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>位域类型为char，第1个字节仅能容纳下f1和f2，所以f2被压缩到第1个字节中，而f3只能从下一个字节开始。因此<code>sizeof(BF1)</code>的结果为2。</p>
<p>含有联合体的结构体的sizeof<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *ptr,ch;</span><br><span class="line">	<span class="keyword">union</span> A  </span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">short</span> a,b;</span><br><span class="line">	    <span class="keyword">unsigned</span> <span class="keyword">int</span> c:<span class="number">2</span>, d:<span class="number">1</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">s1</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样是8＋4＝12个字节<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *ptr,ch;                          </span><br><span class="line">	<span class="keyword">union</span>                      <span class="comment">//联合体是结构体的成员，占内存，并且最大类型是unsigned int，占4</span></span><br><span class="line">	&#123;</span><br><span class="line">	     <span class="keyword">short</span> a,b;</span><br><span class="line">	     <span class="keyword">unsigned</span> <span class="keyword">int</span> c:<span class="number">2</span>, d:<span class="number">1</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">s1</span>* <span class="title">next</span>;</span>                        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样是8＋4＋4＝16个字节</p>
<p>结构体含有结构体的sizeof<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">     <span class="keyword">char</span> c;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">     <span class="keyword">char</span> c1;</span><br><span class="line">     S1 s;</span><br><span class="line">     <span class="keyword">char</span> c2;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(S3);      <span class="comment">//S3=16</span></span><br></pre></td></tr></table></figure></p>
<p>S1的最宽简单成员的类型为int，S3在考虑最宽简单类型成员时是将S1“打散”看的，所以S3的最宽简单类型为int，这样，通过S3定义的变量，其存储空间首地址需要被4整除，整个sizeof(S3)的值也应该被4整除。</p>
<p>c1的偏移量为0，s的偏移量呢这时s是一个整体，它作为结构体变量也满足前面三个准则，所以其大小为8，偏移量为4，c1与s之间便需要3个填充字节，而c2与s之间就不需要了，所以c2的偏移量为12，算上c2的大小为13，13是不能被4整除的，这样末尾还得补上3个填充字节。最后得到sizeof(S3)的值为16。</p>
<p>带有#pragma pack的sizeof：它是用来调整结构体对齐方式的，不同编译器名称和用法略有不同，VC6中通过#pragma pack实现，也可以直接修改/Zp编译开关。<code>#pragma pack</code>的基本用法为：<code>#pragma pack(n)</code>，n为字节对齐数，其取值为1、2、4、8、16，默认是8，如果这个值比结构体成员的sizeof值小，那么该成员的偏移量应该以此值为准，即是说，结构体成员的偏移量应该取二者的最小值，</p>
<p>再看示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push) <span class="comment">// 将当前pack设置压栈保存</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(2)<span class="comment">// 必须在结构体定义之前使用</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> c1;</span><br><span class="line">	S1 s;</span><br><span class="line">	<span class="keyword">char</span> c2</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop) <span class="comment">// 恢复先前的pack设置</span></span></span><br></pre></td></tr></table></figure></p>
<p>计算sizeof(S1)时，min(2, sizeof(i))的值为2，所以i的偏移量为2，加上sizeof(i)等于6，能够被2整除，所以整个S1的大小为6。</p>
<p>同样，对于sizeof(S3)，s的偏移量为2，c2的偏移量为8，加上sizeof(c2)等于9，不能被2整除，添加一个填充字节，所以sizeof(S3)等于10。</p>
<p>空结构体的sizeof<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S5</span> &#123;</span> &#125;;</span><br><span class="line"><span class="keyword">sizeof</span>( S5 ); <span class="comment">// 结果为1</span></span><br></pre></td></tr></table></figure></p>
<p>类的sizeof<br>类的sizeof值等于类中成员变量所占用的内存字节数。如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="keyword">float</span> c;</span><br><span class="line">	<span class="keyword">char</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A object;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(object) is "</span> &lt;&lt; <span class="keyword">sizeof</span>(object) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果为12（我的机器上sizeof(float)值为4，字节对其前面已经讲过）。</p>
<p>不过需要注意的是，如果类中存在静态成员变量，结果又会是什么样子呢？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="keyword">float</span> c;</span><br><span class="line">	<span class="keyword">char</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A object;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(object) is "</span> &lt;&lt; <span class="keyword">sizeof</span>(object) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>16？不对。结果仍然是12.</p>
<p>因为在程序编译期间，就已经为static变量在静态存储区域分配了内存空间，并且这块内存在程序的整个运行期间都存在。而每次声明了类A的一个对象的时候，为该对象在堆上，根据对象的大小分配内存。</p>
<p>如果类A中包含成员函数，那么又会是怎样的情况呢？看下面的例子<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="keyword">float</span> c;</span><br><span class="line">	<span class="keyword">char</span> d;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x+y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A object;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(object) is "</span> &lt;&lt; <span class="keyword">sizeof</span>(object) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	b = object.add(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(object) is "</span> &lt;&lt; <span class="keyword">sizeof</span>(object) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果仍为12。 </p>
<p>因为只有非静态类成员变量在新生成一个object的时候才需要自己的副本。所以每个非静态成员变量在生成新object需要内存，而function是不需要的。</p>
<h1 id="标准C-中的string类"><a href="#标准C-中的string类" class="headerlink" title="标准C++中的string类"></a>标准C++中的string类</h1><p>相信使用过MFC编程的朋友对CString这个类的印象应该非常深刻吧？的确，MFC中的CString类使用起来真的非常的方便好用。但是如果离开了MFC框架，还有没有这样使用起来非常方便的类呢？答案是肯定的。也许有人会说，即使不用MFC框架，也可以想办法使用MFC中的API，具体的操作方法在本文最后给出操作方法。其实，可能很多人很可能会忽略掉标准C++中string类的使用。标准C++中提供的string类得功能也是非常强大的，一般都能满足我们开发项目时使用。现将具体用法的一部分罗列如下，只起一个抛砖引玉的作用吧，好了，废话少说，直接进入正题吧！</p>
<p>要想使用标准C++中string类，必须要包含<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;// 注意是&lt;string&gt;，不是&lt;string.h&gt;，带.h的是C语言中的头文件</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span>  <span class="built_in">std</span>::wstring;</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure></p>
<p>下面你就可以使用string/wstring了，它们两分别对应着char和wchar_t。</p>
<p>string和wstring的用法是一样的，以下只用string作介绍：</p>
<h2 id="string类的构造函数："><a href="#string类的构造函数：" class="headerlink" title="string类的构造函数："></a>string类的构造函数：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>(<span class="keyword">const</span> <span class="keyword">char</span> *s);    <span class="comment">//用c字符串s初始化</span></span><br><span class="line"><span class="built_in">string</span>(<span class="keyword">int</span> n,<span class="keyword">char</span> c);     <span class="comment">//用n个字符c初始化</span></span><br></pre></td></tr></table></figure>
<p>此外，string类还支持默认构造函数和复制构造函数，如string s1；string s2=”hello”；都是正确的写法。当构造的string太长而无法表达时会抛出length_error异常 ；</p>
<h2 id="string类的字符操作："><a href="#string类的字符操作：" class="headerlink" title="string类的字符操作："></a>string类的字符操作：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> n)<span class="keyword">const</span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> &amp;<span class="title">at</span><span class="params">(<span class="keyword">int</span> n)</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> n);</span><br><span class="line"><span class="function"><span class="keyword">char</span> &amp;<span class="title">at</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>operator[]</code>和<code>at()</code>均返回当前字符串中第n个字符的位置，但at函数提供范围检查，当越界时会抛出out_of_range异常，下标运算符[]不提供检查访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">data</span><span class="params">()</span><span class="keyword">const</span></span>;<span class="comment">//返回一个非null终止的c字符数组</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">c_str</span><span class="params">()</span><span class="keyword">const</span></span>;<span class="comment">//返回一个以null终止的c字符串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> n, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;<span class="comment">//把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目</span></span><br></pre></td></tr></table></figure>
<h2 id="string的特性描述"><a href="#string的特性描述" class="headerlink" title="string的特性描述:"></a>string的特性描述:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回当前容量（即string中不必增加内存即可存放的元素个数）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_size</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回string对象中可存放的最大字符串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span><span class="keyword">const</span></span>;        <span class="comment">//返回当前字符串的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span><span class="keyword">const</span></span>;       <span class="comment">//返回当前字符串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span></span>;        <span class="comment">//当前字符串是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> len,<span class="keyword">char</span> c)</span></span>;<span class="comment">//把字符串当前大小置为len，并用字符c填充不足的部分</span></span><br></pre></td></tr></table></figure>
<h2 id="string类的输入输出操作"><a href="#string类的输入输出操作" class="headerlink" title="string类的输入输出操作"></a>string类的输入输出操作</h2><p>string类重载运算符operator&gt;&gt;用于输入，同样重载运算符operator&lt;&lt;用于输出操作。</p>
<p>函数<code>getline(istream &amp;in,string &amp;s);</code>用于从输入流in中读取字符串到s中，以换行符’\n’分开。</p>
<h2 id="string的赋值"><a href="#string的赋值" class="headerlink" title="string的赋值"></a>string的赋值</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s);<span class="comment">//把字符串s赋给当前字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">assign</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;<span class="comment">//用c类型字符串s赋值</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">assign</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s,<span class="keyword">int</span> n)</span></span>;<span class="comment">//用c字符串s开始的n个字符赋值</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">assign</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>;<span class="comment">//把字符串s赋给当前字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">assign</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> c)</span></span>;<span class="comment">//用n个字符c赋值给当前字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">assign</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s,<span class="keyword">int</span> start,<span class="keyword">int</span> n)</span></span>;<span class="comment">//把字符串s中从start开始的n个字符赋给当前字符串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">assign</span><span class="params">(const_iterator first,const_itertor last)</span></span>;<span class="comment">//把first和last迭代器之间的部分赋给字符串</span></span><br></pre></td></tr></table></figure>
<h2 id="string的连接："><a href="#string的连接：" class="headerlink" title="string的连接："></a>string的连接：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> &amp;<span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s);<span class="comment">//把字符串s连接到当前字符串的结尾 </span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;            <span class="comment">//把c类型字符串s连接到当前字符串结尾</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s,<span class="keyword">int</span> n)</span></span>;<span class="comment">//把c类型字符串s的前n个字符连接到当前字符串结尾</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>;    <span class="comment">//同operator+=()</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">append</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s,<span class="keyword">int</span> pos,<span class="keyword">int</span> n)</span></span>;<span class="comment">//把字符串s中从pos开始的n个字符连接到当前字符串的结尾</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">append</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> c)</span></span>;        <span class="comment">//在当前字符串结尾添加n个字符c</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">append</span><span class="params">(const_iterator first,const_iterator last)</span></span>;<span class="comment">//把迭代器first和last之间的部分连接到当前字符串的结尾</span></span><br></pre></td></tr></table></figure>
<h2 id="string的比较："><a href="#string的比较：" class="headerlink" title="string的比较："></a>string的比较：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)<span class="keyword">const</span>;<span class="comment">//比较两个字符串是否相等</span></span><br></pre></td></tr></table></figure>
<p>运算符”&gt;”,”&lt;”,”&gt;=”,”&lt;=”,”!=”均被重载用于字符串的比较；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> <span class="keyword">const</span></span>;<span class="comment">//比较当前字符串和s的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span><span class="keyword">const</span></span>;<span class="comment">//比较当前字符串从pos开始的n个字符组成的字符串与s的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s,<span class="keyword">int</span> pos2,<span class="keyword">int</span> n2)</span><span class="keyword">const</span></span>;<span class="comment">//比较当前字符串从pos开始的n个字符组成的字符串与s中pos2开始的n2个字符组成的字符串的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n,<span class="keyword">const</span> <span class="keyword">char</span> *s)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> n,<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> pos2)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>compare函数在&gt;时返回1，&lt;时返回-1，==时返回0  </p>
<h2 id="string的子串"><a href="#string的子串" class="headerlink" title="string的子串"></a>string的子串</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">substr</span><span class="params">(<span class="keyword">int</span> pos = <span class="number">0</span>,<span class="keyword">int</span> n = npos)</span> <span class="keyword">const</span></span>;<span class="comment">//返回pos开始的n个字符组成的字符串</span></span><br></pre></td></tr></table></figure>
<h2 id="string的交换"><a href="#string的交换" class="headerlink" title="string的交换"></a>string的交换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">string</span> &amp;s2)</span></span>;    <span class="comment">//交换当前字符串与s2的值</span></span><br></pre></td></tr></table></figure>
<h2 id="string类的查找函数"><a href="#string类的查找函数" class="headerlink" title="string类的查找函数"></a>string类的查找函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;<span class="comment">//从pos开始查找字符c在当前字符串的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;<span class="comment">//从pos开始查找字符串s在当前串中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span> <span class="keyword">const</span></span>;<span class="comment">//从pos开始查找字符串s中前n个字符在当前串中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;<span class="comment">//从pos开始查找字符串s在当前串中的位置</span></span><br><span class="line"><span class="comment">//查找成功时返回所在位置，失败返回string::npos的值 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfind</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> pos = npos)</span> <span class="keyword">const</span></span>;<span class="comment">//从pos开始从后向前查找字符c在当前串中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> pos = npos)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n = npos)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfind</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s,<span class="keyword">int</span> pos = npos)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">//从pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置，成功返回所在位置，失败时返回string::npos的值 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_first_of</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;<span class="comment">//从pos开始查找字符c第一次出现的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_first_of</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_first_of</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_first_of</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s,<span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">//从pos开始查找当前串中第一个在s的前n个字符组成的数组里的字符的位置。查找失败返回string::npos </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_first_not_of</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_first_not_of</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_first_not_of</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> pos,<span class="keyword">int</span> n)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_first_not_of</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s,<span class="keyword">int</span> pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">//从当前串中查找第一个不在串s中的字符出现的位置，失败返回string::npos </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last_of</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> pos = npos)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last_of</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> pos = npos)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last_of</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n = npos)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last_of</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s,<span class="keyword">int</span> pos = npos)</span> <span class="keyword">const</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last_not_of</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> pos = npos)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last_not_of</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> pos = npos)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last_not_of</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last_not_of</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s,<span class="keyword">int</span> pos = npos)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">//find_last_of和find_last_not_of与find_first_of和find_first_not_of相似，只不过是从后向前查找</span></span><br></pre></td></tr></table></figure>
<h2 id="string类的替换函数"><a href="#string类的替换函数" class="headerlink" title="string类的替换函数"></a>string类的替换函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">replace</span><span class="params">(<span class="keyword">int</span> p0, <span class="keyword">int</span> n0,<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;<span class="comment">//删除从p0开始的n0个字符，然后在p0处插入串s</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">replace</span><span class="params">(<span class="keyword">int</span> p0, <span class="keyword">int</span> n0,<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>;<span class="comment">//删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">replace</span><span class="params">(<span class="keyword">int</span> p0, <span class="keyword">int</span> n0,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>;<span class="comment">//删除从p0开始的n0个字符，然后在p0处插入串s</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">replace</span><span class="params">(<span class="keyword">int</span> p0, <span class="keyword">int</span> n0,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span></span>;<span class="comment">//删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">replace</span><span class="params">(<span class="keyword">int</span> p0, <span class="keyword">int</span> n0,<span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span>;<span class="comment">//删除p0开始的n0个字符，然后在p0处插入n个字符c</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">replace</span><span class="params">(iterator first0, iterator last0,<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;<span class="comment">//把[first0，last0）之间的部分替换为字符串s</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">replace</span><span class="params">(iterator first0, iterator last0,<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>;<span class="comment">//把[first0，last0）之间的部分替换为s的前n个字符</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">replace</span><span class="params">(iterator first0, iterator last0,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>;<span class="comment">//把[first0，last0）之间的部分替换为串s</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">replace</span><span class="params">(iterator first0, iterator last0,<span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span>;<span class="comment">//把[first0，last0）之间的部分替换为n个字符c</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">replace</span><span class="params">(iterator first0, iterator last0,const_iterator first, const_iterator last)</span></span>;<span class="comment">//把[first0，last0）之间的部分替换成[first，last）之间的字符串</span></span><br></pre></td></tr></table></figure>
<h2 id="string类的插入函数"><a href="#string类的插入函数" class="headerlink" title="string类的插入函数"></a>string类的插入函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">insert</span><span class="params">(<span class="keyword">int</span> p0, <span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">insert</span><span class="params">(<span class="keyword">int</span> p0, <span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">insert</span><span class="params">(<span class="keyword">int</span> p0,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">insert</span><span class="params">(<span class="keyword">int</span> p0,<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="keyword">int</span> pos, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">//前4个函数在p0位置插入字符串s中pos开始的前n个字符</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">insert</span><span class="params">(<span class="keyword">int</span> p0, <span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span>;<span class="comment">//此函数在p0处插入n个字符c</span></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">char</span> c)</span></span>;<span class="comment">//在it处插入字符c，返回插入后迭代器的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator it, const_iterator first, const_iterator last)</span></span>;<span class="comment">//在it处插入[first，last）之间的字符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator it, <span class="keyword">int</span> n, <span class="keyword">char</span> c)</span></span>;<span class="comment">//在it处插入n个字符c</span></span><br></pre></td></tr></table></figure>
<h2 id="string类的删除函数"><a href="#string类的删除函数" class="headerlink" title="string类的删除函数"></a>string类的删除函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>;<span class="comment">//删除[first，last）之间的所有字符，返回删除后迭代器的位置</span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator it)</span></span>;<span class="comment">//删除it指向的字符，返回删除后迭代器的位置</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> &amp;<span class="title">erase</span><span class="params">(<span class="keyword">int</span> pos = <span class="number">0</span>, <span class="keyword">int</span> n = npos)</span></span>;<span class="comment">//删除pos开始的n个字符，返回修改后的字符串</span></span><br></pre></td></tr></table></figure>
<h2 id="string类的迭代器处理："><a href="#string类的迭代器处理：" class="headerlink" title="string类的迭代器处理："></a>string类的迭代器处理：</h2><p>string类提供了向前和向后遍历的迭代器iterator，迭代器提供了访问各个字符的语法，类似于指针操作，迭代器不检查范围。用<code>string::iterator</code>或<code>string::const_iterator</code>声明迭代器变量，const_iterator不允许改变迭代的内容。常用迭代器函数有：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;                <span class="comment">//返回string的起始位置</span></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;                    <span class="comment">//返回string的最后一个字符后面的位置</span></span><br><span class="line"><span class="function">const_iterator <span class="title">rbegin</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">rbegin</span><span class="params">()</span></span>;                <span class="comment">//返回string的最后一个字符的位置</span></span><br><span class="line"><span class="function">const_iterator <span class="title">rend</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">rend</span><span class="params">()</span></span>;                    <span class="comment">//返回string第一个字符位置的前面</span></span><br></pre></td></tr></table></figure></p>
<p>rbegin和rend用于从后向前的迭代访问，通过设置迭代器string::reverse_iterator,string::const_reverse_iterator实现</p>
<h2 id="字符串流处理："><a href="#字符串流处理：" class="headerlink" title="字符串流处理："></a>字符串流处理：</h2><p>通过定义ostringstream和istringstream变量实现，<code>#include &lt;sstream&gt;</code>头文件中。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">input</span><span class="params">(<span class="string">"hello,this is a test"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(input)</span></span>;</span><br><span class="line"><span class="built_in">string</span> s1,s2,s3,s4;</span><br><span class="line">is&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3&gt;&gt;s4;<span class="comment">//s1="hello,this",s2="is",s3="a",s4="test"</span></span><br><span class="line"><span class="built_in">ostringstream</span> os;</span><br><span class="line">os&lt;&lt;s1&lt;&lt;s2&lt;&lt;s3&lt;&lt;s4;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;os.str();</span><br></pre></td></tr></table></figure></p>
<p>以上就是对C++ string类的一个简要介绍。</p>
<h2 id="string特性描述"><a href="#string特性描述" class="headerlink" title="string特性描述"></a>string特性描述</h2><p>可用下列函数来获得string的一些特性：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回当前容量（即string中不必增加内存即可存放的元素个数）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_size</span><span class="params">()</span><span class="keyword">const</span></span>;    <span class="comment">//返回string对象中可存放的最大字符串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span><span class="keyword">const</span></span>;        <span class="comment">//返回当前字符串的大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span><span class="keyword">const</span></span>;       <span class="comment">//返回当前字符串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span></span>;        <span class="comment">//当前字符串是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> len,<span class="keyword">char</span> c)</span></span>;  <span class="comment">//把字符串当前大小置为len，多去少补，多出的字符c填充不足的部分</span></span><br></pre></td></tr></table></figure></p>
<p>测试代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">if</span> (str.empty())</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"str is NULL."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"str is not NULL."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    str = str + <span class="string">"abcdefg"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str is "</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str's size is "</span>&lt;&lt;str.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str's capacity is "</span>&lt;&lt;str.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str's max size is "</span>&lt;&lt;str.max_size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str's length is "</span>&lt;&lt;str.length()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    str.resize(<span class="number">20</span>,<span class="string">'c'</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str is "</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    str.resize(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str is "</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="string的查找"><a href="#string的查找" class="headerlink" title="string的查找"></a>string的查找</h2><p>由于查找是使用最为频繁的功能之一，string提供了非常丰富的查找函数：（注：string::npos）</p>
<p><code>size_type find( const basic_string &amp;str, size_type index );</code>  //返回str在字符串中第一次出现的位置（从index开始查找），如果没找到则返回string::npos</p>
<p><code>size_type find( const char *str, size_type index );</code>  // 同上</p>
<p><code>size_type find( const char *str, size_type index, size_type length );</code>  //返回str在字符串中第一次出现的位置（从index开始查找，长度为length），如果没找到就返回string::npos</p>
<p><code>size_type find( char ch, size_type index );</code>  // 返回字符ch在字符串中第一次出现的位置（从index开始查找），如果没找到就返回string::npos</p>
<p>注意：查找字符串a是否包含子串b,不是用 strA.find(strB) &gt; 0 而是 strA.find(strB) != string:npos 这是为什么呢？（初学者比较容易犯的一个错误）本部分参考自web100与luhao1993</p>
<p>先看下面的代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> idx = str.find(<span class="string">"abc"</span>);</span><br><span class="line"><span class="keyword">if</span> (idx == <span class="built_in">string</span>::npos);</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，idx的类型被定义为int，这是错误的，即使定义为<code>unsigned int</code> 也是错的，它必须定义为 <code>string::size_type</code>。npos 是这样定义的： <code>static const size_type npos = -1</code>; 因为 string::size_type (由字符串配置器 allocator 定义) 描述的是 size，故需为无符号整数型别。因为缺省配置器以型别 size_t 作为 size_type，于是 -1 被转换为无符号整数型别，npos 也就成了该型别的最大无符号值。不过实际数值还是取决于型别 size_type 的实际定义。不幸的是这些最大值都不相同。事实上，(unsigned long)-1 和 (unsigned short)-1 不同(前提是两者型别大小不同)。因此，比较式 idx == string::npos 中，如果 idx 的值为-1，由于 idx 和字符串string::npos 型别不同，比较结果可能得到 false。因此要想判断 find()等查找函数的结果是否为npos，最好的办法是直接比较。</p>
<p>测试代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> loc;</span><br><span class="line">    <span class="built_in">string</span> s=<span class="string">"study hard and make progress everyday! every day!!"</span>;</span><br><span class="line">    loc=s.rfind(<span class="string">"make"</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"the word make is at index"</span>&lt;&lt;loc&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//-1表示没找到</span></span><br><span class="line">    loc=s.rfind(<span class="string">"make"</span>);<span class="comment">//缺省状态下，从最后一个往前找</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"the word make is at index"</span>&lt;&lt;loc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    loc=s.find_first_of(<span class="string">"day"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"the word day(first) is at index "</span>&lt;&lt;loc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    loc=s.find_first_not_of(<span class="string">"study"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"the first word not of study is at index"</span>&lt;&lt;loc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    loc=s.find_last_of(<span class="string">"day"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"the last word of day is at index"</span>&lt;&lt;loc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    loc=s.find(<span class="string">"day"</span>);<span class="comment">//缺陷状态下从第一个往后找</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;loc;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="https://images2018.cnblogs.com/blog/1352320/201803/1352320-20180323101344856-2115596576.png" alt></p>
<h2 id="其他常用函数"><a href="#其他常用函数" class="headerlink" title="其他常用函数"></a>其他常用函数</h2><ul>
<li><code>string &amp;insert(int p,const string &amp;s);  //在p位置插入字符串s</code></li>
<li><code>string &amp;replace(int p, int n,const char *s); //删除从p开始的n个字符，然后在p处插入串s</code></li>
<li><code>string &amp;erase(int p, int n);  //删除p开始的n个字符，返回修改后的字符串</code></li>
<li><code>string substr(int pos = 0,int n = npos) const;  //返回pos开始的n个字符组成的字符串</code></li>
<li><code>void swap(string &amp;s2);    //交换当前字符串与s2的值</code></li>
<li><code>string &amp;append(const char *s);   //把字符串s连接到当前字符串结尾</code></li>
<li><code>void push_back(char c)   //当前字符串尾部加一个字符c</code></li>
<li><code>const char *data()const;   //返回一个非null终止的c字符数组，data():与c_str()类似，用于string转const char*其中它返回的数组是不以空字符终止,</code></li>
<li><code>const char *c_str()const;  //返回一个以null终止的c字符串，即c_str()函数返回一个指向正规C字符串的指针, 内容与本string串相同,用于string转const char*</code></li>
</ul>
<p>测试代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1 = <span class="string">"abc123defg"</span>;</span><br><span class="line">    <span class="built_in">string</span> str2 = <span class="string">"swap!"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1.erase(<span class="number">3</span>,<span class="number">3</span>)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//从索引3开始的3个字符,即删除掉了"123"</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1.insert(<span class="number">0</span>,<span class="string">"123"</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//在头部插入</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1.append(<span class="string">"123"</span>)&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//append()方法可以添加字符串</span></span><br><span class="line">    str1.push_back(<span class="string">'A'</span>);  <span class="comment">//push_back()方法只能添加一个字符</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1.replace(<span class="number">0</span>,<span class="number">3</span>,<span class="string">"hello"</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//即将索引0开始的3个字符替换成"hello"</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1.substr(<span class="number">5</span>,<span class="number">7</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//从索引5开始7个字节</span></span><br><span class="line">    str1.swap(str2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p = str.c_str();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">abc123defg</span><br><span class="line">abcdefg</span><br><span class="line">123abcdefg</span><br><span class="line">123abcdefg123</span><br><span class="line">123abcdefg123A</span><br><span class="line">helloabcdefg123A</span><br><span class="line">abcdefg</span><br><span class="line">swap!</span><br><span class="line">swap!</span><br></pre></td></tr></table></figure></p>
<h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><h2 id="this指针的用处"><a href="#this指针的用处" class="headerlink" title="this指针的用处"></a>this指针的用处</h2><p>一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。  例如，调用<code>date.SetMonth(9) &lt;==&gt; SetMonth(&amp;date, 9)</code>，this帮助完成了这一转换。</p>
<h2 id="this指针的使用"><a href="#this指针的使用" class="headerlink" title="this指针的使用"></a>this指针的使用</h2><p>一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用<code>return *this</code>；另外一种情况是当参数与成员变量名相同时，如<code>this-&gt;n = n</code> （不能写成n = n）。</p>
<h2 id="this指针程序示例"><a href="#this指针程序示例" class="headerlink" title="this指针程序示例"></a>this指针程序示例</h2><p>this指针存在于类的成员函数中,指向被调用函数所在的类实例的地址。根据以下程序来说明this指针<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> 　　</span></span><br><span class="line"><span class="class">&#123;</span> 　　</span><br><span class="line">    <span class="keyword">int</span> x, y; 　　</span><br><span class="line"><span class="keyword">public</span>: 　　</span><br><span class="line">    Point(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; x=a; y=b;&#125; 　　</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MovePoint</span><span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; x+=a; y+=b;&#125; 　　</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"x="</span>&lt;&lt;x&lt;&lt;<span class="string">"y="</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;&#125; &lt;=<span class="string">""</span> font=<span class="string">""</span>&gt;　　</span><br><span class="line">&#125;; 　　</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span> 　　</span>&#123; 　　</span><br><span class="line">    <span class="function">Point <span class="title">point1</span><span class="params">( <span class="number">10</span>,<span class="number">10</span>)</span></span>; 　　</span><br><span class="line">    point1.MovePoint(<span class="number">2</span>,<span class="number">2</span>); 　　</span><br><span class="line">    point1.print(); 　　</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当对象point1调用<code>MovePoint(2,2)</code>函数时，即将point1对象的地址传递给了this指针。 </p>
<p>MovePoint函数的原型应该是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MovePoint</span><span class="params">( Point *<span class="keyword">this</span>, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>第一个参数是指向该类对象的一个指针，我们在定义成员函数时没看见是因为这个参数在类中是隐含的。这样point1的地址传递给了this，所以在MovePoint函数中便显式的写成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MovePoint</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">this</span>-&gt;x +=a; <span class="keyword">this</span>-&gt; y+= b;&#125;</span><br></pre></td></tr></table></figure></p>
<p>即可以知道，point1调用该函数后，也就是point1的数据成员被调用并更新了值。 </p>
<p>即该函数过程可写成<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">point1.x+= a; point1. y + = b;</span><br></pre></td></tr></table></figure></p>
<h2 id="关于this指针的一个经典回答"><a href="#关于this指针的一个经典回答" class="headerlink" title="关于this指针的一个经典回答"></a>关于this指针的一个经典回答</h2><p>当你进入一个房子后，你可以看见桌子、椅子、地板等，但是房子你是看不到全貌了。 </p>
<p>对于一个类的实例来说，你可以看到它的成员函数、成员变量，但是实例本身呢？this是一个指针，它时时刻刻指向你这个实例本身</p>
<h2 id="类的this指针有以下特点："><a href="#类的this指针有以下特点：" class="headerlink" title="类的this指针有以下特点："></a>类的this指针有以下特点：</h2><p>（1）this只能在成员函数中使用。全局函数、静态函数都不能使用this。实际上，成员函数默认第一个参数为<code>T * const this</code>。如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中，func的原型在编译器看来应该是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(A * <span class="keyword">const</span> <span class="keyword">this</span>,<span class="keyword">int</span> p)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>（2）由此可见，this在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">a.func(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<p>此处，编译器将会编译成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A::func(&amp;a,<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<p>看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化，因此，this指针的传递效率比较高—如VC通常是通过ecx寄存器传递this参数的。</p>
<p>（3）几个this指针的易混问题。</p>
<p>A. this指针是什么时候创建的？</p>
<p>this在成员函数的开始执行前构造，在成员的执行结束后清除。</p>
<p>但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用 TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式 创建对象的话，在堆里分配内存，new操作符通过eax返回分配 的地址，然后设置给指针变量。之后去调 用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx。</p>
<p>B. this指针存放在何处？堆、栈、全局变量，还是其他？</p>
<p>this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级 别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内 存中，它们并不是和高级语言变量对应的。</p>
<p>C. this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针 又是如何找到“类实例后函数的”？</p>
<p>大多数编译器通过ecx寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。</p>
<p>在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的。</p>
<p>D. this指针是如何访问类中的变量的？</p>
<p>如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，就很容易理解这个问题了。</p>
<p>在C++中 ,类和结构是只有一个区别的：类的成员默认是private，而结构是public。</p>
<p>this是类的指针，如果换成结构，那this就是结构的指针了。</p>
<p>E. 我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？</p>
<p>this指针只有在成员函数中才有定义。因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&amp;this获得），也可以直接使用它。</p>
<p>F. 每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</p>
<p>普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译器能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。</p>
<h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</li>
<li>类内定义的静态方法不能指向实例本身，也就是没有this指针</li>
<li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li>
<li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li>
<li>在以下场景中，经常需要显式引用 <code>this</code> 指针：<ul>
<li>为实现对象的链式引用；</li>
<li>为避免对同一对象进行赋值操作；</li>
<li>在实现一些数据结构时，如 <code>list</code>。</li>
</ul>
</li>
</ul>
<h1 id="变长参数函数"><a href="#变长参数函数" class="headerlink" title="变长参数函数"></a>变长参数函数</h1><p>首先回顾一下较多使用的变长参数函数，最经典的便是printf。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern int printf(const char *format, ...);</span><br></pre></td></tr></table></figure></p>
<p>以上是一个变长参数的函数声明。我们自己定义一个测试函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">testparams</span><span class="params">(<span class="keyword">int</span> count, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> arg = va_arg(args, <span class="keyword">int</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"arg %d = %d"</span>, i, arg);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    testparams(<span class="number">3</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>变长参数函数的解析，使用到三个宏va_start,va_arg 和va_end，再看va_list的定义<code>typedef char* va_list</code>; 只是一个char指针。</p>
<p>这几个宏如何解析传入的参数呢？</p>
<p>函数的调用，是一个压栈，保存，跳转的过程。简单的流程描述如下：</p>
<ol>
<li>把参数从右到左依次压入栈；</li>
<li>调用call指令，把下一条要执行的指令的地址作为返回地址入栈；（被调用函数执行完后会回到该地址继续执行）</li>
<li>当前的ebp（基址指针）入栈保存，然后把当前esp（栈顶指针）赋给ebp作为新函数栈帧的基址；</li>
<li>执行被调用函数，局部变量等入栈；</li>
<li>返回值放入eax，leave，ebp赋给esp，esp所存的地址赋给ebp；（这里可能需要拷贝临时返回对象）</li>
<li>从返回地址开始继续执行；（把返回地址所存的地址给eip）<br>　<br>由于开始的时候从右至左把参数压栈，va_start 传入最左侧的参数，往右的参数依次更早被压入栈，因此地址依次递增（栈顶地址最小）。va_arg传入当前需要获得的参数的类型，便可以利用 sizeof 计算偏移量，依次获取后面的参数值。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _INTSIZEOF(n)          ((sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ADDRESSOF(v) (&amp;const_cast<span class="meta-string">&lt;char&amp;&gt;(reinterpret_cast&lt;const volatile char&amp;&gt;(v)))</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __crt_va_start_a(ap, v) ((void)(ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __crt_va_arg(ap, t)     (*(t*)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __crt_va_end(ap)        ((void)(ap = (va_list)0))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __crt_va_start(ap, x) ((void)(__vcrt_va_start_verify_argument_type<span class="meta-string">&lt;decltype(x)&gt;(), __crt_va_start_a(ap, x)))</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_start __crt_va_start</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_arg   __crt_va_arg</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_end   __crt_va_end</span></span><br></pre></td></tr></table></figure>
<p>上述宏定义中，<code>_INTSIZEOF(n)</code>将地址的低2位指令，做内存的4字节对齐。每次取参数时，调用<code>__crt_va_arg(ap,t)</code>，返回t类型参数地址的值，同时将ap偏移到t之后。最后，调用<code>_crt_va_end(ap)</code>将ap置0.</p>
<p>变长参数的函数的使用及其原理看了宏定义是很好理解的。从上文可知，要使用变长参数函数的参数，我们必须知道传入的每个参数的类型。printf中，有format字符串中的特殊字符组合来解析后面的参数类型。但是当传入类的构造函数的参数时，我们并不知道每个参数都是什么类型，虽然参数能够依次传入函数，但无法解析并获取每个参数的数值。因此传统的变长参数函数并不足以解决传入任意构造函数参数的问题。</p>
<h1 id="变长参数模板"><a href="#变长参数模板" class="headerlink" title="变长参数模板"></a>变长参数模板</h1><p>我们需要用到C++11的新特性，变长参数模板。</p>
<p>这里举一个使用自定义内存池的例子。定义一个内存池类MemPool.h，以count个类型T为单元分配内存，默认分配一个对象。每当内存内空闲内存不够，则一次申请MEMPOOL_NEW_SIZE个内存对象。内存池本身只负责内存分配，不做初始化工作，因此不需要传入任何参数，只需实例化模板分配相应类型的内存即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UTIL_MEMPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UTIL_MEMPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMPOOL_NEW_SIZE 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> count = <span class="number">1</span>&gt;</span><br><span class="line">class MemPool</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">union</span> MemObj &#123;</span><br><span class="line">        <span class="keyword">char</span> _obj[<span class="number">1</span>];</span><br><span class="line">        MemObj* _freelink;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">Allocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!_freelist) &#123;</span><br><span class="line">            refill();</span><br><span class="line">        &#125;</span><br><span class="line">        MemObj* alloc_mem = _freelist;</span><br><span class="line">        _freelist = _freelist-&gt;_freelink;</span><br><span class="line">        ++_size;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>*)alloc_mem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeAllocate</span><span class="params">(<span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MemObj* q = (MemObj*)p;</span><br><span class="line">        q-&gt;_freelink = _freelist;</span><br><span class="line">        _freelist = q;</span><br><span class="line">        --_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> size_t <span class="title">TotalSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _totalsize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> size_t <span class="title">Size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _size;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">refill</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> size = <span class="keyword">sizeof</span>(T) * count;</span><br><span class="line">        <span class="keyword">char</span>* new_mem = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(size * MEMPOOL_NEW_SIZE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MEMPOOL_NEW_SIZE; ++i) &#123;</span><br><span class="line">            MemObj* free_mem = (MemObj*)(new_mem + i * size);</span><br><span class="line">            free_mem-&gt;_freelink = _freelist;</span><br><span class="line">            _freelist = free_mem;</span><br><span class="line">        &#125;</span><br><span class="line">        _totalsize += MEMPOOL_NEW_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> MemObj* _freelist;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> _totalsize;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> _size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> count&gt;</span><br><span class="line"><span class="keyword">typename</span> MemPool&lt;T, count&gt;::MemObj* MemPool&lt;T, count&gt;::_freelist = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> count&gt;</span><br><span class="line"><span class="keyword">size_t</span> MemPool&lt;T, count&gt;::_totalsize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> count&gt;</span><br><span class="line"><span class="keyword">size_t</span> MemPool&lt;T, count&gt;::_size = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>接下来在没有变长参数的情况下，实现通用MemNew和MemDelete函数模板。这里不对函数模板作详细解释，用函数模板我们可以对不同的类型实现同样的内存池分配操作。如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> *<span class="title">MemNew</span>(<span class="title">size_t</span> <span class="title">count</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T *p = (T*)MemPool&lt;T, count&gt;::Allocate();</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">std</span>::is_pod&lt;T&gt;::value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> (&amp;p[i]) T();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> *<span class="title">MemDelete</span>(<span class="title">T</span> *<span class="title">p</span>, <span class="title">size_t</span> <span class="title">count</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">std</span>::is_pod&lt;T&gt;::value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                p[i].~T();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        MemPool&lt;T, count&gt;::DeAllocate(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述实现中，使用placement new对申请的内存进行构造，使用了默认构造函数，当申请内存的类型不具备默认构造函数时，placement new将报错。对于pod类型，可以省去调用构造函数的过程。</p>
<p>引入C++11变长模板参数后MemNew修改为如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> *<span class="title">MemNew</span>(<span class="title">size_t</span> <span class="title">count</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T *p = (T*)MemPool&lt;T, count&gt;::Allocate();</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">std</span>::is_pod&lt;T&gt;::value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> (&amp;p[i]) T(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上函数定义包含了多个特性，后面我将一一解释，其中class… Args 表示变长参数模板，函数参数中Args&amp;&amp; 为右值引用。std::forward<args> 实现参数的完美转发。这样，无论传入的类型具有什么样的构造函数，都能够完美执行placement new。</args></p>
<p>C++11中引入了变长参数模板的概念，来解决参数个数不确定的模板。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>... <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Test</span> &#123;</span>&#125;;</span><br><span class="line">Test&lt;&gt; test0;</span><br><span class="line">Test&lt;<span class="keyword">int</span>&gt; test1;</span><br><span class="line">Test&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; test2;</span><br><span class="line">Test&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">long</span>&gt; test3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>... <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">test</span>(<span class="title">T</span>... <span class="title">args</span>);</span></span><br><span class="line">test();</span><br><span class="line">test&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>);</span><br><span class="line">test&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">long</span>&gt;(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0L</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="变长参数函数模板"><a href="#变长参数函数模板" class="headerlink" title="变长参数函数模板"></a>变长参数函数模板</h2><p>T… args 为形参包，其中args是模式，形参包中可以有0到任意多个参数。调用函数时，可以传任意多个实参。对于函数定义来说，该如何使用参数包呢？在上文的MemNew中，我们使用std::forward依次将参数包传入构造函数，并不关注每个参数具体是什么。如果需要，我们可以用sizeof…(args)操作获取参数个数，也可以把参数包展开，对每个参数做更多的事。展开的方法有两种，递归函数，逗号表达式。</p>
<p>递归函数方式展开，模板推导的时候，一层层递归展开，最后到没有参数时用定义的一般函数终止。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">test</span>(<span class="title">T</span> <span class="title">first</span>, <span class="title">Args</span>... <span class="title">args</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="string">" "</span> &lt;&lt; first &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    test(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">long</span>&gt;(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0L</span>);</span><br></pre></td></tr></table></figure></p>
<p>output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int 0</span><br><span class="line">int 0</span><br><span class="line">long 0</span><br></pre></td></tr></table></figure></p>
<p>逗号表达式方式展开，利用数组的参数初始化列表和逗号表达式，逐一执行print每个参数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">T</span> <span class="title">arg</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="string">" "</span> &lt;&lt; arg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">test</span>(<span class="title">Args</span>... <span class="title">args</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; (print(args), <span class="number">0</span>)... &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0L</span>);</span><br></pre></td></tr></table></figure></p>
<p>output:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int 0</span><br><span class="line">int 0</span><br><span class="line">long 0</span><br></pre></td></tr></table></figure></p>
<h2 id="变长参数类模板"><a href="#变长参数类模板" class="headerlink" title="变长参数类模板"></a>变长参数类模板</h2><p>变长参数类模板，一般情况下可以方便我们做一些编译期计算。可以通过偏特化和递归推导的方式依次展开模板参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Types</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        value = Test&lt;T&gt;::value + Test&lt;Types...&gt;::value,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Test</span>&lt;T&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        value = <span class="keyword">sizeof</span>(T),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">long</span>&gt; test;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; test.value;</span><br><span class="line"></span><br><span class="line">output: <span class="number">12</span></span><br></pre></td></tr></table></figure>
<h2 id="右值引用和完美转发"><a href="#右值引用和完美转发" class="headerlink" title="右值引用和完美转发"></a>右值引用和完美转发</h2><p>对于变长参数函数模板，需要将形参包展开逐个处理的需求不多，更多的还是像本文的MemNew这样的需求，最终整个传入某个现有的函数。我们把重点放在参数的传递上。</p>
<p>要理解右值引用，需要先说清楚左值和右值。左值是内存中有确定存储地址的对象的表达式的值；右值则是非左值的表达式的值。const左值不可被赋值，临时对象的右值可以被赋值。左值与右值的根本区别在于是否能用&amp;运算符获得内存地址。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i =<span class="number">0</span>;<span class="comment">//i 左值</span></span><br><span class="line"><span class="keyword">int</span> *p = &amp;i;<span class="comment">// i 左值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">foo() = <span class="number">42</span>;<span class="comment">// foo() 左值</span></span><br><span class="line"><span class="keyword">int</span>* p1 = &amp;foo();<span class="comment">// foo() 左值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">j = foo1();<span class="comment">// foo 右值</span></span><br><span class="line"><span class="keyword">int</span> k = j + <span class="number">1</span>;<span class="comment">// j + 1 右值</span></span><br><span class="line"><span class="keyword">int</span> *p2 = &amp;foo1(); <span class="comment">// 错误，无法取右值的地址</span></span><br><span class="line">j = <span class="number">1</span>;<span class="comment">// 1 右值</span></span><br></pre></td></tr></table></figure></p>
<p>理解左值和右值之后，再来看引用，对左值的引用就是左值引用，对右值（纯右值和临终值）的引用就是右值引用。</p>
<p>如下函数foo，传入int类型，返回int类型，这里传入函数的参数0和返回值0都是右值(不能用&amp;取得地址)。于是，未做优化的情况下，传入参数0的时候，我们需要把右值0拷贝给param，函数返回的时候需要将0拷贝给临时对象，临时对象再拷贝给res。当然现在的编译器都做了返回值优化，返回对象是直接创建在返回后的左值上的，这里只用来举个例子<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, param);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> res = foo(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>显然，这里的拷贝都是多余的。可能我们会想要优化，首先将参数int改为int&amp;，传入左值引用，于是0无法传入了，当然我们可以改成const int&amp;，这样终于省去了传参的拷贝。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, param);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于const int&amp; 既可以是左值也可以是右值，传入0或者int变量都能够满足。(但是似乎既然有左值引用的int&amp;类型，就应该有对应的传入右值引用的类型int&amp;&amp;)。另外，这里返回的右值0，似乎不通过拷贝就无法赋值给左值res。</p>
<p>于是有了移动语义，把临时对象的内容直接移动给被赋值的左值对象(std::move)。和右值引用，X&amp;&amp;是到数据类型X的右值引用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp;&amp; <span class="title">foo</span><span class="params">(<span class="keyword">int</span>&amp;&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, param);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::move(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>&amp;&amp; res = foo(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> *pres = &amp;res;</span><br></pre></td></tr></table></figure></p>
<p>将foo改为右值引用参数和返回值，返回右值引用，免去拷贝。这里res是具名引用，运算符右侧的右值引用作为左值，可以取地址。右值引用既有左值性质，也有右值性质。</p>
<p>上述例子还只存在于拷贝的性能问题。回到MemNew这样的函数模板。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>* <span class="title">Test</span>(<span class="title">T</span> <span class="title">arg</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> T(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>* <span class="title">Test</span>(<span class="title">T</span>&amp; <span class="title">arg</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> T(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>* <span class="title">Test</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">arg</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> T(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>* <span class="title">Test</span>(<span class="title">T</span>&amp;&amp; <span class="title">arg</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> T(<span class="built_in">std</span>::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的前三种方式传参，第一种首先有拷贝消耗，其次有的参数就是需要修改的左值。第二种方式则无法传常数等右值。第三种方式虽然左值右值都能传，却无法对传入的参数进行修改。第四种方式使用右值引用，可以解决参数完美转发的问题。</p>
<p>std::forward能够根据实参的数据类型，返回相应类型的左值和右值引用，将参数完整不动的传递下去。<br>解释这个原理涉及到引用塌缩规则<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T&amp; &amp; -&gt;T&amp;</span><br><span class="line">T&amp; &amp;&amp;-&gt;T&amp;</span><br><span class="line">T&amp;&amp; &amp;-&gt;T&amp;</span><br><span class="line">T&amp;&amp; &amp;&amp;-&gt;T&amp;&amp;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt; <span class="title">struct</span> <span class="title">remove_reference</span>      &#123;</span><span class="keyword">typedef</span> T type;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt; <span class="title">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&gt;  &#123;</span><span class="keyword">typedef</span> T type;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt; <span class="title">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&amp;&gt; &#123;</span><span class="keyword">typedef</span> T type;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt; <span class="title">T</span>&amp;&amp; <span class="title">forward</span>( <span class="title">typename</span> <span class="title">std</span>:</span>:remove_reference&lt;T&gt;::type&amp; t )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">std</span>:</span>:remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; a)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于函数模板<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span>* <span class="title">Test</span>(<span class="title">T</span>&amp;&amp; <span class="title">arg</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> T(<span class="built_in">std</span>::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当传入实参为X类型左值时，T为X&amp;，最后的类型为X&amp;。当实参为X类型右值时，T为X，最后的类型为X&amp;&amp;。</p>
<p>x为左值时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X x;</span><br><span class="line">Test(x);</span><br></pre></td></tr></table></figure></p>
<p>T为X&amp;，实例化后<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">X&amp; &amp;&amp; <span class="built_in">std</span>::forward(remove_reference&lt;X&amp;&gt;::type&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;X&amp; &amp;&amp;&gt;(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">X* <span class="title">Test</span><span class="params">(X&amp; &amp;&amp; arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> X(<span class="built_in">std</span>::forward&lt;X&amp;&gt;(arg));  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 塌陷后</span></span><br><span class="line"></span><br><span class="line">X&amp; <span class="built_in">std</span>::forward(X&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;X&amp;&gt;(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">X* <span class="title">Test</span><span class="params">(X&amp; arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> X(<span class="built_in">std</span>::forward&lt;X&amp;&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>x为右值时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">Test(foo());</span><br></pre></td></tr></table></figure></p>
<p>T为X，实例化后<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">X&amp;&amp; <span class="built_in">std</span>::forward(remove_reference&lt;X&gt;::type&amp; a) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;X&amp;&amp;&gt;(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">X* <span class="title">Test</span><span class="params">(X&amp;&amp; arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> X(<span class="built_in">std</span>::forward&lt;X&gt;(arg));  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 塌陷后</span></span><br><span class="line"></span><br><span class="line">X&amp;&amp; <span class="built_in">std</span>::forward(X&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;X&amp;&amp;&gt;(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">X* <span class="title">Test</span><span class="params">(X&amp;&amp; arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> X(<span class="built_in">std</span>::forward&lt;X&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到最终实参总是被推导为和传入时相同的类型引用。</p>
<p>至此，我们讨论了变长参数模板，讨论了右值引用和函数模板的完美转发，完整的解释了MemNew对任意多个参数的构造函数的参数传递过程。利用变长参数函数模板，右值引用和std::forward，可以完成参数的完美转发。</p>
<h1 id="str相关函数"><a href="#str相关函数" class="headerlink" title="str相关函数"></a>str相关函数</h1><p>C语言str系列库函数在不同的库中有不同的实现方法，但原理都是一样的。因为库函数都是没有进行入口参数检查的，并且str系列库函数在面试中经常容易被面试官喊在纸上写某一个函数的实现，因此本文参考了OpenBSD和vc++ 8.0库中的代码，结合自己的编程习惯，部分整理如下：</p>
<p>1、strcpy<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> *d;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (dst == <span class="literal">NULL</span> || src == <span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span> dst;  </span><br><span class="line">  </span><br><span class="line">    d = dst;  </span><br><span class="line">    <span class="keyword">while</span> (*d++ = *src++)    <span class="comment">// while ((*d++ = *src++) != '\0')  </span></span><br><span class="line">        ;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dst;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、strncpy<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//copy at most n characters of src to dst  </span></span><br><span class="line"><span class="comment">//Pad with '\0' if src fewer than n characters  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span>*src, <span class="keyword">size_t</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> *d;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (dst == <span class="literal">NULL</span> || src == <span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span> dst;  </span><br><span class="line">  </span><br><span class="line">    d = dst;  </span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span> &amp;&amp; (*d++ = *src++))    <span class="comment">/* copy string */</span>  </span><br><span class="line">        n--;  </span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">while</span> (--n != <span class="number">0</span>)  </span><br><span class="line">            *d++ == <span class="string">'\0'</span>;                <span class="comment">/* pad out with zeroes */</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dst;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意n是unsigned int，在进行n—操作时特别要小心。如果不小心写成下面这样就会出错：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (n-- != <span class="number">0</span> &amp;&amp; (*d++ = *src++))  </span><br><span class="line">    ;         </span><br><span class="line"><span class="keyword">while</span> (n-- != <span class="number">0</span>)   </span><br><span class="line">    *d++ = <span class="string">'\0'</span>;</span><br></pre></td></tr></table></figure></p>
<p>第一个while循环中，当n变为0时，仍然会执行n—一，此时n等于经由-1变成的大正数，导致后面对n的使用出错。</p>
<p>3、strcat<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> *src)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="keyword">char</span> *d;  </span><br><span class="line">    <span class="keyword">if</span> (dst == <span class="literal">NULL</span> || src == <span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span> dst;  </span><br><span class="line">  </span><br><span class="line">   d = dst;  </span><br><span class="line">   <span class="keyword">while</span> (*d)  </span><br><span class="line">       d++;  </span><br><span class="line">   <span class="comment">//while (*d++ != 0);  </span></span><br><span class="line">   <span class="comment">//d--;  </span></span><br><span class="line">     </span><br><span class="line">   <span class="keyword">while</span> (*d++ = *src++)  </span><br><span class="line">       ;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span> dst;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4、strncat<br>写法1：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//concatenate at most n characters of src to the end of dst  </span></span><br><span class="line"><span class="comment">//terminates dst with '\0'  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncat</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">size_t</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == dst || <span class="literal">NULL</span> == src)  </span><br><span class="line">        <span class="keyword">return</span> dst;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">char</span> *d = dst;  </span><br><span class="line">        <span class="keyword">do</span>   </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> ((*d = *src++) == <span class="string">'\0'</span> )  </span><br><span class="line">                <span class="keyword">return</span> dst;     <span class="comment">//break  </span></span><br><span class="line">            d++;  </span><br><span class="line">        &#125; <span class="keyword">while</span> (--n != <span class="number">0</span>);    </span><br><span class="line">        *d = <span class="string">'\0'</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> dst;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>写法2：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncat</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">size_t</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">   <span class="keyword">char</span> *d;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> (dst == <span class="literal">NULL</span> || src == <span class="literal">NULL</span>)  </span><br><span class="line">       <span class="keyword">return</span> dst;  </span><br><span class="line">     </span><br><span class="line">   d = dst;  </span><br><span class="line">   <span class="keyword">while</span> (*d)  </span><br><span class="line">       d++;  </span><br><span class="line">   <span class="comment">//(1)  </span></span><br><span class="line">   <span class="keyword">while</span> (n != <span class="number">0</span>)  </span><br><span class="line">   &#123;  </span><br><span class="line">       <span class="keyword">if</span> ((*d++ = *src++) == <span class="string">'\0'</span>)  </span><br><span class="line">           <span class="keyword">return</span> dst;  </span><br><span class="line">       n--;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">//(2)  </span></span><br><span class="line">   <span class="comment">//while (n--)       //这种方式写最后n的值不为0，不过这个n后面不会再被使用  </span></span><br><span class="line">      <span class="comment">// if ((*d++ == *src++) == '\0')  </span></span><br><span class="line">         <span class="comment">//  return dst;  </span></span><br><span class="line">  </span><br><span class="line">   *d = <span class="string">'\0'</span>;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span> dst;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5、strcmp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">if</span> (s1 == <span class="literal">NULL</span> || s2 == <span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="comment">//(1)  </span></span><br><span class="line">    <span class="comment">//while (*s1 == *s2++)  </span></span><br><span class="line">    <span class="comment">//  if (*s1++ == '\0')  </span></span><br><span class="line">    <span class="comment">//      return 0;  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//(2)  </span></span><br><span class="line">    <span class="keyword">for</span> (; *s1 == *s2; s1++, s2++)  </span><br><span class="line">        <span class="keyword">if</span> (*s1 == <span class="string">'\0'</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s1 - *(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s2;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>6、strncmp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2, <span class="keyword">size_t</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (s1 == <span class="literal">NULL</span> || s2 == <span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">do</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (*s1 != *s2++)  </span><br><span class="line">            <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s1 - *(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)--s2;  </span><br><span class="line">        <span class="keyword">if</span> (*s1++ == <span class="string">'\0'</span>)  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">    &#125; <span class="keyword">while</span> (--n != <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//do   </span></span><br><span class="line">    <span class="comment">//&#123;  </span></span><br><span class="line">    <span class="comment">//  if (*s1 != *s2)  </span></span><br><span class="line">    <span class="comment">//      return *(unsigned char*)s1 - *(unsigned char*)s2;  </span></span><br><span class="line">    <span class="comment">//  if (*s1 == '\0')  </span></span><br><span class="line">    <span class="comment">//      break;  </span></span><br><span class="line">    <span class="comment">//  s1++;  </span></span><br><span class="line">    <span class="comment">//  s2++;  </span></span><br><span class="line">    <span class="comment">//&#125; while (--n != 0);  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>7、strstr<br>写法1：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//return pointer to first  occurrence of find in s  </span></span><br><span class="line"><span class="comment">//or NULL if not present  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *find)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">char</span> *cp = (<span class="keyword">char</span>*)s;  </span><br><span class="line">    <span class="keyword">char</span> *s1, *s2;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span> || find == <span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (*cp != <span class="string">'\0'</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        s1 = cp;  </span><br><span class="line">        s2 = (<span class="keyword">char</span>*)find;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span> (*s1 &amp;&amp; *s2 &amp;&amp; *s1 == *s2)  </span><br><span class="line">            s1++, s2++;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span>(*s2 == <span class="string">'\0'</span>)  </span><br><span class="line">            <span class="keyword">return</span> cp;  </span><br><span class="line">  </span><br><span class="line">        cp++;  </span><br><span class="line">    &#125;  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>写法2：参照简单模式匹配算法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *find)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (*(s + i) != <span class="string">'\0'</span> &amp;&amp; *(find + j) != <span class="string">'\0'</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (*(s + i + j) == *(find + j))  </span><br><span class="line">            j++;     <span class="comment">//继续比较后一字符  </span></span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            i++;     <span class="comment">//开始新一轮比较  </span></span><br><span class="line">            j = <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> *(find + j) == <span class="string">'\0'</span> ? (<span class="keyword">char</span>*)(s + i) : <span class="literal">NULL</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>8、strchr<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//return pointer to first occurrence of ch in str  </span></span><br><span class="line"><span class="comment">//NULL if not present  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*str, <span class="keyword">int</span> ch)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">while</span> (*str != <span class="string">'\0'</span> &amp;&amp; *str != (<span class="keyword">char</span>)ch)  </span><br><span class="line">        str++;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(*str == (<span class="keyword">char</span>)ch)  </span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">char</span>*)str;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>9、strrchr<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//return pointer to last occurrence of ch in str  </span></span><br><span class="line"><span class="comment">//NULL if not present  </span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strrchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">int</span> ch)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">char</span> *s = (<span class="keyword">char</span>*)str;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">while</span> (*s++)  </span><br><span class="line">       ;       <span class="comment">/* find end of string */</span>  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">while</span> (--s != str &amp;&amp; *s != (<span class="keyword">char</span>)ch)  </span><br><span class="line">       ;       <span class="comment">/* search towards front */</span>  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span>(*s == (<span class="keyword">char</span>)ch)  </span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">char</span>*)s;  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>10、strlen<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span> *str)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *eos = str;  </span><br><span class="line">    <span class="keyword">while</span> (*eos++)  </span><br><span class="line">        ;  </span><br><span class="line">    <span class="keyword">return</span> (eos - <span class="number">1</span> - str);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="RVO"><a href="#RVO" class="headerlink" title="RVO"></a>RVO</h1><h2 id="函数如何返回值"><a href="#函数如何返回值" class="headerlink" title="函数如何返回值"></a>函数如何返回值</h2><p>函数返回值的传递分为两种情况。</p>
<p>当返回的对象的大小不超过8字节时，通过寄存器（eax edx）返回。</p>
<p>当返回的对象的大小大于8字节时，通过栈返回。但是，如果返回struct/class对象，尽管其大小不大于8字节，也是通过栈返回的。</p>
<p>在通过栈返回的时候，栈上会有一块空间来保存函数的返回值。当函数结束的时候，会把要返回的对象拷贝到这块区域，对于内置类型是直接拷贝，类类型的话是调用copy ctor。这块区域又称为函数返回的临时对象（temporary object）。</p>
<p>下面用代码看一下是不是这样。</p>
<p>首先，编写Base类和func()函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    Base() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"default ctor"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">    Base(<span class="keyword">const</span> Base&amp; b) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy ctor "</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Base&amp; b)&#123;  <span class="built_in">cout</span> &lt;&lt; <span class="string">"operator="</span> &lt;&lt; <span class="built_in">endl</span>; a = b.a; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    ~Base()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"dtor "</span> &lt;&lt; <span class="built_in">endl</span>;&#125;;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Base <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用函数：（为了确保临时对象的存在，我绑定一个const引用到它上面；其实不绑定的话，直接func();也会有临时对象的存在）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Base &amp;r = func();</span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default ctor</span><br><span class="line">dtor</span><br></pre></td></tr></table></figure></p>
<p>按理说，存在临时对象，输出应该是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default ctor</span><br><span class="line">copy ctor</span><br><span class="line">dtor</span><br><span class="line">dtor</span><br></pre></td></tr></table></figure></p>
<p>因为这里C++做了返回值优化（RVO）。RVO是一种编译器优化的技术，它把要返回的局部变量直接构造在临时对象所在的区域，达到少调用一次copy ctor的目的。</p>
<p>为了避免RVO，把func()重新编写。这样编译器不清楚哪个局部变量会被返回，所以就避免了返回值优化。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Base <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Base a;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Base b;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用func:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func(0);</span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default ctor // 函数内的局部对象</span><br><span class="line">copy ctor  //局部对象-&gt;临时对象</span><br><span class="line">dtor // 局部对象析构</span><br><span class="line">dtor // 临时对象析构</span><br></pre></td></tr></table></figure></p>
<p>结果符合预期。</p>
<p>如果这样调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base a = func(0);</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default ctor // 函数内的局部对象</span><br><span class="line">copy ctor // ？ </span><br><span class="line">dtor // 局部对象析构</span><br><span class="line">dtor // ？</span><br></pre></td></tr></table></figure></p>
<p>为何是这样？不应该是还有一次临时对象到a的copy ctor和a的dtor吗？<br>这里我猜测进行了另外的优化，将两者合并到了一起，也就是把a的存储区域作为临时对象的区域。</p>
<p>下面这样调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base a = func(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">a = func(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">default ctor // func的局部对象</span><br><span class="line">copy ctor // func的局部对象-&gt;临时对象</span><br><span class="line">dtor // func的局部对象析构</span><br><span class="line"></span><br><span class="line">default ctor // func的局部对象</span><br><span class="line">copy ctor //  func的局部对象-&gt;临时对象（也就是a）</span><br><span class="line">dtor // func的局部对象析构</span><br><span class="line">operator= // 临时对象-&gt;a</span><br><span class="line">dtor // 临时对象析构</span><br><span class="line">dtor // a析构</span><br></pre></td></tr></table></figure></p>
<p>输出十分合理！</p>
<p>RVO，是Return Value Optimization。这是在函数返回返回值的时候编译器所做出的优化，是C++11标准的一部分，C++11称之为copy elision。</p>
<p>在第一次编写的func里面，编译器明确知道函数会返回哪一个局部对象，那么编译器会把存储这个局部对象的地址和存储返回值临时对象的地址进行复用，也就是说避免了从局部对象到临时对象的拷贝操作。这就是RVO。</p>
<p>现在把func重新改为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Base <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下面三种方式调用func。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Base a = func();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">a = func();</span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">default ctor // 局部对象b（也是临时对象）的构造</span><br><span class="line">dtor </span><br><span class="line"></span><br><span class="line">default ctor // 局部对象b（也是临时对象，也是要初始化的对象a）的构造</span><br><span class="line"></span><br><span class="line">default ctor // 局部对象b（也是临时对象）的构造</span><br><span class="line">operator= // 局部对象b（也是临时对象）-&gt; 对象a</span><br><span class="line">dtor // 局部对象b</span><br><span class="line">dtor // 对象a</span><br></pre></td></tr></table></figure></p>
<p>输出十分合理！</p>
<h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move()"></a>std::move()</h2><p>在查阅RVO的资料的时候，看到了这篇博客RVO V.S. std::move，讲的特别好。除了RVO里面还提到了std:move()，为了加深对std::move的理解，我又做了下面几个实验。</p>
<p>重新编写func：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Base <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::move(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后向Base添加下面的成员：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base&amp; operator=(Base&amp;&amp; b)&#123;  cout &lt;&lt; &quot;move operator=&quot; &lt;&lt; endl; a = b.a; return *this;&#125;</span><br><span class="line">Base(Base&amp;&amp; b) &#123; cout &lt;&lt; &quot;move ctor&quot; &lt;&lt;  endl;&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Base a = func();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">a = func();</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">default ctor // 局部对象b</span><br><span class="line">move ctor // 局部对象b向临时对象的移动</span><br><span class="line">dtor</span><br><span class="line">dtor</span><br><span class="line"></span><br><span class="line">default ctor // 局部对象b</span><br><span class="line">move ctor // 局部对象b向临时对象（也是要初始化的对象a）的移动</span><br><span class="line">dtor</span><br><span class="line"></span><br><span class="line">default ctor // 局部对象b</span><br><span class="line">move ctor // 局部对象b向临时对象的移动</span><br><span class="line">dtor // 局部对象b析构</span><br><span class="line">move operator= // 临时对象到a的移动，临时对象是右值，所以用move</span><br><span class="line">dtor // 临时对象析构</span><br><span class="line">dtor</span><br></pre></td></tr></table></figure></p>
<p>func的函数返回类型仍然是Base，而不是Base&amp;&amp;。这意味着函数还是会创建一个Base类的临时对象，只是临时对象是通过右值引用得到的，也就是说通过移动构造函数移动得到的。</p>
<p>把func的返回类型改为Base&amp;&amp;：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Base&amp;&amp; <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::move(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>还是调用，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Base a = func();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">a = func();</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">default ctor // 局部对象</span><br><span class="line">dtor</span><br><span class="line"></span><br><span class="line">default ctor // 局部对象</span><br><span class="line">dtor // 局部对象</span><br><span class="line">move ctor // 局部对象到a的移动（注意：因为这里局部对象已经析构，所以这里的行为是undefined，十分危险）</span><br><span class="line"></span><br><span class="line">default ctor // 局部对象</span><br><span class="line">dtor // 局部对象</span><br><span class="line">move operator= // 局部对象到a的移动</span><br><span class="line">dtor</span><br></pre></td></tr></table></figure></p>
<p>总结：</p>
<ul>
<li>函数的返回类型是类类型，return局部对象，可能会有RVO；</li>
<li>函数的返回类型是类类型，return右值引用，肯定不会有RVO；</li>
<li>函数的返回类型是右值引用，return右值引用，没有临时对象的消耗，但是仍不可取，因为右值引用的对对象在使用前已经析构了。</li>
</ul>
<h1 id="cpp的tr1-function使用"><a href="#cpp的tr1-function使用" class="headerlink" title="cpp的tr1_function使用"></a>cpp的tr1_function使用</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>function是一种通用、多态的函数封装。std::function的实例可以对任何可以调用的目标 进行存储、复制、和调用操作，这些目标包括函数、lambda表达式、绑定表达式、以及其它函数对象等。（c++11起的版本可用） </p>
<p>function（和bind一样）可以实现类似函数指针的功能，却比函数指针更加灵活（体现在占位符上面），尤其是在很多成员调用同一个函数（仅仅是参数类型不同）的时候比较方便。 </p>
<ol>
<li>可以作为函数和成员函数。</li>
<li>可做回调函数，取代函数指针。</li>
<li>可作为函数的参数，从外部控制函数内部的行为。</li>
</ol>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>先看一下下面这块代码： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tr1/functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::tr1::function&lt;<span class="keyword">void</span>()&gt; HandleEvent;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal()&#123;&#125;</span><br><span class="line">    ~Animal()&#123;&#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"I am moving...\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span>:</span> <span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Fish()&#123;&#125;</span><br><span class="line">    ~Fish()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"I am swimming...\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::tr1::function&lt;<span class="keyword">void</span>()&gt; move = &amp;Animal::Move;</span><br><span class="line">    move();</span><br><span class="line"></span><br><span class="line">    move = &amp;Fish::Move;</span><br><span class="line">    move();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Animal类是父类，Fish继承于Animal。测试程序中分别将子类和父类的Move()函数地址赋值给function的指针。调用的结果如下：<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am moving… </span><br><span class="line">I am swimming…</span><br></pre></td></tr></table></figure></p>
<p>为了体现function可以作为函数的参数传入，我们再写一个函数加到原来的代码中进行测试：<br>　　<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Moving</span><span class="params">(<span class="keyword">int</span> option, <span class="built_in">std</span>::tr1::function&lt;<span class="keyword">void</span>()&gt; move)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(option &amp; <span class="number">1</span> == <span class="number">0</span>)&#123;  <span class="comment">//如果option为偶数，则执行Animal类中的Move方法</span></span><br><span class="line">        move = &amp;Animal::Move;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        move = &amp;Fish::Move;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    move();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::tr1::function&lt;<span class="keyword">void</span>()&gt; move = &amp;Animal::Move;</span><br><span class="line">    move();</span><br><span class="line"></span><br><span class="line">    move = &amp;Fish::Move;</span><br><span class="line">    move();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"-------------divid line------------\n"</span>;</span><br><span class="line">    Moving(<span class="number">4</span>,move);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试结果如下：<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I am moving… </span><br><span class="line">I am swimming… </span><br><span class="line">————-divid line———— </span><br><span class="line">I am moving…</span><br></pre></td></tr></table></figure></p>
<h1 id="C-函数调用分析"><a href="#C-函数调用分析" class="headerlink" title="C++函数调用分析"></a>C++函数调用分析</h1><p>这里以一个简单的C语言代码为例，来分析函数调用过程</p>
<p>代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> param1 ,<span class="keyword">int</span> param2,<span class="keyword">int</span> param3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var1 = param1;</span><br><span class="line">        <span class="keyword">int</span> var2 = param2;</span><br><span class="line">        <span class="keyword">int</span> var3 = param3;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"var1=%d,var2=%d,var3=%d"</span>,var1,var2,var3);</span><br><span class="line">        <span class="keyword">return</span> var1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先说明，在堆栈中变量分布是从高地址到低地址分布，EBP是指向栈底的指针，在过程调用中不变，又称为帧指针。ESP指向栈顶，程序执行时移动，ESP减小分配空间，ESP增大释放空间，ESP又称为栈指针。</p>
<p>下面来逐步分析函数的调用过程</p>
<p>函数main执行，main各个参数从右向左逐步压入栈中，最后压入返回地址</p>
<p>执行第15行，3个参数以从左向右的顺序压入堆栈，及从param3到param1，栈内分布如下图：<br><img src="/img/2012072014171977.jpg" alt></p>
<p>然后是返回地址入栈：此时的栈内分布如下：<br><img src="/img/2012072014223353.jpg" alt></p>
<p>第3行函数调用时，通过跳转指令进入函数后，函数地址入栈后，EBP入栈，然后把当前ESP的值给EBP，对应的汇编指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp esp</span><br></pre></td></tr></table></figure></p>
<p>此时栈顶和栈底指向同一位置，栈内分布如下：<br><img src="/img/2012072014393253.jpg" alt></p>
<p>第5行开始执行， int var1 = param1; int var2 = param2; int var3 = param3;按申明顺序依次存储。对应的汇编：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov 0x8(%ebp),%eax</span><br><span class="line">mov %eax,-0x4(%ebp)</span><br></pre></td></tr></table></figure></p>
<p>其中将[EBP+0x8]地址里的内容赋给EAX，即把param的值赋给EAX，然后把EAX的中的值放到[EBP-4]这个地址里，即把EAX值赋给var1，完成C代码 int var1 = param1，其他变量雷同。<br><img src="/img/2012072014460755.jpg" alt></p>
<p>第9行，输出结果，第10行执行 对应的汇编代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov  -0x4(%ebp),%eax</span><br></pre></td></tr></table></figure></p>
<p>最后通过eax寄存器保存函数的返回值；</p>
<p>调用执行函数完毕，局部变量var3，var2，var1一次出栈，EBP恢复原值，返回地址出栈，找到原执行地址，param1，param2，param3依次出栈，函数调用执行完毕。图略</p>
<h1 id="深入理解C-的动态绑定和静态绑定"><a href="#深入理解C-的动态绑定和静态绑定" class="headerlink" title="深入理解C++的动态绑定和静态绑定"></a>深入理解C++的动态绑定和静态绑定</h1><p>为了支持c++的多态性，才用了动态绑定和静态绑定。理解他们的区别有助于更好的理解多态性，以及在编程的过程中避免犯错误。需要理解四个名词：</p>
<ul>
<li>对象的静态类型：对象在声明时采用的类型。是在编译期确定的。</li>
<li>对象的动态类型：目前所指对象的类型。是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。</li>
</ul>
<p>关于对象的静态类型和动态类型，看一个示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">D* pD = <span class="keyword">new</span> D();<span class="comment">//pD的静态类型是它声明的类型D*，动态类型也是D*</span></span><br><span class="line">B* pB = pD;<span class="comment">//pB的静态类型是它声明的类型B*，动态类型是pB所指向的对象pD的类型D*</span></span><br><span class="line">C* pC = <span class="keyword">new</span> C();</span><br><span class="line">pB = pC;<span class="comment">//pB的动态类型是可以更改的，现在它的动态类型是C*</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>静态绑定：绑定的是对象的静态类型，某特性（比如函数）依赖于对象的静态类型，发生在编译期。</li>
<li>动态绑定：绑定的是对象的动态类型，某特性（比如函数）依赖于对象的动态类型，发生在运行期。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>;<span class="comment">//首先说明一下，这个子类重新定义了父类的no-virtual函数，这是一个不好的设计，会导致名称遮掩；这里只是为了说明动态绑定和静态绑定才这样使用。</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">D* pD = <span class="keyword">new</span> D();</span><br><span class="line">B* pB = pD;</span><br></pre></td></tr></table></figure>
<p>让我们看一下，<code>pD-&gt;DoSomething()</code>和<code>pB-&gt;DoSomething()</code>调用的是同一个函数吗？</p>
<blockquote>
<p>不是的，虽然pD和pB都指向同一个对象。因为函数DoSomething是一个no-virtual函数，它是静态绑定的，也就是编译器会在编译期根据对象的静态类型来选择函数。pD的静态类型是D<em>，那么编译器在处理<code>pD-&gt;DoSomething()</code>的时候会将它指向<code>D::DoSomething()</code>。同理，pB的静态类型是B</em>，那<code>pB-&gt;DoSomething()</code>调用的就是<code>B::DoSomething()</code>。</p>
</blockquote>
<p>让我们再来看一下，<code>pD-&gt;vfun()</code>和<code>pB-&gt;vfun()</code>调用的是同一个函数吗？</p>
<blockquote>
<p>是的。因为vfun是一个虚函数，它动态绑定的，也就是说它绑定的是对象的动态类型，pB和pD虽然静态类型不同，但是他们同时指向一个对象，他们的动态类型是相同的，都是D*，所以，他们的调用的是同一个函数：<code>D::vfun()</code>。</p>
</blockquote>
<p>上面都是针对对象指针的情况，对于引用（reference）的情况同样适用。</p>
<p>指针和引用的动态类型和静态类型可能会不一致，但是对象的动态类型和静态类型是一致的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D D;</span><br><span class="line">D.DoSomething()和D.vfun()永远调用的都是D::DoSomething()和D::vfun()。</span><br></pre></td></tr></table></figure></p>
<p>我总结了一句话：只有虚函数才使用的是动态绑定，其他的全部是静态绑定。目前我还没有发现不适用这句话的，如果有错误，希望你可以指出来。</p>
<p><strong>特别需要注意的地方</strong></p>
<p>当缺省参数和虚函数一起出现的时候情况有点复杂，极易出错。我们知道，虚函数是动态绑定的，但是为了执行效率，缺省参数是静态绑定的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfun</span><span class="params">(<span class="keyword">int</span> i = <span class="number">10</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfun</span><span class="params">(<span class="keyword">int</span> i = <span class="number">20</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">D* pD = <span class="keyword">new</span> D();</span><br><span class="line">B* pB = pD;</span><br><span class="line">pD-&gt;vfun();</span><br><span class="line">pB-&gt;vfun();</span><br></pre></td></tr></table></figure></p>
<p>有上面的分析可知<code>pD-&gt;vfun()</code>和<code>pB-&gt;vfun()</code>调用都是函数<code>D::vfun()</code>，但是他们的缺省参数是多少？</p>
<blockquote>
<p>分析一下，缺省参数是静态绑定的，<code>pD-&gt;vfun()</code>时，pD的静态类型是<code>D*</code>，所以它的缺省参数应该是20；同理，<code>pB-&gt;vfun()</code>的缺省参数应该是10。编写代码验证了一下，正确。</p>
</blockquote>
<p>对于这个特性，估计没有人会喜欢。所以，永远记住：</p>
<blockquote>
<p>绝不重新定义继承而来的缺省参数（Never redefine function’s inherited default parameters value.）</p>
</blockquote>
<h1 id="mem函数的类型及用法"><a href="#mem函数的类型及用法" class="headerlink" title="mem函数的类型及用法"></a>mem函数的类型及用法</h1><p><code>memccpy</code>函数原型:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>   *<span class="title">memccpy</span><span class="params">(<span class="keyword">void</span>   *dest,   <span class="keyword">const</span>   <span class="keyword">void</span>   *src,   <span class="keyword">int</span>   c,   <span class="keyword">size_t</span>   n)</span></span></span><br></pre></td></tr></table></figure></p>
<p>函数功能:字符串拷贝，到指定长度或遇到指定字符时停止拷贝</p>
<p>参数说明:           src-源字符串指针，c-中止拷贝检查字符，n-长度,dest-拷贝底目的字符串指针 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">&lt;string.h&gt;; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">&lt;stdio.h&gt;; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span>   *src= <span class="string">"This   is   the   source   string "</span>; </span><br><span class="line">    <span class="keyword">char</span>   dest[<span class="number">50</span>]; </span><br><span class="line">    <span class="keyword">char</span>   *ptr; </span><br><span class="line">    ptr=memccpy(dest,src, 'c ',strlen(src)); </span><br><span class="line">    <span class="keyword">if</span>   (ptr) </span><br><span class="line">    &#123; </span><br><span class="line">        *ptr= '\0 '; </span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">"The   character   was   found:%s "</span>,dest); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"The   character   wasn 't   found "</span>); </span><br><span class="line">    <span class="keyword">return</span>   <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>memchr</code>函数原型:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>   *<span class="title">memchr</span><span class="params">(<span class="keyword">const</span>   <span class="keyword">void</span>   *s,   <span class="keyword">int</span>   c,   <span class="keyword">size_t</span>   n)</span></span></span><br></pre></td></tr></table></figure></p>
<p>在字符串中第开始n个字符中寻找某个字符c的位置 </p>
<p>函数返回:           返回c的位置指针，返回NULL时表示未找到 </p>
<p>参数说明:           s-要搜索的字符串，c-要寻找的字符，n-指定长度 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">&lt;string.h&gt;; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">&lt;stdio.h&gt;; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span>   str[<span class="number">17</span>]; </span><br><span class="line">    <span class="keyword">char</span>   *ptr; </span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">"This   is   a   string "</span>); </span><br><span class="line">    ptr=memchr(str, 'r ',strlen(str)); </span><br><span class="line">    <span class="keyword">if</span>(ptr) </span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">"The   character   'r '   is   at   position:%d "</span>,ptr-str); </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">"The   character   was   not   found "</span>); </span><br><span class="line">    <span class="keyword">return</span>   <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>memcmp</code>函数原型:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span>   <span class="keyword">void</span>   *s1,   <span class="keyword">const</span>   <span class="keyword">void</span>   *s2,   <span class="keyword">size_t</span>   n)</span></span></span><br></pre></td></tr></table></figure></p>
<p>函数功能:           按字典顺序对字符串s1,s2比较，并只比较前n个字符 </p>
<p>函数返回:           返回数值表示比较结果 </p>
<p>参数说明:           s1,s2-要比较的字符串，n-比较的长度 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">auto</span>   <span class="keyword">char</span>   buffer[<span class="number">80</span>]; </span><br><span class="line">    <span class="built_in">strcpy</span>(buffer, <span class="string">"world "</span>); </span><br><span class="line">    <span class="keyword">if</span>(   <span class="built_in">memcmp</span>(buffer, <span class="string">"would   "</span>,<span class="number">6</span>)&lt;<span class="number">0</span>)&#123; </span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">"Less   than\n "</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span>   <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>memicmp</code>函数原型:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>   <span class="title">memicmp</span><span class="params">(<span class="keyword">const</span>   <span class="keyword">void</span>   *s1,   <span class="keyword">const</span>   <span class="keyword">void</span>   *s2,   <span class="keyword">size_t</span>   n)</span></span></span><br></pre></td></tr></table></figure></p>
<p>函数功能:           按字典顺序、不考虑字母大小写对字符串s1,s2比较，并只比较前n个字符 </p>
<p>函数返回:           返回数值表示比较结果 </p>
<p>参数说明:           s1,s2-要比较的字符串，n-比较的长度 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span>   *buf1   =   <span class="string">"ABCDE123 "</span>; </span><br><span class="line">    <span class="keyword">char</span>   *buf2   =   <span class="string">"abcde456 "</span>; </span><br><span class="line">    <span class="keyword">int</span>   stat; </span><br><span class="line">    stat   =   memicmp(buf1,   buf2,   <span class="number">5</span>); </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"The   strings   to   position   5   are   "</span>); </span><br><span class="line">    <span class="keyword">if</span>(stat) </span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">"not "</span>); </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"the   same "</span>); </span><br><span class="line">    <span class="keyword">return</span>   <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>memcpy</code>函数原型:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>   *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span>   *dest,   <span class="keyword">const</span>   <span class="keyword">void</span>   *src,   <span class="keyword">size_t</span>   n)</span></span></span><br></pre></td></tr></table></figure></p>
<p>函数功能:           字符串拷贝 </p>
<p>函数返回:           指向dest的指针 </p>
<p>参数说明:           src-源字符串，n-拷贝的最大长度 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span>   src[]   =   <span class="string">"****************************** "</span>; </span><br><span class="line">    <span class="keyword">char</span>   dest[]   =   <span class="string">"abcdefghijlkmnopqrstuvwxyz0123456709 "</span>; </span><br><span class="line">    <span class="keyword">char</span>   *ptr; </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"destination   before   memcpy:   %s "</span>,dest); </span><br><span class="line">    ptr=<span class="built_in">memcpy</span>(dest,src,<span class="built_in">strlen</span>(src)); </span><br><span class="line">    <span class="keyword">if</span>(ptr) </span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">"destination   after   memcpy:%s "</span>,dest); </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">"memcpy   failed "</span>); </span><br><span class="line">    <span class="keyword">return</span>   <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>memmove</code>函数原型:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>   *<span class="title">memmove</span><span class="params">(<span class="keyword">void</span>   *dest,   <span class="keyword">const</span>   <span class="keyword">void</span>   *src,   <span class="keyword">size_t</span>   n)</span></span></span><br></pre></td></tr></table></figure></p>
<p>函数功能:           字符串拷贝 </p>
<p>函数返回:           指向dest的指针 </p>
<p>参数说明:           src-源字符串，n-拷贝的最大长度 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span>   dest[<span class="number">40</span>]= <span class="string">"abcdefghijklmnopqrstuvwxyz0123456789 "</span>; </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"destination   prior   to   memmove:%s\n "</span>,dest); </span><br><span class="line">    memmove(dest+<span class="number">1</span>,dest,<span class="number">35</span>); </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"destination   after   memmove:%s "</span>,dest); </span><br><span class="line">    <span class="keyword">return</span>   <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>memset</code>函数原型:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>   *<span class="title">memset</span><span class="params">(<span class="keyword">void</span>   *s,   <span class="keyword">int</span>   c,   <span class="keyword">size_t</span>   n)</span></span></span><br></pre></td></tr></table></figure></p>
<p>函数功能:           字符串中的n个字节内容设置为c </p>
<p>参数说明:           s-要设置的字符串，c-设置的内容，n-长度 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>   <span class="meta-string">&lt;mem.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span>   buffer[]   =   <span class="string">"Hello   world "</span>; </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"Buffer   before   memset:%s "</span>,buffer); </span><br><span class="line">    memset(buffer, '* ',strlen(buffer)-1); </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"Buffer   after   memset:%s "</span>,buffer); </span><br><span class="line">    <span class="keyword">return</span>   <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数的重载、隐藏和覆盖"><a href="#函数的重载、隐藏和覆盖" class="headerlink" title="函数的重载、隐藏和覆盖"></a>函数的重载、隐藏和覆盖</h1><p>函数重载只会发生在同一个类中，函数名相同，只能通过参数类型，参数个数或者有无const来区分。不能通过返回值类型区分，而且virtual也是可有可无的，即虚函数和普通函数在同一类中也可以构成函数重载。</p>
<p>基类和派生类中只能是隐藏或者覆盖。</p>
<ol>
<li>隐藏是指派生类中有函数与基类中函数同名，但是没有构成虚函数覆盖，就是隐藏。隐藏的表现：若基类中函数func()被派生类中函数func()隐藏，那么无法通过派生类对象访问基类中的func() 函数，派生类对象只能访问到派生类中的func()函数。不过基类中的func()确实继承到了派生类中。</li>
<li>虚函数也只是在基类和派生类中发挥多态的作用，而在同一类中虚函数也可以重载。</li>
</ol>
<p>虚函数实现多态的条件：</p>
<ul>
<li>基类中将这些成员声明为virtual。</li>
<li>基类和派生类中的这些函数必须同名且参数类型，参数个数，返回值类型必须相同。</li>
<li>将派生类的对象赋给基类指针或者引用，实现多态。</li>
</ul>
<p>缺少任何一条，只会是基类和派生类之间的隐藏，而不是覆盖</p>
<p>如何判断基类和派生类中函数是否是隐藏？当基类和派生类存在同名函数，不论参数类型，参数个数是否相同，派生类中的同名函数都会将基类中的同名函数隐藏掉。</p>
<ul>
<li>基类和派生类都是虚函数，并且同名，但是形参类型或者形参个数不同，多态不满足，但是构成了隐藏，只是没有虚特性。</li>
<li>基类中不是虚函数，派生类中定义为虚函数，不构成多态，只是隐藏关系。 </li>
<li>基类和派生类的两个函数同名，都是虚函数，形参的个数和类型也都相同，但是返回值类型不同，这时编译会报错，因为两个虚函数在隐藏时，返回值类型发生了冲突，因此隐藏发生错误。注意，如果这两个函数不是虚函数，这不会报错，隐藏会成功；同时，如果派生类中是虚函数，基类中不是虚函数，也不过报错，隐藏也是成功的。但是如果基类中为虚函数，派生类中不是，也会报错。这些说明，虚化并隐藏时，返回值类型一定要保持相同。</li>
</ul>
<p>虚函数要求返回值类型也一样，但是有一种情况允许虚函数返回值时本类对象的引用或者指针，也可以构成覆盖。这个是“协变”规则，具体协变看例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span>  A* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="string">"A"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span>  B* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="string">"B"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *pa=<span class="keyword">new</span> B;</span><br><span class="line">    B* pb=pa-&gt;func();<span class="comment">//编译无法通过，因为pa是A*类型指针，编译时，对于pa-&gt;func()翻译成调用的是A类的函数，返回值为 A*类型。而A*类型无法赋值给派生类指针</span></span><br><span class="line">    B* pb=(B*)pa-&gt;func();<span class="comment">//正确</span></span><br><span class="line">    B* pb=(B*)(pa-&gt;func());<span class="comment">//正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>A *pa=new B;</code>对于虚函数将基类指针指向派生类对象，调用派生类的虚函数。该基类指针能解引用的内存空间是继承到派生类中的基类的内存空间。基类指针调用派生类的虚函数，在虚函数中，this指针指向的是派生类本身，也就是在虚函数中将基类指针强制转换成了派生类指针。其实基类指针pa和派生类中的this指针值相同，都是派生类对象的地址。</p>
<p>协变的存在是为了解决返回值的强制类型转换，真正用途是，通过派生类对象调用虚函数，直接返回派生类指针。若无协变，则会返回基类指针，需要再将基类指针强制转换成派生类指针。具体的意思看例子：</p>
<p>若没有协变，那么上述的代码中派生类中虚函数需要改成以下形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span>  A* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"B"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;<span class="comment">//返回值this为B*类型指针，但是因为没有协变，返回的时候将B*类型赋值给了A*类型，然后以A*类型返回到main函数中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    A *pa=b.func();</span><br><span class="line">    B *pb=dynamic&lt;B*&gt; (pa);<span class="comment">//将返回的A*类型强制转换成B*类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译器总是根据类型来调用类成员函数。但是一个派生类的指针可以安全地转化为一个基类的指针。这样删除一个基类的指针的时候，C++不管这个指针指向一个基类对象还是一个派生类的对象，调用的都是基类的析构函数而不是派生类的。如果你依赖于派生类的析构函数的代码来释放资源，而没有重载析构函数，那么会有资源泄漏。所以建议的方式是将<strong>析构函数声明为虚函数</strong>。</p>
<p>也就是<code>delete a</code>的时候，也会执行派生类的析构函数。</p>
<p>一个函数一旦声明为虚函数，那么不管你是否加上virtual修饰符，它在所有派生类中都成为虚函数。但是由于理解明确起见，建议的方式还是加上<code>virtual</code>修饰符。</p>
<p>构造方法用来初始化类的对象，与父类的其它成员不同，它不能被子类继承（子类可以继承父类所有的成员变量和成员方法，但不继承父类的构造方法）。因此，在创建子类对象时，为了初始化从父类继承来的数据成员，系统需要调用其父类的构造方法。</p>
<p>如果没有显式的构造函数，编译器会给一个默认的构造函数，并且该默认的构造函数仅仅在没有显式地声明构造函数情况下创建。</p>
<p>构造原则如下：</p>
<ol>
<li>如果子类没有定义构造方法，则调用父类的无参数的构造方法。</li>
<li>如果子类定义了构造方法，不论是无参数还是带参数，在创建子类的对象的时候,首先执行父类无参数的构造方法，然后执行自己的构造方法。</li>
<li>在创建子类对象时候，如果子类的构造函数没有显示调用父类的构造函数，则会调用父类的默认无参构造函数。</li>
<li>在创建子类对象时候，如果子类的构造函数没有显示调用父类的构造函数且父类自己提供了无参构造函数，则会调用父类自己的无参构造函数。</li>
<li>在创建子类对象时候，如果子类的构造函数没有显示调用父类的构造函数且父类只定义了自己的有参构造函数，则会出错（如果父类只有有参数的构造方法，则子类必须显示调用此带参构造方法）。</li>
<li>如果子类调用父类带参数的构造方法，需要用初始化父类成员对象的方式，比如：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    animal(<span class="keyword">int</span> height, <span class="keyword">int</span> weight)</span><br><span class="line">    &#123;</span><br><span class="line">	    <span class="built_in">cout</span>&lt;&lt;<span class="string">"animal construct"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fish</span>:</span><span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    fish() : animal(<span class="number">400</span>,<span class="number">300</span>), a(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">	    <span class="built_in">cout</span>&lt;&lt;<span class="string">"fish construct"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fish fh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="强制类型转换运算符"><a href="#强制类型转换运算符" class="headerlink" title="强制类型转换运算符"></a>强制类型转换运算符</h1><p>将类型名作为强制类型转换运算符的做法是C语言的老式做法，C++ 为保持兼容而予以保留。</p>
<p>C++ 引入了四种功能不同的强制类型转换运算符以进行强制类型转换：<code>static_cast</code>、<code>reinterpret_cast</code>、<code>const_cast</code>和<code>dynamic_cast</code>。</p>
<p>强制类型转换是有一定风险的，有的转换并不一定安全，如把整型数值转换成指针，把基类指针转换成派生类指针，把一种函数指针转换成另一种函数指针，把常量指针转换成非常量指针等。C++ 引入新的强制类型转换机制，主要是为了克服C语言强制类型转换的以下三个缺点。</p>
<ul>
<li>没有从形式上体现转换功能和风险的不同。例如，将 int 强制转换成 double 是没有风险的，而将常量指针转换成非常量指针，将基类指针转换成派生类指针都是高风险的，而且后两者带来的风险不同（即可能引发不同种类的错误），C语言的强制类型转换形式对这些不同并不加以区分。</li>
<li>将多态基类指针转换成派生类指针时不检查安全性，即无法判断转换后的指针是否确实指向一个派生类对象。</li>
<li>难以在程序中寻找到底什么地方进行了强制类型转换。</li>
</ul>
<p>强制类型转换是引发程序运行时错误的一个原因，因此在程序出错时，可能就会想到是不是有哪些强制类型转换出了问题。</p>
<p>如果采用C语言的老式做法，要在程序中找出所有进行了强制类型转换的地方，显然是很麻烦的，因为这些转换没有统一的格式。</p>
<p>而用 C++ 的方式，则只需要查找_cast字符串就可以了。甚至可以根据错误的类型，有针对性地专门查找某一种强制类型转换。例如，怀疑一个错误可能是由于使用了 reinterpret_cast 导致的，就可以只查找reinterpret_cast字符串。</p>
<p>C++ 强制类型转换运算符的用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">强制类型转换运算符 &lt;要转换到的类型&gt; (待转换的表达式)</span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="keyword">static_cast</span> &lt;<span class="keyword">double</span>&gt; (<span class="number">3</span>*<span class="number">5</span>);  <span class="comment">//将 3*5 的值转换成实数</span></span><br></pre></td></tr></table></figure></p>
<p>下面分别介绍四种强制类型转换运算符。</p>
<h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><p>static_cast用于进行比较“自然”和低风险的转换，如整型和浮点型、字符型之间的互相转换。另外，如果对象所属的类重载了强制类型转换运算符 T（如 T 是 int、int* 或其他类型名），则 static_cast 也能用来进行对象到 T 类型的转换。</p>
<p>static_cast 不能用于在不同类型的指针之间互相转换，也不能用于整型和指针之间的互相转换，当然也不能用于不同类型的引用之间的转换。因为这些属于风险比较高的转换。</p>
<p>static_cast 用法示例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="keyword">char</span>*() &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span>* p = <span class="string">"New Dragon Inn"</span>;</span><br><span class="line">    n = <span class="keyword">static_cast</span> &lt;<span class="keyword">int</span>&gt; (<span class="number">3.14</span>);  <span class="comment">// n 的值变为 3</span></span><br><span class="line">    n = <span class="keyword">static_cast</span> &lt;<span class="keyword">int</span>&gt; (a);  <span class="comment">//调用 a.operator int，n 的值变为 1</span></span><br><span class="line">    p = <span class="keyword">static_cast</span> &lt;<span class="keyword">char</span>*&gt; (a);  <span class="comment">//调用 a.operator char*，p 的值变为 NULL</span></span><br><span class="line">    n = <span class="keyword">static_cast</span> &lt;<span class="keyword">int</span>&gt; (p);  <span class="comment">//编译错误，static_cast不能将指针转换成整型</span></span><br><span class="line">    p = <span class="keyword">static_cast</span> &lt;<span class="keyword">char</span>*&gt; (n);  <span class="comment">//编译错误，static_cast 不能将整型转换成指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><p>reinterpret_cast 用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换。转换时，执行的是逐个比特复制的操作。</p>
<p>这种转换提供了很强的灵活性，但转换的安全性只能由程序员的细心来保证了。例如，程序员执意要把一个 int<em> 指针、函数指针或其他类型的指针转换成 string</em> 类型的指针也是可以的，至于以后用转换后的指针调用 string 类的成员函数引发错误，程序员也只能自行承担查找错误的烦琐工作：（C++ 标准不允许将函数指针转换成对象指针，但有些编译器，如 Visual Studio 2010，则支持这种转换）。</p>
<p>reinterpret_cast 用法示例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    A(<span class="keyword">int</span> n):i(n),j(n) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> &amp;r = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(a); <span class="comment">//强行让 r 引用 a</span></span><br><span class="line">    r = <span class="number">200</span>;  <span class="comment">//把 a.i 变成了 200</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.i &lt;&lt; <span class="string">","</span> &lt;&lt; a.j &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出 200,100</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">300</span>;</span><br><span class="line">    A *pa = <span class="keyword">reinterpret_cast</span>&lt;A*&gt; ( &amp; n); <span class="comment">//强行让 pa 指向 n</span></span><br><span class="line">    pa-&gt;i = <span class="number">400</span>;  <span class="comment">// n 变成 400</span></span><br><span class="line">    pa-&gt;j = <span class="number">500</span>;  <span class="comment">//此条语句不安全，很可能导致程序崩溃</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出 400</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> la = <span class="number">0x12345678abcd</span>LL;</span><br><span class="line">    pa = <span class="keyword">reinterpret_cast</span>&lt;A*&gt;(la); <span class="comment">//la太长，只取低32位0x5678abcd拷贝给pa</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> u = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(pa);<span class="comment">//pa逐个比特拷贝到u</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hex &lt;&lt; u &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//输出 5678abcd</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(* PF1)</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(* PF2)</span> <span class="params">(<span class="keyword">int</span>,<span class="keyword">char</span> *)</span></span>;</span><br><span class="line">    PF1 pf1;  PF2 pf2;</span><br><span class="line">    pf2 = <span class="keyword">reinterpret_cast</span>&lt;PF2&gt;(pf1); <span class="comment">//两个不同类型的函数指针之间可以互相转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序的输出结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">200, 100</span><br><span class="line">400</span><br><span class="line">5678abed</span><br></pre></td></tr></table></figure></p>
<p>第 19 行的代码不安全，因为在编译器看来，pa-&gt;j 的存放位置就是 n 后面的 4 个字节。 本条语句会向这 4 个字节中写入 500。但这 4 个字节不知道是用来存放什么的，贸然向其中写入可能会导致程序错误甚至崩溃。</p>
<p>上面程序中的各种转换都没有实际意义，只是为了演示 reinteipret_cast 的用法而已。在编写黑客程序、病毒或反病毒程序时，也许会用到这样怪异的转换。</p>
<p>reinterpret_cast体现了 C++ 语言的设计思想：用户可以做任何操作，但要为自己的行为负责。</p>
<h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>const_cast 运算符仅用于进行去除 const 属性的转换，它也是四个强制类型转换运算符中唯一能够去除 const 属性的运算符。</p>
<p>将 const 引用转换为同类型的非 const 引用，将 const 指针转换为同类型的非 const 指针时可以使用 const_cast 运算符。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> s = <span class="string">"Inception"</span>;</span><br><span class="line"><span class="built_in">string</span>&amp; p = <span class="keyword">const_cast</span> &lt;<span class="built_in">string</span>&amp;&gt; (s);</span><br><span class="line"><span class="built_in">string</span>* ps = <span class="keyword">const_cast</span> &lt;<span class="built_in">string</span>*&gt; (&amp;s);  <span class="comment">// &amp;s 的类型是 const string*</span></span><br></pre></td></tr></table></figure></p>
<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><p>用 reinterpret_cast 可以将多态基类（包含虚函数的基类）的指针强制转换为派生类的指针，但是这种转换不检查安全性，即不检查转换后的指针是否确实指向一个派生类对象。dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针。</p>
<p>dynamic_cast 是通过“运行时类型检查”来保证安全性的。dynamic_cast 不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用——这种转换没法保证安全性，只好用 reinterpret_cast 来完成。</p>
<p>dynamic_cast 示例程序如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span>  <span class="comment">//有虚函数，因此是多态基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    Derived d;</span><br><span class="line">    Derived* pd;</span><br><span class="line">    pd = <span class="keyword">reinterpret_cast</span> &lt;Derived*&gt; (&amp;b);</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">//此处pd不会为 NULL。reinterpret_cast不检查安全性，总是进行转换</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"unsafe reinterpret_cast"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//不会执行</span></span><br><span class="line">    pd = <span class="keyword">dynamic_cast</span> &lt;Derived*&gt; (&amp;b);</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)  <span class="comment">//结果会是NULL，因为 &amp;b 不指向派生类对象，此转换不安全</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"unsafe dynamic_cast1"</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//会执行</span></span><br><span class="line">    pd = <span class="keyword">dynamic_cast</span> &lt;Derived*&gt; (&amp;d);  <span class="comment">//安全的转换</span></span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)  <span class="comment">//此处 pd 不会为 NULL</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"unsafe dynamic_cast2"</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//不会执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序的输出结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsafe dynamic_cast1</span><br></pre></td></tr></table></figure></p>
<p>第 20 行，通过判断 pd 的值是否为 NULL，就能知道第 19 行进行的转换是否是安全的。第 23 行同理。</p>
<p>如果上面的程序中出现了下面的语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derived &amp; r = <span class="keyword">dynamic_cast</span> &lt;Derived &amp;&gt; (b);</span><br></pre></td></tr></table></figure></p>
<p>那该如何判断该转换是否安全呢？不存在空引用，因此不能通过返回值来判断转换是否安全。C++ 的解决办法是：dynamic_cast 在进行引用的强制转换时，如果发现转换不安全，就会拋出一个异常，通过处理异常，就能发现不安全的转换。</p>
<h1 id="attribute二三事"><a href="#attribute二三事" class="headerlink" title="attribute二三事"></a><strong>attribute</strong>二三事</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> skew_heap_entry_t *<span class="title">skew_heap_insert</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">skew_heap_entry_t</span> *a, <span class="keyword">skew_heap_entry_t</span> *b,</span></span></span><br><span class="line"><span class="function"><span class="params">     compare_f comp)</span> __<span class="title">attribute__</span><span class="params">((always_inline))</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个函数是在做uCore的时候发现的，有一个特别的地方<strong><strong>attribute</strong>((always_inline))</strong>，之前从来没见过，于是去查了一下，不查不知道，一查下一跳啊，这竟然是GUN C的一个从来没听过的属性。</p>
<p>当我们用<code>__inline__ __attribute__((always_inline))</code>修饰一个函数的时候,编译器会将我们的代码编译.在调用的地方将我们的函数,插入到调用的地方.</p>
<p>attribute是GNU C特色之一,在iOS用的比较广泛.系统中有许多地方使用到. attribute可以设置函数属性（Function Attribute ）、变量属性（Variable Attribute ）和类型属性（Type Attribute)等.</p>
<h2 id="函数属性-Function-Attribute"><a href="#函数属性-Function-Attribute" class="headerlink" title="函数属性(Function Attribute)"></a>函数属性(Function Attribute)</h2><ul>
<li>noreturn</li>
<li>noinline</li>
<li>always_inline</li>
<li>pure</li>
<li>const</li>
<li>nothrow</li>
<li>sentinel</li>
<li>format</li>
<li>format_arg</li>
<li>no_instrument_function</li>
<li>section</li>
<li>constructor</li>
<li>destructor</li>
<li>used</li>
<li>unused</li>
<li>deprecated</li>
<li>weak</li>
<li>malloc</li>
<li>alias</li>
<li>warn_unused_result</li>
<li>nonnull</li>
</ul>
<h2 id="类型属性-Type-Attributes"><a href="#类型属性-Type-Attributes" class="headerlink" title="类型属性(Type Attributes)"></a>类型属性(Type Attributes)</h2><ul>
<li>aligned</li>
<li>packed</li>
<li>transparent_union,</li>
<li>unused,</li>
<li>deprecated</li>
<li>may_alias</li>
</ul>
<h2 id="变量属性-Variable-Attribute"><a href="#变量属性-Variable-Attribute" class="headerlink" title="变量属性(Variable Attribute)"></a>变量属性(Variable Attribute)</h2><ul>
<li>aligned</li>
<li>packed</li>
</ul>
<h2 id="Clang特有的"><a href="#Clang特有的" class="headerlink" title="Clang特有的"></a>Clang特有的</h2><ul>
<li>availability</li>
<li>overloadable</li>
</ul>
<h2 id="书写格式"><a href="#书写格式" class="headerlink" title="书写格式"></a>书写格式</h2><p>书写格式：attribute后面会紧跟一对原括弧，括弧里面是相应的attribute参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__(xxx)</span><br></pre></td></tr></table></figure></p>
<h2 id="常见的系统用法"><a href="#常见的系统用法" class="headerlink" title="常见的系统用法"></a>常见的系统用法</h2><h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NS_FORMAT_FUNCTION(F,A) __attribute__((format(__NSString__, F, A)))</span></span><br></pre></td></tr></table></figure>
<p>format属性可以给被声明的函数加上类似printf或者scanf的特征，它可以使编译器检查函数声明和函数实际调用参数之间的格式化字符串是否匹配。该功能十分有用，尤其是处理一些很难发现的bug。对于format参数的使用如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">format (archetype, <span class="built_in">string</span>-index, first-to-check)</span><br></pre></td></tr></table></figure></p>
<p>第一参数需要传递“archetype”指定是哪种风格,这里是 NSString；“string-index”指定传入函数的第几个参数是格式化字符串；“first-to-check”指定第一个可变参数所在的索引.</p>
<h3 id="noreturn"><a href="#noreturn" class="headerlink" title="noreturn"></a>noreturn</h3><p>官方例子: abort() 和 exit()</p>
<p>该属性通知编译器函数从不返回值。当遇到类似函数还未运行到return语句就需要退出来的情况，该属性可以避免出现错误信息。</p>
<h3 id="availability"><a href="#availability" class="headerlink" title="availability"></a>availability</h3><p>官方例子:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (CGSize)sizeWithFont:(UIFont *)<span class="function">font <span class="title">NS_DEPRECATED_IOS</span><span class="params">(<span class="number">2</span>_0, <span class="number">7</span>_0, <span class="string">"Use -sizeWithAttributes:"</span>)</span> __TVOS_PROHIBITED</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//来看一下 后边的宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NS_DEPRECATED_IOS(_iosIntro, _iosDep, ...) CF_DEPRECATED_IOS(_iosIntro, _iosDep, __VA_ARGS__)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CF_DEPRECATED_IOS(_iosIntro, _iosDep, ...) __attribute__((availability(ios,introduced=_iosIntro,deprecated=_iosDep,message=<span class="meta-string">""</span> __VA_ARGS__)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//宏展开以后如下</span></span><br><span class="line">__attribute__((availability(ios,introduced=<span class="number">2</span>_0,deprecated=<span class="number">7</span>_0,message=<span class="string">""</span>__VA_ARGS__)));</span><br><span class="line"><span class="comment">//ios即是iOS平台</span></span><br><span class="line"><span class="comment">//introduced 从哪个版本开始使用</span></span><br><span class="line"><span class="comment">//deprecated 从哪个版本开始弃用</span></span><br><span class="line"><span class="comment">//message    警告的消息</span></span><br></pre></td></tr></table></figure></p>
<p>availability属性是一个以逗号为分隔的参数列表，以平台的名称开始，包含一些放在附加信息里的一些里程碑式的声明。</p>
<ul>
<li>introduced：第一次出现的版本。</li>
<li>deprecated：声明要废弃的版本，意味着用户要迁移为其他API</li>
<li>obsoleted： 声明移除的版本，意味着完全移除，再也不能使用它</li>
<li>unavailable：在这些平台不可用</li>
<li>message：一些关于废弃和移除的额外信息，clang发出警告的时候会提供这些信息，对用户使用替代的API非常有用。</li>
<li>这个属性支持的平台：ios，macosx。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果经常用,建议定义成类似系统的宏</span></span><br><span class="line">- (<span class="keyword">void</span>)oldMethod:(NSString *)<span class="built_in">string</span> __attribute__((availability(ios,introduced=<span class="number">2</span>_0,deprecated=<span class="number">7</span>_0,message=<span class="string">"用 -newMethod: 这个方法替代 "</span>)))&#123;</span><br><span class="line">    NSLog(@<span class="string">"我是旧方法,不要调我"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)newMethod:(NSString *)<span class="built_in">string</span>&#123;</span><br><span class="line">    NSLog(@<span class="string">"我是新方法"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="visibility"><a href="#visibility" class="headerlink" title="visibility"></a>visibility</h3><p>语法:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((visibility(<span class="string">"visibility_type"</span>)))</span><br></pre></td></tr></table></figure></p>
<p>其中，visibility_type 是下列值之一：</p>
<ul>
<li>default:假定的符号可见性可通过其他选项进行更改。缺省可见性将覆盖此类更改。缺省可见性与外部链接对应。</li>
<li>hidden:该符号不存放在动态符号表中，因此，其他可执行文件或共享库都无法直接引用它。使用函数指针可进行间接引用。</li>
<li>internal:除非由特定于处理器的应用二进制接口 (psABI) 指定，否则，内部可见性意味着不允许从另一模块调用该函数。</li>
<li>protected:该符号存放在动态符号表中，但定义模块内的引用将与局部符号绑定。也就是说，另一模块无法覆盖该符号。</li>
</ul>
<p>除指定 default 可见性外，此属性都可与在这些情况下具有外部链接的声明结合使用。<br>您可在 C 和 C++ 中使用此属性。在 C++ 中，还可将它应用于类型、成员函数和命名空间声明。</p>
<p>系统用法:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  UIKIT_EXTERN     extern</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> UIKIT_EXTERN        extern <span class="meta-string">"C"</span> __attribute__((visibility (<span class="meta-string">"default"</span>)))</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">define</span> UIKIT_EXTERN            extern __attribute__((visibility (<span class="meta-string">"default"</span>)))</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="nonnull"><a href="#nonnull" class="headerlink" title="nonnull"></a>nonnull</h3><p>编译器对函数参数进行NULL的检查,参数类型必须是指针类型(包括对象)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">int</span>)addNum1:(<span class="keyword">int</span> *)num1 num2:(<span class="keyword">int</span> *)num2  __attribute__((nonnull (<span class="number">1</span>,<span class="number">2</span>)))&#123;<span class="comment">//1,2表示第一个和第二个参数不能为空</span></span><br><span class="line">    <span class="keyword">return</span>  *num1 + *num2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (NSString *)getHost:(NSURL *)url __attribute__((nonnull (<span class="number">1</span>)))&#123;<span class="comment">//第一个参数不能为空</span></span><br><span class="line">    <span class="keyword">return</span> url.host;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h2><h3 id="aligned"><a href="#aligned" class="headerlink" title="aligned"></a>aligned</h3><p><code>__attribute((aligned (n)))</code>，让所作用的结构成员对齐在n字节自然边界上。如果结构中有成员的长度大于n，则按照最大成员的长度来对齐.例如:</p>
<p>不加修饰的情况<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>  member1;</span><br><span class="line">    <span class="keyword">int</span>   member2;</span><br><span class="line">    <span class="keyword">short</span> member3;</span><br><span class="line">&#125;Family;</span><br></pre></td></tr></table></figure></p>
<p>输出字节:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;Family size is %zd&quot;,sizeof(Family));</span><br></pre></td></tr></table></figure></p>
<p>输出结果为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-07-25 10:28:45.380 Study[917:436064] Family size is 12</span><br></pre></td></tr></table></figure></p>
<p>修改字节对齐为1<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>  member1;</span><br><span class="line">    <span class="keyword">int</span>   member2;</span><br><span class="line">    <span class="keyword">short</span> member3;</span><br><span class="line">&#125;__attribute__ ((aligned (<span class="number">1</span>))) Family;</span><br></pre></td></tr></table></figure></p>
<p>输出字节:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;Family size is %zd&quot;,sizeof(Family));</span><br></pre></td></tr></table></figure></p>
<p>输出结果为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-07-25 10:28:05.315 Study[914:435764] Family size is 12</span><br></pre></td></tr></table></figure></p>
<p>和上面的结果一致,因为设定的字节对齐为1.而结构体中成员的最大字节数是int 4个字节,1 &lt; 4,按照4字节对齐,和系统默认一致.</p>
<p>修改字节对齐为8<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>  member1;</span><br><span class="line">    <span class="keyword">int</span>   member2;</span><br><span class="line">    <span class="keyword">short</span> member3;</span><br><span class="line">&#125;__attribute__ ((aligned (<span class="number">8</span>))) Family;</span><br></pre></td></tr></table></figure></p>
<p>输出字节:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;Family size is %zd&quot;,sizeof(Family));</span><br></pre></td></tr></table></figure></p>
<p>输出结果为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-07-25 10:28:05.315 Study[914:435764] Family size is 16</span><br></pre></td></tr></table></figure></p>
<p>这里 8 &gt; 4,按照8字节对齐,结果为16。</p>
<p>可是想了半天,也不知道这玩意有什么用,设定值小于系统默认的,和没设定一样,设定大了,又浪费空间,效率也没提高,感觉学习学习就好.</p>
<h3 id="packed"><a href="#packed" class="headerlink" title="packed"></a>packed</h3><p>让指定的结构结构体按照一字节对齐,测试:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不加packed修饰</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>    version;</span><br><span class="line">    <span class="keyword">int16_t</span> sid;</span><br><span class="line">    <span class="keyword">int32_t</span> len;</span><br><span class="line">    <span class="keyword">int64_t</span> time;</span><br><span class="line">&#125; Header;</span><br></pre></td></tr></table></figure></p>
<p>计算长度:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;size is %zd&quot;,sizeof(Header));</span><br></pre></td></tr></table></figure></p>
<p>输出结果为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-07-22 11:53:47.728 Study[14378:5523450] size is 16</span><br></pre></td></tr></table></figure></p>
<p>可以看出,默认系统是按照4字节对齐<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加packed修饰</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>    version;</span><br><span class="line">    <span class="keyword">int16_t</span> sid;</span><br><span class="line">    <span class="keyword">int32_t</span> len;</span><br><span class="line">    <span class="keyword">int64_t</span> time;</span><br><span class="line">&#125;__attribute__ ((packed)) Header;</span><br></pre></td></tr></table></figure></p>
<p>计算长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSLog(@&quot;size is %zd&quot;,sizeof(Header));</span><br></pre></td></tr></table></figure></p>
<p>输出结果为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-07-22 11:57:46.970 Study[14382:5524502] size is 15</span><br></pre></td></tr></table></figure></p>
<p>用packed修饰后,变为1字节对齐,这个常用于与协议有关的网络传输中.</p>
<h3 id="noinline-amp-always-inline"><a href="#noinline-amp-always-inline" class="headerlink" title="noinline &amp; always_inline"></a>noinline &amp; always_inline</h3><p>内联函数:内联函数从源代码层看，有函数的结构，而在编译后，却不具备函数的性质。内联函数不是在调用时发生控制转移，而是在编译时将函数体嵌入在每一个调用处。编译时，类似宏替换，使用函数体替换调用处的函数名。一般在代码中用inline修饰，但是能否形成内联函数，需要看编译器对该函数定义的具体处理。这两个都是用在函数上</p>
<ul>
<li>noinline 不内联</li>
<li>always_inline 总是内联</li>
</ul>
<p>内联的本质是用代码块直接替换掉函数调用处，好处是：快减少系统开销.</p>
<p>使用例子:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> __<span class="title">attribute__</span><span class="params">((always_inline))</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="warn-unused-result"><a href="#warn-unused-result" class="headerlink" title="warn_unused_result"></a>warn_unused_result</h3><p>当函数或者方法的返回值很重要时,要求调用者必须检查或者使用返回值,否则编译器会发出警告提示<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> - (BOOL)availiable __attribute__((warn_unused_result))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="constructor-destructor"><a href="#constructor-destructor" class="headerlink" title="constructor / destructor"></a>constructor / destructor</h3><p>意思是: 构造器和析构器;constructor修饰的函数会在main函数之前执行,destructor修饰的函数会在程序exit前调用.<br>示例如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@<span class="string">"main"</span>);</span><br><span class="line">        <span class="keyword">return</span> UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">    NSLog(@<span class="string">"before main"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">__attribute__((destructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">    NSLog(@<span class="string">"after main"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//在viewController中调用exit</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-07-21 21:49:17.446 Study[14162:5415982] before main</span><br><span class="line">2016-07-21 21:49:17.447 Study[14162:5415982] main</span><br><span class="line">2016-07-21 21:49:17.534 Study[14162:5415982] after main</span><br></pre></td></tr></table></figure></p>
<p>注意点:</p>
<ul>
<li>程序退出的时候才会调用after函数,经测试,手动退出程序会执行</li>
<li>上面两个函数不管写在哪个类里,哪个文件中效果都一样</li>
<li>如果存在多个修饰的函数,那么都会执行,顺序不定</li>
<li>实际上如果存在多个修饰过的函数,可以它们的调整优先级</li>
</ul>
<p>代码如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@<span class="string">"main"</span>);</span><br><span class="line">        <span class="keyword">return</span> UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">__attribute__((constructor(<span class="number">101</span>)))</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">before1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    NSLog(@<span class="string">"before main - 1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((constructor(<span class="number">102</span>)))</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">before2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    NSLog(@<span class="string">"before main - 2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">__attribute__((destructor(<span class="number">201</span>)))</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">after1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    NSLog(@<span class="string">"after main - 1"</span>);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((destructor(<span class="number">202</span>)))</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">after2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    NSLog(@<span class="string">"after main - 2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2016-07-21 21:59:35.622 Study[14171:5418393] before main - 1</span><br><span class="line">2016-07-21 21:59:35.624 Study[14171:5418393] before main - 2</span><br><span class="line">2016-07-21 21:59:35.624 Study[14171:5418393] main</span><br><span class="line">2016-07-21 21:59:35.704 Study[14171:5418393] after main - 2</span><br><span class="line">2016-07-21 21:59:35.704 Study[14171:5418393] after main - 1</span><br></pre></td></tr></table></figure></p>
<p>注意点:</p>
<ul>
<li>括号内的值表示优先级,[0,100]这个返回时系统保留的,自己千万别调用.</li>
<li>根据输出结果可以看出,main函数之前的,数值越小,越先调用;main函数之后的数值越大,越先调用.</li>
<li>当函数声明和函数实现分开写时,格式如下:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> __<span class="title">attribute__</span><span class="params">((constructor))</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>讨论:+load,constructor,main的执行顺序,代码如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load&#123;</span><br><span class="line">    NSLog(@<span class="string">"load"</span>);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">    NSLog(@<span class="string">"before main"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2016-07-21 22:13:58.591 Study[14185:5421811] load</span><br><span class="line">2016-07-21 22:13:58.592 Study[14185:5421811] before main</span><br><span class="line">2016-07-21 22:13:58.592 Study[14185:5421811] main</span><br></pre></td></tr></table></figure></p>
<p>可以看出执行顺序为:<code>load-&gt;constructor-&gt;main</code>。为什么呢?</p>
<p>因为 dyld（动态链接器，程序的最初起点）在加载 image（可以理解成 Mach-O 文件）时会先通知 objc runtime 去加载其中所有的类，每加载一个类时，它的 +load 随之调用，全部加载完成后，dyld 才会调用这个 image 中所有的 constructor 方法,然后才调用main函数.</p>
<h3 id="enable-if"><a href="#enable-if" class="headerlink" title="enable_if"></a>enable_if</h3><p>用来检查参数是否合法,只能用来修饰函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAge</span><span class="params">(<span class="keyword">int</span> age)</span></span></span><br><span class="line"><span class="function">__<span class="title">attribute__</span><span class="params">((enable_if(age &gt; <span class="number">0</span>  &amp;&amp; age &lt; <span class="number">120</span>, <span class="string">"你丫太监?"</span>)))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NSLog(@<span class="string">"%d"</span>,age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>表示只能输入的参数只能是 0 ~ 120左右,否则编译报错.</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/27/Leetcode951_1000/" rel="next" title="Leetcode951 - 1000">
                <i class="fa fa-chevron-left"></i> Leetcode951 - 1000
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/30/cpp模板的特化详解/" rel="prev" title="C++模板的特化详解">
                C++模板的特化详解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">271</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#decltype简介"><span class="nav-number">1.</span> <span class="nav-text">decltype简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#decltype用法"><span class="nav-number">2.</span> <span class="nav-text">decltype用法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#推导出表达式类型"><span class="nav-number">2.1.</span> <span class="nav-text">推导出表达式类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#与using-typedef合用，用于定义类型。"><span class="nav-number">2.2.</span> <span class="nav-text">与using/typedef合用，用于定义类型。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重用匿名类型"><span class="nav-number">2.3.</span> <span class="nav-text">重用匿名类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型编程中结合auto，用于追踪函数的返回值类型"><span class="nav-number">2.4.</span> <span class="nav-text">泛型编程中结合auto，用于追踪函数的返回值类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#decltype推导四规则"><span class="nav-number">3.</span> <span class="nav-text">decltype推导四规则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#reverse函数"><span class="nav-number">4.</span> <span class="nav-text">reverse函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-中constexpr作用"><span class="nav-number">5.</span> <span class="nav-text">C++中constexpr作用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#constexpr修饰普通变量"><span class="nav-number">5.1.</span> <span class="nav-text">constexpr修饰普通变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constexpr修饰函数"><span class="nav-number">5.2.</span> <span class="nav-text">constexpr修饰函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constexpr修饰类的构造函数"><span class="nav-number">5.3.</span> <span class="nav-text">constexpr修饰类的构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constexpr修饰模板函数"><span class="nav-number">5.4.</span> <span class="nav-text">constexpr修饰模板函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#附录"><span class="nav-number">6.</span> <span class="nav-text">附录</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#const的用法"><span class="nav-number">7.</span> <span class="nav-text">const的用法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#const变量"><span class="nav-number">7.1.</span> <span class="nav-text">const变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针与const关键字"><span class="nav-number">7.2.</span> <span class="nav-text">指针与const关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#指向const变量的指针："><span class="nav-number">7.2.1.</span> <span class="nav-text">指向const变量的指针：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const指针"><span class="nav-number">7.2.2.</span> <span class="nav-text">const指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const函数参数和返回类型"><span class="nav-number">7.3.</span> <span class="nav-text">const函数参数和返回类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#const修饰函数返回值"><span class="nav-number">7.3.1.</span> <span class="nav-text">const修饰函数返回值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将类数据成员定义为const"><span class="nav-number">7.4.</span> <span class="nav-text">将类数据成员定义为const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#把类对象定义为const"><span class="nav-number">7.5.</span> <span class="nav-text">把类对象定义为const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将类的成员函数定义为const"><span class="nav-number">7.6.</span> <span class="nav-text">将类的成员函数定义为const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于const的疑问："><span class="nav-number">7.7.</span> <span class="nav-text">关于const的疑问：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const与-define的区别："><span class="nav-number">7.8.</span> <span class="nav-text">const与#define的区别：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#宏定义-define的理解与资料整理"><span class="nav-number">8.</span> <span class="nav-text">宏定义#define的理解与资料整理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#利用define来定义-数值宏常量"><span class="nav-number">8.1.</span> <span class="nav-text">利用define来定义 数值宏常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用define来定义-字符串宏常量"><span class="nav-number">8.2.</span> <span class="nav-text">利用define来定义 字符串宏常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用define-宏定义注释符号"><span class="nav-number">8.3.</span> <span class="nav-text">用define 宏定义注释符号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用define-宏定义表达式"><span class="nav-number">8.4.</span> <span class="nav-text">用define 宏定义表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#宏定义中的空格"><span class="nav-number">8.5.</span> <span class="nav-text">宏定义中的空格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undef"><span class="nav-number">8.6.</span> <span class="nav-text">undef</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#new-操作符"><span class="nav-number">9.</span> <span class="nav-text">new 操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#operator-new"><span class="nav-number">9.1.</span> <span class="nav-text">operator new</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#placement-new"><span class="nav-number">9.2.</span> <span class="nav-text">placement new</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">9.3.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Deletion-and-Memory-Deallocation"><span class="nav-number">9.4.</span> <span class="nav-text">Deletion and Memory Deallocation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">9.5.</span> <span class="nav-text">数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#static关键字"><span class="nav-number">10.</span> <span class="nav-text">static关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#作用"><span class="nav-number">10.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全局变量和static变量的区别"><span class="nav-number">10.2.</span> <span class="nav-text">全局变量和static变量的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static-变量"><span class="nav-number">10.3.</span> <span class="nav-text">static 变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static-成员变量"><span class="nav-number">10.4.</span> <span class="nav-text">static 成员变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static-函数"><span class="nav-number">10.5.</span> <span class="nav-text">static 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static-成员函数"><span class="nav-number">10.6.</span> <span class="nav-text">static 成员函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vector和set使用sort方法进行排序"><span class="nav-number">11.</span> <span class="nav-text">vector和set使用sort方法进行排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对vector使用sort函数"><span class="nav-number">11.1.</span> <span class="nav-text">对vector使用sort函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#restrict与GCC的编译优化"><span class="nav-number">12.</span> <span class="nav-text">restrict与GCC的编译优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile"><span class="nav-number">13.</span> <span class="nav-text">volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#why-volatile"><span class="nav-number">13.1.</span> <span class="nav-text">why volatile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IN-C-C"><span class="nav-number">13.2.</span> <span class="nav-text">IN C/C++</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#易变的"><span class="nav-number">13.3.</span> <span class="nav-text">易变的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不可优化的"><span class="nav-number">13.4.</span> <span class="nav-text">不可优化的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序执行的"><span class="nav-number">13.5.</span> <span class="nav-text">顺序执行的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile与多线程语义"><span class="nav-number">13.6.</span> <span class="nav-text">volatile与多线程语义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不保证原子性"><span class="nav-number">13.7.</span> <span class="nav-text">不保证原子性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#inline-内联函数"><span class="nav-number">14.</span> <span class="nav-text">inline 内联函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内联函数和宏定义的区别"><span class="nav-number">14.1.</span> <span class="nav-text">内联函数和宏定义的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主要区别"><span class="nav-number">14.2.</span> <span class="nav-text">主要区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#union"><span class="nav-number">15.</span> <span class="nav-text">union</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11-允许非-POD-类型"><span class="nav-number">15.1.</span> <span class="nav-text">C++11 允许非 POD 类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11-允许联合体有静态成员"><span class="nav-number">15.2.</span> <span class="nav-text">C++11 允许联合体有静态成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非受限联合体的赋值注意事项"><span class="nav-number">15.3.</span> <span class="nav-text">非受限联合体的赋值注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非受限联合体的匿名声明和“枚举式类”"><span class="nav-number">15.4.</span> <span class="nav-text">非受限联合体的匿名声明和“枚举式类”</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#assert"><span class="nav-number">16.</span> <span class="nav-text">assert()</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#assert-的用法和机制"><span class="nav-number">16.1.</span> <span class="nav-text">assert() 的用法和机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NDEBUG-宏"><span class="nav-number">16.2.</span> <span class="nav-text">NDEBUG 宏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意事项"><span class="nav-number">16.3.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#pair类型"><span class="nav-number">17.</span> <span class="nav-text">pair类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#pair类型的定义和初始化"><span class="nav-number">17.1.</span> <span class="nav-text">pair类型的定义和初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pair对象的一些操作"><span class="nav-number">17.2.</span> <span class="nav-text">pair对象的一些操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#map"><span class="nav-number">18.</span> <span class="nav-text">map</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#map对象的定义和初始化"><span class="nav-number">18.1.</span> <span class="nav-text">map对象的定义和初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map中元素的插入"><span class="nav-number">18.2.</span> <span class="nav-text">map中元素的插入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map中元素的查找和读取"><span class="nav-number">18.3.</span> <span class="nav-text">map中元素的查找和读取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从map中删除元素"><span class="nav-number">18.4.</span> <span class="nav-text">从map中删除元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map的基本操作函数："><span class="nav-number">18.5.</span> <span class="nav-text">map的基本操作函数：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#stack"><span class="nav-number">19.</span> <span class="nav-text">stack</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#queues"><span class="nav-number">20.</span> <span class="nav-text">queues</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Priority-Queues"><span class="nav-number">21.</span> <span class="nav-text">Priority Queues</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vector的内部实现原理及基本用法"><span class="nav-number">22.</span> <span class="nav-text">vector的内部实现原理及基本用法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#vector的定义"><span class="nav-number">22.1.</span> <span class="nav-text">vector的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造与析构"><span class="nav-number">22.2.</span> <span class="nav-text">构造与析构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造"><span class="nav-number">22.2.1.</span> <span class="nav-text">构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#析构"><span class="nav-number">22.2.2.</span> <span class="nav-text">析构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入和删除元素"><span class="nav-number">22.3.</span> <span class="nav-text">插入和删除元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他接口"><span class="nav-number">22.4.</span> <span class="nav-text">其他接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本使用"><span class="nav-number">22.5.</span> <span class="nav-text">基本使用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#size-t"><span class="nav-number">23.</span> <span class="nav-text">size_t</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#可移植性问题"><span class="nav-number">23.1.</span> <span class="nav-text">可移植性问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用size-t"><span class="nav-number">23.2.</span> <span class="nav-text">使用size_t</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存对齐"><span class="nav-number">24.</span> <span class="nav-text">内存对齐</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#strlen和sizeof区别？"><span class="nav-number">25.</span> <span class="nav-text">strlen和sizeof区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#OFFSETOF"><span class="nav-number">26.</span> <span class="nav-text">OFFSETOF</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sizeof"><span class="nav-number">27.</span> <span class="nav-text">sizeof</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#标准C-中的string类"><span class="nav-number">28.</span> <span class="nav-text">标准C++中的string类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#string类的构造函数："><span class="nav-number">28.1.</span> <span class="nav-text">string类的构造函数：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string类的字符操作："><span class="nav-number">28.2.</span> <span class="nav-text">string类的字符操作：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string的特性描述"><span class="nav-number">28.3.</span> <span class="nav-text">string的特性描述:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string类的输入输出操作"><span class="nav-number">28.4.</span> <span class="nav-text">string类的输入输出操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string的赋值"><span class="nav-number">28.5.</span> <span class="nav-text">string的赋值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string的连接："><span class="nav-number">28.6.</span> <span class="nav-text">string的连接：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string的比较："><span class="nav-number">28.7.</span> <span class="nav-text">string的比较：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string的子串"><span class="nav-number">28.8.</span> <span class="nav-text">string的子串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string的交换"><span class="nav-number">28.9.</span> <span class="nav-text">string的交换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string类的查找函数"><span class="nav-number">28.10.</span> <span class="nav-text">string类的查找函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string类的替换函数"><span class="nav-number">28.11.</span> <span class="nav-text">string类的替换函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string类的插入函数"><span class="nav-number">28.12.</span> <span class="nav-text">string类的插入函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string类的删除函数"><span class="nav-number">28.13.</span> <span class="nav-text">string类的删除函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string类的迭代器处理："><span class="nav-number">28.14.</span> <span class="nav-text">string类的迭代器处理：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串流处理："><span class="nav-number">28.15.</span> <span class="nav-text">字符串流处理：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string特性描述"><span class="nav-number">28.16.</span> <span class="nav-text">string特性描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string的查找"><span class="nav-number">28.17.</span> <span class="nav-text">string的查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他常用函数"><span class="nav-number">28.18.</span> <span class="nav-text">其他常用函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#this指针"><span class="nav-number">29.</span> <span class="nav-text">this指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#this指针的用处"><span class="nav-number">29.1.</span> <span class="nav-text">this指针的用处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this指针的使用"><span class="nav-number">29.2.</span> <span class="nav-text">this指针的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this指针程序示例"><span class="nav-number">29.3.</span> <span class="nav-text">this指针程序示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于this指针的一个经典回答"><span class="nav-number">29.4.</span> <span class="nav-text">关于this指针的一个经典回答</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的this指针有以下特点："><span class="nav-number">29.5.</span> <span class="nav-text">类的this指针有以下特点：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意事项-1"><span class="nav-number">29.6.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变长参数函数"><span class="nav-number">30.</span> <span class="nav-text">变长参数函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变长参数模板"><span class="nav-number">31.</span> <span class="nav-text">变长参数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#变长参数函数模板"><span class="nav-number">31.1.</span> <span class="nav-text">变长参数函数模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变长参数类模板"><span class="nav-number">31.2.</span> <span class="nav-text">变长参数类模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#右值引用和完美转发"><span class="nav-number">31.3.</span> <span class="nav-text">右值引用和完美转发</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#str相关函数"><span class="nav-number">32.</span> <span class="nav-text">str相关函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RVO"><span class="nav-number">33.</span> <span class="nav-text">RVO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数如何返回值"><span class="nav-number">33.1.</span> <span class="nav-text">函数如何返回值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-move"><span class="nav-number">33.2.</span> <span class="nav-text">std::move()</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cpp的tr1-function使用"><span class="nav-number">34.</span> <span class="nav-text">cpp的tr1_function使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍"><span class="nav-number">34.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例代码"><span class="nav-number">34.2.</span> <span class="nav-text">示例代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-函数调用分析"><span class="nav-number">35.</span> <span class="nav-text">C++函数调用分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#深入理解C-的动态绑定和静态绑定"><span class="nav-number">36.</span> <span class="nav-text">深入理解C++的动态绑定和静态绑定</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#mem函数的类型及用法"><span class="nav-number">37.</span> <span class="nav-text">mem函数的类型及用法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数的重载、隐藏和覆盖"><span class="nav-number">38.</span> <span class="nav-text">函数的重载、隐藏和覆盖</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#强制类型转换运算符"><span class="nav-number">39.</span> <span class="nav-text">强制类型转换运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#static-cast"><span class="nav-number">39.1.</span> <span class="nav-text">static_cast</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reinterpret-cast"><span class="nav-number">39.2.</span> <span class="nav-text">reinterpret_cast</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const-cast"><span class="nav-number">39.3.</span> <span class="nav-text">const_cast</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dynamic-cast"><span class="nav-number">39.4.</span> <span class="nav-text">dynamic_cast</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#attribute二三事"><span class="nav-number">40.</span> <span class="nav-text">attribute二三事</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#函数属性-Function-Attribute"><span class="nav-number">40.1.</span> <span class="nav-text">函数属性(Function Attribute)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型属性-Type-Attributes"><span class="nav-number">40.2.</span> <span class="nav-text">类型属性(Type Attributes)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量属性-Variable-Attribute"><span class="nav-number">40.3.</span> <span class="nav-text">变量属性(Variable Attribute)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Clang特有的"><span class="nav-number">40.4.</span> <span class="nav-text">Clang特有的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#书写格式"><span class="nav-number">40.5.</span> <span class="nav-text">书写格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见的系统用法"><span class="nav-number">40.6.</span> <span class="nav-text">常见的系统用法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#format"><span class="nav-number">40.6.1.</span> <span class="nav-text">format</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#noreturn"><span class="nav-number">40.6.2.</span> <span class="nav-text">noreturn</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#availability"><span class="nav-number">40.6.3.</span> <span class="nav-text">availability</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#visibility"><span class="nav-number">40.6.4.</span> <span class="nav-text">visibility</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nonnull"><span class="nav-number">40.6.5.</span> <span class="nav-text">nonnull</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见用法"><span class="nav-number">40.7.</span> <span class="nav-text">常见用法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#aligned"><span class="nav-number">40.7.1.</span> <span class="nav-text">aligned</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#packed"><span class="nav-number">40.7.2.</span> <span class="nav-text">packed</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#noinline-amp-always-inline"><span class="nav-number">40.7.3.</span> <span class="nav-text">noinline &amp; always_inline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#warn-unused-result"><span class="nav-number">40.7.4.</span> <span class="nav-text">warn_unused_result</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constructor-destructor"><span class="nav-number">40.7.5.</span> <span class="nav-text">constructor / destructor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#enable-if"><span class="nav-number">40.7.6.</span> <span class="nav-text">enable_if</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
