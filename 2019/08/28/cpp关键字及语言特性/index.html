<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="decltype简介我们之前使用的typeid运算符来查询一个变量的类型，这种类型查询在运行时进行。RTTI机制为每一个类型产生一个type_info类型的数据，而typeid查询返回的变量相应type_info数据，通过name成员函数返回类型的名称。同时在C++11中typeid还提供了hash_code这个成员函数，用于返回类型的唯一哈希值。RTTI会导致运行时效率降低，且在泛型编程中，我们">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++关键字及语言特性">
<meta property="og:url" content="http://yoursite.com/2019/08/28/cpp关键字及语言特性/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="decltype简介我们之前使用的typeid运算符来查询一个变量的类型，这种类型查询在运行时进行。RTTI机制为每一个类型产生一个type_info类型的数据，而typeid查询返回的变量相应type_info数据，通过name成员函数返回类型的名称。同时在C++11中typeid还提供了hash_code这个成员函数，用于返回类型的唯一哈希值。RTTI会导致运行时效率降低，且在泛型编程中，我们">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20180912085909216.png">
<meta property="og:image" content="http://yoursite.com/img/909212-20160603234145961-1605510938.png">
<meta property="og:image" content="http://yoursite.com/img/909212-20160603235458727-271967874.png">
<meta property="og:image" content="http://yoursite.com/img/909212-20160604002208836-1075703850.png">
<meta property="og:image" content="http://yoursite.com/img/909212-20160604002803352-2018700987.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1352320/201803/1352320-20180323101344856-2115596576.png">
<meta property="og:updated_time" content="2022-01-02T12:06:51.140Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++关键字及语言特性">
<meta name="twitter:description" content="decltype简介我们之前使用的typeid运算符来查询一个变量的类型，这种类型查询在运行时进行。RTTI机制为每一个类型产生一个type_info类型的数据，而typeid查询返回的变量相应type_info数据，通过name成员函数返回类型的名称。同时在C++11中typeid还提供了hash_code这个成员函数，用于返回类型的唯一哈希值。RTTI会导致运行时效率降低，且在泛型编程中，我们">
<meta name="twitter:image" content="http://yoursite.com/img/20180912085909216.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/08/28/cpp关键字及语言特性/">





  <title>C++关键字及语言特性 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/28/cpp关键字及语言特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++关键字及语言特性</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-28T16:51:00+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="decltype简介"><a href="#decltype简介" class="headerlink" title="decltype简介"></a>decltype简介</h1><p>我们之前使用的typeid运算符来查询一个变量的类型，这种类型查询在运行时进行。RTTI机制为每一个类型产生一个type_info类型的数据，而typeid查询返回的变量相应type_info数据，通过name成员函数返回类型的名称。同时在C++11中typeid还提供了hash_code这个成员函数，用于返回类型的唯一哈希值。RTTI会导致运行时效率降低，且在泛型编程中，我们更需要的是编译时就要确定类型，RTTI并无法满足这样的要求。编译时类型推导的出现正是为了泛型编程，在非泛型编程中，我们的类型都是确定的，根本不需要再进行推导。</p>
<p>而编译时类型推导，除了我们说过的auto关键字，还有本文的decltype。</p>
<p>decltype与auto关键字一样，用于进行<strong>编译时类型推导</strong>，不过它与auto还是有一些区别的。decltype的类型推导并不是像auto一样是从变量声明的初始化表达式获得变量的类型，而是总是以一个普通表达式作为参数，返回该表达式的类型,而且decltype并不会对表达式进行求值。</p>
<h1 id="decltype用法"><a href="#decltype用法" class="headerlink" title="decltype用法"></a>decltype用法</h1><h2 id="推导出表达式类型"><a href="#推导出表达式类型" class="headerlink" title="推导出表达式类型"></a>推导出表达式类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i = 4;</span><br><span class="line">decltype(i) a; //推导结果为int。a的类型为int。</span><br></pre></td></tr></table></figure>
<h2 id="与using-typedef合用，用于定义类型。"><a href="#与using-typedef合用，用于定义类型。" class="headerlink" title="与using/typedef合用，用于定义类型。"></a>与using/typedef合用，用于定义类型。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">using size_t = decltype(sizeof(0));//sizeof(a)的返回值为size_t类型</span><br><span class="line">using ptrdiff_t = decltype((int*)0 - (int*)0);</span><br><span class="line">using nullptr_t = decltype(nullptr);</span><br><span class="line">vector&lt;int &gt;vec;</span><br><span class="line"></span><br><span class="line">typedef decltype(vec.begin()) vectype;</span><br><span class="line">for (vectype i = vec.begin; i != vec.end(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样和auto一样，也提高了代码的可读性。</p>
<h2 id="重用匿名类型"><a href="#重用匿名类型" class="headerlink" title="重用匿名类型"></a>重用匿名类型</h2><p>在C++中，我们有时候会遇上一些匿名类型，如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct </span><br><span class="line">&#123;</span><br><span class="line">    int d ;</span><br><span class="line">    doubel b;</span><br><span class="line">&#125;anon_s;</span><br></pre></td></tr></table></figure></p>
<p>而借助decltype，我们可以重新使用这个匿名的结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype(anon_s) as ;//定义了一个上面匿名的结构体</span><br></pre></td></tr></table></figure></p>
<h2 id="泛型编程中结合auto，用于追踪函数的返回值类型"><a href="#泛型编程中结合auto，用于追踪函数的返回值类型" class="headerlink" title="泛型编程中结合auto，用于追踪函数的返回值类型"></a>泛型编程中结合auto，用于追踪函数的返回值类型</h2><p>这也是decltype最大的用途了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename _Tx, typename _Ty&gt;</span><br><span class="line">auto multiply(_Tx x, _Ty y)-&gt;decltype(_Tx*_Ty)</span><br><span class="line">&#123;</span><br><span class="line">    return x*y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="decltype推导四规则"><a href="#decltype推导四规则" class="headerlink" title="decltype推导四规则"></a>decltype推导四规则</h1><ol>
<li>如果e是一个没有带括号的标记符表达式或者类成员访问表达式，那么的decltype（e）就是e所命名的实体的类型。此外，如果e是一个被重载的函数，则会导致编译错误。</li>
<li>否则 ，假设e的类型是T，如果e是一个将亡值，那么decltype（e）为T&amp;&amp;</li>
<li>否则，假设e的类型是T，如果e是一个左值，那么decltype（e）为T&amp;。</li>
<li>否则，假设e的类型是T，则decltype（e）为T。</li>
</ol>
<p>标记符指的是除去关键字、字面量等编译器需要使用的标记之外的程序员自己定义的标记，而单个标记符对应的表达式即为标记符表达式。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int arr[4]</span><br></pre></td></tr></table></figure></p>
<p>则arr为一个标记符表达式，而arr[3]+0不是。</p>
<p>我们来看下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i=10;</span><br><span class="line">decltype(i) a; //a推导为int</span><br><span class="line">decltype((i))b=i;//b推导为int&amp;，必须为其初始化，否则编译错误</span><br></pre></td></tr></table></figure></p>
<p>仅仅为i加上了()，就导致类型推导结果的差异。这是因为，i是一个标记符表达式，根据推导规则1，类型被推导为int。而(i)为一个左值表达式，所以类型被推导为int&amp;。</p>
<p>通过下面这段代码可以对推导四个规则作进一步了解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">int i = 4;</span><br><span class="line">int arr[5] = &#123; 0 &#125;;</span><br><span class="line">int *ptr = arr;</span><br><span class="line">struct S&#123; double d; &#125;s ;</span><br><span class="line">void Overloaded(int);</span><br><span class="line">void Overloaded(char);//重载的函数</span><br><span class="line">int &amp;&amp; RvalRef();</span><br><span class="line">const bool Func(int);</span><br><span class="line"> </span><br><span class="line">//规则一：推导为其类型</span><br><span class="line">decltype (arr) var1; //int 标记符表达式</span><br><span class="line"> </span><br><span class="line">decltype (ptr) var2;//int *  标记符表达式</span><br><span class="line"> </span><br><span class="line">decltype(s.d) var3;//doubel 成员访问表达式</span><br><span class="line"> </span><br><span class="line">//decltype(Overloaded) var4;//重载函数。编译错误。</span><br><span class="line"> </span><br><span class="line">//规则二：将亡值。推导为类型的右值引用。</span><br><span class="line"> </span><br><span class="line">decltype (RvalRef()) var5 = 1;</span><br><span class="line"> </span><br><span class="line">//规则三：左值，推导为类型的引用。</span><br><span class="line"> </span><br><span class="line">decltype ((i))var6 = i;     //int&amp;</span><br><span class="line"> </span><br><span class="line">decltype (true ? i : i) var7 = i; //int&amp;  条件表达式返回左值。</span><br><span class="line"> </span><br><span class="line">decltype (++i) var8 = i; //int&amp;  ++i返回i的左值。</span><br><span class="line"> </span><br><span class="line">decltype(arr[5]) var9 = i;//int&amp;. []操作返回左值</span><br><span class="line"> </span><br><span class="line">decltype(*ptr)var10 = i;//int&amp; *操作返回左值</span><br><span class="line"> </span><br><span class="line">decltype(&quot;hello&quot;)var11 = &quot;hello&quot;; //const char(&amp;)[9]  字符串字面常量为左值，且为const左值。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">//规则四：以上都不是，则推导为本类型</span><br><span class="line"> </span><br><span class="line">decltype(1) var12;//const int</span><br><span class="line"> </span><br><span class="line">decltype(Func(1)) var13=true;//const bool</span><br><span class="line"> </span><br><span class="line">decltype(i++) var14 = i;//int i++返回右值</span><br></pre></td></tr></table></figure></p>
<p>这里需要提示的是，字符串字面值常量是个左值，且是const左值，而非字符串字面值常量则是个右值。<br>这么多规则，对于我们写代码的来说难免太难记了，特别是规则三。我们可以利用C++11标准库中添加的模板类is_lvalue_reference来判断表达式是否为左值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; is_lvalue_reference&lt;decltype(++i)&gt;::value &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>结果1表示为左值，结果为0为非右值。<br>同样的，也有is_rvalue_reference这样的模板类来判断decltype推断结果是否为右值。</p>
<h1 id="C-中constexpr作用"><a href="#C-中constexpr作用" class="headerlink" title="C++中constexpr作用"></a>C++中constexpr作用</h1><p>constexpr 是 C++ 11 标准新引入的关键字，不过在讲解其具体用法和功能之前，读者需要先搞清楚 C++ 常量表达式的含义。</p>
<p>所谓常量表达式，指的就是由多个（≥1）常量组成的表达式。换句话说，如果表达式中的成员都是常量，那么该表达式就是一个常量表达式。这也意味着，常量表达式一旦确定，其值将无法修改。</p>
<p>实际开发中，我们经常会用到常量表达式。以定义数组为例，数组的长度就必须是一个常量表达式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1)</span></span><br><span class="line"><span class="keyword">int</span> url[<span class="number">10</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 2)</span></span><br><span class="line"><span class="keyword">int</span> url[<span class="number">6</span> + <span class="number">4</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 3)</span></span><br><span class="line"><span class="keyword">int</span> length = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> url[length];<span class="comment">//错误，length是变量</span></span><br></pre></td></tr></table></figure></p>
<p>上述代码演示了 3 种定义 url 数组的方式，其中第 1、2 种定义 url 数组时，长度分别为 10 和 6+4，显然它们都是常量表达式，可以用于表示数组的长度；第 3 种 url 数组的长度为 length，它是变量而非常量，因此不是一个常量表达式，无法用于表示数组的长度。<br>常量表达式的应用场景还有很多，比如匿名枚举、switch-case 结构中的 case 表达式等，感兴趣的读者可自行编码测试，这里不再过多举例。</p>
<p>我们知道，C++ 程序的执行过程大致要经历编译、链接、运行这 3 个阶段。值得一提的是，常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果；而常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p>
<p>对于用 C++ 编写的程序，性能往往是永恒的追求。那么在实际开发中，如何才能判定一个表达式是否为常量表达式，进而获得在编译阶段即可执行的“特权”呢？除了人为判定外，C++11 标准还提供有 constexpr 关键字。</p>
<p>constexpr 关键字的功能是<strong>使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段</strong>。C++ 11 标准中，constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。<br>注意，获得在编译阶段计算出结果的能力，并不代表 constexpr 修饰的表达式一定会在程序编译阶段被执行，具体的计算时机还是编译器说了算。</p>
<h2 id="constexpr修饰普通变量"><a href="#constexpr修饰普通变量" class="headerlink" title="constexpr修饰普通变量"></a>constexpr修饰普通变量</h2><p>C++11 标准中，定义变量时可以用 constexpr 修饰，从而使该变量获得在编译阶段即可计算出结果的能力。</p>
<p>值得一提的是，使用 constexpr 修改普通变量时，变量必须经过初始化且初始值必须是一个常量表达式。举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> num = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> url[num] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    couts&lt;&lt; url[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p>读者可尝试将 constexpr 删除，此时编译器会提示“url[num] 定义中 num 不可用作常量”。</p>
<p>可以看到，程序第 6 行使用 constexpr 修饰 num 变量，同时将 “1+2+3” 这个常量表达式赋值给 num。由此，编译器就可以在编译时期对 num 这个表达式进行计算，因为 num 可以作为定义数组时的长度。</p>
<p>有读者可能发现，将此示例程序中的 constexpr 用 const 关键字替换也可以正常执行，这是因为 num 的定义同时满足“num 是 const 常量且使用常量表达式为其初始化”这 2 个条件，由此编译器会认定 num 是一个常量表达式。<br>注意，const 和 constexpr 并不相同，关于它们的区别，我们会在下一节做详细讲解。</p>
<p>另外需要重点提出的是，当常量表达式中包含浮点数时，考虑到程序编译和运行所在的系统环境可能不同，常量表达式在编译阶段和运行阶段计算出的结果精度很可能会受到影响，因此 C++11 标准规定，浮点常量表达式在编译阶段计算的精度要至少等于（或者高于）运行阶段计算出的精度。</p>
<h2 id="constexpr修饰函数"><a href="#constexpr修饰函数" class="headerlink" title="constexpr修饰函数"></a>constexpr修饰函数</h2><p>constexpr 还可以用于修饰函数的返回值，这样的函数又称为“常量表达式函数”。</p>
<p>注意，constexpr 并非可以修改任意函数的返回值。换句话说，一个函数要想成为常量表达式函数，必须满足如下 4 个条件。</p>
<p>1) 整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，只能包含一条 return 返回语句。</p>
<p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这个函数是无法通过编译的，因为该函数的返回值用 constexpr 修饰，但函数内部包含多条语句。</p>
<p>如下是正确的定义 display() 常量表达式函数的写法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以添加 using 执行、typedef 语句以及 static_assert 断言</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，display() 函数的返回值是用 constexpr 修饰的 int 类型值，且该函数的函数体中只包含一个 return 语句。</p>
<p>2) 该函数必须有返回值，即函数的返回值类型不能是 void。</p>
<p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>像上面这样定义的返回值类型为 void 的函数，不属于常量表达式函数。原因很简单，因为通过类似的函数根本无法获得一个常量。</p>
<p>3) 函数在使用之前，必须有对应的定义语句。我们知道，函数的使用分为“声明”和“定义”两部分，普通的函数调用只需要提前写好该函数的声明部分即可（函数的定义部分可以放在调用位置之后甚至其它文件中），但常量表达式函数在使用前，必须要有该函数的定义。</p>
<p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//普通函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="keyword">int</span> a[display(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//调用普通函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; noconst_dis(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序执行结果为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></p>
<p>读者可自行将 display() 常量表达式函数的定义调整到 main() 函数之后，查看编译器的报错信息。</p>
<p>可以看到，普通函数在调用时，只需要保证调用位置之前有相应的声明即可；而常量表达式函数则不同，调用位置之前必须要有该函数的定义，否则会导致程序编译失败。</p>
<p>4) return 返回的表达式必须是常量表达式，举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="keyword">int</span> a[display(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该程序无法通过编译，编译器报“display(3) 的结果不是常量”的异常。</p>
<p>常量表达式函数的返回值必须是常量表达式的原因很简单，如果想在程序编译阶段获得某个函数返回的常量，则该函数的 return 语句中就不能包含程序运行阶段才能确定值的变量。</p>
<p>注意，在常量表达式函数的 return 语句中，不能包含赋值的操作（例如 return x=1 在常量表达式函数中不允许的）。另外，用 constexpr 修改函数时，函数本身也是支持递归的，感兴趣的读者可自行尝试编码测试。</p>
<h2 id="constexpr修饰类的构造函数"><a href="#constexpr修饰类的构造函数" class="headerlink" title="constexpr修饰类的构造函数"></a>constexpr修饰类的构造函数</h2><p>对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的。</p>
<p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">"zhangsan"</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mt.name &lt;&lt; <span class="string">" "</span> &lt;&lt; mt.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此程序是无法通过编译的，编译器会抛出“constexpr不能修饰自定义类型”的异常。</p>
<p>当我们想自定义一个可产生常量的类型时，正确的做法是在该类型的内部添加一个常量构造函数。例如，修改上面的错误示例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    constexpr myType(char *name,int age):name(name),age(age)&#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">"zhangsan"</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mt.name &lt;&lt; <span class="string">" "</span> &lt;&lt; mt.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序执行结果为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangsan <span class="number">10</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，在 myType 结构体中自定义有一个构造函数，借助此函数，用 constexpr 修饰的 myType 类型的 my 常量即可通过编译。</p>
<p>注意，constexpr 修饰类的构造函数时，要求该构造函数的函数体必须为空，且采用初始化列表的方式为各个成员赋值时，必须使用常量表达式。</p>
<p>前面提到，constexpr 可用于修饰函数，而类中的成员方法完全可以看做是“位于类这个命名空间中的函数”，所以 constexpr 也可以修饰类中的成员函数，只不过此函数必须满足前面提到的 4 个条件。</p>
<p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myType</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    constexpr myType(const char *name,int age):name(name),age(age)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">getname</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">mt</span> &#123;</span> <span class="string">"zhangsan"</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">char</span> * name = mt.getname();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> age = mt.getage();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="string">" "</span> &lt;&lt; age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangsan 10</span><br></pre></td></tr></table></figure></p>
<p>注意，C++11 标准中，不支持用 constexpr 修饰带有 virtual 的成员方法。</p>
<h2 id="constexpr修饰模板函数"><a href="#constexpr修饰模板函数" class="headerlink" title="constexpr修饰模板函数"></a>constexpr修饰模板函数</h2><p>C++11 语法中，constexpr 可以修饰模板函数，但由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。</p>
<p>针对这种情况下，C++11 标准规定，如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。</p>
<p>举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myType</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模板函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">dispaly</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">stu</span>&#123;</span><span class="string">"zhangsan"</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="comment">//普通函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myType</span> <span class="title">ret</span> = <span class="title">dispaly</span>(<span class="title">stu</span>);</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret.name &lt;&lt; <span class="string">" "</span> &lt;&lt; ret.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//常量表达式函数</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> ret1 = dispaly(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ret1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zhangsan 10</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p>
<p>可以看到，示例程序中定义了一个模板函数 display()，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：<br>第 20 行代码处，当模板函数中以自定义结构体 myType 类型进行实例化时，由于该结构体中没有定义常量表达式构造函数，所以实例化后的函数不是常量表达式函数，此时 constexpr 是无效的；<br>第 23 行代码处，模板函数的类型 T 为 int 类型，实例化后的函数符合常量表达式函数的要求，所以该函数的返回值就是一个常量表达式。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// C++98/03</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Factorial</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Factorial</span>&lt;0&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">1</span> : n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C++14</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">factorial2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        result *= i;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(Factorial&lt;<span class="number">3</span>&gt;::value == <span class="number">6</span>, <span class="string">"error"</span>);</span><br><span class="line">    <span class="keyword">static_assert</span>(factorial(<span class="number">3</span>) == <span class="number">6</span>, <span class="string">"error"</span>);</span><br><span class="line">    <span class="keyword">static_assert</span>(factorial2(<span class="number">3</span>) == <span class="number">6</span>, <span class="string">"error"</span>);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; factorial(n) &lt;&lt; factorial2(n) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//66</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码说明：</p>
<ul>
<li>以上代码演示了如何在编译期计算3的阶乘。</li>
<li>在C++11之前，在编译期进行数值计算必须使用模板元编程技巧。具体来说我们通常需要定义一个内含编译期常量value的类模板（也称作元函数）。这个类模板的定义至少需要分成两部分，分别用于处理一般情况和特殊情况。</li>
<li>代码示例中Factorial元函数的定义分为两部分：<ul>
<li>当模板参数大于0时，利用公式 N!=N*(N-1)! 递归调用自身来计算value的值。</li>
<li>当模板参数为0时，将value设为1这个特殊情况下的值。</li>
</ul>
</li>
<li>在C++11之后，编译期的数值计算可以通过使用constexpr声明并定义编译期函数来进行。相对于模板元编程，使用constexpr函数更贴近普通的C++程序，计算过程显得更为直接，意图也更明显。</li>
<li>但在C++11中constexpr函数所受到的限制较多，比如函数体通常只有一句return语句，函数体内既不能声明变量，也不能使用for语句之类的常规控制流语句。</li>
<li>如factorial函数所示，使用C++11在编译期计算阶乘仍然需要利用递归技巧。</li>
<li>C++14解除了对constexpr函数的大部分限制。在C++14的constexpr函数体内我们既可以声明变量，也可以使用goto和try之外大部分的控制流语句。</li>
<li>如factorial2函数所示，使用C++14在编译期计算阶乘只需利用for语句进行常规计算即可。</li>
<li>虽说constexpr函数所定义的是编译期的函数，但实际上在运行期constexpr函数也能被调用。事实上，如果使用编译期常量参数调用constexpr函数，我们就能够在编译期得到运算结果；而如果使用运行期变量参数调用constexpr函数，那么在运行期我们同样也能得到运算结果。</li>
<li>代码第32行所演示的是在运行期使用变量n调用constexpr函数的结果。</li>
<li>准确的说，constexpr函数是一种在编译期和运行期都能被调用并执行的函数。出于constexpr函数的这个特点，在C++11之后进行数值计算时，无论在编译期还是运行期我们都可以统一用一套代码来实现。编译期和运行期在数值计算这点上得到了部分统一。</li>
</ul>
<h1 id="const的用法"><a href="#const的用法" class="headerlink" title="const的用法"></a>const的用法</h1><p>const是不改变的。在C和C++中，我们使用关键字const来使程序元素保持不变。const关键字可以在C++程序的许多上下文中使用。它可以用于：变量、指针、函数参数和返回类型、类数据成员、类成员函数、对象。</p>
<ol>
<li>修饰变量，说明该变量不可以被改变；</li>
<li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li>
<li>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰成员函数，说明该成员函数内不能修改成员变量。</li>
</ol>
<p>下面的声明都是什么意思？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const int a; a是一个常整型数</span><br><span class="line">int const a; a是一个常整型数</span><br><span class="line">const int *a; a是一个指向常整型数的指针，整型数是不可修改的，但指针可以</span><br><span class="line">int * const a; a为指向整型数的常指针，指针指向的整型数可以修改，但指针是不可修改的</span><br><span class="line">int const * a const; a是一个指向常整型数的常指针，指针指向的整型数是不可修改的，同时指针也是不可修改的</span><br></pre></td></tr></table></figure></p>
<h2 id="const变量"><a href="#const变量" class="headerlink" title="const变量"></a>const变量</h2><p>如果你用const关键字做任何变量，你就不能改变它的值。同样，必须在声明的时候初始化常数变量。<br>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main</span><br><span class="line">&#123;</span><br><span class="line">    const int i = 10;</span><br><span class="line">    const int j = i + 10;     // works fine</span><br><span class="line">    i++;    // this leads to Compile time error   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，我们使 i 成为常量，因此如果我们试图改变它的值，我们将得到编译时错误。尽管我们可以用它来代替其他变量。</p>
<h2 id="指针与const关键字"><a href="#指针与const关键字" class="headerlink" title="指针与const关键字"></a>指针与const关键字</h2><p>指针也可以使用const关键字来声明。当我们使用const和指针时，我们可以用两种方式来做：可以把const应用到指针指向的地方，或者我们可以使指针本身成为一个常数。 </p>
<h3 id="指向const变量的指针："><a href="#指向const变量的指针：" class="headerlink" title="指向const变量的指针："></a>指向const变量的指针：</h3><p>意味着指针指向一个const变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int* u;</span><br></pre></td></tr></table></figure></p>
<p>这里，表示u是一个指针，可以指向const int类型变量。指针指向的内容不可改变。简称左定值，因为const位于*号的左边。</p>
<p>我们也可以这样写，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char const* v;</span><br></pre></td></tr></table></figure></p>
<p>表示v是指向const类型的char的指针。<br>指向const变量的指针非常有用，因为它可以用来使任何字符串或数组不可变</p>
<h3 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h3><p>为了使指针保持不变，我们必须把const关键字放到右边。对于const指针p其指向的内存地址不能够被改变，但其内容可以改变。简称，右定向。因为const位于*号的右边。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x = 1;</span><br><span class="line">int* const w = &amp;x;</span><br></pre></td></tr></table></figure></p>
<p>里，w是一个指针，它是const，指向一个int，现在我们不能改变指针，这意味着它总是指向变量x但是可以改变它指向的值，通过改变x的值。</p>
<p>当你想要一个可以在值中改变但不会在内存中移动的存储器时，常量指针指向一个变量是很有用的。因为指针总是指向相同的内存位置，因为它是用const关键字定义的，但是那个内存位置的值可以被更改。<br><strong>左定值，右定向，const修饰不变量</strong></p>
<h2 id="const函数参数和返回类型"><a href="#const函数参数和返回类型" class="headerlink" title="const函数参数和返回类型"></a>const函数参数和返回类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void f(const int i)</span><br><span class="line">&#123;</span><br><span class="line">    i++;    // error</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">const int g()</span><br><span class="line">&#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意几个要点：</p>
<p>①对于内置数据类型，返回const或非const值，不会有任何影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const int h()</span><br><span class="line">&#123;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int j = h();</span><br><span class="line">    int k = h();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>j和k都将被赋值为1。不会出现错误。</p>
<p>②对于用户定义的数据类型，返回const，将阻止它的修改。此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。const 修饰返回的指针或者引用，是否返回一个指向 const 的指针，取决于我们想让用户干什么。</p>
<p>③在程序执行时创建的临时对象总是const类型。值传递的 const 修饰传递，一般这种情况不需要 const 修饰，因为函数会自动产生临时变量复制实参值。<br>当 const 参数为指针时，可以防止指针被意外篡改。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cpf</span><span class="params">(<span class="keyword">int</span> *<span class="keyword">const</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*a&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    *a = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line">    Cpf(&amp;a);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a; <span class="comment">// a 为 9</span></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取 const 外加引用传递的方法。并且对于一般的 int、double 等内置类型，我们不采用引用的传递方式。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test()&#123;&#125;</span><br><span class="line">    Test(<span class="keyword">int</span> _m):_cm(_m)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_cm</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> _cm;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _cm;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cmf</span><span class="params">(<span class="keyword">const</span> Test&amp; _tt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;_tt.get_cm();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">8</span>)</span></span>;</span><br><span class="line">    Cmf(t);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>④如果一个函数有一个非const参数，它在发出调用时不能传递const参数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t</span><span class="params">(<span class="keyword">int</span>*)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// function logic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们把一个const int参数传递给函数t，会出现错误。</p>
<p>⑤但是，一个具有const类型参数的函数，可以传递一个const类型参数以及一个非const参数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// function logic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数可以有一个int，也可以有const int类型参数。</p>
<h3 id="const修饰函数返回值"><a href="#const修饰函数返回值" class="headerlink" title="const修饰函数返回值"></a>const修饰函数返回值</h3><p>(1)指针传递</p>
<p>如果返回const data,non-const pointer，返回值也必须赋给const data,non-const pointer。因为指针指向的数据是常量不能修改。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="title">mallocA</span><span class="params">()</span></span>&#123;  <span class="comment">///const data,non-const pointer</span></span><br><span class="line">    <span class="keyword">int</span> *a=<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> *a = mallocA();</span><br><span class="line">    <span class="comment">///int *b = mallocA();  ///编译错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(2)值传递</p>
<p>如果函数返回值采用“值传递方式”，由于函数会把返回值复制到外部临时的存储单元中，加const 修饰没有任何价值。所以，对于值传递来说，加const没有太多意义。</p>
<p>所以：</p>
<ul>
<li>不要把函数int GetInt(void) 写成const int GetInt(void)。</li>
<li>不要把函数A GetA(void) 写成const A GetA(void)，其中A 为用户自定义的数据类型。</li>
</ul>
<h2 id="将类数据成员定义为const"><a href="#将类数据成员定义为const" class="headerlink" title="将类数据成员定义为const"></a>将类数据成员定义为const</h2><p>这些是类中的数据变量，使用const关键字定义。它们在声明期间未初始化。它们的初始化在构造函数中完成。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Test (<span class="keyword">int</span> x) : i(x)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Test <span class="title">s</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个程序中，i 是一个常量数据成员，在每个对象中它的独立副本将会出现，因此它使用构造函数对每个对象进行初始化。一旦初始化，它的值就不能改变</p>
<h2 id="把类对象定义为const"><a href="#把类对象定义为const" class="headerlink" title="把类对象定义为const"></a>把类对象定义为const</h2><p>当一个对象被声明或使用const关键字创建时，它的数据成员在对象的生命周期中永远不会被改变。</p>
<p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const class_name object;</span><br></pre></td></tr></table></figure></p>
<p>  例如，如果在上面定义的类测试中，我们想要定义一个常数对象，我们可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Test r(30);</span><br></pre></td></tr></table></figure></p>
<h2 id="将类的成员函数定义为const"><a href="#将类的成员函数定义为const" class="headerlink" title="将类的成员函数定义为const"></a>将类的成员函数定义为const</h2><p>const成员函数决不会修改对象中的数据成员。注意：const关键字不能与static关键字同时使用，因为static关键字修饰静态成员函数，静态成员函数不含有this指针，即不能实例化，const成员函数必须具体到某一实例。</p>
<p>如果有个成员函数想修改对象中的某一个成员怎么办？这时我们可以使用mutable关键字修饰这个成员，mutable的意思也是易变的，容易改变的意思，被mutable关键字修饰的成员可以处于不断变化中。</p>
<p>const成员函数不能调用非const成员函数，因为非const成员函数可以会修改成员变量。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span> :</span><br><span class="line">    Point(<span class="keyword">int</span> _x):x(_x)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testConstFunction</span><span class="params">(<span class="keyword">int</span> _x)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">///错误，在const成员函数中，不能修改任何类成员变量</span></span><br><span class="line">        x=_x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">///错误，const成员函数不能调用非onst成员函数，因为非const成员函数可以会修改成员变量</span></span><br><span class="line">        modify_x(_x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify_x</span><span class="params">(<span class="keyword">int</span> _x)</span></span>&#123;</span><br><span class="line">        x=_x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return_type function_name() const;</span><br></pre></td></tr></table></figure></p>
<p>const对象和const成员函数的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StarWars</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    StarWars(<span class="keyword">int</span> x)    <span class="comment">// constructor</span></span><br><span class="line">    &#123; </span><br><span class="line">        i = x; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">falcon</span><span class="params">()</span> <span class="keyword">const</span>  <span class="comment">// constant function</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">            can do anything but will not</span></span><br><span class="line"><span class="comment">            modify any data members</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Falcon has left the Base"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gamma</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        i++; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">StarWars <span class="title">objOne</span><span class="params">(<span class="number">10</span>)</span></span>;        <span class="comment">// non const object</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> StarWars <span class="title">objTwo</span><span class="params">(<span class="number">20</span>)</span></span>;      <span class="comment">// const object</span></span><br><span class="line"> </span><br><span class="line">    objOne.falcon();     <span class="comment">// No error</span></span><br><span class="line">    objTwo.falcon();     <span class="comment">// No error</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; objOne.i &lt;&lt; objTwo.i;</span><br><span class="line"> </span><br><span class="line">    objOne.gamma();     <span class="comment">// No error</span></span><br><span class="line">    objTwo.gamma();     <span class="comment">// Compile time error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Falcon has left the Base</span><br><span class="line">Falcon has left the Base</span><br><span class="line">10 20</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们可以看到，const成员函数永远不会改变类的数据成员，并且它可以与const和非const对象一起使用。但是const对象不能与试图改变其数据成员的成员函数一起使用。</p>
<h1 id="关于const的疑问："><a href="#关于const的疑问：" class="headerlink" title="关于const的疑问："></a>关于const的疑问：</h1><ol>
<li>const什么时候为只读变量？</li>
<li>const什么时候是常量？</li>
</ol>
<p>const常量的判别标准：</p>
<ol>
<li>只有字面量初始化的const常量才会进入符号表</li>
<li>使用其他变量初始化的const常量仍然是只读变量</li>
<li>被volatile修饰的const常量不会进入符号表</li>
</ol>
<p>注意：</p>
<ol>
<li>const引用的类型与初始化变量的类型相同时：初始化变量成为只读变量</li>
<li>const引用的类型与初始化变量的类型不相同时：初生成一个新的只读变量</li>
</ol>
<p>Example:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x = <span class="number">1</span>; <span class="comment">//字面量初始化，此时x为常量，进入符号表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x; <span class="comment">//rx代表只读变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>&amp; nrx = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(rx); <span class="comment">//去掉rx的只读属性</span></span><br><span class="line">    </span><br><span class="line">    nrx = <span class="number">5</span>;  <span class="comment">//改变了nrx内存空间的值</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x = %d\n"</span>, x); <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"rx = %d\n"</span>, rx);  <span class="comment">//  5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"nrx = %d\n"</span>, nrx);  <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;x = %p\n"</span>, &amp;x);  <span class="comment">// &amp;x = 002CFD80</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;rx = %p\n"</span>, &amp;rx);  <span class="comment">// &amp;x = 002CFD80</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;nrx = %p\n"</span>, &amp;nrx);  <span class="comment">// &amp;x = 002CFD80</span></span><br><span class="line">    <span class="comment">//输出的地址相同，说明了x、rx、nrx代表同样的内存空间</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">const</span> <span class="keyword">int</span> y = <span class="number">2</span>;<span class="comment">//volatile代表易变的</span></span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;y);</span><br><span class="line">    </span><br><span class="line">    *p = <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"y = %d\n"</span>, y);  <span class="comment">//y = 6</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p = %p\n"</span>, p);  <span class="comment">//p = 001BF928</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//判别是否是常量是编译器在编译时能不能确认它的值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> z = y;</span><br><span class="line">    </span><br><span class="line">    p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;z);</span><br><span class="line">    </span><br><span class="line">    *p = <span class="number">7</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"z = %d\n"</span>, z); <span class="comment">// z = 7</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p = %p\n"</span>, p); <span class="comment">//p = 001BF910</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'c'</span>; </span><br><span class="line">    <span class="keyword">char</span>&amp; rc = c;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; trc = c;</span><br><span class="line">    </span><br><span class="line">    rc = <span class="string">'a'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c = %c\n"</span>, c); <span class="comment">// c = a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"rc = %c\n"</span>, rc);<span class="comment">// rc = a</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"trc = %c\n"</span>, trc);<span class="comment">//trc = c</span></span><br><span class="line">    <span class="comment">//变量c是char类型，而trc是int类型，所以生成了一个新的只读变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><img src="/img/20180912085909216.png" alt></p>
<h1 id="const与-define的区别："><a href="#const与-define的区别：" class="headerlink" title="const与#define的区别："></a>const与#define的区别：</h1><ul>
<li>const定义的常量是变量带类型，而#define定义的只是个常数不带类型；</li>
<li>define只在预处理阶段起作用，简单的文本替换，而const在编译、链接过程中起作用；</li>
<li>define只是简单的字符串替换没有类型检查。而const是有数据类型的，是要进行判断的，可以避免一些低级错误；</li>
<li>define预处理后，占用代码段空间，const占用数据段空间；</li>
<li>const不能重定义，而define可以通过#undef取消某个符号的定义，进行重定义；</li>
<li>define独特功能，比如可以用来防止文件重复引用。</li>
</ul>
<h1 id="new-操作符（new-operator）"><a href="#new-操作符（new-operator）" class="headerlink" title="new 操作符（new operator）"></a>new 操作符（new operator）</h1><p>当你写这种代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Memory Management"</span>);</span><br></pre></td></tr></table></figure></p>
<p>你使用的new是new操作符。这个操作符就象sizeof一样是语言内置的。你不能改变它的含义，它的功能总是一样的。它要完毕的功能分成两部分。第一部分是分配足够的内存以便容纳所需类型的对象。第二部分是它调用构造函数初始化内存中的对象。new操作符总是做这两件事情，你不能以不论什么方式改变它的行为。</p>
<h1 id="operator-new"><a href="#operator-new" class="headerlink" title="operator new"></a>operator new</h1><p>你所能改变的是怎样为对象分配内存。</p>
<p>new操作符调用一个函数来完毕必需的内存分配，你可以重写或重载这个函数来改变它的行为。new操作符为分配内存所调用函数的名字是operator new。<br>函数operator new 通常这样声明：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>返回值类型是void*，由于这个函数返回一个未经处理（raw）的指针。未初始化的内存。參数size_t确定分配多少内存。</p>
<p>你能添加额外的參数重载函数operator new，可是第一个參数类型必须是size_t。</p>
<p>你一般不会直接调用operator new，可是一旦这么做。你能够象调用其他函数一样调用它：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *rawMemory = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(<span class="built_in">string</span>));</span><br></pre></td></tr></table></figure></p>
<p>操作符operator new将返回一个指针，指向一块足够容纳一个string类型对象的内存。就象malloc一样，operator new的职责仅仅是分配内存。</p>
<p>它对构造函数一无所知。operator new所了解的是内存分配。把operator new 返回的未经处理的指针传递给一个对象是new操作符的工作。当你的编译器遇见这种语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Memory Management"</span>);</span><br></pre></td></tr></table></figure></p>
<p>它生成的代码或多或少与以下的代码相似（很多其它的细节见Effective C++条款8和条款10。还有我的文章Counting object里的凝视。）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *memory = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(<span class="built_in">string</span>)); <span class="comment">// 得到未经处理的内存，为String对象</span></span><br><span class="line">call <span class="built_in">string</span>::<span class="built_in">string</span>(<span class="string">"Memory Management"</span>) </span><br><span class="line">on *memory; <span class="comment">// 内存中的对象</span></span><br><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">static_cast</span>&lt;<span class="built_in">string</span>*&gt;(memory); <span class="comment">// 使ps指针指向新的对象</span></span><br></pre></td></tr></table></figure></p>
<p>注意第二步包括了构造函数的调用，你做为一个程序猿被禁止这样去做。你的编译器则没有这个约束，它能够做它想做的一切。<br>因此假设你想建立一个堆对象就必须用new操作符。不能直接调用构造函数来初始化对象。（总结：operator new是用来分配内存的函数，为new操作符调用。能够被重载（有限制））</p>
<h1 id="placement-new"><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h1><p>有时你确实想直接调用构造函数。在一个已存在的对象上调用构造函数是没有意义的，由于构造函数用来初始化对象。而一个对象只能在给它初值时被初始化一次。</p>
<p>可是有时你有一些已经被分配可是尚未处理的的(raw)内存，你须要在这些内存中构造一个对象。你能够使用一个特殊的operator new ，它被称为placement new。</p>
<p>以下的样例是placement new怎样使用，考虑一下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span></span><br><span class="line">　<span class="keyword">public</span>:</span><br><span class="line">　　Widget(<span class="keyword">int</span> widgetSize);</span><br><span class="line">　　...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget * <span class="title">constructWidgetInBuffer</span><span class="params">(<span class="keyword">void</span> *buffer,<span class="keyword">int</span> widgetSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　<span class="keyword">return</span> <span class="keyword">new</span> (buffer) Widget(widgetSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数返回一个指针。指向一个Widget对象，对象在转递给函数的buffer里分配。<br>当程序使用共享内存或memory-mapped I/O时这个函数可能实用，由于在这样程序里对象必须被放置在一个确定地址上或一块被例程分配的内存里。（參见条款4,一个怎样使用placement new的一个不同样例。）</p>
<p>在constructWidgetInBuffer里面。返回的表达式是：<code>new (buffer) Widget(widgetSize)</code></p>
<p>这初看上去有些陌生，可是它是new操作符的一个使用方法，须要使用一个额外的变量（buffer）。当new操作符隐含调用operator new函数时。把这个变量传递给它。被调用的operator new函数除了带有强制的參数size_t外，还必须接受void*指针參数。指向构造对象占用的内存空间。这个operator new就是placement new，它看上去象这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>, <span class="keyword">void</span> *location)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　<span class="keyword">return</span> location;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这可能比你期望的要简单，可是这就是placement new须要做的事情。毕竟operator new的目的是为对象分配内存然后返回指向该内存的指针。在使用placement new的情况下，调用者已经获得了指向内存的指针。由于调用者知道对象应该放在哪里。placement new必须做的就是返回转递给它的指针。（没实用的（可是强制的）參数size_t没有名字，以防止编译器发出警告说它没有被使用。见条款6。<br>） placement new是标准C++库的一部分。为了使用placement new。你必须使用语句#include <new>（或者假设你的编译器还不支持这新风格的头文件名称）。</new></p>
<p>（总结：placement new是一种特殊的operator new，作用于一块已分配但未处理或未初始化的raw内存）</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>让我们从placement new回来片刻，看看new操作符（new operator）与operator new的关系，（new操作符调用operator new）你想在堆上建立一个对象，应该用new操作符。它既分配内存又为对象调用构造函数。假设你只想分配内存，就应该调用operator new函数；它不会调用构造函数。假设你想定制自己的在堆对象被建立时的内存分配过程，你应该写你自己的operator new函数。然后使用new操作符，new操作符会调用你定制的operator new。假设你想在一块已经获得指针的内存里建立一个对象。应该用placement new。</p>
<h2 id="Deletion-and-Memory-Deallocation"><a href="#Deletion-and-Memory-Deallocation" class="headerlink" title="Deletion and Memory Deallocation"></a>Deletion and Memory Deallocation</h2><p>为了避免内存泄漏，每一个动态内存分配必须与一个等同相反的deallocation相应。</p>
<p>函数operator delete与delete操作符的关系与operator new与new操作符的关系一样。当你看到这些代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string *ps;</span><br><span class="line">...</span><br><span class="line">delete ps; // 使用delete 操作符</span><br></pre></td></tr></table></figure></p>
<p>你的编译器会生成代码来析构对象并释放对象占有的内存。</p>
<p>Operator delete用来释放内存。它被这样声明：<br>void operator delete(void *memoryToBeDeallocated);<br>因此， delete ps;  导致编译器生成类似于这种代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps-&gt;~string(); // call the object&apos;s dtor</span><br><span class="line">operator delete(ps); // deallocate the memory the object occupied</span><br></pre></td></tr></table></figure></p>
<p>这有一个隐含的意思是假设你仅仅想处理未被初始化的内存，你应该绕过new和delete操作符，而调用operator new 获得内存和operator delete释放内存给系统：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void *buffer = operator new(50*sizeof(char)); // 分配足够的内存以容纳50个char</span><br><span class="line">//没有调用构造函数</span><br><span class="line">...</span><br><span class="line">operator delete(buffer); // 释放内存</span><br><span class="line">// 没有调用析构函数</span><br></pre></td></tr></table></figure></p>
<p>这与在C中调用malloc和free等同。</p>
<p>2.placement new建立的对象怎样释放？<br>假设你用placement new在内存中建立对象，你应该避免在该内存中用delete操作符。</p>
<p>由于delete操作符调用operator delete来释放内存，可是包括对象的内存最初不是被operator new分配的。placement new仅仅是返回转递给它的指针。谁知道这个指针来自何方？而你应该显式调用对象的析构函数来解除构造函数的影响：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 在共享内存中分配和释放内存的函数 void * mallocShared(size_t size);</span><br><span class="line"></span><br><span class="line">void freeShared(void *memory);</span><br><span class="line">void *sharedMemory = mallocShared(sizeof(Widget));</span><br><span class="line">Widget *pw = // 如上所看到的,</span><br><span class="line">constructWidgetInBuffer(sharedMemory, 10); // 使用</span><br><span class="line"></span><br><span class="line">// placement new </span><br><span class="line">...</span><br><span class="line">delete pw; // 结果不确定! 共享内存来自</span><br><span class="line">// mallocShared, 而不是operator new</span><br><span class="line">pw-&gt;~Widget(); // 正确。 析构 pw指向的Widget，</span><br><span class="line">// 可是没有释放</span><br><span class="line">//包括Widget的内存</span><br><span class="line">freeShared(pw); // 正确。 释放pw指向的共享内存</span><br><span class="line">// 可是没有调用析构函数</span><br></pre></td></tr></table></figure></p>
<p>如上例所看到的，假设传递给placement new的raw内存是自己动态分配的（通过一些不经常使用的方法），假设你希望避免内存泄漏，你必须释放它。（參见我的文章Counting objects里面关于placement delete的凝视。）</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>如何分配数组？会发生什么？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>]; <span class="comment">// allocate an array of objects</span></span><br></pre></td></tr></table></figure></p>
<p>被使用的new仍然是new操作符，可是建立数组时new操作符的行为与单个对象建立有少许不同。<br>第一是内存不再用operator new分配，取代以等同的数组分配函数，叫做operator new[]（常常被称为array new）。</p>
<p>它与operator new一样能被重载。</p>
<p>在这种编译器下定制数组内存分配是困难的。由于它须要重写全局operator new。这可不是一个能轻易接受的任务。</p>
<p>缺省情况下，全局operator new处理程序中全部的动态内存分配，所以它行为的不论什么改变都将有深入和普遍的影响。并且全局operator new有一个正常的签名（normal signature）。</p>
<p>第二个不同是new操作符调用构造函数的数量。对于数组，在数组里的每个对象的构造函数都必须被调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>]; <span class="comment">// 调用operator new[]为10个string对象分配内存,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后对每一个数组元素调用string对象的缺省构造函数。</span></span><br></pre></td></tr></table></figure></p>
<p>相同当delete操作符用于数组时，它为每一个数组元素调用析构函数，然后调用operator delete来释放内存。</p>
<p>就象你能替换或重载operator delete一样，你也替换或重载operator delete[]。</p>
<h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><p>首先说一下内存的五个区：</p>
<ul>
<li>栈(stack)：由编译器自动分配释放，存放函数的参数值，局部变量的值（除static），其操作方式类似于数据结构中的栈。</li>
<li>堆(heap)：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆(优先队列)是两回事，分配方式倒是类似于链表。</li>
<li>全局区(静态区)：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域(BSS)，程序结束后由系统释放。</li>
<li>文字常量区：常量字符串就是放在这里的，如char str[]=”hello”，程序结束后由系统释放，区别const修饰的变量。</li>
<li>程序代码区：存放函数体的二进制代码。</li>
</ul>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li>
<li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li>
<li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li>
<li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li>
</ol>
<ul>
<li>在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。</li>
<li>在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。</li>
<li>在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用</li>
<li>类内的static成员变量属于整个类所拥有，不能在类内进行定义，只能在类的作用域内进行定义</li>
<li>类内的static成员函数属于整个类所拥有，不能包含this指针，只能调用static成员函数</li>
</ul>
<h2 id="全局变量和static变量的区别"><a href="#全局变量和static变量的区别" class="headerlink" title="全局变量和static变量的区别"></a>全局变量和static变量的区别</h2><ul>
<li>全局变量（外部变量）的说明之前再冠以static就构成了静态的全局变量。<ul>
<li>全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。</li>
<li>这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个原文件组成时，非静态的全局变量在各个源文件中都是有效的。</li>
<li>而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。</li>
</ul>
</li>
<li>static全局变量与普通的全局变量的区别是static全局变量只初始化一次，防止在其他文件单元被引用。</li>
</ul>
<p>static函数与普通的函数作用域不同。尽在本文件中。只在当前源文件中使用的函数应该说明为内部函数（static），内部函数应该在当前源文件中说明和定义。</p>
<p>对于可在当前源文件以外使用的函数应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。static函数与普通函数最主要区别是static函数在内存中只有一份，普通静态函数在每个被调用中维持一份拷贝程序的局部变量存在于（堆栈）中，全局变量存在于（静态区）中，动态申请数据存在于（堆）</p>
<h2 id="static-变量"><a href="#static-变量" class="headerlink" title="static 变量"></a>static 变量</h2><p>静态局部变量保存在全局数据区(静态区)，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。</p>
<ul>
<li>static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;</li>
<li>static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；</li>
<li>static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝</li>
</ul>
<h2 id="static-成员变量"><a href="#static-成员变量" class="headerlink" title="static 成员变量"></a>static 成员变量</h2><p>定义必须在类定义体的外部，在类的内部只是声明，声明必须加static，定义不需要。static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明static变量，任何声明都不可初始化，如extern外部变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义static成员变量，可初始化</span></span><br><span class="line"><span class="keyword">int</span> A::a = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 私有静态成员变量，不能直接用类名调用或者对象调用，只能在类内调用</span></span><br><span class="line"><span class="keyword">int</span> A::b = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>跟类相关的，跟具体的类的对象无关，为所有实例所共享，某个类的实例修改了该静态成员变量，其修改值为该类的其它所有实例所见。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明static变量，任何声明都不可初始化，如extern外部变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义static成员变量，可初始化</span></span><br><span class="line"><span class="keyword">int</span> A::a = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 私有静态成员变量，不能直接用类名调用或者对象调用，只能在类内调用</span></span><br><span class="line"><span class="keyword">int</span> A::b = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// new 两个个实例（对象）</span></span><br><span class="line">    A * instanceA = <span class="keyword">new</span> A();</span><br><span class="line">    A * instanceB = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="comment">// 改变值,均输出1</span></span><br><span class="line">    instanceA-&gt;a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; A::a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; instanceA-&gt;getAValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; instanceB-&gt;getAValue() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="static-函数"><a href="#static-函数" class="headerlink" title="static 函数"></a>static 函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">// 声明</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>,a);</span><br><span class="line">    printHello();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【编译】<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ a.cpp b.cpp -o ab.exe</span><br></pre></td></tr></table></figure></p>
<p>【输出】<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p>
<p>【分析】</p>
<p>如果在a.cpp中的int a = 5;定义前面加上static修饰，那么再次去编译，就会b.cpp报未定义错误。如果在a.cpp中的void printHello()函数前加static修饰，再次去编译，一样会报未定义错误。很明显，所有未加static修饰的函数和全局变量具有全局可见性，其他的源文件也能够访问。static修饰函数和变量这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏。这有点类似于C++中的名字空间。</p>
<h2 id="static-成员函数"><a href="#static-成员函数" class="headerlink" title="static 成员函数"></a>static 成员函数</h2><p>同样的和成员变量一样，跟类相关的，跟具体的类的对象无关，可以通过类名来调用。static成员函数里面不能访问非静态成员变量，也不能调用非静态成员函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printStr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 错误，静态成员函数不能调用非静态成员函数</span></span><br><span class="line">        printStr();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>静态成员函数没有this隐含指针修饰，存在一种情况，用const修饰类的成员函数(写在函数的最后，不是前面，前面是返回值为常量)，表示该函数不能修改该类的状态，如不能在改函数里修改成员变量(除去mutable修饰的外)，因为该函数存在一个隐式的this<em>，const修饰后为const this</em>，但是当static修饰成员函数的时候是没有this指针的，所以不能同时用static和const修饰同一个成员函数，不过可以修饰同一个成员变量。</p>
<p>static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；</p>
<p>虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual</p>
<h1 id="vector和set使用sort方法进行排序"><a href="#vector和set使用sort方法进行排序" class="headerlink" title="vector和set使用sort方法进行排序"></a>vector和set使用sort方法进行排序</h1><p>C++中vector和set都是非常方便的容器，</p>
<p>sort方法是algorithm头文件里的一个标准函数，能进行高效的排序，默认是按元素从小到大排序</p>
<p>将sort方法用到vector和set中能实现多种符合自己需求的排序</p>
<p>首先sort方法可以对静态的数组进行排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int a[10] = &#123; 9, 0, 1, 2, 3, 7, 4, 5, 100, 10 &#125;;</span><br><span class="line">    sort(a, a +10);</span><br><span class="line">    for (int i = 0; i &lt; 10; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><img src="/img/909212-20160603234145961-1605510938.png" alt="结果"></p>
<p>这里可以看到是sort(a,a+10)，但是数组a一共只有9个元素，为什么是a+10而不是a+9呢？</p>
<p>因为sort方法实际上最后一位地址对应的数是不取的，</p>
<p>而且vector，set，map这些容器的end()取出来的值实际上并不是最后一个值，而end的前一个才是最后一个值！</p>
<p>需要用prev(xxx.end())，才能取出容器中最后一个元素。</p>
<p>对vector使用sort函数：</p>
<p>第一种情形：基本类型,如vector<int>,vector<double>,vector<string>也是可以的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    vector&lt;int&gt; a;</span><br><span class="line">    int n = 5;</span><br><span class="line">    while (n--)&#123;</span><br><span class="line">        int score;</span><br><span class="line">        cin &gt;&gt; score;</span><br><span class="line">        a.push_back(score);</span><br><span class="line">    &#125;</span><br><span class="line">    //cout &lt;&lt;&quot; a.end()&quot;&lt;&lt; *a.end() &lt;&lt; endl;       执行这句话会报错！</span><br><span class="line">    cout &lt;&lt; &quot; prev(a.end)&quot; &lt;&lt; *prev(a.end()) &lt;&lt; endl;</span><br><span class="line">    sort(a.begin(), a.end());</span><br><span class="line">    for (vector&lt;int&gt;::iterator it = a.begin(); it != a.end(); it++)&#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></string></double></int></p>
<p><img src="/img/909212-20160603235458727-271967874.png" alt></p>
<p>看到了吗，实际上end的前一个指针指向的元素才是插入时的最后一个值！</p>
<p>排序后从小大大。</p>
<p>第二种情形：用自定义的结构体进行sort算法，</p>
<p>这时候需要自己定义个比较函数，因为sort算法是基于容器中的元素是可以两两比较的，然后从小到大排序，所以要自定义怎么样才是小于（’&lt;’）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//自定义“小于”</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> student &amp;a, <span class="keyword">const</span> student &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.score &lt; b.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;student&gt; vectorStudents;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--)&#123;</span><br><span class="line">        student oneStudent;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">int</span> score;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; name &gt;&gt; score;</span><br><span class="line">        <span class="built_in">strcpy</span>(oneStudent.name, name.c_str());</span><br><span class="line">        oneStudent.score = score;</span><br><span class="line">        vectorStudents.push_back(oneStudent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"===========排序前================"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;student&gt;::iterator it = vectorStudents.begin(); it != vectorStudents.end(); it++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"name: "</span> &lt;&lt; it-&gt;name &lt;&lt; <span class="string">" score: "</span> &lt;&lt; it-&gt;score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(vectorStudents.begin(),vectorStudents.end(),comp);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"===========排序后================"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;student&gt;::iterator it = vectorStudents.begin(); it != vectorStudents.end(); it++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"name: "</span> &lt;&lt; it-&gt;name &lt;&lt; <span class="string">" score: "</span> &lt;&lt; it-&gt;score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/909212-20160604002208836-1075703850.png" alt></p>
<p>对于set做类似的操作。</p>
<p>set是一个集合，内部的元素不会重复，同时它会自动进行排序，也是从小到大</p>
<p>而且set的insert方法没有insert(a,cmp)这种重载，所以如果要把结构体插入set中，我们就要重载’&lt;’运算符。</p>
<p>set方法在插入的时候也是从小到大的，那么我们重载一下&lt;运算符让它从大到小排序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//自定义“小于”</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">const</span> student &amp;a, <span class="keyword">const</span> student &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.score &lt; b.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> student &amp; stu1,<span class="keyword">const</span> student &amp;stu2)&#123;</span><br><span class="line">    <span class="keyword">return</span> stu1.score &gt; stu2.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//vector&lt;student&gt; vectorStudents;</span></span><br><span class="line">    <span class="built_in">set</span>&lt;student&gt; setStudents;</span><br><span class="line">    <span class="comment">//int n = 5;</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--)&#123;</span><br><span class="line">        student oneStudent;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">int</span> score;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; name &gt;&gt; score;</span><br><span class="line">        <span class="built_in">strcpy</span>(oneStudent.name, name.c_str());</span><br><span class="line">        oneStudent.score = score;</span><br><span class="line">        setStudents.insert(oneStudent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"===========排序前================"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">set</span>&lt;student&gt;::iterator it = setStudents.begin(); it != setStudents.end(); it++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"name: "</span> &lt;&lt; it-&gt;name &lt;&lt; <span class="string">" score: "</span> &lt;&lt; it-&gt;score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//sort(setStudents.begin(), setStudents.end(), comp);</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; "===========排序后================" &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//for (set&lt;student&gt;::iterator it = setStudents.begin(); it != setStudents.end(); it++)&#123;</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; "name: " &lt;&lt; it-&gt;name &lt;&lt; " score: " &lt;&lt; it-&gt;score &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/909212-20160604002803352-2018700987.png" alt></p>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><h2 id="why-volatile"><a href="#why-volatile" class="headerlink" title="why volatile"></a>why volatile</h2><p>volatile 关键词，最早出现于20世纪70年代，被用于处理 MMIO(Memory-mapped I/O) 带来的问题。在引入 MMIO 之后，一块内存地址既有可能是真正的内存，也有可能是映射的一个I/O端口。因此，读/写一个内存地址，既有可能是真正地操作内存，也有可能是读/写一个I/O设备。</p>
<p>那么 MMIO 为什么需要引入 volatile 关键词呢？我们结合下面这段示例代码进行解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unsigned int *p = FunB();</span><br><span class="line">unsigned int a;</span><br><span class="line">unsigned int b;</span><br><span class="line"> </span><br><span class="line">a = *p;     // 语句1</span><br><span class="line">b = *p;     // 语句2</span><br><span class="line"> </span><br><span class="line">*p = a;     // 语句3</span><br><span class="line">*p = b;     // 语句4</span><br></pre></td></tr></table></figure></p>
<p>在上述代码片段中，指针p既有可能指向一个内存地址，也有可能指向一个I/O设备。如果指针p指向的是I/O设备，那么语句1和语句2中的变量a和变量b，就会接收到I/O设备的连续两个字节。但是，指针p也有可能指向内存地址，这种情况下，编译器就会进行语句优化，编译器的优化策略会判断变量a和变量b同时从同一个内存地址读取数据，因此在执行完语句1之后，直接将变量a赋值给变量b。对于指针p指向I/O设备的这种情况，就需要防止编译器进行此优化，即不能假设指针b指向的内容不变（对应 volatile 的易变性特性）。</p>
<p>同样，语句3和语句4也有类似的问题，编译器发现将变量a和b同时赋值给指针p是无意义的，因此可能会优化语句3中的赋值操作，而仅仅保留语句4。对于指针p指向I/O设备的情况，也需要防止编译器将类似的写操作给优化消失了（对应 volatile 的不可优化特性）。</p>
<p>对于I/O设备，编译器不能随意交互指令的顺序，因为指令顺序一变，写入I/O设备的内容也就发生变化了（对应 volatile 的顺序性）。</p>
<p>为了满足 MMIO 的这三点需求，就有了 volatile 关键字。</p>
<h2 id="IN-C-C"><a href="#IN-C-C" class="headerlink" title="IN C/C++"></a>IN C/C++</h2><p>在C/C++语言中，使用 volatile 关键字声明的变量（或对象）通常具有与优化、多线程相关的特殊属性。通常，volatile 关键字用来阻止（伪）编译器对其认为的、无法“被代码本身”改变的代码（变量或对象）进行优化。如在C/C++中，volatile 关键字可以用来提醒编译器使用 volatile 声明的变量随时有可能改变，因此编译器在代码编译时就不会对该变量进行某些激进的优化，故而编译生成的程序在每次存储或读取该变量时，都会直接从内存地址中读取数据。相反，如果该变量没有使用 volatile 关键字进行声明，则编译器可能会优化读取和存储操作，可能暂时使用寄存器中该变量的值，而如果这个变量由别的程序（线程）更新了的话，就会出现（内存中与寄存器中的）变量值不一致的现象。</p>
<p>定义为volatile的变量是说这变量可能会被意想不到地改变，即在你程序运行过程中一直会变，你希望这个值被正确的处理，每次从内存中去读这个值，而不是因编译器优化从缓存的地方读取，比如读取缓存在寄存器中的数值，从而保证volatile变量被正确的读取。</p>
<p>在单任务的环境中，一个函数体内部，如果在两次读取变量的值之间的语句没有对变量的值进行修改，那么编译器就会设法对可执行代码进行优化。由于访问寄存器的速度要快过RAM（从RAM中读取变量的值到寄存器），以后只要变量的值没有改变，就一直从寄存器中读取变量的值，而不对RAM进行访问。</p>
<p>而在多任务环境中，虽然在一个函数体内部，在两次读取变量之间没有对变量的值进行修改，但是该变量仍然有可能被其他的程序（如中断程序、另外的线程等）所修改。如果这时还是从寄存器而不是从RAM中读取，就会出现被修改了的变量值不能得到及时反应的问题。</p>
<p> 因为访问寄存器要比访问内存单元快的多,所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。当要求使用volatile声明变量值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。精确地说就是，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用valatile，则编译器将对所声明的语句进行优化。（简洁的说就是：volatile关键词影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错。加了volatile修饰的变量，编译器将不对其相关代码执行优化，而是生成对应代码直接存取原始内存地址）。</p>
<p> 一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。一般说来，volatile用在如下的几个地方：</p>
<ol>
<li>并行设备的硬件寄存器（如：状态寄存器）</li>
<li>中断服务程序中修改的供其它程序检测的变量需要加volatile；</li>
<li>多任务环境下各任务间共享的标志应该加volatile；</li>
<li>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能有不同意义；</li>
</ol>
<p>在C/C++语言中，使用 volatile 关键字声明的变量具有三种特性：易变的、不可优化的、顺序执行的。下面分别对这三种特性进行介绍。</p>
<h2 id="易变的"><a href="#易变的" class="headerlink" title="易变的"></a>易变的</h2><p>volatile 在词典中的主要释义就是“易变的”。</p>
<p>在 C/C++ 语言中，volatile 的易变性体现在：假设有读、写两条语句，依次对同一个 volatile 变量进行操作，那么后一条的读操作不会直接使用前一条的写操作对应的 volatile 变量的寄存器内容，而是重新从内存中读取该 volatile 变量的值。</p>
<p>上述描述的（部分）示例代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> nNum = <span class="number">0</span>;  <span class="comment">// 将nNum声明为volatile</span></span><br><span class="line"><span class="keyword">int</span> nSum = <span class="number">0</span>;</span><br><span class="line">nNum = FunA();      <span class="comment">// nNum被写入的新内容，其值会缓存在寄存器中</span></span><br><span class="line">nSum = nNum + <span class="number">1</span>;    <span class="comment">// 此处会从内存（而非寄存器）中读取nNum的值</span></span><br></pre></td></tr></table></figure></p>
<h2 id="不可优化的"><a href="#不可优化的" class="headerlink" title="不可优化的"></a>不可优化的</h2><p>在 C/C++ 语言中，volatile 的第二个特性是“不可优化性”。volatile 会告诉编译器，不要对 volatile 声明的变量进行各种激进的优化（甚至将变量直接消除），从而保证程序员写在代码中的指令一定会被执行。</p>
<p>上述描述的（部分）示例代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> nNum;  <span class="comment">// 将nNum声明为volatile</span></span><br><span class="line">nNum = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"nNum is: %d"</span>, nNum);</span><br></pre></td></tr></table></figure></p>
<p>在上述代码中，如果变量 nNum 没有声明为 volatile 类型，则编译器在编译过程中就会对其进行优化，直接使用常量“1”进行替换（这样优化之后，生成的汇编代码很简介，执行时效率很高）。而当我们使用 volatile 进行声明后，编译器则不会对其进行优化，nNum 变量仍旧存在，编译器会将该变量从内存中取出，放入寄存器之中，然后再调用 printf() 函数进行打印。</p>
<h2 id="顺序执行的"><a href="#顺序执行的" class="headerlink" title="顺序执行的"></a>顺序执行的</h2><p>在 C/C++ 语言中，volatile 的第三个特性是“顺序执行特性”，即能够保证 volatile 变量间的顺序性，不会被编译器进行乱序优化。</p>
<p>说明：C/C++ 编译器最基本优化原理：保证一段程序的输出，在优化前后无变化。</p>
<p>为了对本特性进行深入了解，下面以两个变量（nNum1 和 nNum2）为例（既然存在“顺序执行”，那描述对象必然大于一个），结合如下示例代码，介绍 volatile 的顺序执行特性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nNum1;</span><br><span class="line"><span class="keyword">int</span> nNum2;</span><br><span class="line">nNum2 = nNum1 + <span class="number">1</span>;    <span class="comment">// 语句1</span></span><br><span class="line">nNum1 = <span class="number">10</span>;           <span class="comment">// 语句2</span></span><br></pre></td></tr></table></figure></p>
<p>在上述代码中：</p>
<ul>
<li>当 nNum1 和 nNum2 都没有使用 volatile 关键字进行修饰时，编译器会对“语句1”和“语句2”的执行顺序进行优化：即先执行“语句2”、再执行“语句1”；</li>
<li>当 nNum2 使用 volatile 关键字进行修饰时，编译器也可能会对“语句1”和“语句2”的执行顺序进行优化：即先执行“语句2”、再执行“语句1”；</li>
<li>当 nNum1 和 nNum2 都使用 volatile 关键字进行修饰时，编译器不会对“语句1”和“语句2”的执行顺序进行优化：即先执行“语句1”、再执行“语句2”；</li>
</ul>
<p>说明：上述论述可通过观察代码的生成的汇编代码进行验证。</p>
<h2 id="volatile与多线程语义"><a href="#volatile与多线程语义" class="headerlink" title="volatile与多线程语义"></a>volatile与多线程语义</h2><p>对于多线程编程而言，在临界区内部，可以通过互斥锁（mutex）保证只有一个线程可以访问该临界区的内容，因此临界区内的变量不需要是 volatile 的；而在临界区外部，被多个线程访问的变量应声明为 volatile 的，这也符合了 volatile 的原意：防止编译器缓存（cache）了被多个线程并发用到的变量。</p>
<p>不过，需要注意的是，由于 volatile 关键字的“顺序执行特性”并非会完全保证语句的顺序执行（如 volatile 变量与非volatile 变量之间的操作；又如一些 CPU 也会对语句的执行顺序进行优化），因此导致了对 volatile 变量的操作并不是原子的，也不能用来为线程建立严格的 happens-before 关系。</p>
<p>对于上述描述，示例代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nNum1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">thread1()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line"> </span><br><span class="line">    nNum1 = <span class="number">666</span>;  <span class="comment">// 语句1</span></span><br><span class="line">    flag = <span class="literal">true</span>;  <span class="comment">// 语句2</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">thread2()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span> == flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 语句3：按照程序设计的预想，此处的nNum1的值应为666，并据此进行逻辑设计</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上述代码中，我们的设计思路是先执行 thread1() 中的“语句1”、“语句2”、再执行 thread2() 中的“语句3”，不过实际上程序的执行结果未必如此。根据 volatile 的“顺序性”，非 volatile 变量 nNum1 和 volatile 变量 flag 的执行顺序，可能会被编译器（或 CPU）进行乱序优化，最终导致thread1中的“语句2”先于“语句1”执行，当“语句2”执行完成但“语句1”尚未执行时，此时 thread2 中的判断语句“if (true == flag)”是成立的，但实际上 nNum1 尚未进行赋值为666（语句1尚未执行），所以在判断语句中针对 nNum1 为666的前提下进行的相关操作，就会有问题了。</p>
<p>这是一个在多线程编程中，使用 volatile 不容易发现的问题。</p>
<p>实际上，上述多线程代码想实现的就是一个 happens-before 语义，即保证 thread1 代码块中的所有代码，一定要在 thread2 代码块的第一条代码之前完成。使用互斥锁（mutex）可以保证 happens-before 语义。但是，在 C/C++ 中的 volatile 关键词不能保证这个语义，也就意味着在多线程环境下使用 C/C++ 的 volatile 关键词，如果不够细心，就可能会出现上述问题。</p>
<p>说明：由于 Java 语言的 volatile 关键字支持 Acquire、Release 语义，因此 Java 语言的 volatile 能够用来构建 happens-before 语义。也就是说，前面提到的 C/C++ 中 volatile 在多线程下使用出现的问题，在 Java 语言中是不存在的。</p>
<h2 id="不保证原子性"><a href="#不保证原子性" class="headerlink" title="不保证原子性"></a>不保证原子性</h2><p>volatile只保证其“可见性”，不保证其“原子性”。</p>
<p>执行count++;这条语句由3条指令组成：</p>
<ol>
<li>将 count 的值从内存加载到 cpu 的某个 寄存器r；</li>
<li>将 寄存器r 的值 +1，结果存放在 寄存器s；</li>
<li>将 寄存器s 中的值写回内存。</li>
</ol>
<p>所以，如果有多个线程同时在执行 count++，在某个线程执行完第（3）步之前，其它线程是看不到它的执行结果的。（这里有疑惑：线程同时执行count++，为了保证其原子性，为何不加mutex lock？而是寻求volatile?）</p>
<p>在没有volatile的时候，执行完count++，执行结果其实是写到CPU缓存中，没有马上写回到内存中，后续在某些情况下（比如CPU缓存不够用）再将CPU缓存中的值flush到内存。因为没有存到内存里，其他线程是不能及时看到执行结果的。</p>
<p>在有volatile的时候，执行完count++，执行结果写入缓存中，并同时写入内存中，所以可以保证其它线程马上看到执行的结果。</p>
<p>但是，volatile 并没有保证原子性，在某个线程执行（1）（2）（3）的时候，volatile 并没有锁定 count 的值，也就是并不能阻塞其他线程也执行（1）（2）（3）。可能有两个线程同时执行（1），所以（2）计算出来一样的结果，然后（3）存回的也是同一个值。<br>考虑下面一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int some_int = 100;</span><br><span class="line">while(some_int == 100)</span><br><span class="line">&#123;</span><br><span class="line">   //your code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为编译器认为some_int没被改变过，一直是100。但是在多线程时，如果执行完第一行，但是还没执行到第三行时，另一个线程修改了some_int，while就不能进入循环了。加了volatile后，阻止了编译器优化，每次读到some_int会从内存中读取，而不是本线程的寄存去（当然这会损失效率）。这就是volatile的作用。</p>
<p>一句话总结：volatile保证线程能读到最新的数据，因为是从内存中读取，且存入内存中。而不是线程各自的寄存器中读写。</p>
<h1 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title="inline 内联函数"></a>inline 内联函数</h1><p>内联函数和普通函数相比可以加快程序运行的速度，因为不需要中断调用，在编译的时候内联函数可以直接嵌入到目标代码中。</p>
<ul>
<li>相当于把内联函数里面的内容写在调用内联函数处；</li>
<li>相当于不用执行进入函数的步骤，直接执行函数体；</li>
<li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li>
<li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li>
<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li>
<li>作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明1（加 inline，建议使用）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明2（不加 inline）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">functionName</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second,...)</span> </span>&#123;<span class="comment">/****/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内定义，隐式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;         <span class="comment">// 隐式内联</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义，需要显式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> A::doA() &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;   <span class="comment">// 需要显式内联</span></span><br></pre></td></tr></table></figure>
<p>编译器对 inline 函数的处理步骤</p>
<ol>
<li>将 inline 函数体复制到 inline 函数调用点处； </li>
<li>为所用 inline 函数中的局部变量分配内存空间； </li>
<li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； </li>
<li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li>
</ol>
<p>优点</p>
<ol>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>
<li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 </li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li>
<li>内联函数在运行时可调试，而宏定义不可以。</li>
</ol>
<p>缺点</p>
<ol>
<li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li>
</ol>
<h2 id="内联函数和宏定义的区别"><a href="#内联函数和宏定义的区别" class="headerlink" title="内联函数和宏定义的区别"></a>内联函数和宏定义的区别</h2><p>内联函数以代码复杂为代价，它以省去函数调用的开销来提高执行效率。所以一方面如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义；另一方面每一处内联函数的调用都要复制代码，消耗更多的内存空间，因此以下情况不宜使用内联函数：</p>
<ul>
<li>函数体内的代码比较长，将导致内存消耗代价</li>
<li>函数体内有循环，函数执行时间要比函数调用开销大</li>
</ul>
<h2 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h2><ul>
<li>内联函数在编译时展开，宏在预编译时展开</li>
<li>内联函数直接嵌入到目标代码中，宏是简单的做文本替换</li>
<li>内联函数有类型、语法判断等功能，而宏没有</li>
<li>内联函数是函数，宏不是</li>
<li>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义</li>
<li>内联函数代码是被放到符号表中，使用时像宏一样展开，没有调用的开销，效率很高；</li>
<li>在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。</li>
<li>内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员，进而提升效率。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。</li>
</ul>
<h1 id="union"><a href="#union" class="headerlink" title="union"></a>union</h1><p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p>
<ul>
<li>默认访问控制符为 public</li>
<li>可以含有构造函数、析构函数</li>
<li>不能含有引用类型的成员</li>
<li>不能继承自其他类，不能作为基类</li>
<li>不能含有虚函数</li>
<li>匿名 union 在定义所在作用域可直接访问 union 成员</li>
<li>匿名 union 不能包含 protected 成员或 private 成员</li>
<li>全局匿名联合必须是静态（static）的</li>
</ul>
<p>C++11 标准规定，任何非引用类型都可以成为联合体的数据成员，这种联合体也被称为非受限联合体。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">bool</span> g, <span class="keyword">int</span> a): gender(g), age(a) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> gender;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> T&#123;</span><br><span class="line">    Student s;  <span class="comment">// 含有非POD类型的成员，gcc-5.1.0  版本报错</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，因为 Student 类带有自定义的构造函数，所以是一个非 POD 类型的，这导致编译器报错。这种规定只是 C++ 为了兼容C语言而制定，然而在长期的编程实践中发现，这种规定是没有必要的。</p>
<h2 id="C-11-允许非-POD-类型"><a href="#C-11-允许非-POD-类型" class="headerlink" title="C++11 允许非 POD 类型"></a>C++11 允许非 POD 类型</h2><p>C++98 不允许联合体的成员是非 POD 类型，但是 C++11 取消了这种限制。POD 是英文 Plain Old Data 的缩写，用来描述一个类型的属性。POD 类型一般具有以下几种特征（包括 class、union 和 struct等）：</p>
<ul>
<li>没有用户自定义的构造函数、析构函数、拷贝构造函数和移动构造函数。</li>
<li>不能包含虚函数和虚基类。</li>
<li>非静态成员必须声明为 public。</li>
<li>类中的第一个非静态成员的类型与其基类不同</li>
<li>在类或者结构体继承时，满足以下两种情况之一： <ul>
<li>派生类中有非静态成员，且只有一个仅包含静态成员的基类；</li>
<li>基类有非静态成员，而派生类没有非静态成员。</li>
</ul>
</li>
<li>所有非静态数据成员均和其基类也符合上述规则（递归定义），也就是说 POD 类型不能包含非 POD 类型的数据。</li>
<li>此外，所有兼容C语言的数据类型都是 POD 类型（struct、union 等不能违背上述规则）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> :</span> B1 &#123; B1 b; &#125;;</span><br></pre></td></tr></table></figure>
<p>class B2 的第一个非静态成员 b 是基类类型，所以它不是 POD 类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span> &#123;</span> <span class="keyword">static</span> <span class="keyword">int</span> n; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span> :</span> B1 &#123; <span class="keyword">int</span> n1; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B3</span> :</span> B2 &#123; <span class="keyword">static</span> <span class="keyword">int</span> n2; &#125;;</span><br></pre></td></tr></table></figure>
<p>对于 B2，派生类 B2 中有非静态成员，且只有一个仅包含静态成员的基类 B1，所以它是 POD 类型。对于 B3，基类 B2 有非静态成员，而派生类 B3 没有非静态成员，所以它也是 POD 类型。</p>
<h2 id="C-11-允许联合体有静态成员"><a href="#C-11-允许联合体有静态成员" class="headerlink" title="C++11 允许联合体有静态成员"></a>C++11 允许联合体有静态成员</h2><p>C++11 删除了联合体不允许拥有静态成员的限制。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> U &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，静态成员变量只能在联合体内定义，却不能在联合体外使用，这使得该规则很没用。</p>
<h2 id="非受限联合体的赋值注意事项"><a href="#非受限联合体的赋值注意事项" class="headerlink" title="非受限联合体的赋值注意事项"></a>非受限联合体的赋值注意事项</h2><p>C++11 规定，如果非受限联合体内有一个非 POD 的成员，而该成员拥有自定义的构造函数，那么这个非受限联合体的默认构造函数将被编译器删除；其他的特殊成员函数，例如默认拷贝构造函数、拷贝赋值操作符以及析构函数等，也将被删除。</p>
<p>这条规则可能导致对象构造失败，请看下面的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">union</span> U &#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;   <span class="comment">// 构造失败，因为 U 的构造函数被删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中，因为 string 类拥有自定义的构造函数，所以 U 的构造函数被删除；定义 U 的类型变量 u 需要调用默认构造函数，所以 u 也就无法定义成功。</p>
<p>解决上面问题的一般需要用到 placement new，代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">union</span> U &#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    U() &#123; <span class="keyword">new</span>(&amp;s) <span class="built_in">string</span>; &#125;</span><br><span class="line">    ~U() &#123; s.~<span class="built_in">string</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>构造时，采用<code>placement new</code>将 s 构造在其地址 &amp;s 上，这里<code>placement new</code>的唯一作用只是调用了一下 string 类的构造函数。注意，在析构时还需要调用 string 类的析构函数。</p>
<h2 id="非受限联合体的匿名声明和“枚举式类”"><a href="#非受限联合体的匿名声明和“枚举式类”" class="headerlink" title="非受限联合体的匿名声明和“枚举式类”"></a>非受限联合体的匿名声明和“枚举式类”</h2><p>匿名联合体是指不具名的联合体（也即没有名字的联合体），一般定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> U&#123;</span><br><span class="line">    <span class="keyword">union</span> &#123; <span class="keyword">int</span> x; &#125;;  <span class="comment">//此联合体为匿名联合体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，联合体 U 内定义了一个不具名的联合体，该联合体包含一个 int 类型的成员变量，我们称这个联合体为匿名联合体。</p>
<p>同样的，非受限联合体也可以匿名，而当非受限的匿名联合体运用于类的声明时，这样的类被称为“枚举式类”。示例如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">bool</span> g, <span class="keyword">int</span> a): gender(g), age(a)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> gender;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> Type &#123; STUDENT, NATIVE, FOREIGENR &#125;;</span><br><span class="line">    Singer(<span class="keyword">bool</span> g, <span class="keyword">int</span> a) : s(g, a) &#123; t = STUDENT; &#125;</span><br><span class="line">    Singer(<span class="keyword">int</span> i) : id(i) &#123; t = NATIVE; &#125;</span><br><span class="line">    Singer(<span class="keyword">const</span> <span class="keyword">char</span>* n, <span class="keyword">int</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = (s &gt; <span class="number">9</span>) ? <span class="number">9</span> : s;</span><br><span class="line">        <span class="built_in">memcpy</span>(name , n, size);</span><br><span class="line">        name[s] = <span class="string">'\0'</span>;</span><br><span class="line">        t = FOREIGENR;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Singer()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type t;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Student s;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singer(<span class="literal">true</span>, <span class="number">13</span>);</span><br><span class="line">    Singer(<span class="number">310217</span>);</span><br><span class="line">    Singer(<span class="string">"J Michael"</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中使用了一个匿名非受限联合体，它作为类 Singer 的“变长成员”来使用，这样的变长成员给类的编写带来了更大的灵活性，这是 C++98 标准中无法达到的。</p>
<h1 id="assert"><a href="#assert" class="headerlink" title="assert()"></a>assert()</h1><p>断言，是宏，而非函数。<code>assert</code>宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p>
<p><code>assert()</code>会对表达式expression进行检测：</p>
<ul>
<li>如果expression的结果为 0（条件不成立），那么断言失败，表明程序出错，<code>assert()</code>会向标准输出设备（一般是显示器）打印一条错误信息，并调用 abort() 函数终止程序的执行。</li>
<li>如果expression的结果为非 0（条件成立），那么断言成功，表明程序正确，<code>assert()</code>不进行任何操作。</li>
</ul>
<p>参数：</p>
<ul>
<li>expression：要检测的表达式。如果表达式的值为 0，那么断言失败，程序终止执行；如果表达式的值为非 0，那么断言成功，assert() 不进行任何操作。</li>
</ul>
<h2 id="assert-的用法和机制"><a href="#assert-的用法和机制" class="headerlink" title="assert() 的用法和机制"></a>assert() 的用法和机制</h2><p><code>assert()</code>的用法很简单，我们只要传入一个表达式，它会计算这个表达式的结果：如果表达式的结果为“假”，<code>assert()</code>会打印出断言失败的信息，并调用<code>abort()</code>函数终止程序的执行；如果表达式的结果为“真”，<code>assert()</code>就什么也不做，程序继续往后执行。</p>
<p>下面是一个具体的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n, result;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n);</span><br><span class="line">    assert(n != <span class="number">0</span>);  <span class="comment">//写作 assert(n) 更加简洁</span></span><br><span class="line">    result = m / n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"result = %d\n"</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="NDEBUG-宏"><a href="#NDEBUG-宏" class="headerlink" title="NDEBUG 宏"></a>NDEBUG 宏</h2><p>如果查看<code>&lt;assert.h&gt;</code>头文件的源码，会发现<code>assert()</code>被定义为下面的样子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assert(e) ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assert(e)  \</span></span><br><span class="line">    ((<span class="keyword">void</span>) ((e) ? ((<span class="keyword">void</span>)<span class="number">0</span>) : __assert (#e, __FILE__, __LINE__)))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>这意味着，一旦定义了NDEBUG宏，<code>assert()</code>就无效了。</p>
<p><code>NDEBUG</code>是”No Debug“的意思，也即“非调试”。有的编译器（例如 Visual Studio）在发布（Release）模式下会定义 NDEBUG 宏，在调试（Debug）模式下不会定义定义这个宏；有的编译器（例如 Xcode）在发布模式和调试模式下都不会定义 NDEBUG 宏，这样当我们以发布模式编译程序时，就必须自己在编译参数中增加<code>NDEBUG</code>宏，或者在包含<code>&lt;assert.h&gt;</code>头文件之前定义<code>NDEBUG</code>宏。</p>
<p>调试模式是程序员在测试代码期间使用的编译模式，发布模式是将程序提供给用户时使用的编译模式。在发布模式下，我们不应该再依赖<code>assert()</code>宏，因为程序一旦出错，<code>assert()</code>会抛出一段用户看不懂的提示信息，并毫无预警地终止程序执行，这样会严重影响软件的用户体验，所以在发布模式下应该让<code>assert()</code>失效。</p>
<p>修改上面的代码，在包含<code>&lt;assert.h&gt;</code>之前定义<code>NDEBUG</code>宏：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n, result;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n);</span><br><span class="line">    assert(n);</span><br><span class="line">    result = m / n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"result = %d\n"</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当以发布模式编译这段代码时，<code>assert()</code>就会失效。如果希望继续以调试模式编译这段代码，去掉<code>NDEBUG</code>宏即可。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1) 使用<code>assert()</code>时，被检测的表达式最好不要太复杂，以下面的代码为例：<code>assert( expression1 &amp;&amp; expression2 &amp;&amp; expression3);</code></p>
<p>当发生错误时，<code>assert()</code>只会告诉我们<code>expression1 &amp;&amp; expression2 &amp;&amp; expression3</code>整个表达式为不成立，但是这个大的表达式还包含了三个小的表达式，并且它们之间是&amp;&amp;运算，任何一个小表达式为不成立都会导致整个表达式为不成立，这样我们就无法推断到底是expression1有问题，还是expression2或者expression3有问题，从而给排错带来麻烦。</p>
<p>这里我们应该遵循使用<code>assert()</code>的一个原则：每次断言只能检验一个表达式。根据这个原则，上面的代码应改为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assert(expression1);</span><br><span class="line">assert(expression2);</span><br><span class="line">assert(expression3);</span><br></pre></td></tr></table></figure></p>
<p>如此，一旦程序出错，我们就知道是哪个小的表达式断言失败了，从而快速定位到有问题的代码。</p>
<p>2) 使用<code>assert()</code>的另外一个注意事项是：不要用会改变环境的语句作为断言的表达式。请看下面的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= <span class="number">110</span>)&#123;</span><br><span class="line">        assert(++i &lt;= <span class="number">100</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"我是第%d行\n"</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 Debug 模式下运行，程序循环到第 101 次时，i 的值为 100，++i &lt;= 100不再成立，断言失败，程序终止运行。</p>
<p>在 Release 模式下运行，编译参数中设置了<code>NDEBUG</code>宏（如果编译器没有默认设置，那么需要你自己来设置），<code>assert()</code>会失效，<code>++i &lt;= 100</code>这个表达式也不起作用了，<code>while()</code>无法终止，成为一个死循环。</p>
<p>定义了<code>NDEBUG</code>宏后，<code>assert(++i &lt;= 100)</code>会被替换为<code>((void)0)</code>。</p>
<h1 id="pair类型"><a href="#pair类型" class="headerlink" title="pair类型"></a>pair类型</h1><h2 id="pair类型的定义和初始化"><a href="#pair类型的定义和初始化" class="headerlink" title="pair类型的定义和初始化"></a>pair类型的定义和初始化</h2><p>pair类型是在有文件utility中定义的，pair类型包含了两个数据值，通常有以下的一些定义和初始化的一些方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;T1, T2&gt; p;</span><br><span class="line">pair&lt;T1, T2&gt; p(v1, v2);</span><br><span class="line">make_pair(v1, v2)</span><br></pre></td></tr></table></figure></p>
<p>上述第一种方法是定义了一个空的pair对象p，第二种方法是定义了包含初始值为v1和v2的pair对象p。第三种方法是以v1和v2值创建的一个新的pair对象。</p>
<h2 id="pair对象的一些操作"><a href="#pair对象的一些操作" class="headerlink" title="pair对象的一些操作"></a>pair对象的一些操作</h2><p>除此之外，pair对象还有一些方法，如取出pair对象中的每一个成员的值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.first</span><br><span class="line">p.second</span><br></pre></td></tr></table></figure></p>
<p>一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">        pair&lt;int, string&gt; p1(0, &quot;Hello&quot;);</span><br><span class="line">        printf(&quot;%d, %s\n&quot;, p1.first, p1.second.c_str());</span><br><span class="line">        pair&lt;int, string&gt; p2 = make_pair(1, &quot;World&quot;);</span><br><span class="line">        printf(&quot;%d, %s\n&quot;, p2.first, p2.second.c_str());</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>标准库map类型是一种以键-值(key-value)存储的数据类型。</p>
<ul>
<li>第一个可以称为关键字(key)，每个关键字只能在map中出现一次；</li>
<li>第二个可能称为该关键字的值(value)；</li>
</ul>
<p>map以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。在map内部所有的数据都是有序的。</p>
<p>以下分别从以下的几个方面总结：</p>
<ul>
<li>map对象的定义和初始化</li>
<li>map对象的基本操作，主要包括添加元素，遍历等</li>
</ul>
<h2 id="map对象的定义和初始化"><a href="#map对象的定义和初始化" class="headerlink" title="map对象的定义和初始化"></a>map对象的定义和初始化</h2><p>map是键-值对的组合，有以下的一些定义的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;k, v&gt; m;</span><br><span class="line">map&lt;k, v&gt; m(m2);</span><br><span class="line">map&lt;k, v&gt; m(b, e);</span><br></pre></td></tr></table></figure></p>
<p>上述第一种方法定义了一个名为m的空的map对象；第二种方法创建了m2的副本m；第三种方法创建了map对象m，并且存储迭代器b和e范围内的所有元素的副本。</p>
<p>map的value_type是存储元素的键以及值的pair类型，键为const。</p>
<p>使用map得包含map类所在的头文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;map&gt;  //注意，STL头文件没有扩展名.h</span><br></pre></td></tr></table></figure></p>
<p>map对象是模板类，需要关键字和存储对象两个模板参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std:map&lt;int, string&gt; personnel;</span><br></pre></td></tr></table></figure></p>
<p>这样就定义了一个用int作为索引,并拥有相关联的指向string的指针.</p>
<p>为了使用方便，可以对模板类进行一下类型定义，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef aap&lt;int,CString&gt; UDT_MAP_INT_CSTRING;</span><br></pre></td></tr></table></figure></p>
<p>map共提供了6个构造函数，这块涉及到内存分配器这些东西，略过不表，在下面我们将接触到一些map的构造方法，这里要说下的就是，我们通常用如下方法构造一个map：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;int, string&gt; mapStudent;</span><br></pre></td></tr></table></figure></p>
<h2 id="map中元素的插入"><a href="#map中元素的插入" class="headerlink" title="map中元素的插入"></a>map中元素的插入</h2><p>在map中元素有两种插入方法：</p>
<ul>
<li>使用下标</li>
<li>使用insert函数</li>
</ul>
<blockquote>
<p>在map中使用下标访问不存在的元素将导致在map容器中添加一个新的元素。</p>
</blockquote>
<p>insert函数的插入方法主要有如下：</p>
<ul>
<li><code>m.insert(e)</code></li>
<li><code>m.insert(beg, end)</code></li>
<li><code>m.insert(iter, e)</code></li>
</ul>
<p>上述的e一个value_type类型的值。beg和end标记的是迭代器的开始和结束。</p>
<p>两种插入方法如下面的例子所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++)&#123;</span><br><span class="line">            mp[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">            mp.insert(make_pair(i, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = mp.begin(); it != mp.end(); it++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d--&gt;%d\n"</span>, it-&gt;first, it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个map对象</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第一种 用insert函數插入pair</span></span><br><span class="line">mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">000</span>, <span class="string">"student_zero"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第二种 用insert函数插入value_type数据</span></span><br><span class="line">mapStudent.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type(<span class="number">001</span>, <span class="string">"student_one"</span>));</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第三种 用"array"方式插入</span></span><br><span class="line">mapStudent[<span class="number">123</span>] = <span class="string">"student_first"</span>;</span><br><span class="line">mapStudent[<span class="number">456</span>] = <span class="string">"student_second"</span>;</span><br></pre></td></tr></table></figure>
<p>以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是不能在插入数据的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapStudent.insert(map&lt;int, string&gt;::value_type (001, &quot;student_one&quot;));</span><br><span class="line">mapStudent.insert(map&lt;int, string&gt;::value_type (001, &quot;student_two&quot;));</span><br></pre></td></tr></table></figure></p>
<h2 id="map中元素的查找和读取"><a href="#map中元素的查找和读取" class="headerlink" title="map中元素的查找和读取"></a>map中元素的查找和读取</h2><p>注意：上述采用下标的方法读取map中元素时，若map中不存在该元素，则会在map中插入。</p>
<p>因此，若只是查找该元素是否存在，可以使用函数count(k)，该函数返回的是k出现的次数；若是想取得key对应的值，可以使用函数find(k)，该函数返回的是指向该元素的迭代器。</p>
<p>上述的两个函数的使用如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">            mp.insert(make_pair(i, i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mp.count(<span class="number">0</span>))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"yes!\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"no!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it_find;</span><br><span class="line">    it_find = mp.find(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (it_find != mp.end())&#123;</span><br><span class="line">            it_find-&gt;second = <span class="number">20</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"no!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">for</span> (it = mp.begin(); it != mp.end(); it++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d-&gt;%d\n"</span>, it-&gt;first, it-&gt;second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="从map中删除元素"><a href="#从map中删除元素" class="headerlink" title="从map中删除元素"></a>从map中删除元素</h2><p>从map中删除元素的函数是erase()，该函数有如下的三种形式：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m.erase(k)</span><br><span class="line">m.erase(p)</span><br><span class="line">m.erase(b, e)</span><br></pre></td></tr></table></figure></p>
<p>第一种方法删除的是m中键为k的元素，返回的是删除的元素的个数；第二种方法删除的是迭代器p指向的元素，返回的是void；第三种方法删除的是迭代器b和迭代器e范围内的元素，返回void。</p>
<p>如下所示：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)&#123;</span><br><span class="line">                mp.insert(make_pair(i, i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mp.erase(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        mp.erase(mp.begin());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span> (it = mp.begin(); it != mp.end(); it++)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d-&gt;%d\n"</span>, it-&gt;first, it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="map的基本操作函数："><a href="#map的基本操作函数：" class="headerlink" title="map的基本操作函数："></a>map的基本操作函数：</h2><p>C++ maps是一种关联式容器，包含“关键字/值”对</p>
<ul>
<li><code>begin()</code>   返回指向map头部的迭代器</li>
<li><code>clear()</code>   删除所有元素</li>
<li><code>count()</code>   返回指定元素出现的次数</li>
<li><code>empty()</code>   如果map为空则返回true</li>
<li><code>end()</code>   返回指向map末尾的迭代器</li>
<li><code>equal_range()</code>   返回特殊条目的迭代器对</li>
<li><code>erase()</code>   删除一个元素</li>
<li><code>find()</code>   查找一个元素</li>
<li><code>get_allocator()</code>   返回map的配置器</li>
<li><code>insert()</code>   插入元素</li>
<li><code>key_comp()</code>   返回比较元素key的函数</li>
<li><code>lower_bound()</code>   返回键值&gt;=给定元素的第一个位置</li>
<li><code>max_size()</code>   返回可以容纳的最大元素个数</li>
<li><code>rbegin()</code>   返回一个指向map尾部的逆向迭代器</li>
<li><code>rend()</code>   返回一个指向map头部的逆向迭代器</li>
<li><code>size()</code>   返回map中元素的个数</li>
<li><code>swap()</code>   交换两个map</li>
<li><code>upper_bound()</code>   返回键值&gt;给定元素的第一个位置</li>
<li><code>value_comp()</code>   返回比较元素value的函数</li>
</ul>
<h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><div class="table-container">
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
<th>复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>size()</td>
<td>返回栈的元素数</td>
<td>O(1)</td>
</tr>
<tr>
<td>top()</td>
<td>返回栈顶的元素</td>
<td>O(1)</td>
</tr>
<tr>
<td>pop()</td>
<td>从栈中取出并删除元素</td>
<td>O(1)</td>
</tr>
<tr>
<td>push(x)</td>
<td>向栈中添加元素x</td>
<td>O(1)</td>
</tr>
<tr>
<td>empty()</td>
<td>在栈为空时返回true</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
</div>
<p>贴一些代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    S.push(<span class="number">3</span>);</span><br><span class="line">    S.push(<span class="number">7</span>);</span><br><span class="line">    S.push(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; S.size() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; S.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    S.pop();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; S.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    S.pop();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; S.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    S.push(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; S.top() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    S.pop();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; S.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="queues"><a href="#queues" class="headerlink" title="queues"></a>queues</h1><p>C++队列是一种容器适配器，它给予程序员一种先进先出(FIFO)的数据结构。</p>
<ol>
<li>back() 返回一个引用，指向最后一个元素</li>
<li>empty() 如果队列空则返回真</li>
<li>front() 返回第一个元素</li>
<li>pop() 删除第一个元素</li>
<li>push() 在末尾加入一个元素</li>
<li>size() 返回队列中元素的个数</li>
</ol>
<p>队列可以用线性表(list)或双向队列(deque)来实现(注意vector container 不能用来实现queue，因为vector 没有成员函数pop_front!)：<br><code>queue&lt;list&lt;int&gt;&gt; q1</code><br><code>queue&lt;deque&lt;int&gt;&gt; q2</code><br>其成员函数有“判空(empty)” 、“尺寸(Size)” 、“首元(front)” 、“尾元(backt)” 、“加入队列(push)” 、“弹出队列(pop)”等操作。</p>
<p>例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">4</span>);</span><br><span class="line">    q.push(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,q.front());</span><br><span class="line">    q.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Priority-Queues"><a href="#Priority-Queues" class="headerlink" title="Priority Queues"></a>Priority Queues</h1><p>C++优先队列类似队列，但是在这个数据结构中的元素按照一定的断言排列有序。</p>
<ol>
<li>empty() 如果优先队列为空，则返回真</li>
<li>pop() 删除第一个元素</li>
<li>push() 加入一个元素</li>
<li>size() 返回优先队列中拥有的元素的个数</li>
<li>top() 返回优先队列中有最高优先级的元素</li>
</ol>
<p>优先级队列可以用向量(vector)或双向队列(deque)来实现(注意list container 不能用来实现queue，因为list 的迭代器不是任意存取iterator，而pop 中用到堆排序时是要求randomaccess iterator 的!)：</p>
<ul>
<li><code>priority_queue&lt;vector&lt;int&gt;, less&lt;int&gt;&gt; pq1</code>; 使用递增less<int>函数对象排序</int></li>
<li><code>priority_queue&lt;deque&lt;int&gt;, greater&lt;int&gt;&gt; pq2</code>; 使用递减greater<int>函数对象排序</int></li>
<li>其成员函数有“判空(empty)” 、“尺寸(Size)” 、“栈顶元素(top)” 、“压栈(push)” 、“弹栈(pop)”等。</li>
</ul>
<p>priority_queue模版类有三个模版参数，元素类型，容器类型，比较算子。其中后两个都可以省略，默认容器为vector，默认算子为less，即小的往前排，大的往后排（出队时序列尾的元素出队）。</p>
<p>初学者在使用priority_queue时，最困难的可能就是如何定义比较算子了。如果是基本数据类型，或已定义了比较运算符的类，可以直接用STL的less算子和greater算子——默认为使用less算子，即小的往前排，大的先出队。如果要定义自己的比较算子，方法有多种，这里介绍其中的一种：重载比较运算符。优先队列试图将两个元素x和y代入比较运算符(对less算子，调用x<y，对greater算子，调用x>y)，若结果为真，则x排在y前面，y将先于x出队，反之，则将y排在x前面，x将先出队。</y，对greater算子，调用x></p>
<p>例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x, y, z; </span><br><span class="line">    T(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c):x(a), y(b), z(c)</span><br><span class="line">    &#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> T &amp;t1, <span class="keyword">const</span> T &amp;t2) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t1.z &lt; t2.z; <span class="comment">// 按照z的顺序来决定t1和t2的顺序</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    priority_queue&lt;T&gt; q; </span><br><span class="line">    q.push(T(<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>)); </span><br><span class="line">    q.push(T(<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>)); </span><br><span class="line">    q.push(T(<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>)); </span><br><span class="line">    q.push(T(<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>)); </span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) </span><br><span class="line">    &#123; </span><br><span class="line">        T t = q.top(); </span><br><span class="line">        q.pop(); </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; t.x &lt;&lt; <span class="string">" "</span> &lt;&lt; t.y &lt;&lt; <span class="string">" "</span> &lt;&lt; t.z &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果为(注意是按照z的顺序从大到小出队的)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3 6 </span><br><span class="line">2 2 5 </span><br><span class="line">1 5 4 </span><br><span class="line">4 4 3</span><br></pre></td></tr></table></figure></p>
<p>再看一个按照z的顺序从小到大出队的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">int</span> x, y, z; </span><br><span class="line">    T(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c):x(a), y(b), z(c) </span><br><span class="line">    &#123;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> T &amp;t1, <span class="keyword">const</span> T &amp;t2) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">return</span> t1.z &gt; t2.z; </span><br><span class="line">&#125; </span><br><span class="line">main() </span><br><span class="line">&#123; </span><br><span class="line">    priority_queue&lt;T, <span class="built_in">vector</span>&lt;T&gt;, greater&lt;T&gt; &gt; q; </span><br><span class="line">    q.push(T(<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>)); </span><br><span class="line">    q.push(T(<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>)); </span><br><span class="line">    q.push(T(<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>)); </span><br><span class="line">    q.push(T(<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>)); </span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) </span><br><span class="line">    &#123; </span><br><span class="line">        T t = q.top(); </span><br><span class="line">        q.pop(); </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; t.x &lt;&lt; <span class="string">" "</span> &lt;&lt; t.y &lt;&lt; <span class="string">" "</span> &lt;&lt; t.z &lt;&lt;  <span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 4 3 </span><br><span class="line">1 5 4 </span><br><span class="line">2 2 5 </span><br><span class="line">3 3 6</span><br></pre></td></tr></table></figure></p>
<h1 id="size-t"><a href="#size-t" class="headerlink" title="size_t"></a>size_t</h1><p>在标准C库中的许多函数使用的参数或者返回值都是表示的用字节表示的对象大小，比如说<code>malloc(n)</code>函数的参数n指明了需要申请的空间大小，还有<code>memcpy(s1, s2, n)</code>的最后一个参数，表明需要复制的内存大小，<code>strlen(s)</code>函数的返回值表明了以’\0’结尾的字符串的长度（不包括’\0’），其返回值并不是该字符串的实际长度，因为要去掉’\0’。</p>
<p>或许你会认为这些参数或者返回值应该被申明为int类型（或者long或者unsigned），但是事实上并不是。C标准中将他们定义为size_t。标准中记载malloc的申明应该出现在，定义为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>memcpy和strlen的申明应该出现在中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *s1, <span class="keyword">void</span> <span class="keyword">const</span> *s2, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">char</span> <span class="keyword">const</span> *s);</span><br></pre></td></tr></table></figure></p>
<p>size_t还经常出现在C++标准库中，此外，C++库中经常会使用一个相似的类型size_type，用的可能比size_t还要多。</p>
<h2 id="可移植性问题"><a href="#可移植性问题" class="headerlink" title="可移植性问题"></a>可移植性问题</h2><p>回忆memcpy(s1, s2, n)函数，它将s2指向地址开始的n个字节拷贝到s2指向的地址，返回s1，这个函数可以拷贝任何数据类型，所以参数和返回值的类型应该为可以指向任何类型的void<em>，同时，&gt;源地址不应该被改变，所以第二个参数s2类型应该为`const void</em>`，这些都不是问题。真正的问题在于我们如何申明第三个参数，它代表了源对象的大小，我相信大部分程序员都会选择int：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *s1, <span class="keyword">void</span> <span class="keyword">const</span> *s2, <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>使用int类型在大部分情况下都是可以的，但是我们可以使用unsigned int代替它让第三个参数表示的范围更大。在大部分机器上，unsigned int的最大值要比int的最大值大两倍。使用unsigned int修饰第三个参数的代价与int是相同的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *s1, <span class="keyword">void</span> <span class="keyword">const</span> *s2, <span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这样似乎没有问题了，unsigned int可以表示最大类型的对象大小了，这种情况只有在整形和指针类型具有相同大小的情况下，比如说在IP16中，整形和指针都占2个字节（16位），而在IP32上面，整形和指针都占4个字节（32位）。</p>
<h2 id="使用size-t"><a href="#使用size-t" class="headerlink" title="使用size_t"></a>使用size_t</h2><p>size_t是一种数据相关的无符号类型，它被设计得足够大以便能够内存中任意对象的大小。在C++中，设计 size_t 就是为了适应多个平台的。ize_t的引入增强了程序在不同平台上的可移植性。</p>
<p>size_t的定义在<code>&lt;stddef.h&gt;</code>,<code>&lt;stdio.h&gt;</code>,<code>&lt;stdlib.h&gt;</code>,<code>&lt;string.h&gt;</code>, <code>&lt;time.h&gt;</code>和<code>&lt;wchar.h&gt;</code>这些标准C头文件中，也出现在相应的C++头文件, 等等中，你应该在你的头文件中至少包含一个这样的头文件在使用size_t之前。包含以上任何C头文件（由C或C++编译的程序）表明将size_t作为全局关键字。根据定义，size_t是sizeof关键字（注：sizeof是关键字，并非运算符）运算结果的类型。所以，应当通过适当的方式声明n来完成赋值：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="keyword">sizeof</span>(thing);</span><br></pre></td></tr></table></figure></p>
<p>考虑到可移植性和程序效率，n应该被申明为size_t类型。类似的，下面的foo函数的参数也应当被申明为sizeof：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="keyword">sizeof</span>(thing));</span><br></pre></td></tr></table></figure></p>
<p>参数中带有size_t的函数通常会含有局部变量用来对数组的大小或者索引进行计算，在这种情况下，size_t是个不错的选择。</p>
<p>size_t的大小并非像很多网上描述的那样，其大小是由系统的位数决定的。size_t的大小是由你生成的程序类型决定的，只是生成的程序类型与系统的类型有一定关系。32bits的程序既可以在64bits的系统上运行，也可以在32bits的系统上运行。但是64bits的程序只能在64bits的系统上运行。然而我们编译的程序一般是32bits的，因此size_t的大小也就变成了4个字节。</p>
<h1 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h1><p>struct/class/union内存对齐原则有四个：</p>
<ol>
<li>数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小（只要该成员&gt;有子成员，比如说是数组，结构体等）的整数倍开始(比如int在３２位机为４字节, 则要从４的整数倍地址开始存储),基本类型不包括struct/class/uinon。</li>
<li>结构体作为成员:如果一个结构里有某些结构体成员,则结构体成员要从其内部”最宽基本类型成员”的整数倍地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)。</li>
<li>收尾工作:结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的”最宽基本类型成员”的整数倍.不足的要补齐.(基本类型不包括struct/class/uinon)。</li>
<li>sizeof(union)，以结构里面size最大元素为union的size,因为在某一时刻，union只有一个成员真正存储于该地址。</li>
</ol>
<p>实例解释：下面以class为代表<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">No. <span class="number">1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(Data) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">No. <span class="number">2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">double</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(Data) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>显然程序No.1 输出的结果为 8， No.2 输出的结果为 16。No.1最大的数据成员是4bytes，1+4=5，补齐为4的倍数，也就是8。而No.2为8bytes，1+8=9，补齐为8的倍数，也就是16。</p>
<p>内存对齐的主要作用是：</p>
<ol>
<li>平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</li>
<li>性能原因：经过内存对齐后，CPU的内存访问速度大大提升。具体原因稍后解释。</li>
</ol>
<h1 id="strlen和sizeof区别？"><a href="#strlen和sizeof区别？" class="headerlink" title="strlen和sizeof区别？"></a>strlen和sizeof区别？</h1><p>sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。</p>
<p>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是’\0’的字符串。</p>
<p>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"name"</span>;</span><br><span class="line">    <span class="keyword">sizeof</span>(str); <span class="comment">// 取的是指针str的长度，是8</span></span><br><span class="line">    <span class="built_in">strlen</span>(str); <span class="comment">// 取的是这个字符串的长度，不包含结尾的 \0。大小是4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数组在内存中是连续存放的，开辟一块连续的内存空间；数组所占存储空间：sizeof（数组名）；数组大小：sizeof(数组名)/sizeof(数组元素数据类型)；用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。</p>
<h1 id="OFFSETOF"><a href="#OFFSETOF" class="headerlink" title="OFFSETOF"></a>OFFSETOF</h1><p>OFFSETOF(s, m)的宏定义，s是结构类型，m是s的成员，求m在s中的偏移量。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSETOF（s, m） size_t（&amp;((s*)0)-&gt;m）</span></span><br></pre></td></tr></table></figure></p>
<h1 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h1><p>sizeof一个类求大小（注意成员变量，函数，虚函数，继承等等对大小的影响）以下运行环境都是一般的，在32位编译环境中。</p>
<p>基本数据类型的sizeof<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">char</span>)&lt;&lt;<span class="built_in">endl</span>;                     结果是<span class="number">1</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">int</span>)&lt;&lt;<span class="built_in">endl</span>;                        结果是<span class="number">4</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>)&lt;&lt;<span class="built_in">endl</span>; 结果是<span class="number">4</span> </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">int</span>)&lt;&lt;<span class="built_in">endl</span>;                结果是<span class="number">4</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">short</span> <span class="keyword">int</span>)&lt;&lt;<span class="built_in">endl</span>;               结果是<span class="number">2</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">float</span>)&lt;&lt;<span class="built_in">endl</span>;                     结果是<span class="number">4</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">double</span>)&lt;&lt;<span class="built_in">endl</span>;                 结果是<span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p>指针变量的sizeof<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *pc =<span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">sizeof</span>( pc ); <span class="comment">// 结果为4</span></span><br><span class="line"><span class="keyword">sizeof</span>(*pc);     <span class="comment">// 结果为1</span></span><br><span class="line"><span class="keyword">int</span> *pi;</span><br><span class="line"><span class="keyword">sizeof</span>( pi ); <span class="comment">//结果为4</span></span><br><span class="line"><span class="keyword">sizeof</span>(*pi);     <span class="comment">//结果为4</span></span><br><span class="line"><span class="keyword">char</span> **ppc = &amp;pc;  </span><br><span class="line"><span class="keyword">sizeof</span>( ppc ); <span class="comment">// 结果为4   </span></span><br><span class="line"><span class="keyword">sizeof</span>( *ppc ); <span class="comment">// 结果为4     </span></span><br><span class="line"><span class="keyword">sizeof</span>( **ppc ); <span class="comment">// 结果为1</span></span><br><span class="line"><span class="keyword">void</span> (*pf)();<span class="comment">// 函数指针</span></span><br><span class="line"><span class="keyword">sizeof</span>( pf );<span class="comment">// 结果为4</span></span><br></pre></td></tr></table></figure></p>
<p>数组的sizeof数组的sizeof值等于数组所占用的内存字节数，如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">int</span> a2[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">sizeof</span>( a1 ); <span class="comment">// 结果为4，字符 末尾还存在一个NULL终止符</span></span><br><span class="line"><span class="keyword">sizeof</span>( a2 ); <span class="comment">// 结果为3*4=12（依赖于int）</span></span><br></pre></td></tr></table></figure></p>
<p>写到这里，提一问，下面的c3，c4值应该是多少呢<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">(<span class="keyword">char</span> a3[<span class="number">3</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c3 = <span class="keyword">sizeof</span>( a3 ); <span class="comment">// c3 == 4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo4</span><span class="params">(<span class="keyword">char</span> a4[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c4 = <span class="keyword">sizeof</span>( a4 ); <span class="comment">// c4 == 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也许当你试图回答c4的值时已经意识到c3答错了，是的，c3!=3。这里函数参数a3已不再是数组类型，而是蜕变成指针，相当于<code>char* a3</code>，为什么仔细想想就不难明白，我们调用函数foo1时，程序会在栈上分配一个大小为3的数组吗不会！数组是“传址”的，调用者只需将实参的地址传递过去，所以a3自然为指针类型<code>char*</code>，c3的值也就为4。</p>
<p>结构体的sizeof<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">double</span> dda1;</span><br><span class="line">	<span class="keyword">char</span> dda;</span><br><span class="line">	<span class="keyword">int</span> type</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>结果为16，为上面的结构分配空间的时候，VC根据成员变量出现的顺序和对齐方式，先为第一个成员dda1分配空间，其起始地址跟结构的起始地址相同（刚好偏移量0刚好为sizeof(double)的倍数），该成员变量占用sizeof(double)=8个字节；接下来为第二个成员dda分配空间，这时下一个可以分配的地址对于结构的起始地址的偏移量为8，是sizeof(char)的倍数，所以把dda存放在偏移量为8的地方满足对齐方式，该成员变量占用sizeof(char)=1个字节；接下来为第三个成员type分配空间，这时下一个可以分配的地址对于结构的起始地址的偏移量为9，不是sizeof(int)=4的倍数，为了满足对齐方式对偏移量的约束问题，VC自动填充3个字节（这三个字节没有放什么东西），这时下一个可以分配的地址对于结构的起始地址的偏移量为12，刚好是sizeof(int)=4的倍数，所以把type存放在偏移量为12的地方，该成员变量占用sizeof(int)=4个字节；这时整个结构的成员变量已经都分配了空间，总的占用的空间大小为：8+1+3+4=16，刚好为结构的字节边界数（即结构中占用最大空间的类型所占用的字节数sizeof(double)=8）的倍数，所以没有空缺的字节需要填充。</p>
<p>含位域结构体的sizeof<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BF1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> f1 : <span class="number">3</span>;</span><br><span class="line"><span class="keyword">char</span> f2 : <span class="number">4</span>;</span><br><span class="line"><span class="keyword">char</span> f3 : <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>位域类型为char，第1个字节仅能容纳下f1和f2，所以f2被压缩到第1个字节中，而f3只能从下一个字节开始。因此sizeof(BF1)的结果为2。</p>
<p>含有联合体的结构体的sizeof<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *ptr,ch;</span><br><span class="line">	<span class="keyword">union</span> A  </span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">short</span> a,b;</span><br><span class="line">	    <span class="keyword">unsigned</span> <span class="keyword">int</span> c:<span class="number">2</span>, d:<span class="number">1</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">s1</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样是8＋4＝12个字节<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> *ptr,ch;                          </span><br><span class="line">	<span class="keyword">union</span>                      <span class="comment">//联合体是结构体的成员，占内存，并且最大类型是unsigned int，占4</span></span><br><span class="line">	&#123;</span><br><span class="line">	     <span class="keyword">short</span> a,b;</span><br><span class="line">	     <span class="keyword">unsigned</span> <span class="keyword">int</span> c:<span class="number">2</span>, d:<span class="number">1</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">s1</span>* <span class="title">next</span>;</span>                        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样是8＋4＋4＝16个字节</p>
<p>结构体体含有结构体的sizeof<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">     <span class="keyword">char</span> c;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">     <span class="keyword">char</span> c1;</span><br><span class="line">     S1 s;</span><br><span class="line">     <span class="keyword">char</span> c2;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(S3);      <span class="comment">//S3=16</span></span><br></pre></td></tr></table></figure></p>
<p>S1的最宽简单成员的类型为int，S3在考虑最宽简单类型成员时是将S1“打散”看的，所以S3的最宽简单类型为int，这样，通过S3定义的变量，其存储空间首地址需要被4整除，整个sizeof(S3)的值也应该被4整除。</p>
<p>c1的偏移量为0，s的偏移量呢这时s是一个整体，它作为结构体变量也满足前面三个准则，所以其大小为8，偏移量为4，c1与s之间便需要3个填充字节，而c2与s之间就不需要了，所以c2的偏移量为12，算上c2的大小为13，13是不能被4整除的，这样末尾还得补上3个填充字节。最后得到sizeof(S3)的值为16。</p>
<p>带有#pragma pack的sizeof：它是用来调整结构体对齐方式的，不同编译器名称和用法略有不同，VC6中通过#pragma pack实现，也可以直接修改/Zp编译开关。<code>#pragma pack</code>的基本用法为：<code>#pragma pack(n)</code>，n为字节对齐数，其取值为1、2、4、8、16，默认是8，如果这个值比结构体成员的sizeof值小，那么该成员的偏移量应该以此值为准，即是说，结构体成员的偏移量应该取二者的最小值，</p>
<p>再看示例：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(push) <span class="comment">// 将当前pack设置压栈保存</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(2)<span class="comment">// 必须在结构体定义之前使用</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> c;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> c1;</span><br><span class="line">	S1 s;</span><br><span class="line">	<span class="keyword">char</span> c2</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(pop) <span class="comment">// 恢复先前的pack设置</span></span></span><br></pre></td></tr></table></figure></p>
<p>计算sizeof(S1)时，min(2, sizeof(i))的值为2，所以i的偏移量为2，加上sizeof(i)等于6，能够被2整除，所以整个S1的大小为6。</p>
<p>同样，对于sizeof(S3)，s的偏移量为2，c2的偏移量为8，加上sizeof(c2)等于9，不能被2整除，添加一个填充字节，所以sizeof(S3)等于10。</p>
<p>空结构体的sizeof<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S5</span> &#123;</span> &#125;;</span><br><span class="line"><span class="keyword">sizeof</span>( S5 ); <span class="comment">// 结果为1</span></span><br></pre></td></tr></table></figure></p>
<p>类的sizeof<br>类的sizeof值等于类中成员变量所占用的内存字节数。如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="keyword">float</span> c;</span><br><span class="line">	<span class="keyword">char</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A object;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(object) is "</span> &lt;&lt; <span class="keyword">sizeof</span>(object) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果为12（我的机器上sizeof(float)值为4，字节对其前面已经讲过）。</p>
<p>不过需要注意的是，如果类中存在静态成员变量，结果又会是什么样子呢？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="keyword">float</span> c;</span><br><span class="line">	<span class="keyword">char</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A object;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(object) is "</span> &lt;&lt; <span class="keyword">sizeof</span>(object) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>16？不对。结果仍然是12.</p>
<p>因为在程序编译期间，就已经为static变量在静态存储区域分配了内存空间，并且这块内存在程序的整个运行期间都存在。而每次声明了类A的一个对象的时候，为该对象在堆上，根据对象的大小分配内存。</p>
<p>如果类A中包含成员函数，那么又会是怎样的情况呢？看下面的例子<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">	<span class="keyword">int</span> b;</span><br><span class="line">	<span class="keyword">float</span> c;</span><br><span class="line">	<span class="keyword">char</span> d;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x+y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A object;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(object) is "</span> &lt;&lt; <span class="keyword">sizeof</span>(object) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	b = object.add(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"sizeof(object) is "</span> &lt;&lt; <span class="keyword">sizeof</span>(object) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果仍为12。 </p>
<p>因为只有非静态类成员变量在新生成一个object的时候才需要自己的副本。所以每个非静态成员变量在生成新object需要内存，而function是不需要的。</p>
<h1 id="标准C-中的string类"><a href="#标准C-中的string类" class="headerlink" title="标准C++中的string类"></a>标准C++中的string类</h1><p>相信使用过MFC编程的朋友对CString这个类的印象应该非常深刻吧？的确，MFC中的CString类使用起来真的非常的方便好用。但是如果离开了MFC框架，还有没有这样使用起来非常方便的类呢？答案是肯定的。也许有人会说，即使不用MFC框架，也可以想办法使用MFC中的API，具体的操作方法在本文最后给出操作方法。其实，可能很多人很可能会忽略掉标准C++中string类的使用。标准C++中提供的string类得功能也是非常强大的，一般都能满足我们开发项目时使用。现将具体用法的一部分罗列如下，只起一个抛砖引玉的作用吧，好了，废话少说，直接进入正题吧！</p>
<p>要想使用标准C++中string类，必须要包含<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;// 注意是&lt;string&gt;，不是&lt;string.h&gt;，带.h的是C语言中的头文件</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span>  <span class="built_in">std</span>::wstring;</span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure></p>
<p>下面你就可以使用string/wstring了，它们两分别对应着char和wchar_t。</p>
<p>string和wstring的用法是一样的，以下只用string作介绍：</p>
<h2 id="string类的构造函数："><a href="#string类的构造函数：" class="headerlink" title="string类的构造函数："></a>string类的构造函数：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string(const char *s);    //用c字符串s初始化</span><br><span class="line">string(int n,char c);     //用n个字符c初始化</span><br></pre></td></tr></table></figure>
<p>此外，string类还支持默认构造函数和复制构造函数，如string s1；string s2=”hello”；都是正确的写法。当构造的string太长而无法表达时会抛出length_error异常 ；</p>
<h2 id="string类的字符操作："><a href="#string类的字符操作：" class="headerlink" title="string类的字符操作："></a>string类的字符操作：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const char &amp;operator[](int n)const;</span><br><span class="line">const char &amp;at(int n)const;</span><br><span class="line">char &amp;operator[](int n);</span><br><span class="line">char &amp;at(int n);</span><br></pre></td></tr></table></figure>
<p><code>operator[]</code>和<code>at()</code>均返回当前字符串中第n个字符的位置，但at函数提供范围检查，当越界时会抛出out_of_range异常，下标运算符[]不提供检查访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const char *data()const;//返回一个非null终止的c字符数组</span><br><span class="line">const char *c_str()const;//返回一个以null终止的c字符串</span><br><span class="line">int copy(char *s, int n, int pos = 0) const;//把当前串中以pos开始的n个字符拷贝到以s为起始位置的字符数组中，返回实际拷贝的数目</span><br></pre></td></tr></table></figure>
<h2 id="string的特性描述"><a href="#string的特性描述" class="headerlink" title="string的特性描述:"></a>string的特性描述:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int capacity()const;    //返回当前容量（即string中不必增加内存即可存放的元素个数）</span><br><span class="line">int max_size()const;    //返回string对象中可存放的最大字符串的长度</span><br><span class="line">int size()const;        //返回当前字符串的大小</span><br><span class="line">int length()const;       //返回当前字符串的长度</span><br><span class="line">bool empty()const;        //当前字符串是否为空</span><br><span class="line">void resize(int len,char c);//把字符串当前大小置为len，并用字符c填充不足的部分</span><br></pre></td></tr></table></figure>
<h2 id="string类的输入输出操作"><a href="#string类的输入输出操作" class="headerlink" title="string类的输入输出操作:"></a>string类的输入输出操作:</h2><p>string类重载运算符operator&gt;&gt;用于输入，同样重载运算符operator&lt;&lt;用于输出操作。</p>
<p>函数<code>getline(istream &amp;in,string &amp;s);</code>用于从输入流in中读取字符串到s中，以换行符’\n’分开。</p>
<h2 id="string的赋值："><a href="#string的赋值：" class="headerlink" title="string的赋值："></a>string的赋值：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string &amp;operator=(const string &amp;s);//把字符串s赋给当前字符串</span><br><span class="line">string &amp;assign(const char *s);//用c类型字符串s赋值</span><br><span class="line">string &amp;assign(const char *s,int n);//用c字符串s开始的n个字符赋值</span><br><span class="line">string &amp;assign(const string &amp;s);//把字符串s赋给当前字符串</span><br><span class="line">string &amp;assign(int n,char c);//用n个字符c赋值给当前字符串</span><br><span class="line">string &amp;assign(const string &amp;s,int start,int n);//把字符串s中从start开始的n个字符赋给当前字符串</span><br><span class="line">string &amp;assign(const_iterator first,const_itertor last);//把first和last迭代器之间的部分赋给字符串</span><br></pre></td></tr></table></figure>
<h2 id="string的连接："><a href="#string的连接：" class="headerlink" title="string的连接："></a>string的连接：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string &amp;operator+=(const string &amp;s);//把字符串s连接到当前字符串的结尾 </span><br><span class="line">string &amp;append(const char *s);            //把c类型字符串s连接到当前字符串结尾</span><br><span class="line">string &amp;append(const char *s,int n);//把c类型字符串s的前n个字符连接到当前字符串结尾</span><br><span class="line">string &amp;append(const string &amp;s);    //同operator+=()</span><br><span class="line">string &amp;append(const string &amp;s,int pos,int n);//把字符串s中从pos开始的n个字符连接到当前字符串的结尾</span><br><span class="line">string &amp;append(int n,char c);        //在当前字符串结尾添加n个字符c</span><br><span class="line">string &amp;append(const_iterator first,const_iterator last);//把迭代器first和last之间的部分连接到当前字符串的结尾</span><br></pre></td></tr></table></figure>
<h2 id="string的比较："><a href="#string的比较：" class="headerlink" title="string的比较："></a>string的比较：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool operator==(const string &amp;s1,const string &amp;s2)const;//比较两个字符串是否相等</span><br></pre></td></tr></table></figure>
<p>运算符”&gt;”,”&lt;”,”&gt;=”,”&lt;=”,”!=”均被重载用于字符串的比较；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int compare(const string &amp;s) const;//比较当前字符串和s的大小</span><br><span class="line">int compare(int pos, int n,const string &amp;s)const;//比较当前字符串从pos开始的n个字符组成的字符串与s的大小</span><br><span class="line">int compare(int pos, int n,const string &amp;s,int pos2,int n2)const;//比较当前字符串从pos开始的n个字符组成的字符串与s中</span><br><span class="line">　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　//pos2开始的n2个字符组成的字符串的大小</span><br><span class="line">int compare(const char *s) const;</span><br><span class="line">int compare(int pos, int n,const char *s) const;</span><br><span class="line">int compare(int pos, int n,const char *s, int pos2) const;</span><br></pre></td></tr></table></figure></p>
<p>compare函数在&gt;时返回1，&lt;时返回-1，==时返回0  </p>
<h2 id="string的子串："><a href="#string的子串：" class="headerlink" title="string的子串："></a>string的子串：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string substr(int pos = 0,int n = npos) const;//返回pos开始的n个字符组成的字符串</span><br></pre></td></tr></table></figure>
<h2 id="string的交换："><a href="#string的交换：" class="headerlink" title="string的交换："></a>string的交换：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void swap(string &amp;s2);    //交换当前字符串与s2的值</span><br></pre></td></tr></table></figure>
<h2 id="string类的查找函数："><a href="#string类的查找函数：" class="headerlink" title="string类的查找函数："></a>string类的查找函数：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int find(char c, int pos = 0) const;//从pos开始查找字符c在当前字符串的位置</span><br><span class="line">int find(const char *s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置</span><br><span class="line">int find(const char *s, int pos, int n) const;//从pos开始查找字符串s中前n个字符在当前串中的位置</span><br><span class="line">int find(const string &amp;s, int pos = 0) const;//从pos开始查找字符串s在当前串中的位置</span><br><span class="line">//查找成功时返回所在位置，失败返回string::npos的值 </span><br><span class="line">int rfind(char c, int pos = npos) const;//从pos开始从后向前查找字符c在当前串中的位置</span><br><span class="line">int rfind(const char *s, int pos = npos) const;</span><br><span class="line">int rfind(const char *s, int pos, int n = npos) const;</span><br><span class="line">int rfind(const string &amp;s,int pos = npos) const;</span><br><span class="line">//从pos开始从后向前查找字符串s中前n个字符组成的字符串在当前串中的位置，成功返回所在位置，失败时返回string::npos的值 </span><br><span class="line">int find_first_of(char c, int pos = 0) const;//从pos开始查找字符c第一次出现的位置</span><br><span class="line">int find_first_of(const char *s, int pos = 0) const;</span><br><span class="line">int find_first_of(const char *s, int pos, int n) const;</span><br><span class="line">int find_first_of(const string &amp;s,int pos = 0) const;</span><br><span class="line">//从pos开始查找当前串中第一个在s的前n个字符组成的数组里的字符的位置。查找失败返回string::npos </span><br><span class="line">int find_first_not_of(char c, int pos = 0) const;</span><br><span class="line">int find_first_not_of(const char *s, int pos = 0) const;</span><br><span class="line">int find_first_not_of(const char *s, int pos,int n) const;</span><br><span class="line">int find_first_not_of(const string &amp;s,int pos = 0) const;</span><br><span class="line">//从当前串中查找第一个不在串s中的字符出现的位置，失败返回string::npos </span><br><span class="line">int find_last_of(char c, int pos = npos) const;</span><br><span class="line">int find_last_of(const char *s, int pos = npos) const;</span><br><span class="line">int find_last_of(const char *s, int pos, int n = npos) const;</span><br><span class="line">int find_last_of(const string &amp;s,int pos = npos) const; </span><br><span class="line">int find_last_not_of(char c, int pos = npos) const;</span><br><span class="line">int find_last_not_of(const char *s, int pos = npos) const;</span><br><span class="line">int find_last_not_of(const char *s, int pos, int n) const;</span><br><span class="line">int find_last_not_of(const string &amp;s,int pos = npos) const;</span><br><span class="line">//find_last_of和find_last_not_of与find_first_of和find_first_not_of相似，只不过是从后向前查找</span><br></pre></td></tr></table></figure>
<h2 id="string类的替换函数"><a href="#string类的替换函数" class="headerlink" title="string类的替换函数"></a>string类的替换函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string &amp;replace(int p0, int n0,const char *s);//删除从p0开始的n0个字符，然后在p0处插入串s</span><br><span class="line">string &amp;replace(int p0, int n0,const char *s, int n);//删除p0开始的n0个字符，然后在p0处插入字符串s的前n个字符</span><br><span class="line">string &amp;replace(int p0, int n0,const string &amp;s);//删除从p0开始的n0个字符，然后在p0处插入串s</span><br><span class="line">string &amp;replace(int p0, int n0,const string &amp;s, int pos, int n);//删除p0开始的n0个字符，然后在p0处插入串s中从pos开始的n个字符</span><br><span class="line">string &amp;replace(int p0, int n0,int n, char c);//删除p0开始的n0个字符，然后在p0处插入n个字符c</span><br><span class="line">string &amp;replace(iterator first0, iterator last0,const char *s);//把[first0，last0）之间的部分替换为字符串s</span><br><span class="line">string &amp;replace(iterator first0, iterator last0,const char *s, int n);//把[first0，last0）之间的部分替换为s的前n个字符</span><br><span class="line">string &amp;replace(iterator first0, iterator last0,const string &amp;s);//把[first0，last0）之间的部分替换为串s</span><br><span class="line">string &amp;replace(iterator first0, iterator last0,int n, char c);//把[first0，last0）之间的部分替换为n个字符c</span><br><span class="line">string &amp;replace(iterator first0, iterator last0,const_iterator first, const_iterator last);//把[first0，last0）之间的部分替换成[first，last）之间的字符串</span><br></pre></td></tr></table></figure>
<h2 id="string类的插入函数"><a href="#string类的插入函数" class="headerlink" title="string类的插入函数"></a>string类的插入函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string &amp;insert(int p0, const char *s);</span><br><span class="line">string &amp;insert(int p0, const char *s, int n);</span><br><span class="line">string &amp;insert(int p0,const string &amp;s);</span><br><span class="line">string &amp;insert(int p0,const string &amp;s, int pos, int n);</span><br><span class="line">//前4个函数在p0位置插入字符串s中pos开始的前n个字符</span><br><span class="line">string &amp;insert(int p0, int n, char c);//此函数在p0处插入n个字符c</span><br><span class="line">iterator insert(iterator it, char c);//在it处插入字符c，返回插入后迭代器的位置</span><br><span class="line">void insert(iterator it, const_iterator first, const_iterator last);//在it处插入[first，last）之间的字符</span><br><span class="line">void insert(iterator it, int n, char c);//在it处插入n个字符c</span><br></pre></td></tr></table></figure>
<h2 id="string类的删除函数"><a href="#string类的删除函数" class="headerlink" title="string类的删除函数"></a>string类的删除函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iterator erase(iterator first, iterator last);//删除[first，last）之间的所有字符，返回删除后迭代器的位置</span><br><span class="line">iterator erase(iterator it);//删除it指向的字符，返回删除后迭代器的位置</span><br><span class="line">string &amp;erase(int pos = 0, int n = npos);//删除pos开始的n个字符，返回修改后的字符串</span><br></pre></td></tr></table></figure>
<h2 id="string类的迭代器处理："><a href="#string类的迭代器处理：" class="headerlink" title="string类的迭代器处理："></a>string类的迭代器处理：</h2><p>string类提供了向前和向后遍历的迭代器iterator，迭代器提供了访问各个字符的语法，类似于指针操作，迭代器不检查范围。用<code>string::iterator</code>或<code>string::const_iterator</code>声明迭代器变量，const_iterator不允许改变迭代的内容。常用迭代器函数有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const_iterator begin()const;</span><br><span class="line">iterator begin();                //返回string的起始位置</span><br><span class="line">const_iterator end()const;</span><br><span class="line">iterator end();                    //返回string的最后一个字符后面的位置</span><br><span class="line">const_iterator rbegin()const;</span><br><span class="line">iterator rbegin();                //返回string的最后一个字符的位置</span><br><span class="line">const_iterator rend()const;</span><br><span class="line">iterator rend();                    //返回string第一个字符位置的前面</span><br></pre></td></tr></table></figure></p>
<p>rbegin和rend用于从后向前的迭代访问，通过设置迭代器string::reverse_iterator,string::const_reverse_iterator实现</p>
<h2 id="字符串流处理："><a href="#字符串流处理：" class="headerlink" title="字符串流处理："></a>字符串流处理：</h2><p>通过定义ostringstream和istringstream变量实现，<code>#include &lt;sstream&gt;</code>头文件中。例如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">input</span><span class="params">(<span class="string">"hello,this is a test"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(input)</span></span>;</span><br><span class="line"><span class="built_in">string</span> s1,s2,s3,s4;</span><br><span class="line">is&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3&gt;&gt;s4;<span class="comment">//s1="hello,this",s2="is",s3="a",s4="test"</span></span><br><span class="line"><span class="built_in">ostringstream</span> os;</span><br><span class="line">os&lt;&lt;s1&lt;&lt;s2&lt;&lt;s3&lt;&lt;s4;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;os.str();</span><br></pre></td></tr></table></figure></p>
<p>以上就是对C++ string类的一个简要介绍。</p>
<h2 id="string特性描述"><a href="#string特性描述" class="headerlink" title="string特性描述"></a>string特性描述</h2><p>可用下列函数来获得string的一些特性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int capacity()const;    //返回当前容量（即string中不必增加内存即可存放的元素个数）</span><br><span class="line">int max_size()const;    //返回string对象中可存放的最大字符串的长度</span><br><span class="line">int size()const;        //返回当前字符串的大小</span><br><span class="line">int length()const;       //返回当前字符串的长度</span><br><span class="line">bool empty()const;        //当前字符串是否为空</span><br><span class="line">void resize(int len,char c);  //把字符串当前大小置为len，多去少补，多出的字符c填充不足的部分</span><br></pre></td></tr></table></figure></p>
<p>测试代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">if</span> (str.empty())</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"str is NULL."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"str is not NULL."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    str = str + <span class="string">"abcdefg"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str is "</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"str's size is "</span>&lt;&lt;str.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">　　     <span class="built_in">cout</span>&lt;&lt;<span class="string">"str's capacity is "</span>&lt;&lt;str.capacity()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str's max size is "</span>&lt;&lt;str.max_size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str's length is "</span>&lt;&lt;str.length()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    str.resize(<span class="number">20</span>,<span class="string">'c'</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str is "</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    str.resize(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str is "</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="string的查找"><a href="#string的查找" class="headerlink" title="string的查找"></a>string的查找</h2><p>由于查找是使用最为频繁的功能之一，string提供了非常丰富的查找函数：（注：string::npos）</p>
<p><code>size_type find( const basic_string &amp;str, size_type index );</code>  //返回str在字符串中第一次出现的位置（从index开始查找），如果没找到则返回string::npos</p>
<p><code>size_type find( const char *str, size_type index );</code>  // 同上</p>
<p><code>size_type find( const char *str, size_type index, size_type length );</code>  //返回str在字符串中第一次出现的位置（从index开始查找，长度为length），如果没找到就返回string::npos</p>
<p><code>size_type find( char ch, size_type index );</code>  // 返回字符ch在字符串中第一次出现的位置（从index开始查找），如果没找到就返回string::npos</p>
<p>注意：查找字符串a是否包含子串b,不是用 strA.find(strB) &gt; 0 而是 strA.find(strB) != string:npos 这是为什么呢？（初学者比较容易犯的一个错误）本部分参考自web100与luhao1993</p>
<p>先看下面的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int idx = str.find(&quot;abc&quot;);</span><br><span class="line">if (idx == string::npos);</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，idx的类型被定义为int，这是错误的，即使定义为<code>unsigned int</code> 也是错的，它必须定义为 <code>string::size_type</code>。npos 是这样定义的： <code>static const size_type npos = -1</code>; 因为 string::size_type (由字符串配置器 allocator 定义) 描述的是 size，故需为无符号整数型别。因为缺省配置器以型别 size_t 作为 size_type，于是 -1 被转换为无符号整数型别，npos 也就成了该型别的最大无符号值。不过实际数值还是取决于型别 size_type 的实际定义。不幸的是这些最大值都不相同。事实上，(unsigned long)-1 和 (unsigned short)-1 不同(前提是两者型别大小不同)。因此，比较式 idx == string::npos 中，如果 idx 的值为-1，由于 idx 和字符串string::npos 型别不同，比较结果可能得到 false。因此要想判断 find()等查找函数的结果是否为npos，最好的办法是直接比较。</p>
<p>测试代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> loc;</span><br><span class="line">    <span class="built_in">string</span> s=<span class="string">"study hard and make progress everyday! every day!!"</span>;</span><br><span class="line">    loc=s.rfind(<span class="string">"make"</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"the word make is at index"</span>&lt;&lt;loc&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//-1表示没找到</span></span><br><span class="line">    loc=s.rfind(<span class="string">"make"</span>);<span class="comment">//缺省状态下，从最后一个往前找</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"the word make is at index"</span>&lt;&lt;loc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    loc=s.find_first_of(<span class="string">"day"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"the word day(first) is at index "</span>&lt;&lt;loc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    loc=s.find_first_not_of(<span class="string">"study"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"the first word not of study is at index"</span>&lt;&lt;loc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    loc=s.find_last_of(<span class="string">"day"</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"the last word of day is at index"</span>&lt;&lt;loc&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    loc=s.find(<span class="string">"day"</span>);<span class="comment">//缺陷状态下从第一个往后找</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;loc;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="https://images2018.cnblogs.com/blog/1352320/201803/1352320-20180323101344856-2115596576.png" alt></p>
<h2 id="其他常用函数"><a href="#其他常用函数" class="headerlink" title="其他常用函数"></a>其他常用函数</h2><ul>
<li><code>string &amp;insert(int p,const string &amp;s);  //在p位置插入字符串s</code></li>
<li><code>string &amp;replace(int p, int n,const char *s); //删除从p开始的n个字符，然后在p处插入串s</code></li>
<li><code>string &amp;erase(int p, int n);  //删除p开始的n个字符，返回修改后的字符串</code></li>
<li><code>string substr(int pos = 0,int n = npos) const;  //返回pos开始的n个字符组成的字符串</code></li>
<li><code>void swap(string &amp;s2);    //交换当前字符串与s2的值</code></li>
<li><code>string &amp;append(const char *s);   //把字符串s连接到当前字符串结尾</code></li>
<li><code>void push_back(char c)   //当前字符串尾部加一个字符c</code></li>
<li><code>const char *data()const;   //返回一个非null终止的c字符数组，data():与c_str()类似，用于string转const char*其中它返回的数组是不以空字符终止,</code></li>
<li><code>const char *c_str()const;  //返回一个以null终止的c字符串，即c_str()函数返回一个指向正规C字符串的指针, 内容与本string串相同,用于string转const char*</code></li>
</ul>
<p>测试代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1 = <span class="string">"abc123defg"</span>;</span><br><span class="line">    <span class="built_in">string</span> str2 = <span class="string">"swap!"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1.erase(<span class="number">3</span>,<span class="number">3</span>)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//从索引3开始的3个字符,即删除掉了"123"</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1.insert(<span class="number">0</span>,<span class="string">"123"</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//在头部插入</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1.append(<span class="string">"123"</span>)&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//append()方法可以添加字符串</span></span><br><span class="line">    str1.push_back(<span class="string">'A'</span>);  <span class="comment">//push_back()方法只能添加一个字符</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1.replace(<span class="number">0</span>,<span class="number">3</span>,<span class="string">"hello"</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//即将索引0开始的3个字符替换成"hello"</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1.substr(<span class="number">5</span>,<span class="number">7</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//从索引5开始7个字节</span></span><br><span class="line">    str1.swap(str2);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p = str.c_str();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">abc123defg</span><br><span class="line">abcdefg</span><br><span class="line">123abcdefg</span><br><span class="line">123abcdefg123</span><br><span class="line">123abcdefg123A</span><br><span class="line">helloabcdefg123A</span><br><span class="line">abcdefg</span><br><span class="line">swap!</span><br><span class="line">swap!</span><br></pre></td></tr></table></figure></p>
<h1 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h1><h2 id="this指针的用处"><a href="#this指针的用处" class="headerlink" title="this指针的用处"></a>this指针的用处</h2><p>一个对象的this指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上this指针，编译器在编译的时候也是加上this的，它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。  例如，调用<code>date.SetMonth(9) &lt;==&gt; SetMonth(&amp;date, 9)</code>，this帮助完成了这一转换。</p>
<h2 id="this指针的使用"><a href="#this指针的使用" class="headerlink" title="this指针的使用"></a>this指针的使用</h2><p>一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用<code>return *this</code>；另外一种情况是当参数与成员变量名相同时，如<code>this-&gt;n = n</code> （不能写成n = n）。</p>
<h2 id="this指针程序示例"><a href="#this指针程序示例" class="headerlink" title="this指针程序示例"></a>this指针程序示例</h2><p>this指针存在于类的成员函数中,指向被调用函数所在的类实例的地址。根据以下程序来说明this指针<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> 　　</span></span><br><span class="line"><span class="class">&#123;</span> 　　</span><br><span class="line">    <span class="keyword">int</span> x, y; 　　</span><br><span class="line"><span class="keyword">public</span>: 　　</span><br><span class="line">    Point(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; x=a; y=b;&#125; 　　</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MovePoint</span><span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; x+=a; y+=b;&#125; 　　</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"x="</span>&lt;&lt;x&lt;&lt;<span class="string">"y="</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;&#125; &lt;=<span class="string">""</span> font=<span class="string">""</span>&gt;　　</span><br><span class="line">&#125;; 　　</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span> 　　</span>&#123; 　　</span><br><span class="line">    <span class="function">Point <span class="title">point1</span><span class="params">( <span class="number">10</span>,<span class="number">10</span>)</span></span>; 　　</span><br><span class="line">    point1.MovePoint(<span class="number">2</span>,<span class="number">2</span>); 　　</span><br><span class="line">    point1.print(); 　　</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当对象point1调用<code>MovePoint(2,2)</code>函数时，即将point1对象的地址传递给了this指针。 </p>
<p>MovePoint函数的原型应该是<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MovePoint</span><span class="params">( Point *<span class="keyword">this</span>, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>第一个参数是指向该类对象的一个指针，我们在定义成员函数时没看见是因为这个参数在类中是隐含的。这样point1的地址传递给了this，所以在MovePoint函数中便显式的写成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MovePoint</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">this</span>-&gt;x +=a; <span class="keyword">this</span>-&gt; y+= b;&#125;</span><br></pre></td></tr></table></figure></p>
<p>即可以知道，point1调用该函数后，也就是point1的数据成员被调用并更新了值。 </p>
<p>即该函数过程可写成<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">point1.x+= a; point1. y + = b;</span><br></pre></td></tr></table></figure></p>
<h2 id="关于this指针的一个经典回答"><a href="#关于this指针的一个经典回答" class="headerlink" title="关于this指针的一个经典回答"></a>关于this指针的一个经典回答</h2><p>当你进入一个房子后，你可以看见桌子、椅子、地板等，但是房子你是看不到全貌了。 </p>
<p>对于一个类的实例来说，你可以看到它的成员函数、成员变量，但是实例本身呢？this是一个指针，它时时刻刻指向你这个实例本身</p>
<h2 id="类的this指针有以下特点："><a href="#类的this指针有以下特点：" class="headerlink" title="类的this指针有以下特点："></a>类的this指针有以下特点：</h2><p>（1）this只能在成员函数中使用。全局函数、静态函数都不能使用this。实际上，成员函数默认第一个参数为<code>T * const this</code>。如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中，func的原型在编译器看来应该是：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(A * <span class="keyword">const</span> <span class="keyword">this</span>,<span class="keyword">int</span> p)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>（2）由此可见，this在成员函数的开始前构造，在成员函数的结束后清除。这个生命周期同任何一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。如：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">a.func(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<p>此处，编译器将会编译成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A::func(&amp;a,<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<p>看起来和静态函数没差别，对吗？不过，区别还是有的。编译器通常会对this指针做一些优化，因此，this指针的传递效率比较高—如VC通常是通过ecx寄存器传递this参数的。</p>
<p>（3）几个this指针的易混问题。</p>
<p>A. this指针是什么时候创建的？</p>
<p>this在成员函数的开始执行前构造，在成员的执行结束后清除。</p>
<p>但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用 TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式 创建对象的话，在堆里分配内存，new操作符通过eax返回分配 的地址，然后设置给指针变量。之后去调 用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx。</p>
<p>B. this指针存放在何处？堆、栈、全局变量，还是其他？</p>
<p>this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级 别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内 存中，它们并不是和高级语言变量对应的。</p>
<p>C. this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针 又是如何找到“类实例后函数的”？</p>
<p>大多数编译器通过ecx寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。</p>
<p>在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿，不会跑的。</p>
<p>D. this指针是如何访问类中的变量的？</p>
<p>如果不是类，而是结构体的话，那么，如何通过结构指针来访问结构中的变量呢？如果你明白这一点的话，就很容易理解这个问题了。</p>
<p>在C++中 ,类和结构是只有一个区别的：类的成员默认是private，而结构是public。</p>
<p>this是类的指针，如果换成结构，那this就是结构的指针了。</p>
<p>E. 我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？</p>
<p>this指针只有在成员函数中才有定义。因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&amp;this获得），也可以直接使用它。</p>
<p>F. 每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</p>
<p>普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译器能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。</p>
<h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</li>
<li>类内定义的静态方法不能指向实例本身，也就是没有this指针</li>
<li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li>
<li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li>
<li>在以下场景中，经常需要显式引用 <code>this</code> 指针：<ul>
<li>为实现对象的链式引用；</li>
<li>为避免对同一对象进行赋值操作；</li>
<li>在实现一些数据结构时，如 <code>list</code>。</li>
</ul>
</li>
</ul>
<h1 id="变长参数函数"><a href="#变长参数函数" class="headerlink" title="变长参数函数"></a>变长参数函数</h1><p>首先回顾一下较多使用的变长参数函数，最经典的便是printf。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern int printf(const char *format, ...);</span><br></pre></td></tr></table></figure></p>
<p>以上是一个变长参数的函数声明。我们自己定义一个测试函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">testparams</span><span class="params">(<span class="keyword">int</span> count, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    va_start(args, count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> arg = va_arg(args, <span class="keyword">int</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"arg %d = %d"</span>, i, arg);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(args);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    testparams(<span class="number">3</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>变长参数函数的解析，使用到三个宏va_start,va_arg 和va_end，再看va_list的定义<code>typedef char* va_list</code>; 只是一个char指针。</p>
<p>这几个宏如何解析传入的参数呢？</p>
<p>函数的调用，是一个压栈，保存，跳转的过程。简单的流程描述如下：</p>
<ol>
<li>把参数从右到左依次压入栈；</li>
<li>调用call指令，把下一条要执行的指令的地址作为返回地址入栈；（被调用函数执行完后会回到该地址继续执行）</li>
<li>当前的ebp（基址指针）入栈保存，然后把当前esp（栈顶指针）赋给ebp作为新函数栈帧的基址；</li>
<li>执行被调用函数，局部变量等入栈；</li>
<li>返回值放入eax，leave，ebp赋给esp，esp所存的地址赋给ebp；（这里可能需要拷贝临时返回对象）</li>
<li>从返回地址开始继续执行；（把返回地址所存的地址给eip）<br>　<br>由于开始的时候从右至左把参数压栈，va_start 传入最左侧的参数，往右的参数依次更早被压入栈，因此地址依次递增（栈顶地址最小）。va_arg传入当前需要获得的参数的类型，便可以利用 sizeof 计算偏移量，依次获取后面的参数值。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _INTSIZEOF(n)          ((sizeof(n) + sizeof(int) - 1) &amp; ~(sizeof(int) - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ADDRESSOF(v) (&amp;const_cast<span class="meta-string">&lt;char&amp;&gt;(reinterpret_cast&lt;const volatile char&amp;&gt;(v)))</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __crt_va_start_a(ap, v) ((void)(ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __crt_va_arg(ap, t)     (*(t*)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __crt_va_end(ap)        ((void)(ap = (va_list)0))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __crt_va_start(ap, x) ((void)(__vcrt_va_start_verify_argument_type<span class="meta-string">&lt;decltype(x)&gt;(), __crt_va_start_a(ap, x)))</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_start __crt_va_start</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_arg   __crt_va_arg</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> va_end   __crt_va_end</span></span><br></pre></td></tr></table></figure>
<p>上述宏定义中，_INTSIZEOF(n) 将地址的低2位指令，做内存的4字节对齐。每次取参数时，调用__crt_va_arg(ap,t) ，返回t类型参数地址的值，同时将ap偏移到t之后。最后，调用_crt_va_end(ap)将ap置0.</p>
<p>变长参数的函数的使用及其原理看了宏定义是很好理解的。从上文可知，要使用变长参数函数的参数，我们必须知道传入的每个参数的类型。printf中，有format字符串中的特殊字符组合来解析后面的参数类型。但是当传入类的构造函数的参数时，我们并不知道每个参数都是什么类型，虽然参数能够依次传入函数，但无法解析并获取每个参数的数值。因此传统的变长参数函数并不足以解决传入任意构造函数参数的问题。</p>
<h1 id="变长参数模板"><a href="#变长参数模板" class="headerlink" title="变长参数模板"></a>变长参数模板</h1><p>我们需要用到C++11的新特性，变长参数模板。</p>
<p>这里举一个使用自定义内存池的例子。定义一个内存池类MemPool.h，以count个类型T为单元分配内存，默认分配一个对象。每当内存内空闲内存不够，则一次申请MEMPOOL_NEW_SIZE个内存对象。内存池本身只负责内存分配，不做初始化工作，因此不需要传入任何参数，只需实例化模板分配相应类型的内存即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UTIL_MEMPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UTIL_MEMPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEMPOOL_NEW_SIZE 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> count = <span class="number">1</span>&gt;</span><br><span class="line">class MemPool</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">union</span> MemObj &#123;</span><br><span class="line">        <span class="keyword">char</span> _obj[<span class="number">1</span>];</span><br><span class="line">        MemObj* _freelink;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">Allocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!_freelist) &#123;</span><br><span class="line">            refill();</span><br><span class="line">        &#125;</span><br><span class="line">        MemObj* alloc_mem = _freelist;</span><br><span class="line">        _freelist = _freelist-&gt;_freelink;</span><br><span class="line">        ++_size;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>*)alloc_mem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeAllocate</span><span class="params">(<span class="keyword">void</span>* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MemObj* q = (MemObj*)p;</span><br><span class="line">        q-&gt;_freelink = _freelist;</span><br><span class="line">        _freelist = q;</span><br><span class="line">        --_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> size_t <span class="title">TotalSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _totalsize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> size_t <span class="title">Size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _size;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">refill</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> size = <span class="keyword">sizeof</span>(T) * count;</span><br><span class="line">        <span class="keyword">char</span>* new_mem = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(size * MEMPOOL_NEW_SIZE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MEMPOOL_NEW_SIZE; ++i) &#123;</span><br><span class="line">            MemObj* free_mem = (MemObj*)(new_mem + i * size);</span><br><span class="line">            free_mem-&gt;_freelink = _freelist;</span><br><span class="line">            _freelist = free_mem;</span><br><span class="line">        &#125;</span><br><span class="line">        _totalsize += MEMPOOL_NEW_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> MemObj* _freelist;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> _totalsize;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> _size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> count&gt;</span><br><span class="line"><span class="keyword">typename</span> MemPool&lt;T, count&gt;::MemObj* MemPool&lt;T, count&gt;::_freelist = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> count&gt;</span><br><span class="line"><span class="keyword">size_t</span> MemPool&lt;T, count&gt;::_totalsize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> count&gt;</span><br><span class="line"><span class="keyword">size_t</span> MemPool&lt;T, count&gt;::_size = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>接下来在没有变长参数的情况下，实现通用MemNew和MemDelete函数模板。这里不对函数模板作详细解释，用函数模板我们可以对不同的类型实现同样的内存池分配操作。如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> *<span class="title">MemNew</span>(<span class="title">size_t</span> <span class="title">count</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T *p = (T*)MemPool&lt;T, count&gt;::Allocate();</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">std</span>::is_pod&lt;T&gt;::value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> (&amp;p[i]) T();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> *<span class="title">MemDelete</span>(<span class="title">T</span> *<span class="title">p</span>, <span class="title">size_t</span> <span class="title">count</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">std</span>::is_pod&lt;T&gt;::value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                p[i].~T();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        MemPool&lt;T, count&gt;::DeAllocate(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述实现中，使用placement new对申请的内存进行构造，使用了默认构造函数，当申请内存的类型不具备默认构造函数时，placement new将报错。对于pod类型，可以省去调用构造函数的过程。</p>
<p>引入C++11变长模板参数后MemNew修改为如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> *<span class="title">MemNew</span>(<span class="title">size_t</span> <span class="title">count</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T *p = (T*)MemPool&lt;T, count&gt;::Allocate();</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">std</span>::is_pod&lt;T&gt;::value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">new</span> (&amp;p[i]) T(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上函数定义包含了多个特性，后面我将一一解释，其中class… Args 表示变长参数模板，函数参数中Args&amp;&amp; 为右值引用。std::forward<args> 实现参数的完美转发。这样，无论传入的类型具有什么样的构造函数，都能够完美执行placement new。</args></p>
<p>C++11中引入了变长参数模板的概念，来解决参数个数不确定的模板。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>... <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">Test</span> &#123;</span>&#125;;</span><br><span class="line">Test&lt;&gt; test0;</span><br><span class="line">Test&lt;<span class="keyword">int</span>&gt; test1;</span><br><span class="line">Test&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; test2;</span><br><span class="line">Test&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">long</span>&gt; test3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>... <span class="title">T</span>&gt; <span class="title">void</span> <span class="title">test</span>(<span class="title">T</span>... <span class="title">args</span>);</span></span><br><span class="line">test();</span><br><span class="line">test&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>);</span><br><span class="line">test&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">long</span>&gt;(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0L</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="变长参数函数模板"><a href="#变长参数函数模板" class="headerlink" title="变长参数函数模板"></a>变长参数函数模板</h2><p>T… args 为形参包，其中args是模式，形参包中可以有0到任意多个参数。调用函数时，可以传任意多个实参。对于函数定义来说，该如何使用参数包呢？在上文的MemNew中，我们使用std::forward依次将参数包传入构造函数，并不关注每个参数具体是什么。如果需要，我们可以用sizeof…(args)操作获取参数个数，也可以把参数包展开，对每个参数做更多的事。展开的方法有两种，递归函数，逗号表达式。</p>
<p>递归函数方式展开，模板推导的时候，一层层递归展开，最后到没有参数时用定义的一般函数终止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T, class... Args&gt; </span><br><span class="line">void test(T first, Args... args)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; typeid(T).name() &lt;&lt; &quot; &quot; &lt;&lt; first &lt;&lt; std::endl;</span><br><span class="line">    test(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test&lt;int, int, long&gt;(0, 0, 0L);</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">int 0</span><br><span class="line">int 0</span><br><span class="line">long 0</span><br></pre></td></tr></table></figure></p>
<p>逗号表达式方式展开，利用数组的参数初始化列表和逗号表达式，逐一执行print每个参数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print</span>(<span class="title">T</span> <span class="title">arg</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="string">" "</span> &lt;&lt; arg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">test</span>(<span class="title">Args</span>... <span class="title">args</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123; (print(args), <span class="number">0</span>)... &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"><span class="keyword">int</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">long</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h2 id="变长参数类模板"><a href="#变长参数类模板" class="headerlink" title="变长参数类模板"></a>变长参数类模板</h2><p>变长参数类模板，一般情况下可以方便我们做一些编译期计算。可以通过偏特化和递归推导的方式依次展开模板参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T, class... Types&gt;</span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    enum &#123;</span><br><span class="line">        value = Test&lt;T&gt;::value + Test&lt;Types...&gt;::value,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Test&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    enum &#123;</span><br><span class="line">        value = sizeof(T),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test&lt;int, int, long&gt; test;</span><br><span class="line">std::cout &lt;&lt; test.value;</span><br><span class="line"></span><br><span class="line">output: 12</span><br></pre></td></tr></table></figure>
<h2 id="右值引用和完美转发"><a href="#右值引用和完美转发" class="headerlink" title="右值引用和完美转发"></a>右值引用和完美转发</h2><p>对于变长参数函数模板，需要将形参包展开逐个处理的需求不多，更多的还是像本文的MemNew这样的需求，最终整个传入某个现有的函数。我们把重点放在参数的传递上。</p>
<p>要理解右值引用，需要先说清楚左值和右值。左值是内存中有确定存储地址的对象的表达式的值；右值则是非左值的表达式的值。const左值不可被赋值，临时对象的右值可以被赋值。左值与右值的根本区别在于是否能用&amp;运算符获得内存地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int i =0;//i 左值</span><br><span class="line">int *p = &amp;i;// i 左值</span><br><span class="line">int&amp; foo();</span><br><span class="line">foo() = 42;// foo() 左值</span><br><span class="line">int* p1 = &amp;foo();// foo() 左值</span><br><span class="line"></span><br><span class="line">int foo1();</span><br><span class="line">int j = 0;</span><br><span class="line">j = foo1();// foo 右值</span><br><span class="line">int k = j + 1;// j + 1 右值</span><br><span class="line">int *p2 = &amp;foo1(); // 错误，无法取右值的地址</span><br><span class="line">j = 1;// 1 右值</span><br></pre></td></tr></table></figure></p>
<p>理解左值和右值之后，再来看引用，对左值的引用就是左值引用，对右值（纯右值和临终值）的引用就是右值引用。</p>
<p>　　如下函数foo，传入int类型，返回int类型，这里传入函数的参数0和返回值0都是右值(不能用&amp;取得地址)。于是，未做优化的情况下，传入参数0的时候，我们需要把右值0拷贝给param，函数返回的时候需要将0拷贝给临时对象，临时对象再拷贝给res。当然现在的编译器都做了返回值优化，返回对象是直接创建在返回后的左值上的，这里只用来举个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int foo(int param)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d&quot;, param);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int res = foo(0);</span><br></pre></td></tr></table></figure></p>
<p>显然，这里的拷贝都是多余的。可能我们会想要优化，首先将参数int改为int&amp;，传入左值引用，于是0无法传入了，当然我们可以改成const int&amp;，这样终于省去了传参的拷贝。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int foo(const int&amp; param)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d&quot;, param);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于const int&amp; 既可以是左值也可以是右值，传入0或者int变量都能够满足。(但是似乎既然有左值引用的int&amp;类型，就应该有对应的传入右值引用的类型int&amp;&amp;)。另外，这里返回的右值0，似乎不通过拷贝就无法赋值给左值res。</p>
<p>于是有了移动语义，把临时对象的内容直接移动给被赋值的左值对象(std::move)。和右值引用，X&amp;&amp;是到数据类型X的右值引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int result = 0;</span><br><span class="line">int&amp;&amp; foo(int&amp;&amp; param)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d&quot;, param);</span><br><span class="line">    return std::move(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int&amp;&amp; res = foo(0);</span><br><span class="line">int *pres = &amp;res;</span><br></pre></td></tr></table></figure></p>
<p>将foo改为右值引用参数和返回值，返回右值引用，免去拷贝。这里res是具名引用，运算符右侧的右值引用作为左值，可以取地址。右值引用既有左值性质，也有右值性质。</p>
<p>上述例子还只存在于拷贝的性能问题。回到MemNew这样的函数模板。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">T* Test(T arg)</span><br><span class="line">&#123;</span><br><span class="line">    return new T(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T* Test(T&amp; arg)</span><br><span class="line">&#123;</span><br><span class="line">    return new T(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T* Test(const T&amp; arg)</span><br><span class="line">&#123;</span><br><span class="line">    return new T(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T* Test(T&amp;&amp; arg)</span><br><span class="line">&#123;</span><br><span class="line">    return new T(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的前三种方式传参，第一种首先有拷贝消耗，其次有的参数就是需要修改的左值。第二种方式则无法传常数等右值。第三种方式虽然左值右值都能传，却无法对传入的参数进行修改。第四种方式使用右值引用，可以解决参数完美转发的问题。</p>
<p>std::forward能够根据实参的数据类型，返回相应类型的左值和右值引用，将参数完整不动的传递下去。<br>解释这个原理涉及到引用塌缩规则</p>
<p>T&amp; &amp; -&gt;T&amp;<br>T&amp; &amp;&amp;-&gt;T&amp;<br>T&amp;&amp; &amp;-&gt;T&amp;<br>T&amp;&amp; &amp;&amp;-&gt;T&amp;&amp;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">template&lt; class T &gt; struct remove_reference      &#123;typedef T type;&#125;;</span><br><span class="line">template&lt; class T &gt; struct remove_reference&lt;T&amp;&gt;  &#123;typedef T type;&#125;;</span><br><span class="line">template&lt; class T &gt; struct remove_reference&lt;T&amp;&amp;&gt; &#123;typedef T type;&#125;;</span><br><span class="line"></span><br><span class="line">template&lt; class T &gt; T&amp;&amp; forward( typename std::remove_reference&lt;T&gt;::type&amp; t )</span><br><span class="line">&#123;</span><br><span class="line">  return static_cast&lt;T&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">typename std::remove_reference&lt;T&gt;::type&amp;&amp; move(T&amp;&amp; a) noexcept</span><br><span class="line">&#123; </span><br><span class="line">  return static_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于函数模板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">T* Test(T&amp;&amp; arg)</span><br><span class="line">&#123;</span><br><span class="line">    return new T(std::forward&lt;T&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当传入实参为X类型左值时，T为X&amp;，最后的类型为X&amp;。当实参为X类型右值时，T为X，最后的类型为X&amp;&amp;。</p>
<p>x为左值时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X x;</span><br><span class="line">Test(x);</span><br></pre></td></tr></table></figure></p>
<p>T为X&amp;，实例化后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">X&amp; &amp;&amp; std::forward(remove_reference&lt;X&amp;&gt;::type&amp; a) noexcept</span><br><span class="line">&#123;</span><br><span class="line">    return static_cast&lt;X&amp; &amp;&amp;&gt;(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X* Test(X&amp; &amp;&amp; arg)</span><br><span class="line">&#123;</span><br><span class="line">    return new X(std::forward&lt;X&amp;&gt;(arg));  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 塌陷后</span><br><span class="line"></span><br><span class="line">X&amp; std::forward(X&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">    return static_cast&lt;X&amp;&gt;(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X* Test(X&amp; arg)</span><br><span class="line">&#123;</span><br><span class="line">    return new X(std::forward&lt;X&amp;&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>x为右值时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X foo();</span><br><span class="line">Test(foo());</span><br></pre></td></tr></table></figure></p>
<p>T为X，实例化后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">X&amp;&amp; std::forward(remove_reference&lt;X&gt;::type&amp; a) noexcept</span><br><span class="line">&#123;</span><br><span class="line">    return static_cast&lt;X&amp;&amp;&gt;(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X* Test(X&amp;&amp; arg)</span><br><span class="line">&#123;</span><br><span class="line">    return new X(std::forward&lt;X&gt;(arg));  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 塌陷后</span><br><span class="line"></span><br><span class="line">X&amp;&amp; std::forward(X&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">    return static_cast&lt;X&amp;&amp;&gt;(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X* Test(X&amp;&amp; arg)</span><br><span class="line">&#123;</span><br><span class="line">    return new X(std::forward&lt;X&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到最终实参总是被推导为和传入时相同的类型引用。</p>
<p>至此，我们讨论了变长参数模板，讨论了右值引用和函数模板的完美转发，完整的解释了MemNew对任意多个参数的构造函数的参数传递过程。利用变长参数函数模板，右值引用和std::forward，可以完成参数的完美转发。</p>
<h1 id="str相关函数"><a href="#str相关函数" class="headerlink" title="str相关函数"></a>str相关函数</h1><p>C语言str系列库函数在不同的库中有不同的实现方法，但原理都是一样的。因为库函数都是没有进行入口参数检查的，并且str系列库函数在面试中经常容易被面试官喊在纸上写某一个函数的实现，因此本文参考了OpenBSD和vc++ 8.0库中的代码，结合自己的编程习惯，部分整理如下：</p>
<p>1、strcpy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">char * strcpy(char *dst, const char *src)  </span><br><span class="line">&#123;  </span><br><span class="line">    char *d;  </span><br><span class="line">  </span><br><span class="line">    if (dst == NULL || src == NULL)  </span><br><span class="line">        return dst;  </span><br><span class="line">  </span><br><span class="line">    d = dst;  </span><br><span class="line">    while (*d++ = *src++)    // while ((*d++ = *src++) != &apos;\0&apos;)  </span><br><span class="line">        ;  </span><br><span class="line">  </span><br><span class="line">    return dst;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2、strncpy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//copy at most n characters of src to dst  </span><br><span class="line">//Pad with &apos;\0&apos; if src fewer than n characters  </span><br><span class="line">char *strncpy(char *dst, const char*src, size_t n)  </span><br><span class="line">&#123;  </span><br><span class="line">    char *d;  </span><br><span class="line">  </span><br><span class="line">    if (dst == NULL || src == NULL)  </span><br><span class="line">        return dst;  </span><br><span class="line">  </span><br><span class="line">    d = dst;  </span><br><span class="line">    while (n != 0 &amp;&amp; (*d++ = *src++))    /* copy string */  </span><br><span class="line">        n--;  </span><br><span class="line">    if (n != 0)  </span><br><span class="line">        while (--n != 0)  </span><br><span class="line">            *d++ == &apos;\0&apos;;                /* pad out with zeroes */  </span><br><span class="line">  </span><br><span class="line">    return dst;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意n是unsigned int，在进行n—操作时特别要小心。如果不小心写成下面这样就会出错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (n-- != 0 &amp;&amp; (*d++ = *src++))  </span><br><span class="line">    ;         </span><br><span class="line">while (n-- != 0)   </span><br><span class="line">    *d++ = &apos;\0&apos;;</span><br></pre></td></tr></table></figure></p>
<p>第一个while循环中，当n变为0时，仍然会执行n—一，此时n等于经由-1变成的大正数，导致后面对n的使用出错。<br>3、strcat<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">char *strcat(char *dst, const char *src)  </span><br><span class="line">&#123;     </span><br><span class="line">    char *d;  </span><br><span class="line">    if (dst == NULL || src == NULL)  </span><br><span class="line">        return dst;  </span><br><span class="line">  </span><br><span class="line">   d = dst;  </span><br><span class="line">   while (*d)  </span><br><span class="line">       d++;  </span><br><span class="line">   //while (*d++ != 0);  </span><br><span class="line">   //d--;  </span><br><span class="line">     </span><br><span class="line">   while (*d++ = *src++)  </span><br><span class="line">       ;  </span><br><span class="line">  </span><br><span class="line">   return dst;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4、strncat<br>写法1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//concatenate at most n characters of src to the end of dst  </span><br><span class="line">//terminates dst with &apos;\0&apos;  </span><br><span class="line">char *strncat(char *dst, const char *src, size_t n)  </span><br><span class="line">&#123;  </span><br><span class="line">    if (NULL == dst || NULL == src)  </span><br><span class="line">        return dst;  </span><br><span class="line">  </span><br><span class="line">    if (n != 0)  </span><br><span class="line">    &#123;  </span><br><span class="line">        char *d = dst;  </span><br><span class="line">        do   </span><br><span class="line">        &#123;  </span><br><span class="line">            if ((*d = *src++) == &apos;\0&apos; )  </span><br><span class="line">                return dst;     //break  </span><br><span class="line">            d++;  </span><br><span class="line">        &#125; while (--n != 0);    </span><br><span class="line">        *d = &apos;\0&apos;;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    return dst;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>写法2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">char *strncat(char *dst, const char *src, size_t n)  </span><br><span class="line">&#123;  </span><br><span class="line">   char *d;  </span><br><span class="line">  </span><br><span class="line">   if (dst == NULL || src == NULL)  </span><br><span class="line">       return dst;  </span><br><span class="line">     </span><br><span class="line">   d = dst;  </span><br><span class="line">   while (*d)  </span><br><span class="line">       d++;  </span><br><span class="line">   //(1)  </span><br><span class="line">   while (n != 0)  </span><br><span class="line">   &#123;  </span><br><span class="line">       if ((*d++ = *src++) == &apos;\0&apos;)  </span><br><span class="line">           return dst;  </span><br><span class="line">       n--;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   //(2)  </span><br><span class="line">   //while (n--)       //这种方式写最后n的值不为0，不过这个n后面不会再被使用  </span><br><span class="line">      // if ((*d++ == *src++) == &apos;\0&apos;)  </span><br><span class="line">         //  return dst;  </span><br><span class="line">  </span><br><span class="line">   *d = &apos;\0&apos;;  </span><br><span class="line">  </span><br><span class="line">   return dst;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5、strcmp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int strcmp(const char *s1, const char *s2)  </span><br><span class="line">&#123;   </span><br><span class="line">    if (s1 == NULL || s2 == NULL)  </span><br><span class="line">        return 0;  </span><br><span class="line">    //(1)  </span><br><span class="line">    //while (*s1 == *s2++)  </span><br><span class="line">    //  if (*s1++ == &apos;\0&apos;)  </span><br><span class="line">    //      return 0;  </span><br><span class="line">  </span><br><span class="line">    //(2)  </span><br><span class="line">    for (; *s1 == *s2; s1++, s2++)  </span><br><span class="line">        if (*s1 == &apos;\0&apos;)  </span><br><span class="line">            return 0;  </span><br><span class="line">    return *(unsigned char*)s1 - *(unsigned char*)s2;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>6、strncmp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int strncmp(const char *s1, const char *s2, size_t n)  </span><br><span class="line">&#123;  </span><br><span class="line">    if (s1 == NULL || s2 == NULL)  </span><br><span class="line">        return 0;  </span><br><span class="line">  </span><br><span class="line">    if (n == 0)  </span><br><span class="line">        return 0;  </span><br><span class="line">    do  </span><br><span class="line">    &#123;  </span><br><span class="line">        if (*s1 != *s2++)  </span><br><span class="line">            return *(unsigned char*)s1 - *(unsigned char*)--s2;  </span><br><span class="line">        if (*s1++ == &apos;\0&apos;)  </span><br><span class="line">            break;  </span><br><span class="line">    &#125; while (--n != 0);  </span><br><span class="line">  </span><br><span class="line">    //do   </span><br><span class="line">    //&#123;  </span><br><span class="line">    //  if (*s1 != *s2)  </span><br><span class="line">    //      return *(unsigned char*)s1 - *(unsigned char*)s2;  </span><br><span class="line">    //  if (*s1 == &apos;\0&apos;)  </span><br><span class="line">    //      break;  </span><br><span class="line">    //  s1++;  </span><br><span class="line">    //  s2++;  </span><br><span class="line">    //&#125; while (--n != 0);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>7、strstr<br>写法1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//return pointer to first  occurrence of find in s  </span><br><span class="line">//or NULL if not present  </span><br><span class="line">char *strstr(const char *s, const char *find)  </span><br><span class="line">&#123;  </span><br><span class="line">    char *cp = (char*)s;  </span><br><span class="line">    char *s1, *s2;  </span><br><span class="line">  </span><br><span class="line">    if (s == NULL || find == NULL)  </span><br><span class="line">        return NULL;  </span><br><span class="line">  </span><br><span class="line">    while (*cp != &apos;\0&apos;)  </span><br><span class="line">    &#123;  </span><br><span class="line">        s1 = cp;  </span><br><span class="line">        s2 = (char*)find;  </span><br><span class="line">  </span><br><span class="line">        while (*s1 &amp;&amp; *s2 &amp;&amp; *s1 == *s2)  </span><br><span class="line">            s1++, s2++;  </span><br><span class="line">  </span><br><span class="line">        if(*s2 == &apos;\0&apos;)  </span><br><span class="line">            return cp;  </span><br><span class="line">  </span><br><span class="line">        cp++;  </span><br><span class="line">    &#125;  </span><br><span class="line">   return NULL;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>写法2：参照简单模式匹配算法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">char *strstr(const char *s, const char *find)  </span><br><span class="line">&#123;  </span><br><span class="line">    int i = 0, j = 0;  </span><br><span class="line">    while (*(s + i) != &apos;\0&apos; &amp;&amp; *(find + j) != &apos;\0&apos;)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if (*(s + i + j) == *(find + j))  </span><br><span class="line">            j++;     //继续比较后一字符  </span><br><span class="line">        else  </span><br><span class="line">        &#123;  </span><br><span class="line">            i++;     //开始新一轮比较  </span><br><span class="line">            j = 0;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return *(find + j) == &apos;\0&apos; ? (char*)(s + i) : NULL;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>8、strchr<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//return pointer to first occurrence of ch in str  </span><br><span class="line">//NULL if not present  </span><br><span class="line">char *strchr(const char*str, int ch)  </span><br><span class="line">&#123;  </span><br><span class="line">    while (*str != &apos;\0&apos; &amp;&amp; *str != (char)ch)  </span><br><span class="line">        str++;  </span><br><span class="line">  </span><br><span class="line">    if(*str == (char)ch)  </span><br><span class="line">        return (char*)str;  </span><br><span class="line">    return NULL;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>9、strrchr<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//return pointer to last occurrence of ch in str  </span><br><span class="line">//NULL if not present  </span><br><span class="line">char *strrchr(const char *str, int ch)  </span><br><span class="line">&#123;  </span><br><span class="line">    if (str == NULL)  </span><br><span class="line">        return NULL;  </span><br><span class="line">  </span><br><span class="line">   char *s = (char*)str;  </span><br><span class="line">  </span><br><span class="line">   while (*s++)  </span><br><span class="line">       ;       /* find end of string */  </span><br><span class="line">  </span><br><span class="line">   while (--s != str &amp;&amp; *s != (char)ch)  </span><br><span class="line">       ;       /* search towards front */  </span><br><span class="line">  </span><br><span class="line">   if(*s == (char)ch)  </span><br><span class="line">       return (char*)s;  </span><br><span class="line">   return NULL;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>10、strlen<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">size_t strlen(const char *str)  </span><br><span class="line">&#123;  </span><br><span class="line">    if (str == NULL)  </span><br><span class="line">        return 0;  </span><br><span class="line">  </span><br><span class="line">    const char *eos = str;  </span><br><span class="line">    while (*eos++)  </span><br><span class="line">        ;  </span><br><span class="line">    return (eos - 1 - str);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/27/Leetcode951_1000/" rel="next" title="Leetcode951 - 1000">
                <i class="fa fa-chevron-left"></i> Leetcode951 - 1000
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/30/cpp模板的特化详解/" rel="prev" title="C++模板的特化详解">
                C++模板的特化详解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">300</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#decltype简介"><span class="nav-number">1.</span> <span class="nav-text">decltype简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#decltype用法"><span class="nav-number">2.</span> <span class="nav-text">decltype用法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#推导出表达式类型"><span class="nav-number">2.1.</span> <span class="nav-text">推导出表达式类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#与using-typedef合用，用于定义类型。"><span class="nav-number">2.2.</span> <span class="nav-text">与using/typedef合用，用于定义类型。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重用匿名类型"><span class="nav-number">2.3.</span> <span class="nav-text">重用匿名类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型编程中结合auto，用于追踪函数的返回值类型"><span class="nav-number">2.4.</span> <span class="nav-text">泛型编程中结合auto，用于追踪函数的返回值类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#decltype推导四规则"><span class="nav-number">3.</span> <span class="nav-text">decltype推导四规则</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-中constexpr作用"><span class="nav-number">4.</span> <span class="nav-text">C++中constexpr作用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#constexpr修饰普通变量"><span class="nav-number">4.1.</span> <span class="nav-text">constexpr修饰普通变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constexpr修饰函数"><span class="nav-number">4.2.</span> <span class="nav-text">constexpr修饰函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constexpr修饰类的构造函数"><span class="nav-number">4.3.</span> <span class="nav-text">constexpr修饰类的构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#constexpr修饰模板函数"><span class="nav-number">4.4.</span> <span class="nav-text">constexpr修饰模板函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#附录"><span class="nav-number">5.</span> <span class="nav-text">附录</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#const的用法"><span class="nav-number">6.</span> <span class="nav-text">const的用法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#const变量"><span class="nav-number">6.1.</span> <span class="nav-text">const变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针与const关键字"><span class="nav-number">6.2.</span> <span class="nav-text">指针与const关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#指向const变量的指针："><span class="nav-number">6.2.1.</span> <span class="nav-text">指向const变量的指针：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const指针"><span class="nav-number">6.2.2.</span> <span class="nav-text">const指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const函数参数和返回类型"><span class="nav-number">6.3.</span> <span class="nav-text">const函数参数和返回类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#const修饰函数返回值"><span class="nav-number">6.3.1.</span> <span class="nav-text">const修饰函数返回值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将类数据成员定义为const"><span class="nav-number">6.4.</span> <span class="nav-text">将类数据成员定义为const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#把类对象定义为const"><span class="nav-number">6.5.</span> <span class="nav-text">把类对象定义为const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将类的成员函数定义为const"><span class="nav-number">6.6.</span> <span class="nav-text">将类的成员函数定义为const</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#关于const的疑问："><span class="nav-number">7.</span> <span class="nav-text">关于const的疑问：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#const与-define的区别："><span class="nav-number">8.</span> <span class="nav-text">const与#define的区别：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#new-操作符（new-operator）"><span class="nav-number">9.</span> <span class="nav-text">new 操作符（new operator）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#operator-new"><span class="nav-number">10.</span> <span class="nav-text">operator new</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#placement-new"><span class="nav-number">11.</span> <span class="nav-text">placement new</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">11.1.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Deletion-and-Memory-Deallocation"><span class="nav-number">11.2.</span> <span class="nav-text">Deletion and Memory Deallocation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">11.3.</span> <span class="nav-text">数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#static关键字"><span class="nav-number">12.</span> <span class="nav-text">static关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#作用"><span class="nav-number">12.1.</span> <span class="nav-text">作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全局变量和static变量的区别"><span class="nav-number">12.2.</span> <span class="nav-text">全局变量和static变量的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static-变量"><span class="nav-number">12.3.</span> <span class="nav-text">static 变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static-成员变量"><span class="nav-number">12.4.</span> <span class="nav-text">static 成员变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static-函数"><span class="nav-number">12.5.</span> <span class="nav-text">static 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#static-成员函数"><span class="nav-number">12.6.</span> <span class="nav-text">static 成员函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vector和set使用sort方法进行排序"><span class="nav-number">13.</span> <span class="nav-text">vector和set使用sort方法进行排序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile"><span class="nav-number">14.</span> <span class="nav-text">volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#why-volatile"><span class="nav-number">14.1.</span> <span class="nav-text">why volatile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IN-C-C"><span class="nav-number">14.2.</span> <span class="nav-text">IN C/C++</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#易变的"><span class="nav-number">14.3.</span> <span class="nav-text">易变的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不可优化的"><span class="nav-number">14.4.</span> <span class="nav-text">不可优化的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#顺序执行的"><span class="nav-number">14.5.</span> <span class="nav-text">顺序执行的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile与多线程语义"><span class="nav-number">14.6.</span> <span class="nav-text">volatile与多线程语义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不保证原子性"><span class="nav-number">14.7.</span> <span class="nav-text">不保证原子性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#inline-内联函数"><span class="nav-number">15.</span> <span class="nav-text">inline 内联函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内联函数和宏定义的区别"><span class="nav-number">15.1.</span> <span class="nav-text">内联函数和宏定义的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主要区别"><span class="nav-number">15.2.</span> <span class="nav-text">主要区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#union"><span class="nav-number">16.</span> <span class="nav-text">union</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11-允许非-POD-类型"><span class="nav-number">16.1.</span> <span class="nav-text">C++11 允许非 POD 类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11-允许联合体有静态成员"><span class="nav-number">16.2.</span> <span class="nav-text">C++11 允许联合体有静态成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非受限联合体的赋值注意事项"><span class="nav-number">16.3.</span> <span class="nav-text">非受限联合体的赋值注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非受限联合体的匿名声明和“枚举式类”"><span class="nav-number">16.4.</span> <span class="nav-text">非受限联合体的匿名声明和“枚举式类”</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#assert"><span class="nav-number">17.</span> <span class="nav-text">assert()</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#assert-的用法和机制"><span class="nav-number">17.1.</span> <span class="nav-text">assert() 的用法和机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NDEBUG-宏"><span class="nav-number">17.2.</span> <span class="nav-text">NDEBUG 宏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意事项"><span class="nav-number">17.3.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#pair类型"><span class="nav-number">18.</span> <span class="nav-text">pair类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#pair类型的定义和初始化"><span class="nav-number">18.1.</span> <span class="nav-text">pair类型的定义和初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pair对象的一些操作"><span class="nav-number">18.2.</span> <span class="nav-text">pair对象的一些操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#map"><span class="nav-number">19.</span> <span class="nav-text">map</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#map对象的定义和初始化"><span class="nav-number">19.1.</span> <span class="nav-text">map对象的定义和初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map中元素的插入"><span class="nav-number">19.2.</span> <span class="nav-text">map中元素的插入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map中元素的查找和读取"><span class="nav-number">19.3.</span> <span class="nav-text">map中元素的查找和读取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从map中删除元素"><span class="nav-number">19.4.</span> <span class="nav-text">从map中删除元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map的基本操作函数："><span class="nav-number">19.5.</span> <span class="nav-text">map的基本操作函数：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#stack"><span class="nav-number">20.</span> <span class="nav-text">stack</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#queues"><span class="nav-number">21.</span> <span class="nav-text">queues</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Priority-Queues"><span class="nav-number">22.</span> <span class="nav-text">Priority Queues</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#size-t"><span class="nav-number">23.</span> <span class="nav-text">size_t</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#可移植性问题"><span class="nav-number">23.1.</span> <span class="nav-text">可移植性问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用size-t"><span class="nav-number">23.2.</span> <span class="nav-text">使用size_t</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#内存对齐"><span class="nav-number">24.</span> <span class="nav-text">内存对齐</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#strlen和sizeof区别？"><span class="nav-number">25.</span> <span class="nav-text">strlen和sizeof区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#OFFSETOF"><span class="nav-number">26.</span> <span class="nav-text">OFFSETOF</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sizeof"><span class="nav-number">27.</span> <span class="nav-text">sizeof</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#标准C-中的string类"><span class="nav-number">28.</span> <span class="nav-text">标准C++中的string类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#string类的构造函数："><span class="nav-number">28.1.</span> <span class="nav-text">string类的构造函数：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string类的字符操作："><span class="nav-number">28.2.</span> <span class="nav-text">string类的字符操作：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string的特性描述"><span class="nav-number">28.3.</span> <span class="nav-text">string的特性描述:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string类的输入输出操作"><span class="nav-number">28.4.</span> <span class="nav-text">string类的输入输出操作:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string的赋值："><span class="nav-number">28.5.</span> <span class="nav-text">string的赋值：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string的连接："><span class="nav-number">28.6.</span> <span class="nav-text">string的连接：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string的比较："><span class="nav-number">28.7.</span> <span class="nav-text">string的比较：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string的子串："><span class="nav-number">28.8.</span> <span class="nav-text">string的子串：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string的交换："><span class="nav-number">28.9.</span> <span class="nav-text">string的交换：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string类的查找函数："><span class="nav-number">28.10.</span> <span class="nav-text">string类的查找函数：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string类的替换函数"><span class="nav-number">28.11.</span> <span class="nav-text">string类的替换函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string类的插入函数"><span class="nav-number">28.12.</span> <span class="nav-text">string类的插入函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string类的删除函数"><span class="nav-number">28.13.</span> <span class="nav-text">string类的删除函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string类的迭代器处理："><span class="nav-number">28.14.</span> <span class="nav-text">string类的迭代器处理：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串流处理："><span class="nav-number">28.15.</span> <span class="nav-text">字符串流处理：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string特性描述"><span class="nav-number">28.16.</span> <span class="nav-text">string特性描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string的查找"><span class="nav-number">28.17.</span> <span class="nav-text">string的查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其他常用函数"><span class="nav-number">28.18.</span> <span class="nav-text">其他常用函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#this指针"><span class="nav-number">29.</span> <span class="nav-text">this指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#this指针的用处"><span class="nav-number">29.1.</span> <span class="nav-text">this指针的用处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this指针的使用"><span class="nav-number">29.2.</span> <span class="nav-text">this指针的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this指针程序示例"><span class="nav-number">29.3.</span> <span class="nav-text">this指针程序示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于this指针的一个经典回答"><span class="nav-number">29.4.</span> <span class="nav-text">关于this指针的一个经典回答</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类的this指针有以下特点："><span class="nav-number">29.5.</span> <span class="nav-text">类的this指针有以下特点：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注意事项-1"><span class="nav-number">29.6.</span> <span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变长参数函数"><span class="nav-number">30.</span> <span class="nav-text">变长参数函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变长参数模板"><span class="nav-number">31.</span> <span class="nav-text">变长参数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#变长参数函数模板"><span class="nav-number">31.1.</span> <span class="nav-text">变长参数函数模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变长参数类模板"><span class="nav-number">31.2.</span> <span class="nav-text">变长参数类模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#右值引用和完美转发"><span class="nav-number">31.3.</span> <span class="nav-text">右值引用和完美转发</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#str相关函数"><span class="nav-number">32.</span> <span class="nav-text">str相关函数</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
