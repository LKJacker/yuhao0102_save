<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Leetcode,">










<meta name="description" content="Leetcode951. Flip Equivalent Binary TreesFor a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees. A binary tree X is flip equivalent">
<meta name="keywords" content="Leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode951 - 1000">
<meta property="og:url" content="http://yoursite.com/2019/08/27/Leetcode951_1000/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Leetcode951. Flip Equivalent Binary TreesFor a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees. A binary tree X is flip equivalent">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20190827800.png">
<meta property="og:image" content="http://yoursite.com/img/20190524001.png">
<meta property="og:image" content="http://yoursite.com/img/20190524002.png">
<meta property="og:image" content="http://yoursite.com/img/20190824002.png">
<meta property="og:image" content="http://yoursite.com/img/20190824003.png">
<meta property="og:image" content="http://yoursite.com/img/20190824004.png">
<meta property="og:image" content="http://yoursite.com/img/20190824005.png">
<meta property="og:image" content="http://yoursite.com/img/20190825101.png">
<meta property="og:image" content="http://yoursite.com/img/20190825102.png">
<meta property="og:image" content="http://yoursite.com/img/20190825103.png">
<meta property="og:updated_time" content="2020-06-11T14:27:21.207Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode951 - 1000">
<meta name="twitter:description" content="Leetcode951. Flip Equivalent Binary TreesFor a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees. A binary tree X is flip equivalent">
<meta name="twitter:image" content="http://yoursite.com/img/20190827800.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/08/27/Leetcode951_1000/">





  <title>Leetcode951 - 1000 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/27/Leetcode951_1000/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode951 - 1000</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-27T21:35:00+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Leetcode951-Flip-Equivalent-Binary-Trees"><a href="#Leetcode951-Flip-Equivalent-Binary-Trees" class="headerlink" title="Leetcode951. Flip Equivalent Binary Trees"></a>Leetcode951. Flip Equivalent Binary Trees</h1><p>For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.</p>
<p>A binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.</p>
<p>Write a function that determines whether two binary trees are flip equivalent.  The trees are given by root nodes root1 and root2.</p>
<p>Example 1:</p>
<p>Input: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]<br>Output: true<br>Explanation: We flipped at nodes with values 1, 3, and 5.<br><img src="/img/20190827800.png" alt></p>
<p>这种做法好复杂啊。。。有太多情况需要考虑了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    bool compare(TreeNode* root1, TreeNode* root2)&#123;</span><br><span class="line">        if( root1-&gt;left == NULL &amp;&amp; root1-&gt;right == NULL &amp;&amp; root2-&gt;left == NULL &amp;&amp; root2-&gt;right == NULL ) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else if( root1-&gt;left != NULL &amp;&amp; root1-&gt;right != NULL &amp;&amp; root2-&gt;left != NULL &amp;&amp; root2-&gt;right != NULL ) &#123;</span><br><span class="line">             if(root1-&gt;left-&gt;val == root2-&gt;left-&gt;val &amp;&amp; root1-&gt;right-&gt;val == root2-&gt;right-&gt;val) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else if(root1-&gt;right-&gt;val == root2-&gt;left-&gt;val &amp;&amp; root1-&gt;left-&gt;val == root2-&gt;right-&gt;val) &#123;</span><br><span class="line">                TreeNode* temp = root1-&gt;right;</span><br><span class="line">                root1-&gt;right = root1-&gt;left;</span><br><span class="line">                root1-&gt;left = temp;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ( root1-&gt;left == NULL &amp;&amp; root1-&gt;right != NULL &amp;&amp; root2-&gt;left == NULL &amp;&amp; root2-&gt;right != NULL )&#123;</span><br><span class="line">            if(root1-&gt;right-&gt;val == root2-&gt;right-&gt;val) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ( root1-&gt;left != NULL &amp;&amp; root1-&gt;right == NULL &amp;&amp; root2-&gt;left != NULL &amp;&amp; root2-&gt;right == NULL ) &#123;</span><br><span class="line">            if(root1-&gt;left-&gt;val == root2-&gt;left-&gt;val) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ( root1-&gt;left == NULL &amp;&amp; root1-&gt;right != NULL &amp;&amp; root2-&gt;left != NULL &amp;&amp; root2-&gt;right == NULL )&#123;</span><br><span class="line">            if(root1-&gt;right-&gt;val == root2-&gt;left-&gt;val) &#123;</span><br><span class="line">                root1-&gt;left = root1-&gt;right;</span><br><span class="line">                root1-&gt;right = NULL;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ( root1-&gt;left != NULL &amp;&amp; root1-&gt;right == NULL &amp;&amp; root2-&gt;left == NULL &amp;&amp; root2-&gt;right != NULL ) &#123;</span><br><span class="line">            if(root1-&gt;left-&gt;val == root2-&gt;right-&gt;val) &#123;</span><br><span class="line">                root1-&gt;right = root1-&gt;left;</span><br><span class="line">                root1-&gt;left = NULL;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool order(TreeNode* root1, TreeNode* root2)&#123;</span><br><span class="line">        if (root1 == NULL &amp;&amp; root2 == NULL) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root1 == NULL || root2 == NULL) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if( root1 != NULL &amp;&amp; root2 != NULL ) &#123;</span><br><span class="line">            if(root1-&gt;val == root2-&gt;val)</span><br><span class="line">                compare(root1, root2);</span><br><span class="line">            else</span><br><span class="line">                return false;</span><br><span class="line">            return order(root1-&gt;left, root2-&gt;left) &amp;&amp; order(root1-&gt;right, root2-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool flipEquiv(TreeNode* root1, TreeNode* root2) &#123;</span><br><span class="line">        return order(root1, root2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>另一种做法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool flipEquiv(TreeNode* root1, TreeNode* root2) &#123;</span><br><span class="line">        // Two null trees are flip equivalent</span><br><span class="line">        // A non-null and null tree are NOT flip equivalent</span><br><span class="line">        // Two non-null trees with different root values are NOT flip equivalent</span><br><span class="line">        // Two non-null trees are flip equivalent if</span><br><span class="line">        //      The left subtree of tree1 is flip equivalent with the left subtree of tree2 and the right subtree of tree1 is   </span><br><span class="line">        //      flipequivalent with the right subtree of tree2 (no flip case)</span><br><span class="line">        //      OR</span><br><span class="line">        //      The right subtree of tree1 is flip equivalent with the left subtree of tree2 and the left subtree of tree1 is</span><br><span class="line">        //      flipequivalent with the right subtree of tree2 (flip case)</span><br><span class="line">        if ( !root1 &amp;&amp; !root2 ) return true;</span><br><span class="line">        if ( !root1 &amp;&amp; root2 || root1 &amp;&amp;!root2 || root1-&gt;val != root2-&gt;val ) return false;</span><br><span class="line">        return flipEquiv( root1-&gt;left, root2-&gt;left ) &amp;&amp; flipEquiv( root1-&gt;right, root2-&gt;right )</span><br><span class="line">            || flipEquiv( root1-&gt;right, root2-&gt;left ) &amp;&amp; flipEquiv( root1-&gt;left, root2-&gt;right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode953-Verifying-an-Alien-Dictionary"><a href="#Leetcode953-Verifying-an-Alien-Dictionary" class="headerlink" title="Leetcode953. Verifying an Alien Dictionary"></a>Leetcode953. Verifying an Alien Dictionary</h1><p>In an alien language, surprisingly they also use english lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.</p>
<p>Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographicaly in this alien language.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: As &apos;h&apos; comes before &apos;l&apos; in this language, then the sequence is sorted.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: As &apos;d&apos; comes after &apos;l&apos; in this language, then words[0] &gt; words[1], hence the sequence is unsorted.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;apple&quot;,&quot;app&quot;], order = &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The first three characters &quot;app&quot; match, and the second string is shorter (in size.) According to lexicographical rules &quot;apple&quot; &gt; &quot;app&quot;, because &apos;l&apos; &gt; &apos;∅&apos;, where &apos;∅&apos; is defined as the blank character which is less than any other character (More info).</span><br></pre></td></tr></table></figure></p>
<p>从一个新的字母序判断是不是有序的字符串数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    bool isAlienSorted(vector&lt;string&gt;&amp; words, string order) &#123;</span><br><span class="line">        map&lt;char, int&gt; mp;</span><br><span class="line">        for(int i = 0; i &lt; order.length(); i ++)</span><br><span class="line">            mp[order[i]] = i;</span><br><span class="line">        int size = words.size();</span><br><span class="line">        for(int i = 0; i &lt; size-1; i ++) &#123;</span><br><span class="line">            int j = i + 1;</span><br><span class="line">            int min_size = min(words[i].length(), words[j].length());</span><br><span class="line">            int k;</span><br><span class="line">            for(k = 0; k &lt; min_size; k ++)</span><br><span class="line">                if(mp[words[i][k]] &gt; mp[words[j][k]])</span><br><span class="line">                    return false;</span><br><span class="line">                else if (mp[words[i][k]] &lt; mp[words[j][k]])</span><br><span class="line">                    break;</span><br><span class="line">	            if(k == min_size &amp;&amp; words[i].length() &gt; words[j].length())</span><br><span class="line">	                return false;</span><br><span class="line">	        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode958-Check-Completeness-of-a-Binary-Tree"><a href="#Leetcode958-Check-Completeness-of-a-Binary-Tree" class="headerlink" title="Leetcode958. Check Completeness of a Binary Tree"></a>Leetcode958. Check Completeness of a Binary Tree</h1><p>Given a binary tree, determine if it is a complete binary tree.</p>
<p>Definition of a complete binary tree from Wikipedia:<br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Every level before the last is full (ie. levels with node-values &#123;1&#125; and &#123;2, 3&#125;), and all nodes in the last level (&#123;4, 5, 6&#125;) are as far left as possible.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,null,7]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The node with value 7 isn&apos;t as far left as possible.</span><br></pre></td></tr></table></figure></p>
<p>用BFS遍历二叉树，当遇到空节点时，如果队列中还有未遍历的节点则该二叉树不完整。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Definition for a binary tree node.</span><br><span class="line">   * struct TreeNode &#123;</span><br><span class="line">   *     int val;</span><br><span class="line">   *     TreeNode *left;</span><br><span class="line">   *     TreeNode *right;</span><br><span class="line">   *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">   * &#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isCompleteTree(TreeNode* root) &#123;</span><br><span class="line">        if(root == NULL)</span><br><span class="line">            return true;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        TreeNode* temp;</span><br><span class="line">        bool res = true;</span><br><span class="line">        while(!q.empty()) &#123;</span><br><span class="line">            int size = q.size();</span><br><span class="line">            temp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            if(temp == NULL)</span><br><span class="line">                res = false;</span><br><span class="line">            else &#123;</span><br><span class="line">                if(!res)</span><br><span class="line">                    return false;</span><br><span class="line">                q.push(temp-&gt;left);</span><br><span class="line">                q.push(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode961-N-Repeated-Element-in-Size-2N-Array"><a href="#Leetcode961-N-Repeated-Element-in-Size-2N-Array" class="headerlink" title="Leetcode961. N-Repeated Element in Size 2N Array"></a>Leetcode961. N-Repeated Element in Size 2N Array</h1><p>In a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times.</p>
<p>Return the element repeated N times.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,2,5,3,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,1,5,2,5,3,5,4]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>4 &lt;= A.length &lt;= 10000<br>0 &lt;= A[i] &lt; 10000<br>A.length is even</p>
<p>一个桶排序搞定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int repeatedNTimes(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        int counter[10000];</span><br><span class="line">        memset(counter, 0, sizeof(counter));</span><br><span class="line">        for(int i = 0; i &lt; A.size(); i ++)&#123;</span><br><span class="line">            counter[A[i]] ++;</span><br><span class="line">            if(counter[A[i]] &gt;= A.size() / 2)</span><br><span class="line">                return A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>看到了大佬的解法，跪了，如果有两个连续一样的元素，直接返回</p>
<p>The intuition here is that the repeated numbers have to appear either next to each other (A[i] == A[i + 1]), or alternated (A[i] == A[i + 2]).</p>
<p>The only exception is sequences like [2, 1, 3, 2]. In this case, the result is the last number, so we just return it in the end. This solution has O(n) runtime.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int repeatedNTimes(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">  for (auto i = 0; i &lt; A.size() - 2; ++i)</span><br><span class="line">    if (A[i] == A[i + 1] || A[i] == A[i + 2]) return A[i];</span><br><span class="line">  return A[A.size() - 1]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Another interesting approach is to use randomization (courtesy of @lee215 ). If you pick two numbers randomly, there is a 25% chance you bump into the repeated number. So, in average, we will find the answer in 4 attempts, thus O(4) runtime.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int repeatedNTimes(vector&lt;int&gt;&amp; A, int i = 0, int j = 0) &#123;</span><br><span class="line">  while (A[i = rand() % A.size()] != A[j = rand() % A.size()] || i == j);</span><br><span class="line">  return A[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode965-Univalued-Binary-Tree"><a href="#Leetcode965-Univalued-Binary-Tree" class="headerlink" title="Leetcode965. Univalued Binary Tree"></a>Leetcode965. Univalued Binary Tree</h1><p>A binary tree is univalued if every node in the tree has the same value.</p>
<p>Return true if and only if the given tree is univalued.</p>
<p>Example 1:<br><img src="/img/20190524001.png" alt><br>Input: [1,1,1,1,1,null,1]<br>Output: true</p>
<p>Example 2:<br><img src="/img/20190524002.png" alt><br>Input: [2,2,2,5,2]<br>Output: false</p>
<p>Note:</p>
<p>The number of nodes in the given tree will be in the range [1, 100].<br>Each node’s value will be an integer in the range [0, 99].<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool des(TreeNode* root,int val)&#123;</span><br><span class="line">        if(root==NULL)</span><br><span class="line">            return true;</span><br><span class="line">        if(root-&gt;val != val)</span><br><span class="line">            return false;</span><br><span class="line">        return des(root-&gt;left,val)&amp;&amp;des(root-&gt;right,val);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    bool isUnivalTree(TreeNode* root) &#123;</span><br><span class="line">        if(root==NULL)</span><br><span class="line">            return true;</span><br><span class="line">        return des(root,root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode970-Powerful-Integers"><a href="#Leetcode970-Powerful-Integers" class="headerlink" title="Leetcode970. Powerful Integers"></a>Leetcode970. Powerful Integers</h1><p>Easy</p>
<p>130</p>
<p>272</p>
<p>Add to List</p>
<p>Share<br>Given two positive integers x and y, an integer is powerful if it is equal to x^i + y^j for some integers i &gt;= 0 and j &gt;= 0. Return a list of all powerful integers that have value less than or equal to bound.</p>
<p>You may return the answer in any order.  In your answer, each value should occur at most once.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: x = 2, y = 3, bound = 10</span><br><span class="line">Output: [2,3,4,5,7,9,10]</span><br><span class="line">Explanation: </span><br><span class="line">2 = 2^0 + 3^0</span><br><span class="line">3 = 2^1 + 3^0</span><br><span class="line">4 = 2^0 + 3^1</span><br><span class="line">5 = 2^1 + 3^1</span><br><span class="line">7 = 2^2 + 3^1</span><br><span class="line">9 = 2^3 + 3^0</span><br><span class="line">10 = 2^0 + 3^2</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x = 3, y = 5, bound = 15</span><br><span class="line">Output: [2,4,6,8,10,14]</span><br></pre></td></tr></table></figure></p>
<p>方法很简单，如果x/y等于1，那么幂值只会是1；如果x/y 大于1，由于 bound &lt;= 10^6，幂的最大值是20(pow(2,20) &gt; 10^6)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    vector&lt;int&gt; powerfulIntegers(int x, int y, int bound) &#123;</span><br><span class="line">        set&lt;int&gt; res;</span><br><span class="line">        long temp;</span><br><span class="line">        int x_max = x &gt; 1 ? 20 : 1;</span><br><span class="line">        int y_max = y &gt; 1 ? 20 : 1;</span><br><span class="line">        for(int i = 0 ; i &lt; x_max &amp;&amp; pow(x, i) &lt;= bound; i ++)</span><br><span class="line">            for(int j = 0 ; j &lt; y_max &amp;&amp; pow(y, j) &lt;= bound; j ++) &#123;</span><br><span class="line">                temp = pow(x, i) + pow(y, j);</span><br><span class="line">                if(temp &lt;= bound) </span><br><span class="line">                    res.insert(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        return vector&lt;int&gt;(res.begin(), res.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode971-Flip-Binary-Tree-To-Match-Preorder-Traversal"><a href="#Leetcode971-Flip-Binary-Tree-To-Match-Preorder-Traversal" class="headerlink" title="Leetcode971. Flip Binary Tree To Match Preorder Traversal"></a>Leetcode971. Flip Binary Tree To Match Preorder Traversal</h1><p>Given a binary tree with N nodes, each node has a different value from {1, …, N}.</p>
<p>A node in this binary tree can be flipped by swapping the left child and the right child of that node.</p>
<p>Consider the sequence of N values reported by a preorder traversal starting from the root.  Call such a sequence of N values the voyage of the tree.</p>
<p>(Recall that a preorder traversal of a node means we report the current node’s value, then preorder-traverse the left child, then preorder-traverse the right child.)</p>
<p>Our goal is to flip the least number of nodes in the tree so that the voyage of the tree matches the voyage we are given.</p>
<p>If we can do so, then return a list of the values of all nodes flipped.  You may return the answer in any order.</p>
<p>If we cannot do so, then return the list [-1].</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2], voyage = [2,1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3], voyage = [1,3,2]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3], voyage = [1,2,3]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure></p>
<p>最少翻转哪些节点，能使得二叉树的前序遍历变成voyage.</p>
<p>其实这个题不难，因为题目就说了是前序遍历，所以做法肯定还是前序遍历。我刚开始一直想不通的地方在于，题目又是返回[-1]，又是正常返回，没想好怎么做区分。其实做法就是递归函数不仅要修改res数组，还要返回表示能不能构成题目条件的bool变量。</p>
<p>看到二叉树的题，很大可能就需要递归，所以直接先写出dfs函数，然后再慢慢向里面填东西。</p>
<p>我们定义的dfs函数意义是，我们能不能通过翻转（或者不翻转）该root节点的左右子树，得到对应v。如果能，返回true，否则返回false。</p>
<p>首先在递归函数中，我们对root节点进行判断，如果root不存在，这种情况不应该认为是题目输入错误，而是应该认为已经遍历到最底部了，这个时候相当于root = [], voyage = []，所以返回true;在先序遍历的时候，root节点是第一个要被遍历到的节点，如果不和voyage[0]相等，直接返回false;</p>
<p>这个题目的难点在于是否需要翻转一个节点的左右孩子。判断的方法其实是简单的：如果voyage第二个元素等于root的左孩子，那么说明不用翻转，直接递归调用左右孩子；否则如果voyage的第二个元素等于root的右孩子，那么还要注意一下，在左孩子存在的情况下，我们需要翻转当前的节点左右孩子。</p>
<p>翻转是什么概念呢？这里并没有直接交换，而是把当前遍历到的位置使用遍历i保存起来，这样voyage[i]就表示当前遍历到哪个位置了。所以dfs调用两个孩子的顺序很讲究，它体现了先序遍历先解决哪个树的问题，也就是完成了逻辑上的交换左右孩子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    int i = 0;</span><br><span class="line">    vector&lt;int&gt; ans;</span><br><span class="line">    </span><br><span class="line">    bool dfs(TreeNode* root, vector&lt;int&gt;&amp; voyage) &#123;</span><br><span class="line">        if(!root) </span><br><span class="line">            return true;</span><br><span class="line">        if(root-&gt;val != voyage[i++])</span><br><span class="line">            return false;</span><br><span class="line">        if(root-&gt;left &amp;&amp; root-&gt;left-&gt;val == voyage[i])</span><br><span class="line">            return dfs(root-&gt;left, voyage) &amp;&amp; dfs(root-&gt;right, voyage);</span><br><span class="line">        else if(root-&gt;right &amp;&amp; root-&gt;right-&gt;val == voyage[i]) &#123;</span><br><span class="line">            if(root-&gt;left)</span><br><span class="line">                ans.push_back(root-&gt;val);</span><br><span class="line">            return dfs(root-&gt;right, voyage) &amp;&amp; dfs(root-&gt;left, voyage);</span><br><span class="line">        &#125;</span><br><span class="line">        return !root-&gt;left &amp;&amp; !root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; flipMatchVoyage(TreeNode* root, vector&lt;int&gt;&amp; voyage) &#123;</span><br><span class="line">        if(dfs(root, voyage))</span><br><span class="line">            return ans;</span><br><span class="line">        return &#123;-1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode976-Largest-Perimeter-Triangle"><a href="#Leetcode976-Largest-Perimeter-Triangle" class="headerlink" title="Leetcode976. Largest Perimeter Triangle"></a>Leetcode976. Largest Perimeter Triangle</h1><p>Given an array A of positive lengths, return the largest perimeter of a triangle with non-zero area, formed from 3 of these lengths.</p>
<p>If it is impossible to form any triangle of non-zero area, return 0.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,2]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,3,4]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,6,2,3]</span><br><span class="line">Output: 8</span><br></pre></td></tr></table></figure></p>
<p>三角形的条件：两边之和&gt;第三边。</p>
<p>若要构成最大的三角形周长，只需要对数组排序，一直取出最大的三个值作为三角形的边，符合条件即可返回。</p>
<p>证明：若数组A为自然顺序，A[N]&gt;=A[N-1]+A[N-2]，则A[N]&gt;=A[N-1]+A[N-3]，A[N]与后面的数字更不可能构成三角形，可以直接排除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    int largestPerimeter(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        sort(A.begin(), A.end());</span><br><span class="line">        for(int i = A.size() - 1; i &gt;= 2; i --) &#123;</span><br><span class="line">            if(A[i - 2] + A[i - 1] &gt; A[i])</span><br><span class="line">                return A[i - 2] + A[i - 1] + A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode977-Squares-of-a-Sorted-Array"><a href="#Leetcode977-Squares-of-a-Sorted-Array" class="headerlink" title="Leetcode977. Squares of a Sorted Array"></a>Leetcode977. Squares of a Sorted Array</h1><p>Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [-4,-1,0,3,10]</span><br><span class="line">Output: [0,1,9,16,100]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [-7,-3,2,3,11]</span><br><span class="line">Output: [4,9,9,49,121]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= A.length &lt;= 10000<br>-10000 &lt;= A[i] &lt;= 10000<br>A is sorted in non-decreasing order.</p>
<p>给一个vector，有正有负，输出排序之后的平方数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        vector&lt;int&gt; res(A.size());</span><br><span class="line">        int l = 0,r = A.size()-1, p = A.size() - 1;</span><br><span class="line">        while(l&lt;=r)&#123;</span><br><span class="line">            res[p--]=pow(A[abs(A[l])&gt;abs(A[r])?l++:r--],2);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>另一种方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        vector&lt;int&gt; res(A.size());</span><br><span class="line">        int i=0,j=0,k=0;</span><br><span class="line">        while(i&lt;A.size() &amp;&amp; A[i]&lt;0)</span><br><span class="line">            i++;</span><br><span class="line">        j=i-1;</span><br><span class="line">        while(j&gt;=0 &amp;&amp; i&lt;A.size())&#123;</span><br><span class="line">            res[k++] = pow(A[abs(A[i])&lt;abs(A[j])?i++:j--],2);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(j&gt;=0)</span><br><span class="line">            res[k++]=pow(A[j--],2);</span><br><span class="line">        while(i&lt;A.size())</span><br><span class="line">            res[k++]=pow(A[i++],2);</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode978-Longest-Turbulent-Subarray"><a href="#Leetcode978-Longest-Turbulent-Subarray" class="headerlink" title="Leetcode978. Longest Turbulent Subarray"></a>Leetcode978. Longest Turbulent Subarray</h1><p>A subarray A[i], A[i+1], …, A[j] of A is said to be turbulent if and only if:</p>
<p>For i &lt;= k &lt; j, A[k] &gt; A[k+1] when k is odd, and A[k] &lt; A[k+1] when k is even;<br>OR, for i &lt;= k &lt; j, A[k] &gt; A[k+1] when k is even, and A[k] &lt; A[k+1] when k is odd.<br>That is, the subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.</p>
<p>Return the length of a maximum size turbulent subarray of A.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [9,4,2,10,7,8,8,1,9]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: (A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; A[5])</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,8,12,16]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [100]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>隐藏很深的dp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    int maxTurbulenceSize(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        int sizee = A.size();</span><br><span class="line">        int res = 1;</span><br><span class="line">        vector&lt;int&gt; up(sizee, 1);</span><br><span class="line">        vector&lt;int&gt; down(sizee, 1);</span><br><span class="line">        </span><br><span class="line">        for(int i = 1; i &lt; sizee; i ++) &#123;</span><br><span class="line">            if(A[i] &gt; A[i - 1])</span><br><span class="line">                up[i] = down[i - 1] + 1;</span><br><span class="line">            if(A[i] &lt; A[i - 1])</span><br><span class="line">                down[i] = up[i - 1] + 1;</span><br><span class="line">            res = max(res, max(up[i], down[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>首先预处理一下，记录数组中数字变化趋势，1增加-1减少0不变，然后得到一个新的数组，为了省空间我直接在原来数组进行操作的，也可以开辟个新的数组。然后比较相邻数变化即可，若相邻数字乘积为负，则说明满足湍流数组性质，累加记录其长度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    int maxTurbulenceSize(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        int sizee = A.size();</span><br><span class="line">        int res = 0;</span><br><span class="line">        int count = 2;</span><br><span class="line">        for(int i = 1; i &lt; sizee; i ++) &#123;</span><br><span class="line">            if(A[i] &gt; A[i - 1])</span><br><span class="line">                A[i-1] = 1;</span><br><span class="line">            else if(A[i] &lt; A[i + 1])</span><br><span class="line">                A[i-1] = -1;</span><br><span class="line">            else </span><br><span class="line">                A[i-1] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt; sizee - 1; i ++) &#123;</span><br><span class="line">            while(i &lt; sizee - 1 &amp;&amp; A[i] * A[i-1] &lt; 0) &#123;</span><br><span class="line">                count ++;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, count);</span><br><span class="line">            count = 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode979-Distribute-Coins-in-Binary-Tree"><a href="#Leetcode979-Distribute-Coins-in-Binary-Tree" class="headerlink" title="Leetcode979. Distribute Coins in Binary Tree"></a>Leetcode979. Distribute Coins in Binary Tree</h1><p>Given the root of a binary tree with N nodes, each node in the tree has node.val coins, and there are N coins total.</p>
<p>In one move, we may choose two adjacent nodes and move one coin from one node to another.  (The move may be from parent to child, or from child to parent.)</p>
<p>Return the number of moves required to make every node have exactly one coin.</p>
<p>Example 1:<br><img src="/img/20190824002.png" alt></p>
<p>Input: [3,0,0]<br>Output: 2<br>Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.</p>
<p>Example 2:<br><img src="/img/20190824003.png" alt></p>
<p>Input: [0,3,0]<br>Output: 3<br>Explanation: From the left child of the root, we move two coins to the root [taking two moves].  Then, we move one coin from the root of the tree to the right child.</p>
<p>Example 3:<br><img src="/img/20190824004.png" alt></p>
<p>Input: [1,0,2]<br>Output: 2</p>
<p>Example 4:<br><img src="/img/20190824005.png" alt></p>
<p>Input: [1,0,0,null,3]<br>Output: 4</p>
<p>Note:</p>
<p>1&lt;= N &lt;= 100<br>0 &lt;= node.val &lt;= N</p>
<p>给你一个二叉树，对于每个节点的val，每次只能往父亲或者儿子移动1，最后使得所有节点值都为1，求最小的移动次数。</p>
<p>思路：从叶子到根寻找，对于每个节点，只能剩下一个。多了的值肯定要全给父亲，少的值全问父亲要，统计一下就好了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Definition for a binary tree node.</span><br><span class="line">   * struct TreeNode &#123;</span><br><span class="line">   *     int val;</span><br><span class="line">   *     TreeNode *left;</span><br><span class="line">   *     TreeNode *right;</span><br><span class="line">   *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">   * &#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    int ans=0;</span><br><span class="line">    int distributeCoins(TreeNode* root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    int dfs(TreeNode* root)&#123;</span><br><span class="line">        if(root==NULL)</span><br><span class="line">            return 0;</span><br><span class="line">        int left = dfs(root-&gt;left);</span><br><span class="line">        int right = dfs(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        ans += abs(left) + abs(right);</span><br><span class="line">        return root-&gt;val -1 + left + right ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode980-Unique-Paths-III"><a href="#Leetcode980-Unique-Paths-III" class="headerlink" title="Leetcode980. Unique Paths III"></a>Leetcode980. Unique Paths III</h1><p>On a 2-dimensional grid, there are 4 types of squares:</p>
<p><code>1</code> represents the starting square.  There is exactly one starting square.<br><code>2</code> represents the ending square.  There is exactly one ending square.<br><code>0</code> represents empty squares we can walk over.<br><code>-1</code> represents obstacles that we cannot walk over.<br>Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We have the following two paths: </span><br><span class="line">1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)</span><br><span class="line">2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,0,0,0],[0,0,0,0],[0,0,0,2]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: We have the following four paths: </span><br><span class="line">1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)</span><br><span class="line">2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)</span><br><span class="line">3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)</span><br><span class="line">4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,1],[2,0]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: </span><br><span class="line">There is no path that walks over every empty square exactly once.</span><br><span class="line">Note that the starting and ending square can be anywhere in the grid.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= grid.length * grid[0].length &lt;= 20</p>
<p>给了一个二维矩阵，1代表起点，2代表终点，0代表可以走的格子，-1代表障碍物。求从起点到终点，把所有的可以走的格子都遍历一遍，所有可能的不同路径数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; dirs = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">    int uniquePathsIII(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int M=grid.size();</span><br><span class="line">        int zerosize=0,res=0;</span><br><span class="line">        int N=grid[0].size();</span><br><span class="line">        for(int i=0;i&lt;M;i++)</span><br><span class="line">            for(int j=0;j&lt;N;j++)</span><br><span class="line">                if(grid[i][j]==0)</span><br><span class="line">                    zerosize++;</span><br><span class="line">        for(int i=0;i&lt;M;i++)</span><br><span class="line">            for(int j=0;j&lt;N;j++)</span><br><span class="line">                if(grid[i][j]==1)</span><br><span class="line">                    dfs(grid,i,j,0,zerosize,res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, int pathcount, int zerocount, int&amp; res)&#123;</span><br><span class="line">        if(grid[x][y]==2 &amp;&amp; zerocount == pathcount )&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        int M=grid.size();</span><br><span class="line">        int N=grid[0].size();</span><br><span class="line">        </span><br><span class="line">        int pre=grid[x][y];</span><br><span class="line">        if(pre==0)</span><br><span class="line">            pathcount++;</span><br><span class="line">        grid[x][y]=-1;</span><br><span class="line">        for (auto d : dirs) &#123;</span><br><span class="line">            int nx = x + d.first;</span><br><span class="line">            int ny = y + d.second;</span><br><span class="line">            if (nx &lt; 0 || nx &gt;= M || ny &lt; 0 || ny &gt;= N || grid[nx][ny] == -1)</span><br><span class="line">                continue;</span><br><span class="line">            dfs(grid, nx, ny, pathcount, zerocount, res);</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y]=pre;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode981-Time-Based-Key-Value-Store"><a href="#Leetcode981-Time-Based-Key-Value-Store" class="headerlink" title="Leetcode981. Time Based Key-Value Store"></a>Leetcode981. Time Based Key-Value Store</h1><p>Create a timebased key-value store class TimeMap, that supports two operations.</p>
<ul>
<li>set(string key, string value, int timestamp):Stores the key and value, along with the given timestamp.</li>
<li>get(string key, int timestamp)<ul>
<li>Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev &lt;= timestamp.</li>
<li>If there are multiple such values, it returns the one with the largest timestamp_prev.</li>
<li>If there are no values, it returns the empty string (“”).</li>
</ul>
</li>
</ul>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: inputs = [&quot;TimeMap&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;], inputs = [[],[&quot;foo&quot;,&quot;bar&quot;,1],[&quot;foo&quot;,1],[&quot;foo&quot;,3],[&quot;foo&quot;,&quot;bar2&quot;,4],[&quot;foo&quot;,4],[&quot;foo&quot;,5]]</span><br><span class="line">Output: [null,null,&quot;bar&quot;,&quot;bar&quot;,null,&quot;bar2&quot;,&quot;bar2&quot;]</span><br><span class="line">Explanation:   </span><br><span class="line">TimeMap kv;   </span><br><span class="line">kv.set(&quot;foo&quot;, &quot;bar&quot;, 1); // store the key &quot;foo&quot; and value &quot;bar&quot; along with timestamp = 1   </span><br><span class="line">kv.get(&quot;foo&quot;, 1);  // output &quot;bar&quot;   </span><br><span class="line">kv.get(&quot;foo&quot;, 3); // output &quot;bar&quot; since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 ie &quot;bar&quot;   </span><br><span class="line">kv.set(&quot;foo&quot;, &quot;bar2&quot;, 4);   </span><br><span class="line">kv.get(&quot;foo&quot;, 4); // output &quot;bar2&quot;   </span><br><span class="line">kv.get(&quot;foo&quot;, 5); //output &quot;bar2&quot;</span><br></pre></td></tr></table></figure></p>
<p>这个题太麻烦了，没有耐心做了，只看了看，本来想用很好的方法，比如二分实现一下，但是发现这种简单粗暴的方法竟然也能过，就算了……<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class TimeMap &#123;</span><br><span class="line">private:</span><br><span class="line">  unordered_map&lt;string, map&lt;int, string&gt;&gt; mp;</span><br><span class="line">  vector&lt;int&gt; tvec;</span><br><span class="line">public:</span><br><span class="line">  /** Initialize your data structure here. */</span><br><span class="line">  TimeMap() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  void set(string key, string value, int timestamp) &#123;</span><br><span class="line">      mp[key][timestamp] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	string get(string key, int timestamp) &#123;</span><br><span class="line">		if(!mp.count(key)) </span><br><span class="line">			return &quot;&quot;;</span><br><span class="line">		if(mp[key].count(timestamp)) </span><br><span class="line">			return mp[key][timestamp];</span><br><span class="line">    	for(auto it = mp[key].rbegin(); it != mp[key].rend(); it++) &#123;</span><br><span class="line">    		if(it-&gt;first &gt; timestamp) </span><br><span class="line">				continue;</span><br><span class="line">        	else </span><br><span class="line">				return it-&gt;second;</span><br><span class="line">		&#125;</span><br><span class="line">    return &quot;&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode983-Minimum-Cost-For-Tickets"><a href="#Leetcode983-Minimum-Cost-For-Tickets" class="headerlink" title="Leetcode983. Minimum Cost For Tickets"></a>Leetcode983. Minimum Cost For Tickets</h1><p>In a country popular for train travel, you have planned some train travelling one year in advance.  The days of the year that you will travel is given as an array days.  Each day is an integer from 1 to 365.</p>
<p>Train tickets are sold in 3 different ways:</p>
<ul>
<li>a 1-day pass is sold for costs[0] dollars;</li>
<li>a 7-day pass is sold for costs[1] dollars;</li>
<li>a 30-day pass is sold for costs[2] dollars.</li>
</ul>
<p>The passes allow that many days of consecutive travel.  For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8.</p>
<p>Return the minimum number of dollars you need to travel every day in the given list of days. </p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: days = [1,4,6,7,8,20], costs = [2,7,15]</span><br><span class="line">Output: 11</span><br><span class="line">Explanation: </span><br><span class="line">For example, here is one way to buy passes that lets you travel your travel plan:</span><br><span class="line">On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.</span><br><span class="line">On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.</span><br><span class="line">On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.</span><br><span class="line">In total you spent $11 and covered all the days of your travel.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]</span><br><span class="line">Output: 17</span><br><span class="line">Explanation: </span><br><span class="line">For example, here is one way to buy passes that lets you travel your travel plan:</span><br><span class="line">On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.</span><br><span class="line">On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.</span><br><span class="line">In total you spent $17 and covered all the days of your travel.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= days.length &lt;= 365</li>
<li>1 &lt;= days[i] &lt;= 365</li>
<li>days is in strictly increasing order.</li>
<li>costs.length == 3</li>
<li>1 &lt;= costs[i] &lt;= 1000</li>
</ul>
<p>days数组中存储的是该年中去旅游的日期（范围为1到365之间的数字），costs数组大小为3，存储的是1天，7天和30天火车票的价格。我们需要做一个方案选择合适的购票方案达到旅游days天最省钱的目的。</p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>采用动态规划进行解决，假设现在是第days[i]天，我们在该天出行旅游需要选择买票方案，现在我们有三种方案：第一，购买一天的通行票，当天出行，花费就是第days[i-1]天的花费加上一天的通行票价；第二，购买七天的通行票，而七天的通行票可以在连续的七天之内使用，所以花费是第days[i-7]天的花费加上七天的通行票价（即从第days[i-8]天到days[i]天的花费都包含在这七天的通行票中）；第三，购买三十天的通行票，同理，花费是days[i-30]天加上三十天的通行票价。然后我们在这三种方案中选择最实惠的。最后，在实现代码中注意数组越界的问题。</p>
<p>使用dp[j]代表着我们旅行到i天为止需要的最少旅行价格，递推公式为：</p>
<ul>
<li>dp[j] = dp[j-1] （第j天不用旅行）</li>
<li>dp[j] = min(dp[j-1] + costs[0], dp[j-7] + costs[1], dp[j-30] + costs[2]) （第j天需要旅行）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    int mincostTickets(vector&lt;int&gt;&amp; days, vector&lt;int&gt;&amp; costs) &#123;</span><br><span class="line">        if(days.size() == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        int dp[366] = &#123;0&#125;;</span><br><span class="line">        for(int i = 1; i &lt; 366; i ++) &#123;</span><br><span class="line">            if(find(days.begin(), days.end(), i) == days.end() )</span><br><span class="line">                dp[i] = dp[i - 1];</span><br><span class="line">            else &#123;</span><br><span class="line">                dp[i] = min(dp[i-1] + costs[0], min(dp[max(0, i-7)]+costs[1], dp[max(0, i-30)]+costs[2]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[365];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode984-String-Without-AAA-or-BBB"><a href="#Leetcode984-String-Without-AAA-or-BBB" class="headerlink" title="Leetcode984. String Without AAA or BBB"></a>Leetcode984. String Without AAA or BBB</h1><p>Given two integers A and B, return any string S such that:</p>
<ul>
<li>S has length A + B and contains exactly A ‘a’ letters, and exactly B ‘b’ letters;</li>
<li>The substring ‘aaa’ does not occur in S;</li>
<li>The substring ‘bbb’ does not occur in S.</li>
</ul>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = 1, B = 2</span><br><span class="line">Output: &quot;abb&quot;</span><br><span class="line">Explanation: &quot;abb&quot;, &quot;bab&quot; and &quot;bba&quot; are all correct answers.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = 4, B = 1</span><br><span class="line">Output: &quot;aabaa&quot;</span><br></pre></td></tr></table></figure></p>
<p>使用贪心，先选较多的然后再选较少的字母。主要是看两个字母哪个比较多，较多的哪个放到A上，然后判断A和B是否大于0，或者A是否大于B。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    string strWithout3a3b(int A, int B) &#123;</span><br><span class="line">        char a = &apos;a&apos;, b = &apos;b&apos;;</span><br><span class="line">        int temp2;</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        if(A &lt; B) &#123;</span><br><span class="line">            a = &apos;b&apos;;</span><br><span class="line">            b = &apos;a&apos;;</span><br><span class="line">            temp2 = A;</span><br><span class="line">            A = B;</span><br><span class="line">            B = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        while(A&gt;0 || B&gt;0) &#123;</span><br><span class="line">            if(A &gt; 0) &#123;</span><br><span class="line">                res += a;</span><br><span class="line">                A --;</span><br><span class="line">            &#125;</span><br><span class="line">            if(A &gt; B) &#123;</span><br><span class="line">                res += a;</span><br><span class="line">                A --;</span><br><span class="line">            &#125;</span><br><span class="line">            if(B &gt; 0) &#123;</span><br><span class="line">                res += b;</span><br><span class="line">                B --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode985-Sum-of-Even-Numbers-After-Queries"><a href="#Leetcode985-Sum-of-Even-Numbers-After-Queries" class="headerlink" title="Leetcode985. Sum of Even Numbers After Queries"></a>Leetcode985. Sum of Even Numbers After Queries</h1><p>We have an array A of integers, and an array queries of queries.</p>
<p>For the i-th query val = queries[i][0], index = queries[i][1], we add val to A[index].  Then, the answer to the i-th query is the sum of the even values of A.</p>
<p>(Here, the given index = queries[i][1] is a 0-based index, and each query permanently modifies the array A.)</p>
<p>Return the answer to all queries.  Your answer array should have answer[i] as the answer to the i-th query.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]</span><br><span class="line">Output: [8,6,2,4]</span><br><span class="line">Explanation: </span><br><span class="line">	At the beginning, the array is [1,2,3,4].</span><br><span class="line">	After adding 1 to A[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.</span><br><span class="line">	After adding -3 to A[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.</span><br><span class="line">	After adding -4 to A[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.</span><br><span class="line">	After adding 2 to A[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4.</span><br></pre></td></tr></table></figure></p>
<p>题意比较曲折，就是在queries中的每个pair，某个位置加上一个数，在计算A数组中所有偶数的和。下边的代码会超时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    vector&lt;int&gt; sumEvenAfterQueries(vector&lt;int&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        int size = queries.size(), val, index, sum;</span><br><span class="line">        for(int i = 0; i &lt; size; i ++) &#123;</span><br><span class="line">            sum = 0;</span><br><span class="line">            val = queries[i][0];</span><br><span class="line">            index = queries[i][1];</span><br><span class="line">            A[index] += val;</span><br><span class="line">            for(int j = 0; j &lt; A.size(); j ++)</span><br><span class="line">                sum += (A[j]%2 ? 0 : A[j]);</span><br><span class="line">            res.push_back(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>应首先计算出所有的偶数和，再根据运算之后的结果进行计算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    vector&lt;int&gt; sumEvenAfterQueries(vector&lt;int&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        int size = queries.size(), val, index, sum = 0;</span><br><span class="line">        for(int i = 0; i &lt; A.size(); i ++)</span><br><span class="line">            sum += (A[i]%2 ? 0 : A[i]);</span><br><span class="line">        for(int i = 0; i &lt; size; i ++) &#123;</span><br><span class="line">            val = queries[i][0];</span><br><span class="line">            index = queries[i][1];</span><br><span class="line">            if(A[index]%2 == 0)</span><br><span class="line">                sum -= A[index];</span><br><span class="line">            A[index] += val;</span><br><span class="line">            if(A[index]%2 == 0)</span><br><span class="line">                sum += A[index];</span><br><span class="line">            res.push_back(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode986-Interval-List-Intersections"><a href="#Leetcode986-Interval-List-Intersections" class="headerlink" title="Leetcode986. Interval List Intersections"></a>Leetcode986. Interval List Intersections</h1><p>Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order.</p>
<p>Return the intersection of these two interval lists.</p>
<p>(Formally, a closed interval [a, b] (with a &lt;= b) denotes the set of real numbers x with a &lt;= x &lt;= b.  The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval.  For example, the intersection of [1, 3] and [2, 4] is [2, 3].)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; intervalIntersection(vector&lt;vector&lt;int&gt;&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; B) &#123;</span><br><span class="line">        if(A.size() == 0 || B.size() == 0)</span><br><span class="line">            return vector&lt;vector&lt;int&gt;&gt;&#123;&#125;;</span><br><span class="line">        int sizea = A.size(), sizeb = B.size();</span><br><span class="line">        int l, r;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for(int i = 0, j = 0; i &lt; sizea &amp;&amp; j &lt; sizeb;) &#123;</span><br><span class="line">            l = max(A[i][0], B[j][0]);</span><br><span class="line">            r = min(A[i][1], B[j][1]);</span><br><span class="line">            if(l &lt;= r) </span><br><span class="line">                res.push_back(&#123;l, r&#125;);</span><br><span class="line">            if(r == A[i][1])</span><br><span class="line">                i ++;</span><br><span class="line">            else j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>贪心，由于排好序了，直接双指针扫，思路和归并排序合并比较类似，注意往后移动的条件是尾部，因为一个矩形的结束条件是尾部比完了，不能写成是头部</p>
<h1 id="Leetcode987-Vertical-Order-Traversal-of-a-Binary-Tree"><a href="#Leetcode987-Vertical-Order-Traversal-of-a-Binary-Tree" class="headerlink" title="Leetcode987. Vertical Order Traversal of a Binary Tree"></a>Leetcode987. Vertical Order Traversal of a Binary Tree</h1><p>Given a binary tree, return the vertical order traversal of its nodes values.</p>
<p>For each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1).</p>
<p>Running a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates).</p>
<p>If two nodes have the same position, then the value of the node that is reported first is the value that is smaller.</p>
<p>Return an list of non-empty reports in order of X coordinate.  Every report will have a list of values of nodes.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[9],[3,15],[20],[7]]</span><br><span class="line">Explanation: </span><br><span class="line">Without loss of generality, we can assume the root node is at position (0, 0):</span><br><span class="line">Then, the node with value 9 occurs at position (-1, -1);</span><br><span class="line">The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2);</span><br><span class="line">The node with value 20 occurs at position (1, -1);</span><br><span class="line">The node with value 7 occurs at position (2, -2).</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6,7]</span><br><span class="line">Output: [[4],[2],[1,5,6],[3],[7]]</span><br><span class="line">Explanation: </span><br><span class="line">The node with value 5 and the node with value 6 have the same position according to the given scheme.</span><br><span class="line">However, in the report &quot;[1,5,6]&quot;, the node value of 5 comes first since 5 is smaller than 6.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>The tree will have between 1 and 1000 nodes.</li>
<li>Each node s value will be between 0 and 1000.</li>
</ul>
<p>要求把相同X的节点位置放在一起，并且要求结果中节点的存放是从上到下的。如果两个节点的坐标相同，那么value小的节点排列在前面。通过维护一个队列，我们从上到下依次遍历每个节点，给每个节点设置好了坐标。这个队列存储的是个三元组（TreeNode*,int x,int y）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Definition for a binary tree node.</span><br><span class="line">   * struct TreeNode &#123;</span><br><span class="line">   *     int val;</span><br><span class="line">   *     TreeNode *left;</span><br><span class="line">   *     TreeNode *right;</span><br><span class="line">   *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="line">   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="line">   * &#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    struct dat&#123;</span><br><span class="line">        TreeNode* root;</span><br><span class="line">        int x, y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; verticalTraversal(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;struct dat&gt; q;</span><br><span class="line">        struct dat te = &#123;root, 0, 0&#125;;</span><br><span class="line">        q.push(te);</span><br><span class="line">        map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; node;</span><br><span class="line">        while(!q.empty()) &#123;</span><br><span class="line">            struct dat temp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            node[temp.x].push_back(make_pair(-temp.y, temp.root-&gt;val));</span><br><span class="line">            if(temp.root-&gt;left)</span><br><span class="line">                q.push(&#123;temp.root-&gt;left, temp.x - 1, temp.y - 1&#125;);</span><br><span class="line">            if(temp.root-&gt;right)</span><br><span class="line">                q.push(&#123;temp.root-&gt;right, temp.x + 1, temp.y - 1&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for(auto it : node) &#123;</span><br><span class="line">            sort(it.second.begin(), it.second.end());</span><br><span class="line">            vector&lt;int&gt; tempp;</span><br><span class="line">            for(auto i : it.second)</span><br><span class="line">                tempp.push_back(i.second);</span><br><span class="line">            res.push_back(tempp);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode988-Smallest-String-Starting-From-Leaf"><a href="#Leetcode988-Smallest-String-Starting-From-Leaf" class="headerlink" title="Leetcode988. Smallest String Starting From Leaf"></a>Leetcode988. Smallest String Starting From Leaf</h1><p>Given the root of a binary tree, each node has a value from 0 to 25 representing the letters ‘a’ to ‘z’: a value of 0 represents ‘a’, a value of 1 represents ‘b’, and so on.</p>
<p>Find the lexicographically smallest string that starts at a leaf of this tree and ends at the root.</p>
<p>(As a reminder, any shorter prefix of a string is lexicographically smaller: for example, “ab” is lexicographically smaller than “aba”.  A leaf of a node is a node that has no children.)</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,2,3,4,3,4]</span><br><span class="line">Output: &quot;dba&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [25,1,3,1,3,0,2]</span><br><span class="line">Output: &quot;adz&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,1,null,1,0,null,0]</span><br><span class="line">Output: &quot;abc&quot;</span><br></pre></td></tr></table></figure></p>
<p>这个数组代表一个树，图就不上了，从叶子节点开始找到一个最小的字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Definition for a binary tree node.</span><br><span class="line">   * struct TreeNode &#123;</span><br><span class="line">   *     int val;</span><br><span class="line">   *     TreeNode *left;</span><br><span class="line">   *     TreeNode *right;</span><br><span class="line">   *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">   * &#125;;</span><br><span class="line">   */</span><br><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    </span><br><span class="line">    string result = &quot;zzzzzzzzzz&quot;;</span><br><span class="line">    void bianli(TreeNode* root, string cur) &#123;</span><br><span class="line">        if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) &#123;</span><br><span class="line">            cur = (char)((root-&gt;val) + &apos;a&apos;)+cur;</span><br><span class="line">            result = result &lt; cur ? result : cur;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;left != NULL) &#123;</span><br><span class="line">            bianli(root-&gt;left, (char)(root-&gt;val+&apos;a&apos;)+cur);</span><br><span class="line">        &#125;</span><br><span class="line">        if(root-&gt;right != NULL) &#123;</span><br><span class="line">            bianli(root-&gt;right, (char)(root-&gt;val+&apos;a&apos;)+cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string smallestFromLeaf(TreeNode* root) &#123;</span><br><span class="line">        bianli(root, &quot;&quot;);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode989-Add-to-Array-Form-of-Integer"><a href="#Leetcode989-Add-to-Array-Form-of-Integer" class="headerlink" title="Leetcode989. Add to Array-Form of Integer"></a>Leetcode989. Add to Array-Form of Integer</h1><p>For a non-negative integer X, the array-form of X is an array of its digits in left to right order.  For example, if X = 1231, then the array form is [1,2,3,1].</p>
<p>Given the array-form A of a non-negative integer X, return the array-form of the integer X+K.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2,0,0], K = 34</span><br><span class="line">Output: [1,2,3,4]</span><br><span class="line">Explanation: 1200 + 34 = 1234</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2,7,4], K = 181</span><br><span class="line">Output: [4,5,5]</span><br><span class="line">Explanation: 274 + 181 = 455</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2,1,5], K = 806</span><br><span class="line">Output: [1,0,2,1]</span><br><span class="line">Explanation: 215 + 806 = 1021</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [9,9,9,9,9,9,9,9,9,9], K = 1</span><br><span class="line">Output: [1,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">Explanation: 9999999999 + 1 = 10000000000</span><br></pre></td></tr></table></figure></p>
<p>Note：</p>
<ul>
<li>1 &lt;= A.length &lt;= 10000</li>
<li>0 &lt;= A[i] &lt;= 9</li>
<li>0 &lt;= K &lt;= 10000</li>
<li>If A.length &gt; 1, then A[0] != 0</li>
</ul>
<p>大概意思是一个数组代表一个数，再给一个整数K，返回结果的各位数组成的数组，注意进位，我的做法很麻烦，需要两次反转。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; addToArrayForm(vector&lt;int&gt;&amp; A, int K) &#123;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        int L=K;</span><br><span class="line">        reverse(A.begin(), A.end());</span><br><span class="line">        for(int i = 0; i &lt; A.size(); i++)&#123;</span><br><span class="line">            A[i] = A[i] + L;</span><br><span class="line">            L = A[i]/10;</span><br><span class="line">            A[i]=A[i]%10;</span><br><span class="line">        &#125;</span><br><span class="line">        while(L&gt;0) &#123;</span><br><span class="line">            A.push_back(L%10);</span><br><span class="line">            L = L/10;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(A.begin(), A.end());</span><br><span class="line">        return A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从数组最右边开始，逐位相加，用carry记录进位，每一次取和的最右一位存入链表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;Integer&gt; addToArrayForm(int[] A, int K) &#123;</span><br><span class="line">        int len = A.length;</span><br><span class="line">        int carry = 0;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        for(int i = len - 1; i &gt; -1; i--)&#123;</span><br><span class="line">            int sum = carry + A[i] + K % 10;</span><br><span class="line">            list.add(sum % 10);</span><br><span class="line">            carry = sum / 10;</span><br><span class="line">            K /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        carry += K;</span><br><span class="line">        while(carry != 0)&#123;</span><br><span class="line">            list.add(carry % 10);</span><br><span class="line">            carry /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode990-Satisfiability-of-Equality-Equations"><a href="#Leetcode990-Satisfiability-of-Equality-Equations" class="headerlink" title="Leetcode990. Satisfiability of Equality Equations"></a>Leetcode990. Satisfiability of Equality Equations</h1><p>Given an array equations of strings that represent relationships between variables, each string equations[i] has length 4 and takes one of two different forms: “a==b” or “a!=b”.  Here, a and b are lowercase letters (not necessarily different) that represent one-letter variable names.</p>
<p>Return true if and only if it is possible to assign integers to variable names so as to satisfy all the given equations.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a==b&quot;,&quot;b!=a&quot;]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.  There is no way to assign the variables to satisfy both equations.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;b==a&quot;,&quot;a==b&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We could assign a = 1 and b = 1 to satisfy both equations.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= equations.length &lt;= 500</li>
<li>equations[i].length == 4</li>
<li>equations[i][0] and equations[i][3] are lowercase letters</li>
<li>equations[i][1] is either ‘=’ or ‘!’</li>
<li>equations[i][2] is ‘=’</li>
</ul>
<p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：”a==b”或 “a!=b”。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p>
<p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。</p>
<p>这个问题一看就是并查集问题，所以直接使用并查集就过了。将所有相等的元素构成一个集合中，然后判断不相等的元素是不是相同根即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int arr[26];</span><br><span class="line">    int find(int x) &#123;</span><br><span class="line">        return arr[x]==x?x:find(arr[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    void uni(int x, int y) &#123;</span><br><span class="line">        arr[find(y)]=find(x);</span><br><span class="line">    &#125;</span><br><span class="line">    bool equationsPossible(vector&lt;string&gt;&amp; equations) &#123;</span><br><span class="line">        for(int i=0;i&lt;26;i++)</span><br><span class="line">            arr[i]=i;</span><br><span class="line">        for(int i=0;i&lt;equations.size();i++)&#123;</span><br><span class="line">            if(equations[i][1]==&apos;=&apos;) &#123;</span><br><span class="line">                uni(equations[i][0]-&apos;a&apos;, equations[i][3]-&apos;a&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i=0;i&lt;equations.size();i++)&#123; </span><br><span class="line">            if(equations[i][1]==&apos;!&apos; &amp;&amp; find(equations[i][0]-&apos;a&apos;)==find(equations[i][3]-&apos;a&apos;)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode993-Cousins-in-Binary-Tree"><a href="#Leetcode993-Cousins-in-Binary-Tree" class="headerlink" title="Leetcode993. Cousins in Binary Tree"></a>Leetcode993. Cousins in Binary Tree</h1><p>Easy</p>
<p>794</p>
<p>49</p>
<p>Add to List</p>
<p>Share<br>In a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1.</p>
<p>Two nodes of a binary tree are cousins if they have the same depth, but have different parents. We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree. Return true if and only if the nodes corresponding to the values x and y are cousins.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4], x = 4, y = 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,null,4,null,5], x = 5, y = 4</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,null,4], x = 2, y = 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>求解x，y的深度和父亲结点，如果深度一样，父亲结点不同，就是true；否则，就是false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    </span><br><span class="line">    TreeNode* dfs(TreeNode* root, int x, int depth, int &amp;level) &#123;</span><br><span class="line">        if(root == NULL)</span><br><span class="line">            return NULL;</span><br><span class="line">        if((root-&gt;left &amp;&amp; root-&gt;left-&gt;val == x) || (root-&gt;right &amp;&amp; root-&gt;right-&gt;val == x)) &#123;</span><br><span class="line">            level = depth;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *left = dfs(root-&gt;left, x, depth + 1, level);</span><br><span class="line">        if (left) </span><br><span class="line">            return left;</span><br><span class="line"></span><br><span class="line">        TreeNode *right = dfs(root-&gt;right, x, depth + 1, level);</span><br><span class="line">        if (right) </span><br><span class="line">            return right;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool isCousins(TreeNode* root, int x, int y) &#123;</span><br><span class="line">        int level_a, level_b;</span><br><span class="line">        TreeNode *xx = dfs(root, x, 0, level_a);</span><br><span class="line">        TreeNode *yy = dfs(root, y, 0, level_b);</span><br><span class="line">        if(xx != yy &amp;&amp; level_a == level_b)</span><br><span class="line">            return true;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode997-Find-the-Town-Judge"><a href="#Leetcode997-Find-the-Town-Judge" class="headerlink" title="Leetcode997. Find the Town Judge"></a>Leetcode997. Find the Town Judge</h1><p>In a town, there are N people labelled from 1 to N.  There is a rumor that one of these people is secretly the town judge.</p>
<p>If the town judge exists, then:</p>
<p>The town judge trusts nobody.<br>Everybody (except for the town judge) trusts the town judge.<br>There is exactly one person that satisfies properties 1 and 2.<br>You are given trust, an array of pairs trust[i] = [a, b] representing that the person labelled a trusts the person labelled b.</p>
<p>If the town judge exists and can be identified, return the label of the town judge.  Otherwise, return -1.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 2, trust = [[1,2]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, trust = [[1,3],[2,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, trust = [[1,3],[2,3],[3,1]]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, trust = [[1,2],[2,3]]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>在一个小镇里，按从 1 到 N 标记了 N 个人。传言称，这些人中有一个是小镇上的秘密法官。如果小镇的法官真的存在，那么：小镇的法官不相信任何人。每个人（除了小镇法官外）都信任小镇的法官。只有一个人同时满足属性 1 和属性 2 。给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示标记为 a 的人信任标记为 b 的人。如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 -1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    int findJudge(int N, vector&lt;vector&lt;int&gt;&gt;&amp; trust) &#123;</span><br><span class="line">        int in[1005] = &#123;0&#125;, out[1005] = &#123;0&#125;;</span><br><span class="line">        for(int i = 0; i &lt; trust.size(); i ++) &#123;</span><br><span class="line">            in[trust[i][1]] ++;</span><br><span class="line">            out[trust[i][0]] = -1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1; i &lt;= N; i ++) &#123;</span><br><span class="line">            if(out[i] == 0 &amp;&amp; in[i] == N - 1)</span><br><span class="line">                return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode999-Available-Captures-for-Rook"><a href="#Leetcode999-Available-Captures-for-Rook" class="headerlink" title="Leetcode999. Available Captures for Rook"></a>Leetcode999. Available Captures for Rook</h1><p>On an 8 x 8 chessboard, there is one white rook.  There also may be empty squares, white bishops, and black pawns.  These are given as characters ‘R’, ‘.’, ‘B’, and ‘p’ respectively. Uppercase characters represent white pieces, and lowercase characters represent black pieces.</p>
<p>The rook moves as in the rules of Chess: it chooses one of four cardinal directions (north, east, west, and south), then moves in that direction until it chooses to stop, reaches the edge of the board, or captures an opposite colored pawn by moving to the same square it occupies.  Also, rooks cannot move into the same square as other friendly bishops.</p>
<p>Return the number of pawns the rook can capture in one move.</p>
<p>Example 1:<br><img src="/img/20190825101.png" alt></p>
<p>Input:<br>[[“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],<br> [“.”,”.”,”.”,”p”,”.”,”.”,”.”,”.”],<br> [“.”,”.”,”.”,”R”,”.”,”.”,”.”,”p”],<br> [“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],<br> [“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],<br> [“.”,”.”,”.”,”p”,”.”,”.”,”.”,”.”],<br> [“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],<br> [“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”]]<br>Output: 3<br>Explanation:<br>In this example the rook is able to capture all the pawns.</p>
<p>Example 2:<br><img src="/img/20190825102.png" alt></p>
<p>Input: [<br> [“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],<br> [“.”,”p”,”p”,”p”,”p”,”p”,”.”,”.”],<br> [“.”,”p”,”p”,”B”,”p”,”p”,”.”,”.”],<br> [“.”,”p”,”B”,”R”,”B”,”p”,”.”,”.”],<br> [“.”,”p”,”p”,”B”,”p”,”p”,”.”,”.”],<br> [“.”,”p”,”p”,”p”,”p”,”p”,”.”,”.”],<br> [“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],<br> [“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”]]<br>Output: 0<br>Explanation:<br>Bishops are blocking the rook to capture any pawn.</p>
<p>Example 3:<br><img src="/img/20190825103.png" alt></p>
<p>Input: [<br> [“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],<br> [“.”,”.”,”.”,”p”,”.”,”.”,”.”,”.”],<br> [“.”,”.”,”.”,”p”,”.”,”.”,”.”,”.”],<br> [“p”,”p”,”.”,”R”,”.”,”p”,”B”,”.”],<br> [“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”],<br> [“.”,”.”,”.”,”B”,”.”,”.”,”.”,”.”],<br> [“.”,”.”,”.”,”p”,”.”,”.”,”.”,”.”],<br> [“.”,”.”,”.”,”.”,”.”,”.”,”.”,”.”]]<br>Output: 3<br>Explanation:<br>The rook can capture the pawns at positions b5, d6 and f5.</p>
<p>Note:</p>
<ol>
<li>board.length == board[i].length == 8</li>
<li>board[i][j] is either ‘R’, ‘.’, ‘B’, or ‘p’</li>
<li>There is exactly one cell with board[i][j] == ‘R’</li>
</ol>
<p>非常无聊，数格子就好了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numRookCaptures(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;</span><br><span class="line">        int x,y;</span><br><span class="line">        int res=0;</span><br><span class="line">        bool bBlack;</span><br><span class="line">        for (int row = 0; row &lt; 8; row++) </span><br><span class="line">            for (int col = 0; col &lt; 8; col++) </span><br><span class="line">                if (board[row][col] == &apos;R&apos; ||</span><br><span class="line">                    board[row][col] == &apos;r&apos;) &#123;</span><br><span class="line">                    x = row;</span><br><span class="line">                    y = col;</span><br><span class="line">                    if (board[row][col] == &apos;R&apos;) &#123;</span><br><span class="line">                        bBlack = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        bBlack = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">        </span><br><span class="line">        for(int j=x-1;j&gt;=0;j--)&#123;</span><br><span class="line">            if(board[j][y]==&apos;.&apos;)</span><br><span class="line">                continue;</span><br><span class="line">            if(board[j][y]==&apos;P&apos; &amp;&amp; bBlack==true)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(board[j][y]==&apos;p&apos; &amp;&amp; bBlack==false)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=x+1;j&lt;8;j++)&#123;</span><br><span class="line">            if(board[j][y]==&apos;.&apos;)</span><br><span class="line">                continue;</span><br><span class="line">            if(board[j][y]==&apos;P&apos; &amp;&amp; bBlack==true)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(board[j][y]==&apos;p&apos; &amp;&amp; bBlack==false)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                break;            </span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=y-1;j&gt;=0;j--)&#123;</span><br><span class="line">            if(board[x][j]==&apos;.&apos;)</span><br><span class="line">                continue;</span><br><span class="line">            if(board[x][j]==&apos;P&apos; &amp;&amp; bBlack==true)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(board[x][j]==&apos;p&apos; &amp;&amp; bBlack==false)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                break;            </span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=y+1;j&lt;8;j++)&#123;</span><br><span class="line">            if(board[x][j]==&apos;.&apos;)</span><br><span class="line">                continue;</span><br><span class="line">            if(board[x][j]==&apos;P&apos; &amp;&amp; bBlack==true)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(board[x][j]==&apos;p&apos; &amp;&amp; bBlack==false)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                break;            </span><br><span class="line">        &#125;        </span><br><span class="line">        return res;</span><br><span class="line">            </span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/27/Leetcode551_600/" rel="next" title="Leetcode551 - 600">
                <i class="fa fa-chevron-left"></i> Leetcode551 - 600
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/28/cpp关键字decltype/" rel="prev" title="C++11关键字decltype">
                C++11关键字decltype <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">232</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode951-Flip-Equivalent-Binary-Trees"><span class="nav-number">1.</span> <span class="nav-text">Leetcode951. Flip Equivalent Binary Trees</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode953-Verifying-an-Alien-Dictionary"><span class="nav-number">2.</span> <span class="nav-text">Leetcode953. Verifying an Alien Dictionary</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode958-Check-Completeness-of-a-Binary-Tree"><span class="nav-number">3.</span> <span class="nav-text">Leetcode958. Check Completeness of a Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode961-N-Repeated-Element-in-Size-2N-Array"><span class="nav-number">4.</span> <span class="nav-text">Leetcode961. N-Repeated Element in Size 2N Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode965-Univalued-Binary-Tree"><span class="nav-number">5.</span> <span class="nav-text">Leetcode965. Univalued Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode970-Powerful-Integers"><span class="nav-number">6.</span> <span class="nav-text">Leetcode970. Powerful Integers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode971-Flip-Binary-Tree-To-Match-Preorder-Traversal"><span class="nav-number">7.</span> <span class="nav-text">Leetcode971. Flip Binary Tree To Match Preorder Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode976-Largest-Perimeter-Triangle"><span class="nav-number">8.</span> <span class="nav-text">Leetcode976. Largest Perimeter Triangle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode977-Squares-of-a-Sorted-Array"><span class="nav-number">9.</span> <span class="nav-text">Leetcode977. Squares of a Sorted Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode978-Longest-Turbulent-Subarray"><span class="nav-number">10.</span> <span class="nav-text">Leetcode978. Longest Turbulent Subarray</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode979-Distribute-Coins-in-Binary-Tree"><span class="nav-number">11.</span> <span class="nav-text">Leetcode979. Distribute Coins in Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode980-Unique-Paths-III"><span class="nav-number">12.</span> <span class="nav-text">Leetcode980. Unique Paths III</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode981-Time-Based-Key-Value-Store"><span class="nav-number">13.</span> <span class="nav-text">Leetcode981. Time Based Key-Value Store</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode983-Minimum-Cost-For-Tickets"><span class="nav-number">14.</span> <span class="nav-text">Leetcode983. Minimum Cost For Tickets</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述"><span class="nav-number">14.1.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode984-String-Without-AAA-or-BBB"><span class="nav-number">15.</span> <span class="nav-text">Leetcode984. String Without AAA or BBB</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode985-Sum-of-Even-Numbers-After-Queries"><span class="nav-number">16.</span> <span class="nav-text">Leetcode985. Sum of Even Numbers After Queries</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode986-Interval-List-Intersections"><span class="nav-number">17.</span> <span class="nav-text">Leetcode986. Interval List Intersections</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode987-Vertical-Order-Traversal-of-a-Binary-Tree"><span class="nav-number">18.</span> <span class="nav-text">Leetcode987. Vertical Order Traversal of a Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode988-Smallest-String-Starting-From-Leaf"><span class="nav-number">19.</span> <span class="nav-text">Leetcode988. Smallest String Starting From Leaf</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode989-Add-to-Array-Form-of-Integer"><span class="nav-number">20.</span> <span class="nav-text">Leetcode989. Add to Array-Form of Integer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode990-Satisfiability-of-Equality-Equations"><span class="nav-number">21.</span> <span class="nav-text">Leetcode990. Satisfiability of Equality Equations</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode993-Cousins-in-Binary-Tree"><span class="nav-number">22.</span> <span class="nav-text">Leetcode993. Cousins in Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode997-Find-the-Town-Judge"><span class="nav-number">23.</span> <span class="nav-text">Leetcode997. Find the Town Judge</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode999-Available-Captures-for-Rook"><span class="nav-number">24.</span> <span class="nav-text">Leetcode999. Available Captures for Rook</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
