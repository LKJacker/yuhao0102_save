<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Leetcode,">










<meta name="description" content="Leetcode951. Flip Equivalent Binary TreesFor a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees. A binary tree X is flip equivalent">
<meta name="keywords" content="Leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode951 - 1000">
<meta property="og:url" content="http://yoursite.com/2019/08/27/Leetcode951_1000/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Leetcode951. Flip Equivalent Binary TreesFor a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees. A binary tree X is flip equivalent">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20190827800.png">
<meta property="og:image" content="http://yoursite.com/img/20190524001.png">
<meta property="og:image" content="http://yoursite.com/img/20190524002.png">
<meta property="og:image" content="http://yoursite.com/img/20190824002.png">
<meta property="og:image" content="http://yoursite.com/img/20190824003.png">
<meta property="og:image" content="http://yoursite.com/img/20190824004.png">
<meta property="og:image" content="http://yoursite.com/img/20190824005.png">
<meta property="og:updated_time" content="2020-05-25T07:24:14.791Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode951 - 1000">
<meta name="twitter:description" content="Leetcode951. Flip Equivalent Binary TreesFor a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees. A binary tree X is flip equivalent">
<meta name="twitter:image" content="http://yoursite.com/img/20190827800.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/08/27/Leetcode951_1000/">





  <title>Leetcode951 - 1000 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/27/Leetcode951_1000/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode951 - 1000</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-27T21:35:00+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Leetcode951-Flip-Equivalent-Binary-Trees"><a href="#Leetcode951-Flip-Equivalent-Binary-Trees" class="headerlink" title="Leetcode951. Flip Equivalent Binary Trees"></a>Leetcode951. Flip Equivalent Binary Trees</h1><p>For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.</p>
<p>A binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.</p>
<p>Write a function that determines whether two binary trees are flip equivalent.  The trees are given by root nodes root1 and root2.</p>
<p>Example 1:</p>
<p>Input: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]<br>Output: true<br>Explanation: We flipped at nodes with values 1, 3, and 5.<br><img src="/img/20190827800.png" alt></p>
<p>这种做法好复杂啊。。。有太多情况需要考虑了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    bool compare(TreeNode* root1, TreeNode* root2)&#123;</span><br><span class="line">        if( root1-&gt;left == NULL &amp;&amp; root1-&gt;right == NULL &amp;&amp; root2-&gt;left == NULL &amp;&amp; root2-&gt;right == NULL ) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        else if( root1-&gt;left != NULL &amp;&amp; root1-&gt;right != NULL &amp;&amp; root2-&gt;left != NULL &amp;&amp; root2-&gt;right != NULL ) &#123;</span><br><span class="line">             if(root1-&gt;left-&gt;val == root2-&gt;left-&gt;val &amp;&amp; root1-&gt;right-&gt;val == root2-&gt;right-&gt;val) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else if(root1-&gt;right-&gt;val == root2-&gt;left-&gt;val &amp;&amp; root1-&gt;left-&gt;val == root2-&gt;right-&gt;val) &#123;</span><br><span class="line">                TreeNode* temp = root1-&gt;right;</span><br><span class="line">                root1-&gt;right = root1-&gt;left;</span><br><span class="line">                root1-&gt;left = temp;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ( root1-&gt;left == NULL &amp;&amp; root1-&gt;right != NULL &amp;&amp; root2-&gt;left == NULL &amp;&amp; root2-&gt;right != NULL )&#123;</span><br><span class="line">            if(root1-&gt;right-&gt;val == root2-&gt;right-&gt;val) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ( root1-&gt;left != NULL &amp;&amp; root1-&gt;right == NULL &amp;&amp; root2-&gt;left != NULL &amp;&amp; root2-&gt;right == NULL ) &#123;</span><br><span class="line">            if(root1-&gt;left-&gt;val == root2-&gt;left-&gt;val) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ( root1-&gt;left == NULL &amp;&amp; root1-&gt;right != NULL &amp;&amp; root2-&gt;left != NULL &amp;&amp; root2-&gt;right == NULL )&#123;</span><br><span class="line">            if(root1-&gt;right-&gt;val == root2-&gt;left-&gt;val) &#123;</span><br><span class="line">                root1-&gt;left = root1-&gt;right;</span><br><span class="line">                root1-&gt;right = NULL;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if ( root1-&gt;left != NULL &amp;&amp; root1-&gt;right == NULL &amp;&amp; root2-&gt;left == NULL &amp;&amp; root2-&gt;right != NULL ) &#123;</span><br><span class="line">            if(root1-&gt;left-&gt;val == root2-&gt;right-&gt;val) &#123;</span><br><span class="line">                root1-&gt;right = root1-&gt;left;</span><br><span class="line">                root1-&gt;left = NULL;</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool order(TreeNode* root1, TreeNode* root2)&#123;</span><br><span class="line">        if (root1 == NULL &amp;&amp; root2 == NULL) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root1 == NULL || root2 == NULL) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if( root1 != NULL &amp;&amp; root2 != NULL ) &#123;</span><br><span class="line">            if(root1-&gt;val == root2-&gt;val)</span><br><span class="line">                compare(root1, root2);</span><br><span class="line">            else</span><br><span class="line">                return false;</span><br><span class="line">            return order(root1-&gt;left, root2-&gt;left) &amp;&amp; order(root1-&gt;right, root2-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool flipEquiv(TreeNode* root1, TreeNode* root2) &#123;</span><br><span class="line">        return order(root1, root2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>另一种做法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool flipEquiv(TreeNode* root1, TreeNode* root2) &#123;</span><br><span class="line">        // Two null trees are flip equivalent</span><br><span class="line">        // A non-null and null tree are NOT flip equivalent</span><br><span class="line">        // Two non-null trees with different root values are NOT flip equivalent</span><br><span class="line">        // Two non-null trees are flip equivalent if</span><br><span class="line">        //      The left subtree of tree1 is flip equivalent with the left subtree of tree2 and the right subtree of tree1 is   </span><br><span class="line">        //      flipequivalent with the right subtree of tree2 (no flip case)</span><br><span class="line">        //      OR</span><br><span class="line">        //      The right subtree of tree1 is flip equivalent with the left subtree of tree2 and the left subtree of tree1 is</span><br><span class="line">        //      flipequivalent with the right subtree of tree2 (flip case)</span><br><span class="line">        if ( !root1 &amp;&amp; !root2 ) return true;</span><br><span class="line">        if ( !root1 &amp;&amp; root2 || root1 &amp;&amp;!root2 || root1-&gt;val != root2-&gt;val ) return false;</span><br><span class="line">        return flipEquiv( root1-&gt;left, root2-&gt;left ) &amp;&amp; flipEquiv( root1-&gt;right, root2-&gt;right )</span><br><span class="line">            || flipEquiv( root1-&gt;right, root2-&gt;left ) &amp;&amp; flipEquiv( root1-&gt;left, root2-&gt;right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode965-Univalued-Binary-Tree"><a href="#Leetcode965-Univalued-Binary-Tree" class="headerlink" title="Leetcode965. Univalued Binary Tree"></a>Leetcode965. Univalued Binary Tree</h1><p>A binary tree is univalued if every node in the tree has the same value.</p>
<p>Return true if and only if the given tree is univalued.</p>
<p>Example 1:<br><img src="/img/20190524001.png" alt><br>Input: [1,1,1,1,1,null,1]<br>Output: true</p>
<p>Example 2:<br><img src="/img/20190524002.png" alt><br>Input: [2,2,2,5,2]<br>Output: false</p>
<p>Note:</p>
<p>The number of nodes in the given tree will be in the range [1, 100].<br>Each node’s value will be an integer in the range [0, 99].<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool des(TreeNode* root,int val)&#123;</span><br><span class="line">        if(root==NULL)</span><br><span class="line">            return true;</span><br><span class="line">        if(root-&gt;val != val)</span><br><span class="line">            return false;</span><br><span class="line">        return des(root-&gt;left,val)&amp;&amp;des(root-&gt;right,val);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    bool isUnivalTree(TreeNode* root) &#123;</span><br><span class="line">        if(root==NULL)</span><br><span class="line">            return true;</span><br><span class="line">        return des(root,root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode961-N-Repeated-Element-in-Size-2N-Array"><a href="#Leetcode961-N-Repeated-Element-in-Size-2N-Array" class="headerlink" title="Leetcode961. N-Repeated Element in Size 2N Array"></a>Leetcode961. N-Repeated Element in Size 2N Array</h1><p>In a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times.</p>
<p>Return the element repeated N times.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,2,5,3,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,1,5,2,5,3,5,4]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>4 &lt;= A.length &lt;= 10000<br>0 &lt;= A[i] &lt; 10000<br>A.length is even</p>
<p>一个桶排序搞定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int repeatedNTimes(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        int counter[10000];</span><br><span class="line">        memset(counter,0,sizeof(counter));</span><br><span class="line">        for(int i=0;i&lt;A.size();i++)&#123;</span><br><span class="line">            counter[A[i]]++;</span><br><span class="line">            if(counter[A[i]]&gt;=A.size()/2)</span><br><span class="line">                return A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>看到了大佬的解法，跪了，如果有两个连续一样的元素，直接返回</p>
<p>The intuition here is that the repeated numbers have to appear either next to each other (A[i] == A[i + 1]), or alternated (A[i] == A[i + 2]).</p>
<p>The only exception is sequences like [2, 1, 3, 2]. In this case, the result is the last number, so we just return it in the end. This solution has O(n) runtime.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int repeatedNTimes(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">  for (auto i = 0; i &lt; A.size() - 2; ++i)</span><br><span class="line">    if (A[i] == A[i + 1] || A[i] == A[i + 2]) return A[i];</span><br><span class="line">  return A[A.size() - 1]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Another interesting approach is to use randomization (courtesy of @lee215 ). If you pick two numbers randomly, there is a 25% chance you bump into the repeated number. So, in average, we will find the answer in 4 attempts, thus O(4) runtime.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int repeatedNTimes(vector&lt;int&gt;&amp; A, int i = 0, int j = 0) &#123;</span><br><span class="line">  while (A[i = rand() % A.size()] != A[j = rand() % A.size()] || i == j);</span><br><span class="line">  return A[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode977-Squares-of-a-Sorted-Array"><a href="#Leetcode977-Squares-of-a-Sorted-Array" class="headerlink" title="Leetcode977. Squares of a Sorted Array"></a>Leetcode977. Squares of a Sorted Array</h1><p>Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [-4,-1,0,3,10]</span><br><span class="line">Output: [0,1,9,16,100]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [-7,-3,2,3,11]</span><br><span class="line">Output: [4,9,9,49,121]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= A.length &lt;= 10000<br>-10000 &lt;= A[i] &lt;= 10000<br>A is sorted in non-decreasing order.</p>
<p>给一个vector，有正有负，输出排序之后的平方数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        vector&lt;int&gt; res(A.size());</span><br><span class="line">        int l = 0,r = A.size()-1, p = A.size() - 1;</span><br><span class="line">        while(l&lt;=r)&#123;</span><br><span class="line">            res[p--]=pow(A[abs(A[l])&gt;abs(A[r])?l++:r--],2);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>另一种方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        vector&lt;int&gt; res(A.size());</span><br><span class="line">        int i=0,j=0,k=0;</span><br><span class="line">        while(i&lt;A.size() &amp;&amp; A[i]&lt;0)</span><br><span class="line">            i++;</span><br><span class="line">        j=i-1;</span><br><span class="line">        while(j&gt;=0 &amp;&amp; i&lt;A.size())&#123;</span><br><span class="line">            res[k++] = pow(A[abs(A[i])&lt;abs(A[j])?i++:j--],2);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(j&gt;=0)</span><br><span class="line">            res[k++]=pow(A[j--],2);</span><br><span class="line">        while(i&lt;A.size())</span><br><span class="line">            res[k++]=pow(A[i++],2);</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode979-Distribute-Coins-in-Binary-Tree"><a href="#Leetcode979-Distribute-Coins-in-Binary-Tree" class="headerlink" title="Leetcode979. Distribute Coins in Binary Tree"></a>Leetcode979. Distribute Coins in Binary Tree</h1><p>Given the root of a binary tree with N nodes, each node in the tree has node.val coins, and there are N coins total.</p>
<p>In one move, we may choose two adjacent nodes and move one coin from one node to another.  (The move may be from parent to child, or from child to parent.)</p>
<p>Return the number of moves required to make every node have exactly one coin.</p>
<p>Example 1:<br><img src="/img/20190824002.png" alt></p>
<p>Input: [3,0,0]<br>Output: 2<br>Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.</p>
<p>Example 2:<br><img src="/img/20190824003.png" alt></p>
<p>Input: [0,3,0]<br>Output: 3<br>Explanation: From the left child of the root, we move two coins to the root [taking two moves].  Then, we move one coin from the root of the tree to the right child.</p>
<p>Example 3:<br><img src="/img/20190824004.png" alt></p>
<p>Input: [1,0,2]<br>Output: 2</p>
<p>Example 4:<br><img src="/img/20190824005.png" alt></p>
<p>Input: [1,0,0,null,3]<br>Output: 4</p>
<p>Note:</p>
<p>1&lt;= N &lt;= 100<br>0 &lt;= node.val &lt;= N</p>
<p>给你一个二叉树，对于每个节点的val，每次只能往父亲或者儿子移动1，最后使得所有节点值都为1，求最小的移动次数。</p>
<p>思路：从叶子到根寻找，对于每个节点，只能剩下一个。多了的值肯定要全给父亲，少的值全问父亲要，统计一下就好了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Definition for a binary tree node.</span><br><span class="line">   * struct TreeNode &#123;</span><br><span class="line">   *     int val;</span><br><span class="line">   *     TreeNode *left;</span><br><span class="line">   *     TreeNode *right;</span><br><span class="line">   *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">   * &#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    int ans=0;</span><br><span class="line">    int distributeCoins(TreeNode* root) &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    int dfs(TreeNode* root)&#123;</span><br><span class="line">        if(root==NULL)</span><br><span class="line">            return 0;</span><br><span class="line">        int left = dfs(root-&gt;left);</span><br><span class="line">        int right = dfs(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        ans += abs(left) + abs(right);</span><br><span class="line">        return root-&gt;val -1 + left + right ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode980-Unique-Paths-III"><a href="#Leetcode980-Unique-Paths-III" class="headerlink" title="Leetcode980. Unique Paths III"></a>Leetcode980. Unique Paths III</h1><p>On a 2-dimensional grid, there are 4 types of squares:</p>
<p><code>1</code> represents the starting square.  There is exactly one starting square.<br><code>2</code> represents the ending square.  There is exactly one ending square.<br><code>0</code> represents empty squares we can walk over.<br><code>-1</code> represents obstacles that we cannot walk over.<br>Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We have the following two paths: </span><br><span class="line">1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)</span><br><span class="line">2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,0,0,0],[0,0,0,0],[0,0,0,2]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: We have the following four paths: </span><br><span class="line">1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)</span><br><span class="line">2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)</span><br><span class="line">3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)</span><br><span class="line">4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,1],[2,0]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: </span><br><span class="line">There is no path that walks over every empty square exactly once.</span><br><span class="line">Note that the starting and ending square can be anywhere in the grid.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= grid.length * grid[0].length &lt;= 20</p>
<p>给了一个二维矩阵，1代表起点，2代表终点，0代表可以走的格子，-1代表障碍物。求从起点到终点，把所有的可以走的格子都遍历一遍，所有可能的不同路径数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;pair&lt;int, int&gt;&gt; dirs = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;</span><br><span class="line">    int uniquePathsIII(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int M=grid.size();</span><br><span class="line">        int zerosize=0,res=0;</span><br><span class="line">        int N=grid[0].size();</span><br><span class="line">        for(int i=0;i&lt;M;i++)</span><br><span class="line">            for(int j=0;j&lt;N;j++)</span><br><span class="line">                if(grid[i][j]==0)</span><br><span class="line">                    zerosize++;</span><br><span class="line">        for(int i=0;i&lt;M;i++)</span><br><span class="line">            for(int j=0;j&lt;N;j++)</span><br><span class="line">                if(grid[i][j]==1)</span><br><span class="line">                    dfs(grid,i,j,0,zerosize,res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, int pathcount, int zerocount, int&amp; res)&#123;</span><br><span class="line">        if(grid[x][y]==2 &amp;&amp; zerocount == pathcount )&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        int M=grid.size();</span><br><span class="line">        int N=grid[0].size();</span><br><span class="line">        </span><br><span class="line">        int pre=grid[x][y];</span><br><span class="line">        if(pre==0)</span><br><span class="line">            pathcount++;</span><br><span class="line">        grid[x][y]=-1;</span><br><span class="line">        for (auto d : dirs) &#123;</span><br><span class="line">            int nx = x + d.first;</span><br><span class="line">            int ny = y + d.second;</span><br><span class="line">            if (nx &lt; 0 || nx &gt;= M || ny &lt; 0 || ny &gt;= N || grid[nx][ny] == -1)</span><br><span class="line">                continue;</span><br><span class="line">            dfs(grid, nx, ny, pathcount, zerocount, res);</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y]=pre;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode985-Sum-of-Even-Numbers-After-Queries"><a href="#Leetcode985-Sum-of-Even-Numbers-After-Queries" class="headerlink" title="Leetcode985. Sum of Even Numbers After Queries"></a>Leetcode985. Sum of Even Numbers After Queries</h1><p>We have an array A of integers, and an array queries of queries.</p>
<p>For the i-th query val = queries[i][0], index = queries[i][1], we add val to A[index].  Then, the answer to the i-th query is the sum of the even values of A.</p>
<p>(Here, the given index = queries[i][1] is a 0-based index, and each query permanently modifies the array A.)</p>
<p>Return the answer to all queries.  Your answer array should have answer[i] as the answer to the i-th query.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]</span><br><span class="line">Output: [8,6,2,4]</span><br><span class="line">Explanation: </span><br><span class="line">	At the beginning, the array is [1,2,3,4].</span><br><span class="line">	After adding 1 to A[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.</span><br><span class="line">	After adding -3 to A[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.</span><br><span class="line">	After adding -4 to A[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.</span><br><span class="line">	After adding 2 to A[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4.</span><br></pre></td></tr></table></figure></p>
<p>题意比较曲折，就是在queries中的每个pair，某个位置加上一个数，在计算A数组中所有偶数的和。下边的代码会超时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    vector&lt;int&gt; sumEvenAfterQueries(vector&lt;int&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        int size = queries.size(), val, index, sum;</span><br><span class="line">        for(int i = 0; i &lt; size; i ++) &#123;</span><br><span class="line">            sum = 0;</span><br><span class="line">            val = queries[i][0];</span><br><span class="line">            index = queries[i][1];</span><br><span class="line">            A[index] += val;</span><br><span class="line">            for(int j = 0; j &lt; A.size(); j ++)</span><br><span class="line">                sum += (A[j]%2 ? 0 : A[j]);</span><br><span class="line">            res.push_back(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>应首先计算出所有的偶数和，再根据运算之后的结果进行计算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    vector&lt;int&gt; sumEvenAfterQueries(vector&lt;int&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        int size = queries.size(), val, index, sum = 0;</span><br><span class="line">        for(int i = 0; i &lt; A.size(); i ++)</span><br><span class="line">            sum += (A[i]%2 ? 0 : A[i]);</span><br><span class="line">        for(int i = 0; i &lt; size; i ++) &#123;</span><br><span class="line">            val = queries[i][0];</span><br><span class="line">            index = queries[i][1];</span><br><span class="line">            if(A[index]%2 == 0)</span><br><span class="line">                sum -= A[index];</span><br><span class="line">            A[index] += val;</span><br><span class="line">            if(A[index]%2 == 0)</span><br><span class="line">                sum += A[index];</span><br><span class="line">            res.push_back(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode986-Interval-List-Intersections"><a href="#Leetcode986-Interval-List-Intersections" class="headerlink" title="Leetcode986. Interval List Intersections"></a>Leetcode986. Interval List Intersections</h1><p>Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order.</p>
<p>Return the intersection of these two interval lists.</p>
<p>(Formally, a closed interval [a, b] (with a &lt;= b) denotes the set of real numbers x with a &lt;= x &lt;= b.  The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval.  For example, the intersection of [1, 3] and [2, 4] is [2, 3].)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; intervalIntersection(vector&lt;vector&lt;int&gt;&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; B) &#123;</span><br><span class="line">        if(A.size() == 0 || B.size() == 0)</span><br><span class="line">            return vector&lt;vector&lt;int&gt;&gt;&#123;&#125;;</span><br><span class="line">        int sizea = A.size(), sizeb = B.size();</span><br><span class="line">        int l, r;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        for(int i = 0, j = 0; i &lt; sizea &amp;&amp; j &lt; sizeb;) &#123;</span><br><span class="line">            l = max(A[i][0], B[j][0]);</span><br><span class="line">            r = min(A[i][1], B[j][1]);</span><br><span class="line">            if(l &lt;= r) </span><br><span class="line">                res.push_back(&#123;l, r&#125;);</span><br><span class="line">            if(r == A[i][1])</span><br><span class="line">                i ++;</span><br><span class="line">            else j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>贪心，由于排好序了，直接双指针扫，思路和归并排序合并比较类似，注意往后移动的条件是尾部，因为一个矩形的结束条件是尾部比完了，不能写成是头部</p>
<h1 id="Leetcode987-Vertical-Order-Traversal-of-a-Binary-Tree"><a href="#Leetcode987-Vertical-Order-Traversal-of-a-Binary-Tree" class="headerlink" title="Leetcode987. Vertical Order Traversal of a Binary Tree"></a>Leetcode987. Vertical Order Traversal of a Binary Tree</h1><p>Given a binary tree, return the vertical order traversal of its nodes values.</p>
<p>For each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1).</p>
<p>Running a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates).</p>
<p>If two nodes have the same position, then the value of the node that is reported first is the value that is smaller.</p>
<p>Return an list of non-empty reports in order of X coordinate.  Every report will have a list of values of nodes.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[9],[3,15],[20],[7]]</span><br><span class="line">Explanation: </span><br><span class="line">Without loss of generality, we can assume the root node is at position (0, 0):</span><br><span class="line">Then, the node with value 9 occurs at position (-1, -1);</span><br><span class="line">The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2);</span><br><span class="line">The node with value 20 occurs at position (1, -1);</span><br><span class="line">The node with value 7 occurs at position (2, -2).</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6,7]</span><br><span class="line">Output: [[4],[2],[1,5,6],[3],[7]]</span><br><span class="line">Explanation: </span><br><span class="line">The node with value 5 and the node with value 6 have the same position according to the given scheme.</span><br><span class="line">However, in the report &quot;[1,5,6]&quot;, the node value of 5 comes first since 5 is smaller than 6.</span><br><span class="line">```	 </span><br><span class="line">Note:</span><br><span class="line">- The tree will have between 1 and 1000 nodes.</span><br><span class="line">- Each node s value will be between 0 and 1000.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">要求把相同X的节点位置放在一起，并且要求结果中节点的存放是从上到下的。如果两个节点的坐标相同，那么value小的节点排列在前面。通过维护一个队列，我们从上到下依次遍历每个节点，给每个节点设置好了坐标。这个队列存储的是个三元组（TreeNode*,int x,int y）</span><br></pre></td></tr></table></figure></p>
<p>/**</p>
<ul>
<li>Definition for a binary tree node.</li>
<li>struct TreeNode {</li>
<li>int val;</li>
<li>TreeNode *left;</li>
<li>TreeNode *right;</li>
<li>TreeNode() : val(0), left(nullptr), right(nullptr) {}</li>
<li>TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</li>
<li>TreeNode(int x, TreeNode <em>left, TreeNode </em>right) : val(x), left(left), right(right) {}</li>
<li><p>};<br><em>/<br>class Solution {<br>public:<br>struct dat{<br>   TreeNode</em> root;<br>   int x, y;<br>};</p>
<p>vector&lt;vector<int>&gt; verticalTraversal(TreeNode* root) {<br>   queue<struct dat> q;<br>   struct dat te = {root, 0, 0};<br>   q.push(te);<br>   map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; node;<br>   while(!q.empty()) {</struct></int></p>
<pre><code>struct dat temp = q.front();
q.pop();
node[temp.x].push_back(make_pair(-temp.y, temp.root-&gt;val));
if(temp.root-&gt;left)
    q.push({temp.root-&gt;left, temp.x - 1, temp.y - 1});
if(temp.root-&gt;right)
    q.push({temp.root-&gt;right, temp.x + 1, temp.y - 1});
</code></pre><p>   }<br>   vector&lt;vector<int>&gt; res;<br>   for(auto it : node) {</int></p>
<pre><code>sort(it.second.begin(), it.second.end());
vector&lt;int&gt; tempp;
for(auto i : it.second)
    tempp.push_back(i.second);
res.push_back(tempp);
</code></pre><p>   }<br>   return res;<br>}<br>};</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Leetcode988. Smallest String Starting From Leaf</span><br><span class="line">Given the root of a binary tree, each node has a value from 0 to 25 representing the letters &apos;a&apos; to &apos;z&apos;: a value of 0 represents &apos;a&apos;, a value of 1 represents &apos;b&apos;, and so on.</span><br><span class="line"></span><br><span class="line">Find the lexicographically smallest string that starts at a leaf of this tree and ends at the root.</span><br><span class="line"></span><br><span class="line">(As a reminder, any shorter prefix of a string is lexicographically smaller: for example, &quot;ab&quot; is lexicographically smaller than &quot;aba&quot;.  A leaf of a node is a node that has no children.)</span><br><span class="line"></span><br><span class="line">Example 1:</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Input: [0,1,2,3,4,3,4]<br>Output: “dba”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br></pre></td></tr></table></figure></p>
<p>Input: [25,1,3,1,3,0,2]<br>Output: “adz”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Example 3:</span><br></pre></td></tr></table></figure></p>
<p>Input: [2,2,1,null,1,0,null,0]<br>Output: “abc”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个数组代表一个树，图就不上了，从叶子节点开始找到一个最小的字符串。</span><br></pre></td></tr></table></figure></p>
<p>/**</p>
<ul>
<li>Definition for a binary tree node.</li>
<li>struct TreeNode {</li>
<li>int val;</li>
<li>TreeNode *left;</li>
<li>TreeNode *right;</li>
<li>TreeNode(int x) : val(x), left(NULL), right(NULL) {}</li>
<li><p>};<br>*/<br>class Solution {<br>public:</p>
<p>string result = “zzzzzzzzzz”;<br>void bianli(TreeNode* root, string cur) {<br>   if(root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL) {</p>
<pre><code>cur = (char)((root-&gt;val) + &apos;a&apos;)+cur;
result = result &lt; cur ? result : cur;
return;
</code></pre><p>   }<br>   if(root-&gt;left != NULL) {</p>
<pre><code>bianli(root-&gt;left, (char)(root-&gt;val+&apos;a&apos;)+cur);
</code></pre><p>   }<br>   if(root-&gt;right != NULL) {</p>
<pre><code>bianli(root-&gt;right, (char)(root-&gt;val+&apos;a&apos;)+cur);
</code></pre><p>   }<br>}</p>
<p>string smallestFromLeaf(TreeNode* root) {<br>   bianli(root, “”);<br>   return result;<br>}<br>};</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Leetcode989. Add to Array-Form of Integer</span><br><span class="line">For a non-negative integer X, the array-form of X is an array of its digits in left to right order.  For example, if X = 1231, then the array form is [1,2,3,1].</span><br><span class="line"></span><br><span class="line">Given the array-form A of a non-negative integer X, return the array-form of the integer X+K.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Input: A = [1,2,0,0], K = 34<br>Output: [1,2,3,4]<br>Explanation: 1200 + 34 = 1234<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br></pre></td></tr></table></figure></p>
<p>Input: A = [2,7,4], K = 181<br>Output: [4,5,5]<br>Explanation: 274 + 181 = 455<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Example 3:</span><br></pre></td></tr></table></figure></p>
<p>Input: A = [2,1,5], K = 806<br>Output: [1,0,2,1]<br>Explanation: 215 + 806 = 1021<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Example 4:</span><br></pre></td></tr></table></figure></p>
<p>Input: A = [9,9,9,9,9,9,9,9,9,9], K = 1<br>Output: [1,0,0,0,0,0,0,0,0,0,0]<br>Explanation: 9999999999 + 1 = 10000000000<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Note：</span><br><span class="line">- 1 &lt;= A.length &lt;= 10000</span><br><span class="line">- 0 &lt;= A[i] &lt;= 9</span><br><span class="line">- 0 &lt;= K &lt;= 10000</span><br><span class="line">- If A.length &gt; 1, then A[0] != 0</span><br><span class="line"></span><br><span class="line">大概意思是一个数组代表一个数，再给一个整数K，返回结果的各位数组成的数组，注意进位，我的做法很麻烦，需要两次反转。</span><br></pre></td></tr></table></figure></p>
<p>class Solution {<br>public:<br>    vector<int> addToArrayForm(vector<int>&amp; A, int K) {<br>        vector<int> result;<br>        int L=K;<br>        reverse(A.begin(), A.end());<br>        for(int i = 0; i &lt; A.size(); i++){<br>            A[i] = A[i] + L;<br>            L = A[i]/10;<br>            A[i]=A[i]%10;<br>        }<br>        while(L&gt;0) {<br>            A.push_back(L%10);<br>            L = L/10;<br>        }<br>        reverse(A.begin(), A.end());<br>        return A;<br>    }<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">从数组最右边开始，逐位相加，用carry记录进位，每一次取和的最右一位存入链表</span><br></pre></td></tr></table></figure></int></int></int></p>
<p>class Solution {<br>    public List<integer> addToArrayForm(int[] A, int K) {<br>        int len = A.length;<br>        int carry = 0;<br>        List<integer> list = new ArrayList<integer>();<br>        for(int i = len - 1; i &gt; -1; i–){<br>            int sum = carry + A[i] + K % 10;<br>            list.add(sum % 10);<br>            carry = sum / 10;<br>            K /= 10;<br>        }<br>        carry += K;<br>        while(carry != 0){<br>            list.add(carry % 10);<br>            carry /= 10;<br>        }<br>        Collections.reverse(list);<br>        return list;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Leetcode990. Satisfiability of Equality Equations</span><br><span class="line">Given an array equations of strings that represent relationships between variables, each string equations[i] has length 4 and takes one of two different forms: &quot;a==b&quot; or &quot;a!=b&quot;.  Here, a and b are lowercase letters (not necessarily different) that represent one-letter variable names.</span><br><span class="line"></span><br><span class="line">Return true if and only if it is possible to assign integers to variable names so as to satisfy all the given equations.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br></pre></td></tr></table></figure></integer></integer></integer></p>
<p>Input: [“a==b”,”b!=a”]<br>Output: false<br>Explanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.  There is no way to assign the variables to satisfy both equations.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br></pre></td></tr></table></figure></p>
<p>Input: [“b==a”,”a==b”]<br>Output: true<br>Explanation: We could assign a = 1 and b = 1 to satisfy both equations.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Example 3:</span><br></pre></td></tr></table></figure></p>
<p>Input: [“a==b”,”b==c”,”a==c”]<br>Output: true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Example 4:</span><br></pre></td></tr></table></figure></p>
<p>Input: [“a==b”,”b!=c”,”c==a”]<br>Output: false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Example 5:</span><br></pre></td></tr></table></figure></p>
<p>Input: [“c==c”,”b==d”,”x!=z”]<br>Output: true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Note:</span><br><span class="line">- 1 &lt;= equations.length &lt;= 500</span><br><span class="line">- equations[i].length == 4</span><br><span class="line">- equations[i][0] and equations[i][3] are lowercase letters</span><br><span class="line">- equations[i][1] is either &apos;=&apos; or &apos;!&apos;</span><br><span class="line">- equations[i][2] is &apos;=&apos;</span><br><span class="line"></span><br><span class="line">给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：&quot;a==b&quot;或 &quot;a!=b&quot;。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</span><br><span class="line"></span><br><span class="line">只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。</span><br><span class="line"></span><br><span class="line">这个问题一看就是并查集问题，所以直接使用并查集就过了。将所有相等的元素构成一个集合中，然后判断不相等的元素是不是相同根即可。</span><br></pre></td></tr></table></figure></p>
<p>class Solution {<br>public:<br>    int arr[26];<br>    int find(int x) {<br>        return arr[x]==x?x:find(arr[x]);<br>    }<br>    void uni(int x, int y) {<br>        arr[find(y)]=find(x);<br>    }<br>    bool equationsPossible(vector<string>&amp; equations) {<br>        for(int i=0;i&lt;26;i++)<br>            arr[i]=i;<br>        for(int i=0;i&lt;equations.size();i++){<br>            if(equations[i][1]==’=’) {<br>                uni(equations[i][0]-‘a’, equations[i][3]-‘a’);<br>            }<br>        }<br>        for(int i=0;i&lt;equations.size();i++){<br>            if(equations[i][1]==’!’ &amp;&amp; find(equations[i][0]-‘a’)==find(equations[i][3]-‘a’)) {<br>                return false;<br>            }<br>        }<br>        return true;<br>    }<br>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Leetcode999. Available Captures for Rook</span><br><span class="line">On an 8 x 8 chessboard, there is one white rook.  There also may be empty squares, white bishops, and black pawns.  These are given as characters &apos;R&apos;, &apos;.&apos;, &apos;B&apos;, and &apos;p&apos; respectively. Uppercase characters represent white pieces, and lowercase characters represent black pieces.</span><br><span class="line"></span><br><span class="line">The rook moves as in the rules of Chess: it chooses one of four cardinal directions (north, east, west, and south), then moves in that direction until it chooses to stop, reaches the edge of the board, or captures an opposite colored pawn by moving to the same square it occupies.  Also, rooks cannot move into the same square as other friendly bishops.</span><br><span class="line"></span><br><span class="line">Return the number of pawns the rook can capture in one move.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">![](/img/20190825101.png)</span><br><span class="line"></span><br><span class="line">Input: </span><br><span class="line">[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">In this example the rook is able to capture all the pawns.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">![](/img/20190825102.png)</span><br><span class="line"></span><br><span class="line">Input: [</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;R&quot;,&quot;B&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: </span><br><span class="line">Bishops are blocking the rook to capture any pawn.</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">![](/img/20190825103.png)</span><br><span class="line"></span><br><span class="line">Input: [</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">The rook can capture the pawns at positions b5, d6 and f5.</span><br><span class="line"> </span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">1. board.length == board[i].length == 8</span><br><span class="line">2. board[i][j] is either &apos;R&apos;, &apos;.&apos;, &apos;B&apos;, or &apos;p&apos;</span><br><span class="line">3. There is exactly one cell with board[i][j] == &apos;R&apos;</span><br><span class="line"></span><br><span class="line">非常无聊，数格子就好了。</span><br></pre></td></tr></table></figure></string></p>
<p>class Solution {<br>public:<br>    int numRookCaptures(vector&lt;vector<char>&gt;&amp; board) {<br>        int x,y;<br>        int res=0;<br>        bool bBlack;<br>        for (int row = 0; row &lt; 8; row++)<br>            for (int col = 0; col &lt; 8; col++)<br>                if (board[row][col] == ‘R’ ||<br>                    board[row][col] == ‘r’) {<br>                    x = row;<br>                    y = col;<br>                    if (board[row][col] == ‘R’) {<br>                        bBlack = false;<br>                    }<br>                    else {<br>                        bBlack = true;<br>                    }<br>                    break;<br>                }</char></p>
<pre><code>    for(int j=x-1;j&gt;=0;j--){
        if(board[j][y]==&apos;.&apos;)
            continue;
        if(board[j][y]==&apos;P&apos; &amp;&amp; bBlack==true){
            res++;
            break;
        }
        else if(board[j][y]==&apos;p&apos; &amp;&amp; bBlack==false){
            res++;
            break;
        }
        else
            break;
    }
    for(int j=x+1;j&lt;8;j++){
        if(board[j][y]==&apos;.&apos;)
            continue;
        if(board[j][y]==&apos;P&apos; &amp;&amp; bBlack==true){
            res++;
            break;
        }
        else if(board[j][y]==&apos;p&apos; &amp;&amp; bBlack==false){
            res++;
            break;
        }
        else
            break;            
    }
    for(int j=y-1;j&gt;=0;j--){
        if(board[x][j]==&apos;.&apos;)
            continue;
        if(board[x][j]==&apos;P&apos; &amp;&amp; bBlack==true){
            res++;
            break;
        }
        else if(board[x][j]==&apos;p&apos; &amp;&amp; bBlack==false){
            res++;
            break;
        }
        else
            break;            
    }
    for(int j=y+1;j&lt;8;j++){
        if(board[x][j]==&apos;.&apos;)
            continue;
        if(board[x][j]==&apos;P&apos; &amp;&amp; bBlack==true){
            res++;
            break;
        }
        else if(board[x][j]==&apos;p&apos; &amp;&amp; bBlack==false){
            res++;
            break;
        }
        else
            break;            
    }        
    return res;


}
</code></pre><p>};<br><code>`</code></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/27/Leetcode557/" rel="next" title="Leetcode557. Reverse Words in a String III">
                <i class="fa fa-chevron-left"></i> Leetcode557. Reverse Words in a String III
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/28/cpp关键字decltype/" rel="prev" title="C++11关键字decltype">
                C++11关键字decltype <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">244</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode951-Flip-Equivalent-Binary-Trees"><span class="nav-number">1.</span> <span class="nav-text">Leetcode951. Flip Equivalent Binary Trees</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode965-Univalued-Binary-Tree"><span class="nav-number">2.</span> <span class="nav-text">Leetcode965. Univalued Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode961-N-Repeated-Element-in-Size-2N-Array"><span class="nav-number">3.</span> <span class="nav-text">Leetcode961. N-Repeated Element in Size 2N Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode977-Squares-of-a-Sorted-Array"><span class="nav-number">4.</span> <span class="nav-text">Leetcode977. Squares of a Sorted Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode979-Distribute-Coins-in-Binary-Tree"><span class="nav-number">5.</span> <span class="nav-text">Leetcode979. Distribute Coins in Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode980-Unique-Paths-III"><span class="nav-number">6.</span> <span class="nav-text">Leetcode980. Unique Paths III</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode985-Sum-of-Even-Numbers-After-Queries"><span class="nav-number">7.</span> <span class="nav-text">Leetcode985. Sum of Even Numbers After Queries</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode986-Interval-List-Intersections"><span class="nav-number">8.</span> <span class="nav-text">Leetcode986. Interval List Intersections</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode987-Vertical-Order-Traversal-of-a-Binary-Tree"><span class="nav-number">9.</span> <span class="nav-text">Leetcode987. Vertical Order Traversal of a Binary Tree</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
