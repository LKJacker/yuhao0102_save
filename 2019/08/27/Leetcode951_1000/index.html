<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Leetcode,">










<meta name="description" content="Leetcode951. Flip Equivalent Binary TreesFor a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees. A binary tree X is flip equivalent">
<meta name="keywords" content="Leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode951 - 1000">
<meta property="og:url" content="http://yoursite.com/2019/08/27/Leetcode951_1000/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Leetcode951. Flip Equivalent Binary TreesFor a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees. A binary tree X is flip equivalent">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20190827800.png">
<meta property="og:image" content="http://yoursite.com/img/20211115105401.png">
<meta property="og:image" content="http://yoursite.com/img/20211115105402.png">
<meta property="og:image" content="http://yoursite.com/img/20211115105403.png">
<meta property="og:image" content="http://yoursite.com/img/20211115105404.png">
<meta property="og:image" content="http://yoursite.com/img/20211115105405.png">
<meta property="og:image" content="http://yoursite.com/img/20211115105406.png">
<meta property="og:image" content="http://yoursite.com/img/20211115105407.png">
<meta property="og:image" content="http://yoursite.com/img/20190524001.png">
<meta property="og:image" content="http://yoursite.com/img/20190524002.png">
<meta property="og:image" content="http://yoursite.com/img/20190824002.png">
<meta property="og:image" content="http://yoursite.com/img/20190824003.png">
<meta property="og:image" content="http://yoursite.com/img/20190824004.png">
<meta property="og:image" content="http://yoursite.com/img/20190824005.png">
<meta property="og:image" content="http://yoursite.com/img/20211115105408.png">
<meta property="og:image" content="http://yoursite.com/img/1636992467.png">
<meta property="og:image" content="http://yoursite.com/img/1636992495.jpg">
<meta property="og:image" content="http://yoursite.com/img/20190825101.png">
<meta property="og:image" content="http://yoursite.com/img/20190825102.png">
<meta property="og:image" content="http://yoursite.com/img/20190825103.png">
<meta property="og:updated_time" content="2021-11-16T05:31:04.749Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode951 - 1000">
<meta name="twitter:description" content="Leetcode951. Flip Equivalent Binary TreesFor a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees. A binary tree X is flip equivalent">
<meta name="twitter:image" content="http://yoursite.com/img/20190827800.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/08/27/Leetcode951_1000/">





  <title>Leetcode951 - 1000 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/27/Leetcode951_1000/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode951 - 1000</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-27T21:35:00+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Leetcode951-Flip-Equivalent-Binary-Trees"><a href="#Leetcode951-Flip-Equivalent-Binary-Trees" class="headerlink" title="Leetcode951. Flip Equivalent Binary Trees"></a>Leetcode951. Flip Equivalent Binary Trees</h1><p>For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.</p>
<p>A binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.</p>
<p>Write a function that determines whether two binary trees are flip equivalent.  The trees are given by root nodes root1 and root2.</p>
<p>Example 1:</p>
<p>Input: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]<br>Output: true<br>Explanation: We flipped at nodes with values 1, 3, and 5.<br><img src="/img/20190827800.png" alt></p>
<p>这种做法好复杂啊。。。有太多情况需要考虑了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(TreeNode* root1, TreeNode* root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root1-&gt;left == <span class="literal">NULL</span> &amp;&amp; root1-&gt;right == <span class="literal">NULL</span> &amp;&amp; root2-&gt;left == <span class="literal">NULL</span> &amp;&amp; root2-&gt;right == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( root1-&gt;left != <span class="literal">NULL</span> &amp;&amp; root1-&gt;right != <span class="literal">NULL</span> &amp;&amp; root2-&gt;left != <span class="literal">NULL</span> &amp;&amp; root2-&gt;right != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">             <span class="keyword">if</span>(root1-&gt;left-&gt;val == root2-&gt;left-&gt;val &amp;&amp; root1-&gt;right-&gt;val == root2-&gt;right-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root1-&gt;right-&gt;val == root2-&gt;left-&gt;val &amp;&amp; root1-&gt;left-&gt;val == root2-&gt;right-&gt;val) &#123;</span><br><span class="line">                TreeNode* temp = root1-&gt;right;</span><br><span class="line">                root1-&gt;right = root1-&gt;left;</span><br><span class="line">                root1-&gt;left = temp;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( root1-&gt;left == <span class="literal">NULL</span> &amp;&amp; root1-&gt;right != <span class="literal">NULL</span> &amp;&amp; root2-&gt;left == <span class="literal">NULL</span> &amp;&amp; root2-&gt;right != <span class="literal">NULL</span> )&#123;</span><br><span class="line">            <span class="keyword">if</span>(root1-&gt;right-&gt;val == root2-&gt;right-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( root1-&gt;left != <span class="literal">NULL</span> &amp;&amp; root1-&gt;right == <span class="literal">NULL</span> &amp;&amp; root2-&gt;left != <span class="literal">NULL</span> &amp;&amp; root2-&gt;right == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root1-&gt;left-&gt;val == root2-&gt;left-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( root1-&gt;left == <span class="literal">NULL</span> &amp;&amp; root1-&gt;right != <span class="literal">NULL</span> &amp;&amp; root2-&gt;left != <span class="literal">NULL</span> &amp;&amp; root2-&gt;right == <span class="literal">NULL</span> )&#123;</span><br><span class="line">            <span class="keyword">if</span>(root1-&gt;right-&gt;val == root2-&gt;left-&gt;val) &#123;</span><br><span class="line">                root1-&gt;left = root1-&gt;right;</span><br><span class="line">                root1-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( root1-&gt;left != <span class="literal">NULL</span> &amp;&amp; root1-&gt;right == <span class="literal">NULL</span> &amp;&amp; root2-&gt;left == <span class="literal">NULL</span> &amp;&amp; root2-&gt;right != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root1-&gt;left-&gt;val == root2-&gt;right-&gt;val) &#123;</span><br><span class="line">                root1-&gt;right = root1-&gt;left;</span><br><span class="line">                root1-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">order</span><span class="params">(TreeNode* root1, TreeNode* root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">NULL</span> &amp;&amp; root2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">NULL</span> || root2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( root1 != <span class="literal">NULL</span> &amp;&amp; root2 != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root1-&gt;val == root2-&gt;val)</span><br><span class="line">                compare(root1, root2);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> order(root1-&gt;left, root2-&gt;left) &amp;&amp; order(root1-&gt;right, root2-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">flipEquiv</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> order(root1, root2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>另一种做法<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">flipEquiv</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Two null trees are flip equivalent</span></span><br><span class="line">        <span class="comment">// A non-null and null tree are NOT flip equivalent</span></span><br><span class="line">        <span class="comment">// Two non-null trees with different root values are NOT flip equivalent</span></span><br><span class="line">        <span class="comment">// Two non-null trees are flip equivalent if</span></span><br><span class="line">        <span class="comment">//      The left subtree of tree1 is flip equivalent with the left subtree of tree2 and the right subtree of tree1 is   </span></span><br><span class="line">        <span class="comment">//      flipequivalent with the right subtree of tree2 (no flip case)</span></span><br><span class="line">        <span class="comment">//      OR</span></span><br><span class="line">        <span class="comment">//      The right subtree of tree1 is flip equivalent with the left subtree of tree2 and the left subtree of tree1 is</span></span><br><span class="line">        <span class="comment">//      flipequivalent with the right subtree of tree2 (flip case)</span></span><br><span class="line">        <span class="keyword">if</span> ( !root1 &amp;&amp; !root2 ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> ( !root1 &amp;&amp; root2 || root1 &amp;&amp;!root2 || root1-&gt;val != root2-&gt;val ) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> flipEquiv( root1-&gt;left, root2-&gt;left ) &amp;&amp; flipEquiv( root1-&gt;right, root2-&gt;right )</span><br><span class="line">            || flipEquiv( root1-&gt;right, root2-&gt;left ) &amp;&amp; flipEquiv( root1-&gt;left, root2-&gt;right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode953-Verifying-an-Alien-Dictionary"><a href="#Leetcode953-Verifying-an-Alien-Dictionary" class="headerlink" title="Leetcode953. Verifying an Alien Dictionary"></a>Leetcode953. Verifying an Alien Dictionary</h1><p>In an alien language, surprisingly they also use english lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.</p>
<p>Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographicaly in this alien language.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;hello&quot;,&quot;leetcode&quot;], order = &quot;hlabcdefgijkmnopqrstuvwxyz&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: As &apos;h&apos; comes before &apos;l&apos; in this language, then the sequence is sorted.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;word&quot;,&quot;world&quot;,&quot;row&quot;], order = &quot;worldabcefghijkmnpqstuvxyz&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: As &apos;d&apos; comes after &apos;l&apos; in this language, then words[0] &gt; words[1], hence the sequence is unsorted.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;apple&quot;,&quot;app&quot;], order = &quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The first three characters &quot;app&quot; match, and the second string is shorter (in size.) According to lexicographical rules &quot;apple&quot; &gt; &quot;app&quot;, because &apos;l&apos; &gt; &apos;∅&apos;, where &apos;∅&apos; is defined as the blank character which is less than any other character (More info).</span><br></pre></td></tr></table></figure></p>
<p>从一个新的字母序判断是不是有序的字符串数组。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAlienSorted</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">string</span> order)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; order.length(); i ++)</span><br><span class="line">            mp[order[i]] = i;</span><br><span class="line">        <span class="keyword">int</span> size = words.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size<span class="number">-1</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> min_size = min(words[i].length(), words[j].length());</span><br><span class="line">            <span class="keyword">int</span> k;</span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; min_size; k ++)</span><br><span class="line">                <span class="keyword">if</span>(mp[words[i][k]] &gt; mp[words[j][k]])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (mp[words[i][k]] &lt; mp[words[j][k]])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">	            <span class="keyword">if</span>(k == min_size &amp;&amp; words[i].length() &gt; words[j].length())</span><br><span class="line">	                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode955-Delete-Columns-to-Make-Sorted-II"><a href="#Leetcode955-Delete-Columns-to-Make-Sorted-II" class="headerlink" title="Leetcode955. Delete Columns to Make Sorted II"></a>Leetcode955. Delete Columns to Make Sorted II</h1><p>We are given an array A of N lowercase letter strings, all of the same length.</p>
<p>Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.</p>
<p>For example, if we have an array A = [“abcdef”,”uvwxyz”] and deletion indices {0, 2, 3}, then the final array after deletions is [“bef”,”vyz”].</p>
<p>Suppose we chose a set of deletion indices D such that after deletions, the final array has its elements in lexicographic order (A[0] &lt;= A[1] &lt;= A[2] … &lt;= A[A.length - 1]).</p>
<p>Return the minimum possible value of D.length.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;ca&quot;,&quot;bb&quot;,&quot;ac&quot;]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation:</span><br><span class="line">After deleting the first column, A = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].</span><br><span class="line">Now A is in lexicographic order (ie. A[0] &lt;= A[1] &lt;= A[2]).</span><br><span class="line">We require at least 1 deletion since initially A was not in lexicographic order, so the answer is 1.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;xc&quot;,&quot;yb&quot;,&quot;za&quot;]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:</span><br><span class="line">A is already in lexicographic order, so we don&apos;t need to delete anything.</span><br><span class="line">Note that the rows of A are not necessarily in lexicographic order:</span><br><span class="line">ie. it is NOT necessarily true that (A[0][0] &lt;= A[0][1] &lt;= ...)</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;zyx&quot;,&quot;wvu&quot;,&quot;tsr&quot;]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">We have to delete every column.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 100</li>
<li>1 &lt;= A[i].length &lt;= 100</li>
</ul>
<p>这道题说是给了一个字符串数组，里面的字符串长度均相同，这样如果将每个字符串看作一个字符数组的话，于是就可以看作的一个二维数组，题目要求数组中的字符串是按照字母顺序的，问最少需要删掉多少列。我们知道比较两个长度相等的字符串的字母顺序时，就是从开头起按照两两对应的位置比较，只要前面的字符顺序已经比出来了，后面的字符的顺序就不用管了，比如 “bx” 和 “ea”，因为 b 比 e 小，所以 “bx” 比 “ea” 小，后面的 x 和 a 的顺序无关紧要。如果看成二维数组的话，在比较<code>A[i][j]</code>和<code>A[i+1][j]</code>时，假如 [0, j-1] 中的某个位置k，已经满足了<code>A[i][k] &lt; A[i+1][k]</code>的话，这里就不用再比了，所以用一个数组 sorted 来标记某相邻的两个字符串之间是否已经按照字母顺序排列了。然后用两个 for 循环，外层是遍历列，内层是遍历行，然后看若<code>sorted[i]</code>为 false，且<code>A[i][j] &gt; A[i + 1][j]</code>的话，说明当前列需要被删除，结果 res 自增1，且 break 掉内层 for 循环。当内层 for 循环 break 掉或者自己结束后，此时看 i 是否小于 m-1，是的话说明是 break 掉的，直接 continue 外层循环。若是自己退出的，则在遍历一遍所有行，更新一下 sorted 数组即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDeletionSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, m = A.size(), n = A[<span class="number">0</span>].size(), i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sorted(m - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!sorted[i] &amp;&amp; A[i][j] &gt; A[i + <span class="number">1</span>][j]) &#123;</span><br><span class="line">                    ++res;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; m - <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                sorted[i] |= A[i][j] &lt; A[i + <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode957-Prison-Cells-After-N-Days"><a href="#Leetcode957-Prison-Cells-After-N-Days" class="headerlink" title="Leetcode957. Prison Cells After N Days"></a>Leetcode957. Prison Cells After N Days</h1><p>There are 8 prison cells in a row, and each cell is either occupied or vacant.</p>
<p>Each day, whether the cell is occupied or vacant changes according to the following rules:</p>
<p>If a cell has two adjacent neighbors that are both occupied or both vacant, then the cell becomes occupied.<br>Otherwise, it becomes vacant.<br>(Note that because the prison is a row, the first and the last cells in the row can’t have two adjacent neighbors.)</p>
<p>We describe the current state of the prison in the following way: cells[i] == 1 if the i-th cell is occupied, else cells[i] == 0.</p>
<p>Given the initial state of the prison, return the state of the prison after N days (and N such changes described above.)</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: cells = [0,1,0,1,1,0,0,1], N = 7</span><br><span class="line">Output: [0,0,1,1,0,0,0,0]</span><br><span class="line">Explanation: The following table summarizes the state of the prison on each day:</span><br><span class="line">Day 0: [0, 1, 0, 1, 1, 0, 0, 1]</span><br><span class="line">Day 1: [0, 1, 1, 0, 0, 0, 0, 0]</span><br><span class="line">Day 2: [0, 0, 0, 0, 1, 1, 1, 0]</span><br><span class="line">Day 3: [0, 1, 1, 0, 0, 1, 0, 0]</span><br><span class="line">Day 4: [0, 0, 0, 0, 0, 1, 0, 0]</span><br><span class="line">Day 5: [0, 1, 1, 1, 0, 1, 0, 0]</span><br><span class="line">Day 6: [0, 0, 1, 0, 1, 1, 0, 0]</span><br><span class="line">Day 7: [0, 0, 1, 1, 0, 0, 0, 0]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: cells = [1,0,0,1,0,0,1,0], N = 1000000000</span><br><span class="line">Output: [0,0,1,1,1,1,1,0]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>cells.length == 8</li>
<li>cells[i] is in {0, 1}</li>
<li>1 &lt;= N &lt;= 10^9</li>
</ul>
<p>这道题给了一个只由0和1构成的数组，数组长度固定为8，现在要进行N步变换，变换的规则是若一个位置的左右两边的数字相同，则该位置的数字变为1，反之则变为0，让求N步变换后的数组的状态。需要注意的数组的开头和结尾的两个位置，由于一个没有左边，一个没有右边，默认其左右两边的数字不相等，所以不管首尾数字初始的时候是啥，在第一次变换之后一定会是0，而且一直会保持0的状态。可能是有一个周期循环的，这样就完全没有必要每次都算一遍。正确的做法的应该是建立状态和当前N值的映射，一旦当前计算出的状态在 HashMap 中出现了，说明周期找到了，这样就可以通过取余来快速的缩小N值。为了使用 HashMap 而不是 TreeMap，这里首先将数组变为字符串，然后开始循环N，将当前状态映射为 N-1，然后新建了一个长度为8，且都是0的字符串。更新的时候不用考虑首尾两个位置，因为前面说了，首尾两个位置一定会变为0。更新完成了后，便在 HashMap 查找这个状态是否出现过，是的话算出周期，然后N对周期取余。最后再把状态字符串转为数组即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prisonAfterNDays(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cells, <span class="keyword">int</span> N) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : cells) str += to_string(num);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            m[str] = N--;</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">cur</span><span class="params">(<span class="number">8</span>, <span class="string">'0'</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">7</span>; ++i) &#123;</span><br><span class="line">                cur[i] = (str[i - <span class="number">1</span>] == str[i + <span class="number">1</span>]) ? <span class="string">'1'</span> : <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            str = cur;</span><br><span class="line">            <span class="keyword">if</span> (m.count(str)) &#123;</span><br><span class="line">                N %= m[str] - N;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : str) res.push_back(c - <span class="string">'0'</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode958-Check-Completeness-of-a-Binary-Tree"><a href="#Leetcode958-Check-Completeness-of-a-Binary-Tree" class="headerlink" title="Leetcode958. Check Completeness of a Binary Tree"></a>Leetcode958. Check Completeness of a Binary Tree</h1><p>Given a binary tree, determine if it is a complete binary tree.</p>
<p>Definition of a complete binary tree from Wikipedia:<br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Every level before the last is full (ie. levels with node-values &#123;1&#125; and &#123;2, 3&#125;), and all nodes in the last level (&#123;4, 5, 6&#125;) are as far left as possible.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,null,7]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The node with value 7 isn&apos;t as far left as possible.</span><br></pre></td></tr></table></figure></p>
<p>用BFS遍历二叉树，当遇到空节点时，如果队列中还有未遍历的节点则该二叉树不完整。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        q.push(root);</span><br><span class="line">        TreeNode* temp;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            temp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="literal">NULL</span>)</span><br><span class="line">                res = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(!res)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                q.push(temp-&gt;left);</span><br><span class="line">                q.push(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode959-Regions-Cut-By-Slashes"><a href="#Leetcode959-Regions-Cut-By-Slashes" class="headerlink" title="Leetcode959. Regions Cut By Slashes"></a>Leetcode959. Regions Cut By Slashes</h1><p>In a N x N grid composed of 1 x 1 squares, each 1 x 1 square consists of a /, \, or blank space.  These characters divide the square into contiguous regions.</p>
<p>(Note that backslash characters are escaped, so a \ is represented as “\\”.)</p>
<p>Return the number of regions.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [</span><br><span class="line">  &quot; /&quot;,</span><br><span class="line">  &quot;/ &quot;</span><br><span class="line">]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Explanation: The 2x2 grid is as follows:<br><img src="/img/20211115105401.png" alt></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [</span><br><span class="line">  &quot; /&quot;,</span><br><span class="line">  &quot;  &quot;</span><br><span class="line">]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Explanation: The 2x2 grid is as follows:<br><img src="/img/20211115105402.png" alt></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [</span><br><span class="line">  &quot;\\/&quot;,</span><br><span class="line">  &quot;/\\&quot;</span><br><span class="line">]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: (Recall that because \ characters are escaped, &quot;\\/&quot; refers to \/, and &quot;/\\&quot; refers to /\.)</span><br></pre></td></tr></table></figure></p>
<p>The 2x2 grid is as follows:<br><img src="/img/20211115105403.png" alt></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [</span><br><span class="line">  &quot;/\\&quot;,</span><br><span class="line">  &quot;\\/&quot;</span><br><span class="line">]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: (Recall that because \ characters are escaped, &quot;/\\&quot; refers to /\, and &quot;\\/&quot; refers to \/.)</span><br></pre></td></tr></table></figure></p>
<p>The 2x2 grid is as follows:<br><img src="/img/20211115105404.png" alt></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [</span><br><span class="line">  &quot;//&quot;,</span><br><span class="line">  &quot;/ &quot;</span><br><span class="line">]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The 2x2 grid is as follows:</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/20211115105405.png" alt></p>
<p>Note:</p>
<ul>
<li>1 &lt;= grid.length == grid[0].length &lt;= 30</li>
<li>grid[i][j] is either ‘/‘, ‘\’, or ‘ ‘.</li>
</ul>
<p>这道题说是有个 NxN 个小方块，每个小方块里可能是斜杠，反斜杠，或者是空格。然后问这些斜杠能将整个区域划分成多少个小区域。这的确是一道很有意思的题目，虽然只是 Medium 的难度，但是博主拿到题目的时候是懵逼的，这尼玛怎么做？无奈只好去论坛上看大神们的解法，结果发现大神们果然牛b，巧妙的将这道题转化为了岛屿个数问题 Number of Islands，具体的做法将每个小区间化为九个小格子，这样斜杠或者反斜杠就是对角线或者逆对角线了，是不是有点图像像素化的感觉，就是当你把某个图片尽可能的放大后，到最后你看到也就是一个个不同颜色的小格子组成了这幅图片。这样只要把斜杠的位置都标记为1，而空白的位置都标记为0，这样只要找出分隔开的0的群组的个数就可以了，就是岛屿个数的问题啦。使用一个 DFS 来遍历即可，这个并不难，这道题难就难在需要想出来这种像素化得转化，确实需要灵光一现啊，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">regionsBySlashes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; nums(<span class="number">3</span> * n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span> * n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'/'</span>) &#123;</span><br><span class="line">                    nums[i * <span class="number">3</span>][j * <span class="number">3</span> + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">                    nums[i * <span class="number">3</span> + <span class="number">1</span>][j * <span class="number">3</span> + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    nums[i * <span class="number">3</span> + <span class="number">2</span>][j * <span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="string">'\\'</span>) &#123;</span><br><span class="line">                    nums[i * <span class="number">3</span>][j * <span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">                    nums[i * <span class="number">3</span> + <span class="number">1</span>][j * <span class="number">3</span> + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    nums[i * <span class="number">3</span> + <span class="number">2</span>][j * <span class="number">3</span> + <span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    helper(nums, i, j);</span><br><span class="line">                    ++res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; i &lt; nums.size() &amp;&amp; j &lt; nums.size() &amp;&amp; nums[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            nums[i][j] = <span class="number">1</span>;</span><br><span class="line">            helper(nums, i - <span class="number">1</span>, j);</span><br><span class="line">            helper(nums, i, j + <span class="number">1</span>);</span><br><span class="line">            helper(nums, i + <span class="number">1</span>, j);</span><br><span class="line">            helper(nums, i, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode961-N-Repeated-Element-in-Size-2N-Array"><a href="#Leetcode961-N-Repeated-Element-in-Size-2N-Array" class="headerlink" title="Leetcode961. N-Repeated Element in Size 2N Array"></a>Leetcode961. N-Repeated Element in Size 2N Array</h1><p>In a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times.</p>
<p>Return the element repeated N times.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,2,5,3,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,1,5,2,5,3,5,4]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>4 &lt;= A.length &lt;= 10000<br>0 &lt;= A[i] &lt; 10000<br>A.length is even</p>
<p>一个桶排序搞定<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">repeatedNTimes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> counter[<span class="number">10000</span>];</span><br><span class="line">        <span class="built_in">memset</span>(counter, <span class="number">0</span>, <span class="keyword">sizeof</span>(counter));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i ++)&#123;</span><br><span class="line">            counter[A[i]] ++;</span><br><span class="line">            <span class="keyword">if</span>(counter[A[i]] &gt;= A.size() / <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>看到了大佬的解法，跪了，如果有两个连续一样的元素，直接返回</p>
<p>The intuition here is that the repeated numbers have to appear either next to each other (A[i] == A[i + 1]), or alternated (A[i] == A[i + 2]).</p>
<p>The only exception is sequences like [2, 1, 3, 2]. In this case, the result is the last number, so we just return it in the end. This solution has O(n) runtime.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int repeatedNTimes(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">  for (auto i = 0; i &lt; A.size() - 2; ++i)</span><br><span class="line">    if (A[i] == A[i + 1] || A[i] == A[i + 2]) return A[i];</span><br><span class="line">  return A[A.size() - 1]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Another interesting approach is to use randomization (courtesy of @lee215 ). If you pick two numbers randomly, there is a 25% chance you bump into the repeated number. So, in average, we will find the answer in 4 attempts, thus O(4) runtime.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int repeatedNTimes(vector&lt;int&gt;&amp; A, int i = 0, int j = 0) &#123;</span><br><span class="line">  while (A[i = rand() % A.size()] != A[j = rand() % A.size()] || i == j);</span><br><span class="line">  return A[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode962-Maximum-Width-Ramp"><a href="#Leetcode962-Maximum-Width-Ramp" class="headerlink" title="Leetcode962. Maximum Width Ramp"></a>Leetcode962. Maximum Width Ramp</h1><p>A ramp in an integer array nums is a pair (i, j) for which i &lt; j and nums[i] &lt;= nums[j]. The width of such a ramp is j - i.</p>
<p>Given an integer array nums, return the maximum width of a ramp in nums. If there is no ramp in nums, return 0.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [6,0,8,2,1,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The maximum width ramp is achieved at (i, j) = (1, 5): nums[1] = 0 and nums[5] = 5.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [9,8,1,0,1,9,4,0,4,1]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: The maximum width ramp is achieved at (i, j) = (2, 9): nums[2] = 1 and nums[9] = 1.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>2 &lt;= nums.length &lt;= 5 * 104</li>
<li>0 &lt;= nums[i] &lt;= 5 * 104</li>
</ul>
<p>这道题说给了一个数组A，这里定义了一种叫做 Ramp 的范围 (i, j)，满足 i &lt; j 且 A[i] &lt;= A[j]，而 ramp 就是 j - i，这里让求最宽的 ramp，若没有，则返回0。其实就是让在数组中找一前一后的两个数字，前面的数字小于等于后面的数字，且两个数字需要相距最远，让求这个最远的距离。先想一下，什么时侯不存在这个 ramp，就是当数组是严格递减的时候，那么不存在前面的数字小于等于后面的数字的情况，于是 ramp 是0。这道题的优化解法应该是使用单调栈。这里用一个数组 idx，来记录一个单调递减数组中数字的下标，遍历原数组A，对于每个遍历到的数字 A[i]，判断若此时下标数组为空，或者当前数字 A[i] 小于该下标数组中最后一个坐标在A中表示的数字时，将当前坐标i加入 idx，继续保持单调递减的顺序。反之，若 A[i] 比较大，则可以用二分搜索法来找出单调递减数组中第一个小于 A[i] 的数字的坐标，这样就可以快速得到 ramp 的大小，并用来更新结果 res 即可，这样整体的复杂度就降到了 O(nlgn)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxWidthRamp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.size() == <span class="number">0</span> || nums[i] &lt;= nums[s.back()])</span><br><span class="line">                s.push_back(i);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> left = <span class="number">0</span>, right = s.size()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (nums[mid] &gt; nums[i])</span><br><span class="line">                        left = mid+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">                res = max(res, i - s[right]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>或者：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxWidthRamp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>, i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; A.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(s.empty() || A[s.top()] &gt; A[i])<span class="comment">//单调递减栈</span></span><br><span class="line">                s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = A.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp; A[i] &gt;= A[s.top()])</span><br><span class="line">            &#123;</span><br><span class="line">                maxlen = max(maxlen, i-s.top());</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode963-Minimum-Area-Rectangle-II"><a href="#Leetcode963-Minimum-Area-Rectangle-II" class="headerlink" title="Leetcode963. Minimum Area Rectangle II"></a>Leetcode963. Minimum Area Rectangle II</h1><p>Given a set of points in the xy-plane, determine the minimum area of any rectangle formed from these points, with sides not necessarily parallel to the x and y axes.</p>
<p>If there isn’t any rectangle, return 0.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2],[2,1],[1,0],[0,1]]</span><br><span class="line">Output: 2.00000</span><br><span class="line">Explanation: The minimum area rectangle occurs at [1,2],[2,1],[1,0],[0,1], with an area of 2.</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/20211115105406.png" alt></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,1],[2,1],[1,1],[1,0],[2,0]]</span><br><span class="line">Output: 1.00000 </span><br><span class="line">Explanation: The minimum area rectangle occurs at [1,0],[1,1],[2,1],[2,0], with an area of 1.</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/20211115105407.png" alt></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,3],[1,2],[3,1],[1,3],[2,1]]</span><br><span class="line">Output: 0 </span><br><span class="line">Explanation: There is no possible rectangle to form from these points.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]]</span><br><span class="line">Output: 2.00000 </span><br><span class="line">Explanation: The minimum area rectangle occurs at [2,1],[2,3],[3,3],[3,1], with an area of 2.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= points.length &lt;= 50</li>
<li>0 &lt;= points[i][0] &lt;= 40000</li>
<li>0 &lt;= points[i][1] &lt;= 40000</li>
<li>All points are distinct.</li>
<li>Answers within 10^-5 of the actual value will be accepted as correct.</li>
</ul>
<p>这道题是之前那道 Minimum Area Rectangle 的拓展，虽说是拓展，但是解题思想完全不同。那道题由于矩形不能随意翻转，所以任意两个相邻的顶点一定是相同的横坐标或者纵坐标，而这道题就不一样了，矩形可以任意翻转，就不能利用之前的特点了。那该怎么办呢，这里就要利用到矩形的对角线的特点了，我们都知道矩形的两条对角线长度是相等的，而且相交于矩形的中心，这个中心可以通过两个对顶点的坐标求出来。只要找到了两组对顶点，它们的中心重合，并且表示的对角线长度相等，则一定可以组成矩形。基于这种思想，可以遍历任意两个顶点，求出它们之间的距离，和中心点的坐标，将这两个信息组成一个字符串，建立和顶点在数组中位置之间的映射，这样能组成矩形的点就被归类到一起了。接下来就是遍历这个 HashMap 了，只能取出两组顶点及更多的地方，开始遍历，分别通过顶点的坐标算出两条边的长度，然后相乘用来更新结果 res 即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">minAreaFreeRect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">double</span> res = DBL_MAX;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">long</span> dist = getLength(points[i], points[j]);</span><br><span class="line">                <span class="keyword">double</span> centerX = (points[i][<span class="number">0</span>] + points[j][<span class="number">0</span>]) / <span class="number">2.0</span>;</span><br><span class="line">                <span class="keyword">double</span> centerY = (points[i][<span class="number">1</span>] + points[j][<span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">                <span class="built_in">string</span> key = to_string(dist) + <span class="string">"_"</span> + to_string(centerX) + <span class="string">"_"</span> + to_string(centerY);</span><br><span class="line">                m[key].push_back(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : m) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec = a.second;</span><br><span class="line">            <span class="keyword">if</span> (vec.size() &lt; <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.size(); ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; vec.size(); ++j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> p1 = vec[i][<span class="number">0</span>], p2 = vec[j][<span class="number">0</span>], p3 = vec[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">double</span> len1 = <span class="built_in">sqrt</span>(getLength(points[p1], points[p2]));</span><br><span class="line">                    <span class="keyword">double</span> len2 = <span class="built_in">sqrt</span>(getLength(points[p1], points[p3]));</span><br><span class="line">                    res = min(res, len1 * len2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == DBL_MAX ? <span class="number">0.0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pt1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pt2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (pt1[<span class="number">0</span>] - pt2[<span class="number">0</span>]) * (pt1[<span class="number">0</span>] - pt2[<span class="number">0</span>]) + (pt1[<span class="number">1</span>] - pt2[<span class="number">1</span>]) * (pt1[<span class="number">1</span>] - pt2[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode965-Univalued-Binary-Tree"><a href="#Leetcode965-Univalued-Binary-Tree" class="headerlink" title="Leetcode965. Univalued Binary Tree"></a>Leetcode965. Univalued Binary Tree</h1><p>A binary tree is univalued if every node in the tree has the same value.</p>
<p>Return true if and only if the given tree is univalued.</p>
<p>Example 1:<br><img src="/img/20190524001.png" alt><br>Input: [1,1,1,1,1,null,1]<br>Output: true</p>
<p>Example 2:<br><img src="/img/20190524002.png" alt><br>Input: [2,2,2,5,2]<br>Output: false</p>
<p>Note:</p>
<p>The number of nodes in the given tree will be in the range [1, 100].<br>Each node’s value will be an integer in the range [0, 99].<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">des</span><span class="params">(TreeNode* root,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val != val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> des(root-&gt;left,val)&amp;&amp;des(root-&gt;right,val);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isUnivalTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> des(root,root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode966-Vowel-Spellchecker"><a href="#Leetcode966-Vowel-Spellchecker" class="headerlink" title="Leetcode966. Vowel Spellchecker"></a>Leetcode966. Vowel Spellchecker</h1><p>Given a wordlist, we want to implement a spellchecker that converts a query word into a correct word.</p>
<p>For a given query word, the spell checker handles two categories of spelling mistakes:</p>
<ul>
<li>Capitalization: If the query matches a word in the wordlist (case-insensitive), then the query word is returned with the same case as the case in the wordlist.<ul>
<li>Example: wordlist = [“yellow”], query = “YellOw”: correct = “yellow”</li>
<li>Example: wordlist = [“Yellow”], query = “yellow”: correct = “Yellow”</li>
<li>Example: wordlist = [“yellow”], query = “yellow”: correct = “yellow”</li>
</ul>
</li>
<li>Vowel Errors: If after replacing the vowels (‘a’, ‘e’, ‘i’, ‘o’, ‘u’) of the query word with any vowel individually, it matches a word in the wordlist - (case-insensitive), then the query word is returned with the same case as the match in the wordlist.<ul>
<li>Example: wordlist = [“YellOw”], query = “yollow”: correct = “YellOw”</li>
<li>Example: wordlist = [“YellOw”], query = “yeellow”: correct = “” (no match)</li>
<li>Example: wordlist = [“YellOw”], query = “yllw”: correct = “” (no match)</li>
</ul>
</li>
</ul>
<p>In addition, the spell checker operates under the following precedence rules:</p>
<ul>
<li>When the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back.</li>
<li>When the query matches a word up to capitlization, you should return the first such match in the wordlist.</li>
<li>When the query matches a word up to vowel errors, you should return the first such match in the wordlist.</li>
<li>If the query has no matches in the wordlist, you should return the empty string.</li>
</ul>
<p>Given some queries, return a list of words answer, where answer[i] is the correct word for query = queries[i].</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: wordlist = [&quot;KiTe&quot;,&quot;kite&quot;,&quot;hare&quot;,&quot;Hare&quot;], queries = [&quot;kite&quot;,&quot;Kite&quot;,&quot;KiTe&quot;,&quot;Hare&quot;,&quot;HARE&quot;,&quot;Hear&quot;,&quot;hear&quot;,&quot;keti&quot;,&quot;keet&quot;,&quot;keto&quot;]</span><br><span class="line">Output: [&quot;kite&quot;,&quot;KiTe&quot;,&quot;KiTe&quot;,&quot;Hare&quot;,&quot;hare&quot;,&quot;&quot;,&quot;&quot;,&quot;KiTe&quot;,&quot;&quot;,&quot;KiTe&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= wordlist.length &lt;= 5000</li>
<li>1 &lt;= queries.length &lt;= 5000</li>
<li>1 &lt;= wordlist[i].length &lt;= 7</li>
<li>1 &lt;= queries[i].length &lt;= 7</li>
<li>All strings in wordlist and queries consist only of english letters.</li>
</ul>
<p>这道题给了一组单词，让实现一个拼写检查器，把查询单词转换成一个正确的单词。这个拼写检查器主要有两种功能，一种是可以忽略大小写，另一种是忽略元音的错误，所谓元音是 a，e，i，o，u，这五个字母。另外题目中还制定了一些其他规则：假如有和查询单词一模一样的单词，考虑大小写，此时应该优先返回。第二个优先级是字母及顺序都一样，但大小写可能不同的，第三个优先级是有元音错误的单词也可以返回，最后都不满足的话返回空串。首先对于第一种情况，返回和查询单词一模一样的单词，很简单，将所有单词放入一个 HashSet 中，这样就可以快速确定一个查询单词是否在原单词数组中出现过。对于第二种情况，做法是将每个单词都转为小写，然后建立小写单词和原单词之间都映射，注意对于转为小写后相同都单词，我们只映射第一个出现该小写状态的单词，后面的不用管。对于第三种情况，对于每个单词，转为小写之后，然后把所有的元音字母用特殊字符替代，比如下划线，然后也是建立这种特殊处理后的状态和原单词之间的映射。当映射都建立好了之后，就可以遍历所有的查询单词了，首先是去 HashSet 中找，若有跟该查询单词一模一样的，直接加入结果 res 中。若没有，则先将查询单词变为小写，然后去第一个 HashMap 中查找，若存在，直接加入结果 res 中。若没有，再把所有的元音变为下划线，去第二个 HashMap 中查找，存在则直接加入结果 res 中。若没有，则将空串加入结果 res 中，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">tolower</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'Z'</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">char</span>)(c + <span class="number">32</span>);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; spellchecker(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordlist, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; st;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; map_v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordlist.size(); i ++) &#123;</span><br><span class="line">            <span class="built_in">string</span> word = wordlist[i];</span><br><span class="line">            st.insert(word);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; word.length(); j ++)</span><br><span class="line">                word[j] = <span class="built_in">tolower</span>(word[j]);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">map</span>.count(word))</span><br><span class="line">                <span class="built_in">map</span>[word] = wordlist[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; word.length(); j ++)</span><br><span class="line">                <span class="keyword">if</span> (word[j] == <span class="string">'a'</span> || word[j] == <span class="string">'e'</span> || word[j] == <span class="string">'i'</span> || word[j] == <span class="string">'o'</span> || word[j] == <span class="string">'u'</span>)</span><br><span class="line">                    word[j] = <span class="string">'_'</span>;</span><br><span class="line">            <span class="keyword">if</span> (!map_v.count(word))</span><br><span class="line">                map_v[word] = wordlist[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span>&amp; query : queries) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st.count(query)) &#123;</span><br><span class="line">                res.push_back(query);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; query.length(); j ++)</span><br><span class="line">                query[j] = <span class="built_in">tolower</span>(query[j]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.count(query)) &#123;</span><br><span class="line">                res.push_back(<span class="built_in">map</span>[query]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; query.length(); j ++)</span><br><span class="line">                <span class="keyword">if</span> (query[j] == <span class="string">'a'</span> || query[j] == <span class="string">'e'</span> || query[j] == <span class="string">'i'</span> || query[j] == <span class="string">'o'</span> || query[j] == <span class="string">'u'</span>)</span><br><span class="line">                    query[j] = <span class="string">'_'</span>;</span><br><span class="line">            <span class="keyword">if</span> (map_v.count(query)) &#123;</span><br><span class="line">                res.push_back(map_v[query]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode969-Pancake-Sorting"><a href="#Leetcode969-Pancake-Sorting" class="headerlink" title="Leetcode969. Pancake Sorting"></a>Leetcode969. Pancake Sorting</h1><p>Given an array of integers arr, sort the array by performing a series of pancake flips.</p>
<p>In one pancake flip we do the following steps:</p>
<ul>
<li>Choose an integer k where 1 &lt;= k &lt;= arr.length.</li>
<li>Reverse the sub-array arr[1…k].</li>
</ul>
<p>For example, if arr = [3,2,1,4] and we performed a pancake flip choosing k = 3, we reverse the sub-array [3,2,1], so arr = [1,2,3,4] after the pancake flip at k = 3.</p>
<p>Return the k-values corresponding to a sequence of pancake flips that sort arr. Any valid answer that sorts the array within 10 * arr.length flips will be judged as correct.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [3,2,4,1]</span><br><span class="line">Output: [4,2,4,3]</span><br><span class="line">Explanation:</span><br><span class="line">We perform 4 pancake flips, with k values 4, 2, 4, and 3.</span><br><span class="line">Starting state: arr = [3, 2, 4, 1]</span><br><span class="line">After 1st flip (k = 4): arr = [1, 4, 2, 3]</span><br><span class="line">After 2nd flip (k = 2): arr = [4, 1, 2, 3]</span><br><span class="line">After 3rd flip (k = 4): arr = [3, 2, 1, 4]</span><br><span class="line">After 4th flip (k = 3): arr = [1, 2, 3, 4], which is sorted.</span><br></pre></td></tr></table></figure></p>
<p>Notice that we return an array of the chosen k values of the pancake flips.</p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,2,3]</span><br><span class="line">Output: []</span><br><span class="line">Explanation: The input is already sorted, so there is no need to flip anything.</span><br></pre></td></tr></table></figure></p>
<p>Note that other answers, such as [3, 3], would also be accepted.</p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= arr.length &lt;= 100</li>
<li>1 &lt;= arr[i] &lt;= arr.length</li>
<li>All integers in arr are unique (i.e. arr is a permutation of the integers from 1 to arr.length).</li>
</ul>
<p>这道题给了长度为n的数组，由1到n的组成，顺序是打乱的。现在说我们可以任意翻转前k个数字，k的范围是1到n，问怎么个翻转法能将数组翻成有序的。题目说并不限定具体的翻法，只要在 10*n 的次数内翻成有序的都是可以的，任你随意翻，就算有无效的步骤也无所谓。题目中给的例子1其实挺迷惑的，因为并不知道为啥要那样翻，也没有一个固定的翻法，所以可能会误导大家。必须要自己想出一个固定的翻法，这样才能应对所有的情况。每次先将数组中最大数字找出来，然后将最大数字翻转到首位置，然后翻转整个数组，这样最大数字就跑到最后去了。然后将最后面的最大数字去掉，这样又重现一样的情况，重复同样的步骤，直到数组只剩一个数字1为止，在过程中就把每次要翻转的位置都记录到结果 res 中就可以了，注意这里 C++ 的翻转函数 reverse 的结束位置是开区间，很容易出错，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pancakeSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.size(), j; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; arr[j] != i; ++j);</span><br><span class="line">            reverse(arr.begin(), arr.begin() + j + <span class="number">1</span>);</span><br><span class="line">            res.push_back(j + <span class="number">1</span>);</span><br><span class="line">            reverse(arr.begin(), arr.begin() + i);</span><br><span class="line">            res.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode970-Powerful-Integers"><a href="#Leetcode970-Powerful-Integers" class="headerlink" title="Leetcode970. Powerful Integers"></a>Leetcode970. Powerful Integers</h1><p>Given two positive integers x and y, an integer is powerful if it is equal to x^i + y^j for some integers i &gt;= 0 and j &gt;= 0. Return a list of all powerful integers that have value less than or equal to bound.</p>
<p>You may return the answer in any order.  In your answer, each value should occur at most once.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: x = 2, y = 3, bound = 10</span><br><span class="line">Output: [2,3,4,5,7,9,10]</span><br><span class="line">Explanation: </span><br><span class="line">2 = 2^0 + 3^0</span><br><span class="line">3 = 2^1 + 3^0</span><br><span class="line">4 = 2^0 + 3^1</span><br><span class="line">5 = 2^1 + 3^1</span><br><span class="line">7 = 2^2 + 3^1</span><br><span class="line">9 = 2^3 + 3^0</span><br><span class="line">10 = 2^0 + 3^2</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: x = 3, y = 5, bound = 15</span><br><span class="line">Output: [2,4,6,8,10,14]</span><br></pre></td></tr></table></figure></p>
<p>方法很简单，如果x/y等于1，那么幂值只会是1；如果x/y 大于1，由于 bound &lt;= 10^6，幂的最大值是20(pow(2,20) &gt; 10^6)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; powerfulIntegers(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> bound) &#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">long</span> temp;</span><br><span class="line">        <span class="keyword">int</span> x_max = x &gt; <span class="number">1</span> ? <span class="number">20</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y_max = y &gt; <span class="number">1</span> ? <span class="number">20</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; x_max &amp;&amp; <span class="built_in">pow</span>(x, i) &lt;= bound; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; y_max &amp;&amp; <span class="built_in">pow</span>(y, j) &lt;= bound; j ++) &#123;</span><br><span class="line">                temp = <span class="built_in">pow</span>(x, i) + <span class="built_in">pow</span>(y, j);</span><br><span class="line">                <span class="keyword">if</span>(temp &lt;= bound) </span><br><span class="line">                    res.insert(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(res.begin(), res.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode971-Flip-Binary-Tree-To-Match-Preorder-Traversal"><a href="#Leetcode971-Flip-Binary-Tree-To-Match-Preorder-Traversal" class="headerlink" title="Leetcode971. Flip Binary Tree To Match Preorder Traversal"></a>Leetcode971. Flip Binary Tree To Match Preorder Traversal</h1><p>Given a binary tree with N nodes, each node has a different value from {1, …, N}.</p>
<p>A node in this binary tree can be flipped by swapping the left child and the right child of that node.</p>
<p>Consider the sequence of N values reported by a preorder traversal starting from the root.  Call such a sequence of N values the voyage of the tree.</p>
<p>(Recall that a preorder traversal of a node means we report the current node’s value, then preorder-traverse the left child, then preorder-traverse the right child.)</p>
<p>Our goal is to flip the least number of nodes in the tree so that the voyage of the tree matches the voyage we are given.</p>
<p>If we can do so, then return a list of the values of all nodes flipped.  You may return the answer in any order.</p>
<p>If we cannot do so, then return the list [-1].</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2], voyage = [2,1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3], voyage = [1,3,2]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3], voyage = [1,2,3]</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure></p>
<p>最少翻转哪些节点，能使得二叉树的前序遍历变成voyage.</p>
<p>其实这个题不难，因为题目就说了是前序遍历，所以做法肯定还是前序遍历。我刚开始一直想不通的地方在于，题目又是返回[-1]，又是正常返回，没想好怎么做区分。其实做法就是递归函数不仅要修改res数组，还要返回表示能不能构成题目条件的bool变量。</p>
<p>看到二叉树的题，很大可能就需要递归，所以直接先写出dfs函数，然后再慢慢向里面填东西。</p>
<p>我们定义的dfs函数意义是，我们能不能通过翻转（或者不翻转）该root节点的左右子树，得到对应v。如果能，返回true，否则返回false。</p>
<p>首先在递归函数中，我们对root节点进行判断，如果root不存在，这种情况不应该认为是题目输入错误，而是应该认为已经遍历到最底部了，这个时候相当于<code>root = []</code>, <code>voyage = []</code>，所以返回true；在先序遍历的时候，root节点是第一个要被遍历到的节点，如果不和voyage[0]相等，直接返回false;</p>
<p>这个题目的难点在于是否需要翻转一个节点的左右孩子。判断的方法其实是简单的：如果voyage第二个元素等于root的左孩子，那么说明不用翻转，直接递归调用左右孩子；否则如果voyage的第二个元素等于root的右孩子，那么还要注意一下，在左孩子存在的情况下，我们需要翻转当前的节点左右孩子。</p>
<p>翻转是什么概念呢？这里并没有直接交换，而是把当前遍历到的位置使用遍历i保存起来，这样voyage[i]就表示当前遍历到哪个位置了。所以dfs调用两个孩子的顺序很讲究，它体现了先序遍历先解决哪个树的问题，也就是完成了逻辑上的交换左右孩子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; voyage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val != voyage[i++])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left &amp;&amp; root-&gt;left-&gt;val == voyage[i])</span><br><span class="line">            <span class="keyword">return</span> dfs(root-&gt;left, voyage) &amp;&amp; dfs(root-&gt;right, voyage);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right &amp;&amp; root-&gt;right-&gt;val == voyage[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">                ans.push_back(root-&gt;val);</span><br><span class="line">            <span class="keyword">return</span> dfs(root-&gt;right, voyage) &amp;&amp; dfs(root-&gt;left, voyage);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> !root-&gt;left &amp;&amp; !root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; flipMatchVoyage(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; voyage) &#123;</span><br><span class="line">        <span class="keyword">if</span>(dfs(root, voyage))</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode973-K-Closest-Points-to-Origin"><a href="#Leetcode973-K-Closest-Points-to-Origin" class="headerlink" title="Leetcode973. K Closest Points to Origin"></a>Leetcode973. K Closest Points to Origin</h1><p>We have a list of points on the plane.  Find the K closest points to the origin (0, 0).</p>
<p>(Here, the distance between two points on a plane is the Euclidean distance.)</p>
<p>You may return the answer in any order.  The answer is guaranteed to be unique (except for the order that it is in.)</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[1,3],[-2,2]], K = 1</span><br><span class="line">Output: [[-2,2]]</span><br><span class="line">Explanation:</span><br><span class="line">The distance between (1, 3) and the origin is sqrt(10).</span><br><span class="line">The distance between (-2, 2) and the origin is sqrt(8).</span><br><span class="line">Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.</span><br><span class="line">We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: points = [[3,3],[5,-1],[-2,4]], K = 2</span><br><span class="line">Output: [[3,3],[-2,4]]</span><br><span class="line">(The answer [[-2,4],[3,3]] would also be accepted.)</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= K &lt;= points.length &lt;= 10000</li>
<li>-10000 &lt; points[i][0] &lt; 10000</li>
<li>-10000 &lt; points[i][1] &lt; 10000</li>
</ul>
<p>这道题给了平面上的一系列的点，让求最接近原点的K个点。基本上没有什么难度，无非就是要知道点与点之间的距离该如何求。一种比较直接的方法就是给这个二维数组排序，自定义排序方法，按照离原点的距离从小到大排序，注意这里我们并不需要求出具体的距离值，只要知道互相的大小关系即可，所以并不需要开方。排好序之后，返回前k个点即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; kClosest(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        sort(points.begin(), points.end(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] * a[<span class="number">0</span>] + a[<span class="number">1</span>] * a[<span class="number">1</span>] &lt; b[<span class="number">0</span>] * b[<span class="number">0</span>] + b[<span class="number">1</span>] * b[<span class="number">1</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(points.begin(), points.begin() + K);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面这种解法是使用最大堆 Max Heap 来做的，在 C++ 中就是用优先队列来做，这里维护一个大小为k的最大堆，里面放一个 pair 对儿，由距离原点的距离，和该点在原数组中的下标组成，这样优先队列就可以按照到原点的距离排队了，距离大的就在队首。这样每当个数超过k个了之后，就将队首的元素移除即可，最后把剩下的k个点存入结果 res 中即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; kClosest(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = points[i][<span class="number">0</span>] * points[i][<span class="number">0</span>] + points[i][<span class="number">1</span>] * points[i][<span class="number">1</span>];</span><br><span class="line">            pq.push(&#123;t, i&#125;);</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &gt; K) pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = pq.top(); pq.pop();</span><br><span class="line">            res.push_back(points[t.second]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>借鉴快速排序的思想：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">comp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1[<span class="number">0</span>] * p1[<span class="number">0</span>] + p1[<span class="number">1</span>] * p1[<span class="number">1</span>] - p2[<span class="number">0</span>] * p2[<span class="number">0</span>] - p2[<span class="number">1</span>] * p2[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; priot = points[l];</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; comp(points[r], priot) &gt;= <span class="number">0</span>) r --;</span><br><span class="line">            points[l] = points[r];</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; comp(points[l], priot) &lt;= <span class="number">0</span>) l ++;</span><br><span class="line">            points[r] = points[l];</span><br><span class="line">        &#125;</span><br><span class="line">        points[l] = priot;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; kClosest(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = points.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = helper(points, l, r);</span><br><span class="line">            <span class="keyword">if</span> (mid == k)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mid &gt; k)</span><br><span class="line">                r = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i ++)</span><br><span class="line">            res.push_back(points[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode976-Largest-Perimeter-Triangle"><a href="#Leetcode976-Largest-Perimeter-Triangle" class="headerlink" title="Leetcode976. Largest Perimeter Triangle"></a>Leetcode976. Largest Perimeter Triangle</h1><p>Given an array A of positive lengths, return the largest perimeter of a triangle with non-zero area, formed from 3 of these lengths.</p>
<p>If it is impossible to form any triangle of non-zero area, return 0.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,2]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,3,4]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,6,2,3]</span><br><span class="line">Output: 8</span><br></pre></td></tr></table></figure></p>
<p>三角形的条件：两边之和&gt;第三边。</p>
<p>若要构成最大的三角形周长，只需要对数组排序，一直取出最大的三个值作为三角形的边，符合条件即可返回。</p>
<p>证明：若数组A为自然顺序，A[N]&gt;=A[N-1]+A[N-2]，则A[N]&gt;=A[N-1]+A[N-3]，A[N]与后面的数字更不可能构成三角形，可以直接排除。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        sort(A.begin(), A.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = A.size() - <span class="number">1</span>; i &gt;= <span class="number">2</span>; i --) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i - <span class="number">2</span>] + A[i - <span class="number">1</span>] &gt; A[i])</span><br><span class="line">                <span class="keyword">return</span> A[i - <span class="number">2</span>] + A[i - <span class="number">1</span>] + A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode977-Squares-of-a-Sorted-Array"><a href="#Leetcode977-Squares-of-a-Sorted-Array" class="headerlink" title="Leetcode977. Squares of a Sorted Array"></a>Leetcode977. Squares of a Sorted Array</h1><p>Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [-4,-1,0,3,10]</span><br><span class="line">Output: [0,1,9,16,100]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [-7,-3,2,3,11]</span><br><span class="line">Output: [4,9,9,49,121]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 10000</li>
<li>-10000 &lt;= A[i] &lt;= 10000</li>
<li>A is sorted in non-decreasing order.</li>
</ul>
<p>给一个vector，有正有负，输出排序之后的平方数组。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortedSquares(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(A.size());</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = A.size()<span class="number">-1</span>, p = A.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            res[p--] = <span class="built_in">pow</span>(A[<span class="built_in">abs</span>(A[l]) &gt; <span class="built_in">abs</span>(A[r]) ? l++ : r--],<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>另一种方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortedSquares(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(A.size());</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; A.size() &amp;&amp; A[i] &lt; <span class="number">0</span>)</span><br><span class="line">            i ++;</span><br><span class="line">        j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; i &lt; A.size())&#123;</span><br><span class="line">            res[k++] = <span class="built_in">pow</span>(A[<span class="built_in">abs</span>(A[i]) &lt; <span class="built_in">abs</span>(A[j]) ? i ++ : j --], <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)</span><br><span class="line">            res[k++]=<span class="built_in">pow</span>(A[j--],<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">while</span>(i&lt;A.size())</span><br><span class="line">            res[k++]=<span class="built_in">pow</span>(A[i++],<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode978-Longest-Turbulent-Subarray"><a href="#Leetcode978-Longest-Turbulent-Subarray" class="headerlink" title="Leetcode978. Longest Turbulent Subarray"></a>Leetcode978. Longest Turbulent Subarray</h1><p>A subarray A[i], A[i+1], …, A[j] of A is said to be turbulent if and only if:</p>
<ul>
<li>For i &lt;= k &lt; j, A[k] &gt; A[k+1] when k is odd, and A[k] &lt; A[k+1] when k is even;</li>
<li>OR, for i &lt;= k &lt; j, A[k] &gt; A[k+1] when k is even, and A[k] &lt; A[k+1] when k is odd.</li>
</ul>
<p>That is, the subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.</p>
<p>Return the length of a maximum size turbulent subarray of A.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [9,4,2,10,7,8,8,1,9]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: (A[1] &gt; A[2] &lt; A[3] &gt; A[4] &lt; A[5])</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,8,12,16]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [100]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>隐藏很深的dp<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sizee = A.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; up(sizee, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; down(sizee, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sizee; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt; A[i - <span class="number">1</span>])</span><br><span class="line">                up[i] = down[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &lt; A[i - <span class="number">1</span>])</span><br><span class="line">                down[i] = up[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            res = max(res, max(up[i], down[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>首先预处理一下，记录数组中数字变化趋势，1增加-1减少0不变，然后得到一个新的数组，为了省空间我直接在原来数组进行操作的，也可以开辟个新的数组。然后比较相邻数变化即可，若相邻数字乘积为负，则说明满足湍流数组性质，累加记录其长度。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxTurbulenceSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sizee = A.size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sizee; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt; A[i - <span class="number">1</span>])</span><br><span class="line">                A[i<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(A[i] &lt; A[i + <span class="number">1</span>])</span><br><span class="line">                A[i<span class="number">-1</span>] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                A[i<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sizee - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; sizee - <span class="number">1</span> &amp;&amp; A[i] * A[i<span class="number">-1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                count ++;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, count);</span><br><span class="line">            count = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode979-Distribute-Coins-in-Binary-Tree"><a href="#Leetcode979-Distribute-Coins-in-Binary-Tree" class="headerlink" title="Leetcode979. Distribute Coins in Binary Tree"></a>Leetcode979. Distribute Coins in Binary Tree</h1><p>Given the root of a binary tree with N nodes, each node in the tree has node.val coins, and there are N coins total.</p>
<p>In one move, we may choose two adjacent nodes and move one coin from one node to another.  (The move may be from parent to child, or from child to parent.)</p>
<p>Return the number of moves required to make every node have exactly one coin.</p>
<p>Example 1:<br><img src="/img/20190824002.png" alt></p>
<p>Input: [3,0,0]<br>Output: 2<br>Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.</p>
<p>Example 2:<br><img src="/img/20190824003.png" alt></p>
<p>Input: [0,3,0]<br>Output: 3<br>Explanation: From the left child of the root, we move two coins to the root [taking two moves].  Then, we move one coin from the root of the tree to the right child.</p>
<p>Example 3:<br><img src="/img/20190824004.png" alt></p>
<p>Input: [1,0,2]<br>Output: 2</p>
<p>Example 4:<br><img src="/img/20190824005.png" alt></p>
<p>Input: [1,0,0,null,3]<br>Output: 4</p>
<p>Note:</p>
<p>1&lt;= N &lt;= 100<br>0 &lt;= node.val &lt;= N</p>
<p>给你一个二叉树，对于每个节点的val，每次只能往父亲或者儿子移动1，最后使得所有节点值都为1，求最小的移动次数。</p>
<p>思路：从叶子到根寻找，对于每个节点，只能剩下一个。多了的值肯定要全给父亲，少的值全问父亲要，统计一下就好了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">distributeCoins</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = dfs(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = dfs(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        ans += <span class="built_in">abs</span>(left) + <span class="built_in">abs</span>(right);</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val <span class="number">-1</span> + left + right ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode980-Unique-Paths-III"><a href="#Leetcode980-Unique-Paths-III" class="headerlink" title="Leetcode980. Unique Paths III"></a>Leetcode980. Unique Paths III</h1><p>On a 2-dimensional grid, there are 4 types of squares:</p>
<p><code>1</code> represents the starting square.  There is exactly one starting square.<br><code>2</code> represents the ending square.  There is exactly one ending square.<br><code>0</code> represents empty squares we can walk over.<br><code>-1</code> represents obstacles that we cannot walk over.<br>Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: We have the following two paths: </span><br><span class="line">1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)</span><br><span class="line">2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,0,0,0],[0,0,0,0],[0,0,0,2]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: We have the following four paths: </span><br><span class="line">1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)</span><br><span class="line">2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)</span><br><span class="line">3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)</span><br><span class="line">4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,1],[2,0]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: </span><br><span class="line">There is no path that walks over every empty square exactly once.</span><br><span class="line">Note that the starting and ending square can be anywhere in the grid.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= grid.length * grid[0].length &lt;= 20</p>
<p>给了一个二维矩阵，1代表起点，2代表终点，0代表可以走的格子，-1代表障碍物。求从起点到终点，把所有的可以走的格子都遍历一遍，所有可能的不同路径数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsIII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> M=grid.size();</span><br><span class="line">        <span class="keyword">int</span> zerosize=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> N=grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">0</span>)</span><br><span class="line">                    zerosize++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;N;j++)</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)</span><br><span class="line">                    dfs(grid,i,j,<span class="number">0</span>,zerosize,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> pathcount, <span class="keyword">int</span> zerocount, <span class="keyword">int</span>&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid[x][y]==<span class="number">2</span> &amp;&amp; zerocount == pathcount )&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> M=grid.size();</span><br><span class="line">        <span class="keyword">int</span> N=grid[<span class="number">0</span>].size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> pre=grid[x][y];</span><br><span class="line">        <span class="keyword">if</span>(pre==<span class="number">0</span>)</span><br><span class="line">            pathcount++;</span><br><span class="line">        grid[x][y]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> d : dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x + d.first;</span><br><span class="line">            <span class="keyword">int</span> ny = y + d.second;</span><br><span class="line">            <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= M || ny &lt; <span class="number">0</span> || ny &gt;= N || grid[nx][ny] == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            dfs(grid, nx, ny, pathcount, zerocount, res);</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y]=pre;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode981-Time-Based-Key-Value-Store"><a href="#Leetcode981-Time-Based-Key-Value-Store" class="headerlink" title="Leetcode981. Time Based Key-Value Store"></a>Leetcode981. Time Based Key-Value Store</h1><p>Create a timebased key-value store class TimeMap, that supports two operations.</p>
<ul>
<li>set(string key, string value, int timestamp):Stores the key and value, along with the given timestamp.</li>
<li>get(string key, int timestamp)<ul>
<li>Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev &lt;= timestamp.</li>
<li>If there are multiple such values, it returns the one with the largest timestamp_prev.</li>
<li>If there are no values, it returns the empty string (“”).</li>
</ul>
</li>
</ul>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: inputs = [&quot;TimeMap&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;,&quot;set&quot;,&quot;get&quot;,&quot;get&quot;], inputs = [[],[&quot;foo&quot;,&quot;bar&quot;,1],[&quot;foo&quot;,1],[&quot;foo&quot;,3],[&quot;foo&quot;,&quot;bar2&quot;,4],[&quot;foo&quot;,4],[&quot;foo&quot;,5]]</span><br><span class="line">Output: [null,null,&quot;bar&quot;,&quot;bar&quot;,null,&quot;bar2&quot;,&quot;bar2&quot;]</span><br><span class="line">Explanation:   </span><br><span class="line">TimeMap kv;   </span><br><span class="line">kv.set(&quot;foo&quot;, &quot;bar&quot;, 1); // store the key &quot;foo&quot; and value &quot;bar&quot; along with timestamp = 1   </span><br><span class="line">kv.get(&quot;foo&quot;, 1);  // output &quot;bar&quot;   </span><br><span class="line">kv.get(&quot;foo&quot;, 3); // output &quot;bar&quot; since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 ie &quot;bar&quot;   </span><br><span class="line">kv.set(&quot;foo&quot;, &quot;bar2&quot;, 4);   </span><br><span class="line">kv.get(&quot;foo&quot;, 4); // output &quot;bar2&quot;   </span><br><span class="line">kv.get(&quot;foo&quot;, 5); //output &quot;bar2&quot;</span><br></pre></td></tr></table></figure></p>
<p>这个题太麻烦了，没有耐心做了，只看了看，本来想用很好的方法，比如二分实现一下，但是发现这种简单粗暴的方法竟然也能过，就算了……<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeMap</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;&gt; mp;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tvec;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">  TimeMap() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="built_in">string</span> key, <span class="built_in">string</span> value, <span class="keyword">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">      mp[key][timestamp] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">get</span><span class="params">(<span class="built_in">string</span> key, <span class="keyword">int</span> timestamp)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!mp.count(key)) </span><br><span class="line">			<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">		<span class="keyword">if</span>(mp[key].count(timestamp)) </span><br><span class="line">			<span class="keyword">return</span> mp[key][timestamp];</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">auto</span> it = mp[key].rbegin(); it != mp[key].rend(); it++) &#123;</span><br><span class="line">    		<span class="keyword">if</span>(it-&gt;first &gt; timestamp) </span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">        	<span class="keyword">else</span> </span><br><span class="line">				<span class="keyword">return</span> it-&gt;second;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode983-Minimum-Cost-For-Tickets"><a href="#Leetcode983-Minimum-Cost-For-Tickets" class="headerlink" title="Leetcode983. Minimum Cost For Tickets"></a>Leetcode983. Minimum Cost For Tickets</h1><p>In a country popular for train travel, you have planned some train travelling one year in advance.  The days of the year that you will travel is given as an array days.  Each day is an integer from 1 to 365.</p>
<p>Train tickets are sold in 3 different ways:</p>
<ul>
<li>a 1-day pass is sold for costs[0] dollars;</li>
<li>a 7-day pass is sold for costs[1] dollars;</li>
<li>a 30-day pass is sold for costs[2] dollars.</li>
</ul>
<p>The passes allow that many days of consecutive travel.  For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8.</p>
<p>Return the minimum number of dollars you need to travel every day in the given list of days. </p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: days = [1,4,6,7,8,20], costs = [2,7,15]</span><br><span class="line">Output: 11</span><br><span class="line">Explanation: </span><br><span class="line">For example, here is one way to buy passes that lets you travel your travel plan:</span><br><span class="line">On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.</span><br><span class="line">On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.</span><br><span class="line">On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.</span><br><span class="line">In total you spent $11 and covered all the days of your travel.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]</span><br><span class="line">Output: 17</span><br><span class="line">Explanation: </span><br><span class="line">For example, here is one way to buy passes that lets you travel your travel plan:</span><br><span class="line">On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.</span><br><span class="line">On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.</span><br><span class="line">In total you spent $17 and covered all the days of your travel.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= days.length &lt;= 365</li>
<li>1 &lt;= days[i] &lt;= 365</li>
<li>days is in strictly increasing order.</li>
<li>costs.length == 3</li>
<li>1 &lt;= costs[i] &lt;= 1000</li>
</ul>
<p>days数组中存储的是该年中去旅游的日期（范围为1到365之间的数字），costs数组大小为3，存储的是1天，7天和30天火车票的价格。我们需要做一个方案选择合适的购票方案达到旅游days天最省钱的目的。</p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>采用动态规划进行解决，假设现在是第days[i]天，我们在该天出行旅游需要选择买票方案，现在我们有三种方案：第一，购买一天的通行票，当天出行，花费就是第days[i-1]天的花费加上一天的通行票价；第二，购买七天的通行票，而七天的通行票可以在连续的七天之内使用，所以花费是第days[i-7]天的花费加上七天的通行票价（即从第days[i-8]天到days[i]天的花费都包含在这七天的通行票中）；第三，购买三十天的通行票，同理，花费是days[i-30]天加上三十天的通行票价。然后我们在这三种方案中选择最实惠的。最后，在实现代码中注意数组越界的问题。</p>
<p>使用dp[j]代表着我们旅行到i天为止需要的最少旅行价格，递推公式为：</p>
<ul>
<li>dp[j] = dp[j-1] （第j天不用旅行）</li>
<li>dp[j] = min(dp[j-1] + costs[0], dp[j-7] + costs[1], dp[j-30] + costs[2]) （第j天需要旅行）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; days, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(days.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">366</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">366</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(find(days.begin(), days.end(), i) == days.end() )</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = min(dp[i<span class="number">-1</span>] + costs[<span class="number">0</span>], min(dp[max(<span class="number">0</span>, i<span class="number">-7</span>)]+costs[<span class="number">1</span>], dp[max(<span class="number">0</span>, i<span class="number">-30</span>)]+costs[<span class="number">2</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">365</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode984-String-Without-AAA-or-BBB"><a href="#Leetcode984-String-Without-AAA-or-BBB" class="headerlink" title="Leetcode984. String Without AAA or BBB"></a>Leetcode984. String Without AAA or BBB</h1><p>Given two integers A and B, return any string S such that:</p>
<ul>
<li>S has length A + B and contains exactly A ‘a’ letters, and exactly B ‘b’ letters;</li>
<li>The substring ‘aaa’ does not occur in S;</li>
<li>The substring ‘bbb’ does not occur in S.</li>
</ul>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = 1, B = 2</span><br><span class="line">Output: &quot;abb&quot;</span><br><span class="line">Explanation: &quot;abb&quot;, &quot;bab&quot; and &quot;bba&quot; are all correct answers.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = 4, B = 1</span><br><span class="line">Output: &quot;aabaa&quot;</span><br></pre></td></tr></table></figure></p>
<p>使用贪心，先选较多的然后再选较少的字母。主要是看两个字母哪个比较多，较多的哪个放到A上，然后判断A和B是否大于0，或者A是否大于B。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">strWithout3a3b</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a = <span class="string">'a'</span>, b = <span class="string">'b'</span>;</span><br><span class="line">        <span class="keyword">int</span> temp2;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(A &lt; B) &#123;</span><br><span class="line">            a = <span class="string">'b'</span>;</span><br><span class="line">            b = <span class="string">'a'</span>;</span><br><span class="line">            temp2 = A;</span><br><span class="line">            A = B;</span><br><span class="line">            B = temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(A&gt;<span class="number">0</span> || B&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res += a;</span><br><span class="line">                A --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(A &gt; B) &#123;</span><br><span class="line">                res += a;</span><br><span class="line">                A --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(B &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res += b;</span><br><span class="line">                B --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode985-Sum-of-Even-Numbers-After-Queries"><a href="#Leetcode985-Sum-of-Even-Numbers-After-Queries" class="headerlink" title="Leetcode985. Sum of Even Numbers After Queries"></a>Leetcode985. Sum of Even Numbers After Queries</h1><p>We have an array A of integers, and an array queries of queries.</p>
<p>For the i-th query val = queries[i][0], index = queries[i][1], we add val to A[index].  Then, the answer to the i-th query is the sum of the even values of A.</p>
<p>(Here, the given index = queries[i][1] is a 0-based index, and each query permanently modifies the array A.)</p>
<p>Return the answer to all queries.  Your answer array should have answer[i] as the answer to the i-th query.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]</span><br><span class="line">Output: [8,6,2,4]</span><br><span class="line">Explanation: </span><br><span class="line">	At the beginning, the array is [1,2,3,4].</span><br><span class="line">	After adding 1 to A[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.</span><br><span class="line">	After adding -3 to A[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.</span><br><span class="line">	After adding -4 to A[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.</span><br><span class="line">	After adding 2 to A[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4.</span><br></pre></td></tr></table></figure></p>
<p>题意比较曲折，就是在queries中的每个pair，某个位置加上一个数，在计算A数组中所有偶数的和。下边的代码会超时：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sumEvenAfterQueries(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> size = queries.size(), val, index, sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            val = queries[i][<span class="number">0</span>];</span><br><span class="line">            index = queries[i][<span class="number">1</span>];</span><br><span class="line">            A[index] += val;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A.size(); j ++)</span><br><span class="line">                sum += (A[j]%<span class="number">2</span> ? <span class="number">0</span> : A[j]);</span><br><span class="line">            res.push_back(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>应首先计算出所有的偶数和，再根据运算之后的结果进行计算。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sumEvenAfterQueries(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> size = queries.size(), val, index, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i ++)</span><br><span class="line">            sum += (A[i]%<span class="number">2</span> ? <span class="number">0</span> : A[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            val = queries[i][<span class="number">0</span>];</span><br><span class="line">            index = queries[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(A[index]%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                sum -= A[index];</span><br><span class="line">            A[index] += val;</span><br><span class="line">            <span class="keyword">if</span>(A[index]%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                sum += A[index];</span><br><span class="line">            res.push_back(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode986-Interval-List-Intersections"><a href="#Leetcode986-Interval-List-Intersections" class="headerlink" title="Leetcode986. Interval List Intersections"></a>Leetcode986. Interval List Intersections</h1><p>Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order.</p>
<p>Return the intersection of these two interval lists.</p>
<p>(Formally, a closed interval [a, b] (with a &lt;= b) denotes the set of real numbers x with a &lt;= x &lt;= b.  The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval.  For example, the intersection of [1, 3] and [2, 4] is [2, 3].)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; intervalIntersection(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; B) &#123;</span><br><span class="line">        <span class="keyword">if</span>(A.size() == <span class="number">0</span> || B.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&#123;&#125;;</span><br><span class="line">        <span class="keyword">int</span> sizea = A.size(), sizeb = B.size();</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; sizea &amp;&amp; j &lt; sizeb;) &#123;</span><br><span class="line">            l = max(A[i][<span class="number">0</span>], B[j][<span class="number">0</span>]);</span><br><span class="line">            r = min(A[i][<span class="number">1</span>], B[j][<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(l &lt;= r) </span><br><span class="line">                res.push_back(&#123;l, r&#125;);</span><br><span class="line">            <span class="keyword">if</span>(r == A[i][<span class="number">1</span>])</span><br><span class="line">                i ++;</span><br><span class="line">            <span class="keyword">else</span> j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>贪心，由于排好序了，直接双指针扫，思路和归并排序合并比较类似，注意往后移动的条件是尾部，因为一个矩形的结束条件是尾部比完了，不能写成是头部</p>
<h1 id="Leetcode987-Vertical-Order-Traversal-of-a-Binary-Tree"><a href="#Leetcode987-Vertical-Order-Traversal-of-a-Binary-Tree" class="headerlink" title="Leetcode987. Vertical Order Traversal of a Binary Tree"></a>Leetcode987. Vertical Order Traversal of a Binary Tree</h1><p>Given a binary tree, return the vertical order traversal of its nodes values.</p>
<p>For each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1).</p>
<p>Running a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates).</p>
<p>If two nodes have the same position, then the value of the node that is reported first is the value that is smaller.</p>
<p>Return an list of non-empty reports in order of X coordinate.  Every report will have a list of values of nodes.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,9,20,null,null,15,7]</span><br><span class="line">Output: [[9],[3,15],[20],[7]]</span><br><span class="line">Explanation: </span><br><span class="line">Without loss of generality, we can assume the root node is at position (0, 0):</span><br><span class="line">Then, the node with value 9 occurs at position (-1, -1);</span><br><span class="line">The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2);</span><br><span class="line">The node with value 20 occurs at position (1, -1);</span><br><span class="line">The node with value 7 occurs at position (2, -2).</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6,7]</span><br><span class="line">Output: [[4],[2],[1,5,6],[3],[7]]</span><br><span class="line">Explanation: </span><br><span class="line">The node with value 5 and the node with value 6 have the same position according to the given scheme.</span><br><span class="line">However, in the report &quot;[1,5,6]&quot;, the node value of 5 comes first since 5 is smaller than 6.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>The tree will have between 1 and 1000 nodes.</li>
<li>Each node s value will be between 0 and 1000.</li>
</ul>
<p>要求把相同X的节点位置放在一起，并且要求结果中节点的存放是从上到下的。如果两个节点的坐标相同，那么value小的节点排列在前面。通过维护一个队列，我们从上到下依次遍历每个节点，给每个节点设置好了坐标。这个队列存储的是个三元组（TreeNode*,int x,int y）<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dat</span>&#123;</span></span><br><span class="line">        TreeNode* root;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; verticalTraversal(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;struct dat&gt; q;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dat</span> <span class="title">te</span> = &#123;</span>root, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        q.push(te);</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; node;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">dat</span> <span class="title">temp</span> = <span class="title">q</span>.<span class="title">front</span>();</span></span><br><span class="line">            q.pop();</span><br><span class="line">            node[temp.x].push_back(make_pair(-temp.y, temp.root-&gt;val));</span><br><span class="line">            <span class="keyword">if</span>(temp.root-&gt;left)</span><br><span class="line">                q.push(&#123;temp.root-&gt;left, temp.x - <span class="number">1</span>, temp.y - <span class="number">1</span>&#125;);</span><br><span class="line">            <span class="keyword">if</span>(temp.root-&gt;right)</span><br><span class="line">                q.push(&#123;temp.root-&gt;right, temp.x + <span class="number">1</span>, temp.y - <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : node) &#123;</span><br><span class="line">            sort(it.second.begin(), it.second.end());</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tempp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i : it.second)</span><br><span class="line">                tempp.push_back(i.second);</span><br><span class="line">            res.push_back(tempp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode988-Smallest-String-Starting-From-Leaf"><a href="#Leetcode988-Smallest-String-Starting-From-Leaf" class="headerlink" title="Leetcode988. Smallest String Starting From Leaf"></a>Leetcode988. Smallest String Starting From Leaf</h1><p>Given the root of a binary tree, each node has a value from 0 to 25 representing the letters ‘a’ to ‘z’: a value of 0 represents ‘a’, a value of 1 represents ‘b’, and so on.</p>
<p>Find the lexicographically smallest string that starts at a leaf of this tree and ends at the root.</p>
<p>(As a reminder, any shorter prefix of a string is lexicographically smaller: for example, “ab” is lexicographically smaller than “aba”.  A leaf of a node is a node that has no children.)</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,2,3,4,3,4]</span><br><span class="line">Output: &quot;dba&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [25,1,3,1,3,0,2]</span><br><span class="line">Output: &quot;adz&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,1,null,1,0,null,0]</span><br><span class="line">Output: &quot;abc&quot;</span><br></pre></td></tr></table></figure></p>
<p>这个数组代表一个树，图就不上了，从叶子节点开始找到一个最小的字符串。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> result = <span class="string">"zzzzzzzzzz"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bianli</span><span class="params">(TreeNode* root, <span class="built_in">string</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cur = (<span class="keyword">char</span>)((root-&gt;val) + <span class="string">'a'</span>)+cur;</span><br><span class="line">            result = result &lt; cur ? result : cur;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            bianli(root-&gt;left, (<span class="keyword">char</span>)(root-&gt;val+<span class="string">'a'</span>)+cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            bianli(root-&gt;right, (<span class="keyword">char</span>)(root-&gt;val+<span class="string">'a'</span>)+cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestFromLeaf</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        bianli(root, <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode989-Add-to-Array-Form-of-Integer"><a href="#Leetcode989-Add-to-Array-Form-of-Integer" class="headerlink" title="Leetcode989. Add to Array-Form of Integer"></a>Leetcode989. Add to Array-Form of Integer</h1><p>For a non-negative integer X, the array-form of X is an array of its digits in left to right order.  For example, if X = 1231, then the array form is [1,2,3,1].</p>
<p>Given the array-form A of a non-negative integer X, return the array-form of the integer X+K.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2,0,0], K = 34</span><br><span class="line">Output: [1,2,3,4]</span><br><span class="line">Explanation: 1200 + 34 = 1234</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2,7,4], K = 181</span><br><span class="line">Output: [4,5,5]</span><br><span class="line">Explanation: 274 + 181 = 455</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2,1,5], K = 806</span><br><span class="line">Output: [1,0,2,1]</span><br><span class="line">Explanation: 215 + 806 = 1021</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [9,9,9,9,9,9,9,9,9,9], K = 1</span><br><span class="line">Output: [1,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">Explanation: 9999999999 + 1 = 10000000000</span><br></pre></td></tr></table></figure></p>
<p>Note：</p>
<ul>
<li>1 &lt;= A.length &lt;= 10000</li>
<li>0 &lt;= A[i] &lt;= 9</li>
<li>0 &lt;= K &lt;= 10000</li>
<li>If A.length &gt; 1, then A[0] != 0</li>
</ul>
<p>大概意思是一个数组代表一个数，再给一个整数K，返回结果的各位数组成的数组，注意进位，我的做法很麻烦，需要两次反转。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; addToArrayForm(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> L=K;</span><br><span class="line">        reverse(A.begin(), A.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)&#123;</span><br><span class="line">            A[i] = A[i] + L;</span><br><span class="line">            L = A[i]/<span class="number">10</span>;</span><br><span class="line">            A[i]=A[i]%<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(L&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            A.push_back(L%<span class="number">10</span>);</span><br><span class="line">            L = L/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(A.begin(), A.end());</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>从数组最右边开始，逐位相加，用carry记录进位，每一次取和的最右一位存入链表<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">addToArrayForm</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; -<span class="number">1</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = carry + A[i] + K % <span class="number">10</span>;</span><br><span class="line">            list.add(sum % <span class="number">10</span>);</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            K /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        carry += K;</span><br><span class="line">        <span class="keyword">while</span>(carry != <span class="number">0</span>)&#123;</span><br><span class="line">            list.add(carry % <span class="number">10</span>);</span><br><span class="line">            carry /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode990-Satisfiability-of-Equality-Equations"><a href="#Leetcode990-Satisfiability-of-Equality-Equations" class="headerlink" title="Leetcode990. Satisfiability of Equality Equations"></a>Leetcode990. Satisfiability of Equality Equations</h1><p>Given an array equations of strings that represent relationships between variables, each string equations[i] has length 4 and takes one of two different forms: “a==b” or “a!=b”.  Here, a and b are lowercase letters (not necessarily different) that represent one-letter variable names.</p>
<p>Return true if and only if it is possible to assign integers to variable names so as to satisfy all the given equations.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a==b&quot;,&quot;b!=a&quot;]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.  There is no way to assign the variables to satisfy both equations.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;b==a&quot;,&quot;a==b&quot;]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We could assign a = 1 and b = 1 to satisfy both equations.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= equations.length &lt;= 500</li>
<li>equations[i].length == 4</li>
<li>equations[i][0] and equations[i][3] are lowercase letters</li>
<li>equations[i][1] is either ‘=’ or ‘!’</li>
<li>equations[i][2] is ‘=’</li>
</ul>
<p>给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：”a==b”或 “a!=b”。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。</p>
<p>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。</p>
<p>这个问题一看就是并查集问题，所以直接使用并查集就过了。将所有相等的元素构成一个集合中，然后判断不相等的元素是不是相同根即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">26</span>];</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[x]==x?x:find(arr[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">uni</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        arr[find(y)]=find(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equationsPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; equations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            arr[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;equations.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(equations[i][<span class="number">1</span>]==<span class="string">'='</span>) &#123;</span><br><span class="line">                uni(equations[i][<span class="number">0</span>]-<span class="string">'a'</span>, equations[i][<span class="number">3</span>]-<span class="string">'a'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;equations.size();i++)&#123; </span><br><span class="line">            <span class="keyword">if</span>(equations[i][<span class="number">1</span>]==<span class="string">'!'</span> &amp;&amp; find(equations[i][<span class="number">0</span>]-<span class="string">'a'</span>)==find(equations[i][<span class="number">3</span>]-<span class="string">'a'</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode991-Broken-Calculator"><a href="#Leetcode991-Broken-Calculator" class="headerlink" title="Leetcode991. Broken Calculator"></a>Leetcode991. Broken Calculator</h1><p>On a broken calculator that has a number showing on its display, we can perform two operations:</p>
<ul>
<li>Double: Multiply the number on the display by 2, or;</li>
<li>Decrement: Subtract 1 from the number on the display.</li>
</ul>
<p>Initially, the calculator is displaying the number X.</p>
<p>Return the minimum number of operations needed to display the number Y.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: X = 2, Y = 3</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Use double operation and then decrement operation &#123;2 -&gt; 4 -&gt; 3&#125;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: X = 5, Y = 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Use decrement and then double &#123;5 -&gt; 4 -&gt; 8&#125;.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: X = 3, Y = 10</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:  Use double, decrement and double &#123;3 -&gt; 6 -&gt; 5 -&gt; 10&#125;.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: X = 1024, Y = 1</span><br><span class="line">Output: 1023</span><br><span class="line">Explanation: Use decrement operations 1023 times.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= X &lt;= 10^9</li>
<li>1 &lt;= Y &lt;= 10^9</li>
</ul>
<p>这道题说是有一个坏了的计算器，其实就显示一个数字X，现在我们有两种操作，一种乘以2操作，一种是减1操作，问最少需要多少次操作才能得到目标数字Y。好，现在来分析，由于X和Y的大小关系并不确定，最简单的当然是X和Y相等，就不需要另外的操作了。当X大于Y时，由于都是正数，肯定就不能再乘2了，所以此时直接就可以返回 X-Y。比较复杂的情况就是Y大于X的情况，此时X既可以减1，又可以乘以2，但是仔细想想，我们的最终目的应该是要减小Y，直至其小于等于X，就可以直接得到结果。这里X乘以2的效果就相当于Y除以2，操作数都一样，但是Y除以2时还要看Y的奇偶性，如果Y是偶数，那么 OK，可以直接除以2，若是奇数，需要将其变为偶数，由于X可以减1，等价过来就是Y加1，所以思路就有了，当Y大于X时进行循环，然后判断Y的奇偶性，若是偶数，直接除以2，若是奇数，则加1，当然此时结果 res 也要对应增加。循环退出后，还要加上 X-Y 的值即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">brokenCalc</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(target &gt; start) &#123;</span><br><span class="line">            target = (target % <span class="number">2</span>) ? (target + <span class="number">1</span>) : target / <span class="number">2</span>;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + start - target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>若用递归来写就相当的简洁了，可以两行搞定，当然若你够 geek 的话，也可以压缩到一行，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">brokenCalc</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (X &gt;= Y) <span class="keyword">return</span> X - Y;</span><br><span class="line">        <span class="keyword">return</span> (Y % <span class="number">2</span> == <span class="number">0</span>) ? (<span class="number">1</span> + brokenCalc(X, Y / <span class="number">2</span>)) : (<span class="number">1</span> + brokenCalc(X, Y + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode993-Cousins-in-Binary-Tree"><a href="#Leetcode993-Cousins-in-Binary-Tree" class="headerlink" title="Leetcode993. Cousins in Binary Tree"></a>Leetcode993. Cousins in Binary Tree</h1><p>In a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1.</p>
<p>Two nodes of a binary tree are cousins if they have the same depth, but have different parents. We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree. Return true if and only if the nodes corresponding to the values x and y are cousins.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4], x = 4, y = 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,null,4,null,5], x = 5, y = 4</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,null,4], x = 2, y = 3</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>求解x，y的深度和父亲结点，如果深度一样，父亲结点不同，就是true；否则，就是false。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x, <span class="keyword">int</span> depth, <span class="keyword">int</span> &amp;level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>((root-&gt;left &amp;&amp; root-&gt;left-&gt;val == x) || (root-&gt;right &amp;&amp; root-&gt;right-&gt;val == x)) &#123;</span><br><span class="line">            level = depth;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *left = dfs(root-&gt;left, x, depth + <span class="number">1</span>, level);</span><br><span class="line">        <span class="keyword">if</span> (left) </span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">        TreeNode *right = dfs(root-&gt;right, x, depth + <span class="number">1</span>, level);</span><br><span class="line">        <span class="keyword">if</span> (right) </span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCousins</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> level_a, level_b;</span><br><span class="line">        TreeNode *xx = dfs(root, x, <span class="number">0</span>, level_a);</span><br><span class="line">        TreeNode *yy = dfs(root, y, <span class="number">0</span>, level_b);</span><br><span class="line">        <span class="keyword">if</span>(xx != yy &amp;&amp; level_a == level_b)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode994-Rotting-Oranges"><a href="#Leetcode994-Rotting-Oranges" class="headerlink" title="Leetcode994. Rotting Oranges"></a>Leetcode994. Rotting Oranges</h1><p>You are given an m x n grid where each cell can have one of three values:</p>
<ul>
<li>0 representing an empty cell,</li>
<li>1 representing a fresh orange, or</li>
<li>2 representing a rotten orange.</li>
</ul>
<p>Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.</p>
<p>Return  the minimum number of minutes that must elapse until no cell has a fresh orange. If  this is impossible, return  -1.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[2,1,1],[1,1,0],[0,1,1]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/20211115105408.png" alt></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[2,1,1],[0,1,1],[1,0,1]]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[0,2]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>m == grid.length</li>
<li>n == grid[i].length</li>
<li>1 &lt;= m, n &lt;= 10</li>
<li>grid[i][j] is 0, 1, or 2.</li>
</ul>
<p>这道题说给的一个 mxn 大小的格子上有些新鲜和腐烂的橘子，每一分钟腐烂的橘子都会传染给其周围四个中的新鲜橘子，使得其也变得腐烂。现在问需要多少分钟可以使得所有的新鲜橘子都变腐烂，无法做到时返回 -1。由于这里新鲜的橘子自己不会变腐烂，只有被周围的腐烂橘子传染才会，所以当新鲜橘子周围不会出现腐烂橘子的时候，那么这个新鲜橘子就不会腐烂，这才会有返回 -1 的情况。这道题就是个典型的广度优先遍历 Breadth First Search，并没有什么太大的难度，先遍历一遍整个二维数组，统计出所有新鲜橘子的个数，并把腐烂的橘子坐标放入一个队列 queue，之后进行 while 循环，循环条件是队列不会空，且 freshLeft 大于0，使用层序遍历的方法，用个 for 循环在内部。每次取出队首元素，遍历其周围四个位置，越界或者不是新鲜橘子都跳过，否则将新鲜橘子标记为腐烂，加入队列中，并且 freshLeft 自减1。每层遍历完成之后，结果 res 自增1，最后返回的时候，若还有新鲜橘子，即 freshLeft 大于0时，返回 -1，否则返回 res 即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, m = grid.size(), n = grid[<span class="number">0</span>].size(), freshLeft = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs&#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    freshLeft ++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>)</span><br><span class="line">                    q.push(make_pair(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty() &amp;&amp; freshLeft &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = q.front().first, y = q.front().second;</span><br><span class="line">                q.pop();</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j ++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> xx = x + dirs[j][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> yy = y + dirs[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">0</span> &gt; xx || xx &gt;= m || <span class="number">0</span> &gt; yy || yy &gt;= n || grid[xx][yy] != <span class="number">1</span>) </span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    grid[xx][yy] = <span class="number">2</span>;</span><br><span class="line">                    q.push(make_pair(xx, yy));</span><br><span class="line">                    freshLeft --;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> freshLeft &gt; <span class="number">0</span> ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode997-Find-the-Town-Judge"><a href="#Leetcode997-Find-the-Town-Judge" class="headerlink" title="Leetcode997. Find the Town Judge"></a>Leetcode997. Find the Town Judge</h1><p>In a town, there are N people labelled from 1 to N.  There is a rumor that one of these people is secretly the town judge.</p>
<p>If the town judge exists, then:</p>
<p>The town judge trusts nobody.<br>Everybody (except for the town judge) trusts the town judge.<br>There is exactly one person that satisfies properties 1 and 2.<br>You are given trust, an array of pairs trust[i] = [a, b] representing that the person labelled a trusts the person labelled b.</p>
<p>If the town judge exists and can be identified, return the label of the town judge.  Otherwise, return -1.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 2, trust = [[1,2]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, trust = [[1,3],[2,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, trust = [[1,3],[2,3],[3,1]]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, trust = [[1,2],[2,3]]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>在一个小镇里，按从 1 到 N 标记了 N 个人。传言称，这些人中有一个是小镇上的秘密法官。如果小镇的法官真的存在，那么：小镇的法官不相信任何人。每个人（除了小镇法官外）都信任小镇的法官。只有一个人同时满足属性 1 和属性 2 。给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示标记为 a 的人信任标记为 b 的人。如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 -1。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findJudge</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; trust)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> in[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;, out[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; trust.size(); i ++) &#123;</span><br><span class="line">            in[trust[i][<span class="number">1</span>]] ++;</span><br><span class="line">            out[trust[i][<span class="number">0</span>]] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(out[i] == <span class="number">0</span> &amp;&amp; in[i] == N - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode998-Maximum-Binary-Tree-II"><a href="#Leetcode998-Maximum-Binary-Tree-II" class="headerlink" title="Leetcode998. Maximum Binary Tree II"></a>Leetcode998. Maximum Binary Tree II</h1><p>We are given the root node of a maximum tree: a tree where every node has a value greater than any other value in its subtree.<br>Just as in the previous problem, the given tree was constructed from an list A (root = Construct(A)) recursively with the following Construct(A) routine:</p>
<ul>
<li>If A is empty, return null.</li>
<li>Otherwise, let A[i] be the largest element of A. Create a root node with value A[i].</li>
<li>The left child of root will be Construct([A[0], A[1], …, A[i-1]])</li>
<li>The right child of root will be Construct([A[i+1], A[i+2], …, A[A.length - 1]])</li>
<li>Return root.</li>
</ul>
<p>Note that we were not given A directly, only a root node root = Construct(A).</p>
<p>Suppose B is a copy of A with the value val appended to it. It is guaranteed that B has unique values.</p>
<p>Return Construct(B).</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [4,1,3,null,null,2], val = 5</span><br><span class="line">Output: [5,4,null,1,3,null,null,2]</span><br><span class="line">Explanation: A = [1,4,2,3], B = [1,4,2,3,5]</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1636992467.png" alt></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [5,2,4,null,1], val = 3</span><br><span class="line">Output: [5,2,4,null,1,null,3]</span><br><span class="line">Explanation: A = [2,1,5,4], B = [2,1,5,4,3]</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/1636992495.jpg" alt></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [5,2,3,null,1], val = 4</span><br><span class="line">Output: [5,2,4,null,1,3]</span><br><span class="line">Explanation: A = [2,1,5,3], B = [2,1,5,3,4]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= B.length &lt;= 100</li>
</ul>
<p>和上一题654相比，这道题没有给max binary tree的原始数组nums，而是已经从654建好的tree root。那么已知新的数组是nums后面再加一个val，要返回modify过的新max binary tree。那么分为三种情况讨论，也就是example给出的三种：</p>
<ol>
<li>val &gt; root -&gt;val，新数字将成为新的根节点，root被连接到左边；</li>
<li>val &lt; root -&gt; val，那么要遍历寻找该插入的位置，因为顺序问题，我们不考虑向左子树插入，只向右子树方向递归寻找这个再一次使val &gt; root -&gt; val满足的位置。如果没有找到，需要将新节点连成最后一个max的右子树；</li>
<li>如果找到了这样一个节点parent，那么它的右子树将被连接到新节点的左子树，而新节点被连到parent的右子树。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoMaxTree</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        <span class="keyword">if</span> (!root || root -&gt; val &lt; val)  &#123;</span><br><span class="line">            node -&gt; left = root;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        root -&gt; right = insertIntoMaxTree(root -&gt; right, val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode999-Available-Captures-for-Rook"><a href="#Leetcode999-Available-Captures-for-Rook" class="headerlink" title="Leetcode999. Available Captures for Rook"></a>Leetcode999. Available Captures for Rook</h1><p>On an 8 x 8 chessboard, there is one white rook.  There also may be empty squares, white bishops, and black pawns.  These are given as characters ‘R’, ‘.’, ‘B’, and ‘p’ respectively. Uppercase characters represent white pieces, and lowercase characters represent black pieces.</p>
<p>The rook moves as in the rules of Chess: it chooses one of four cardinal directions (north, east, west, and south), then moves in that direction until it chooses to stop, reaches the edge of the board, or captures an opposite colored pawn by moving to the same square it occupies.  Also, rooks cannot move into the same square as other friendly bishops.</p>
<p>Return the number of pawns the rook can capture in one move.</p>
<p>Example 1:<br><img src="/img/20190825101.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">In this example the rook is able to capture all the pawns.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><img src="/img/20190825102.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: [</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;R&quot;,&quot;B&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: </span><br><span class="line">Bishops are blocking the rook to capture any pawn.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><img src="/img/20190825103.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Input: [</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line"> [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">The rook can capture the pawns at positions b5, d6 and f5.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ol>
<li>board.length == board[i].length == 8</li>
<li>board[i][j] is either ‘R’, ‘.’, ‘B’, or ‘p’</li>
<li>There is exactly one cell with board[i][j] == ‘R’</li>
</ol>
<p>非常无聊，数格子就好了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> bBlack;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">8</span>; row++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="number">8</span>; col++) </span><br><span class="line">                <span class="keyword">if</span> (board[row][col] == <span class="string">'R'</span> ||</span><br><span class="line">                    board[row][col] == <span class="string">'r'</span>) &#123;</span><br><span class="line">                    x = row;</span><br><span class="line">                    y = col;</span><br><span class="line">                    <span class="keyword">if</span> (board[row][col] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                        bBlack = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        bBlack = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=x<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[j][y]==<span class="string">'.'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[j][y]==<span class="string">'P'</span> &amp;&amp; bBlack==<span class="literal">true</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(board[j][y]==<span class="string">'p'</span> &amp;&amp; bBlack==<span class="literal">false</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=x+<span class="number">1</span>;j&lt;<span class="number">8</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[j][y]==<span class="string">'.'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[j][y]==<span class="string">'P'</span> &amp;&amp; bBlack==<span class="literal">true</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(board[j][y]==<span class="string">'p'</span> &amp;&amp; bBlack==<span class="literal">false</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=y<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[x][j]==<span class="string">'.'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[x][j]==<span class="string">'P'</span> &amp;&amp; bBlack==<span class="literal">true</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(board[x][j]==<span class="string">'p'</span> &amp;&amp; bBlack==<span class="literal">false</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=y+<span class="number">1</span>;j&lt;<span class="number">8</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[x][j]==<span class="string">'.'</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(board[x][j]==<span class="string">'P'</span> &amp;&amp; bBlack==<span class="literal">true</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(board[x][j]==<span class="string">'p'</span> &amp;&amp; bBlack==<span class="literal">false</span>)&#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/27/Leetcode551_600/" rel="next" title="Leetcode551 - 600">
                <i class="fa fa-chevron-left"></i> Leetcode551 - 600
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/28/cpp关键字及语言特性/" rel="prev" title="C++关键字及语言特性">
                C++关键字及语言特性 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">301</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode951-Flip-Equivalent-Binary-Trees"><span class="nav-number">1.</span> <span class="nav-text">Leetcode951. Flip Equivalent Binary Trees</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode953-Verifying-an-Alien-Dictionary"><span class="nav-number">2.</span> <span class="nav-text">Leetcode953. Verifying an Alien Dictionary</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode955-Delete-Columns-to-Make-Sorted-II"><span class="nav-number">3.</span> <span class="nav-text">Leetcode955. Delete Columns to Make Sorted II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode957-Prison-Cells-After-N-Days"><span class="nav-number">4.</span> <span class="nav-text">Leetcode957. Prison Cells After N Days</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode958-Check-Completeness-of-a-Binary-Tree"><span class="nav-number">5.</span> <span class="nav-text">Leetcode958. Check Completeness of a Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode959-Regions-Cut-By-Slashes"><span class="nav-number">6.</span> <span class="nav-text">Leetcode959. Regions Cut By Slashes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode961-N-Repeated-Element-in-Size-2N-Array"><span class="nav-number">7.</span> <span class="nav-text">Leetcode961. N-Repeated Element in Size 2N Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode962-Maximum-Width-Ramp"><span class="nav-number">8.</span> <span class="nav-text">Leetcode962. Maximum Width Ramp</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode963-Minimum-Area-Rectangle-II"><span class="nav-number">9.</span> <span class="nav-text">Leetcode963. Minimum Area Rectangle II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode965-Univalued-Binary-Tree"><span class="nav-number">10.</span> <span class="nav-text">Leetcode965. Univalued Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode966-Vowel-Spellchecker"><span class="nav-number">11.</span> <span class="nav-text">Leetcode966. Vowel Spellchecker</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode969-Pancake-Sorting"><span class="nav-number">12.</span> <span class="nav-text">Leetcode969. Pancake Sorting</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode970-Powerful-Integers"><span class="nav-number">13.</span> <span class="nav-text">Leetcode970. Powerful Integers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode971-Flip-Binary-Tree-To-Match-Preorder-Traversal"><span class="nav-number">14.</span> <span class="nav-text">Leetcode971. Flip Binary Tree To Match Preorder Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode973-K-Closest-Points-to-Origin"><span class="nav-number">15.</span> <span class="nav-text">Leetcode973. K Closest Points to Origin</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode976-Largest-Perimeter-Triangle"><span class="nav-number">16.</span> <span class="nav-text">Leetcode976. Largest Perimeter Triangle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode977-Squares-of-a-Sorted-Array"><span class="nav-number">17.</span> <span class="nav-text">Leetcode977. Squares of a Sorted Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode978-Longest-Turbulent-Subarray"><span class="nav-number">18.</span> <span class="nav-text">Leetcode978. Longest Turbulent Subarray</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode979-Distribute-Coins-in-Binary-Tree"><span class="nav-number">19.</span> <span class="nav-text">Leetcode979. Distribute Coins in Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode980-Unique-Paths-III"><span class="nav-number">20.</span> <span class="nav-text">Leetcode980. Unique Paths III</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode981-Time-Based-Key-Value-Store"><span class="nav-number">21.</span> <span class="nav-text">Leetcode981. Time Based Key-Value Store</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode983-Minimum-Cost-For-Tickets"><span class="nav-number">22.</span> <span class="nav-text">Leetcode983. Minimum Cost For Tickets</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#算法描述"><span class="nav-number">22.1.</span> <span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode984-String-Without-AAA-or-BBB"><span class="nav-number">23.</span> <span class="nav-text">Leetcode984. String Without AAA or BBB</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode985-Sum-of-Even-Numbers-After-Queries"><span class="nav-number">24.</span> <span class="nav-text">Leetcode985. Sum of Even Numbers After Queries</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode986-Interval-List-Intersections"><span class="nav-number">25.</span> <span class="nav-text">Leetcode986. Interval List Intersections</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode987-Vertical-Order-Traversal-of-a-Binary-Tree"><span class="nav-number">26.</span> <span class="nav-text">Leetcode987. Vertical Order Traversal of a Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode988-Smallest-String-Starting-From-Leaf"><span class="nav-number">27.</span> <span class="nav-text">Leetcode988. Smallest String Starting From Leaf</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode989-Add-to-Array-Form-of-Integer"><span class="nav-number">28.</span> <span class="nav-text">Leetcode989. Add to Array-Form of Integer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode990-Satisfiability-of-Equality-Equations"><span class="nav-number">29.</span> <span class="nav-text">Leetcode990. Satisfiability of Equality Equations</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode991-Broken-Calculator"><span class="nav-number">30.</span> <span class="nav-text">Leetcode991. Broken Calculator</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode993-Cousins-in-Binary-Tree"><span class="nav-number">31.</span> <span class="nav-text">Leetcode993. Cousins in Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode994-Rotting-Oranges"><span class="nav-number">32.</span> <span class="nav-text">Leetcode994. Rotting Oranges</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode997-Find-the-Town-Judge"><span class="nav-number">33.</span> <span class="nav-text">Leetcode997. Find the Town Judge</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode998-Maximum-Binary-Tree-II"><span class="nav-number">34.</span> <span class="nav-text">Leetcode998. Maximum Binary Tree II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode999-Available-Captures-for-Rook"><span class="nav-number">35.</span> <span class="nav-text">Leetcode999. Available Captures for Rook</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
