<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="编程语言 根据熟悉的语言，谈谈两种语言的区别？  主要浅谈下C/C++和PHP语言的区别: 1)PHP弱类型语言，一种脚本语言，对数据的类型不要求过多，较多的应用于Web应用开发，现在好多互联网开发公司的主流web后台开发语言，主要框架为mvc模型，如smarty,yaf，升级的PHP7速度较快，对服务器的压力要小很多，在新浪微博已经有应用，对比很明显。 2)C/C++开发语言，C语言更偏向硬件底">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux C&#x2F;C++服务器后台开发面试题总结">
<meta property="og:url" content="http://yoursite.com/2019/08/14/cpp面试总结/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="编程语言 根据熟悉的语言，谈谈两种语言的区别？  主要浅谈下C/C++和PHP语言的区别: 1)PHP弱类型语言，一种脚本语言，对数据的类型不要求过多，较多的应用于Web应用开发，现在好多互联网开发公司的主流web后台开发语言，主要框架为mvc模型，如smarty,yaf，升级的PHP7速度较快，对服务器的压力要小很多，在新浪微博已经有应用，对比很明显。 2)C/C++开发语言，C语言更偏向硬件底">
<meta property="og:locale" content="zn-ch">
<meta property="og:updated_time" content="2019-08-14T12:44:44.347Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux C&#x2F;C++服务器后台开发面试题总结">
<meta name="twitter:description" content="编程语言 根据熟悉的语言，谈谈两种语言的区别？  主要浅谈下C/C++和PHP语言的区别: 1)PHP弱类型语言，一种脚本语言，对数据的类型不要求过多，较多的应用于Web应用开发，现在好多互联网开发公司的主流web后台开发语言，主要框架为mvc模型，如smarty,yaf，升级的PHP7速度较快，对服务器的压力要小很多，在新浪微博已经有应用，对比很明显。 2)C/C++开发语言，C语言更偏向硬件底">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/08/14/cpp面试总结/">





  <title>Linux C/C++服务器后台开发面试题总结 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/14/cpp面试总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux C/C++服务器后台开发面试题总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-14T19:50:00+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h1><ol>
<li>根据熟悉的语言，谈谈两种语言的区别？</li>
</ol>
<p>主要浅谈下C/C++和PHP语言的区别:</p>
<p>1)PHP弱类型语言，一种脚本语言，对数据的类型不要求过多，较多的应用于Web应用开发，现在好多互联网开发公司的主流web后台开发语言，主要框架为mvc模型，如smarty,yaf，升级的PHP7速度较快，对服务器的压力要小很多，在新浪微博已经有应用，对比很明显。</p>
<p>2)C/C++开发语言，C语言更偏向硬件底层开发，C++语言是目前为止我认为语法内容最多的一种语言。C/C++在执行速度上要快很多，毕竟其他类型的语言大都是C开发的，更多应用于网络编程和嵌入式编程。</p>
<ol start="2">
<li>volatile是干啥用的，（必须将cpu的寄存器缓存机制回答的很透彻），使用实例有哪些？（重点）</li>
</ol>
<p>1）访问寄存器比访问内存单元要快,编译器会优化减少内存的读取，可能会读脏数据。声明变量为volatile，编译器不再对访问该变量的代码优化，仍然从内存读取，使访问稳定。</p>
<p>总结：volatile关键词影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不再编译优化，以免出错。</p>
<p>2）使用实例如下(区分C程序员和嵌入式系统程序员的最基本的问题。)：<br>并行设备的硬件寄存器（如：状态寄存器）<br>一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)<br>多线程应用中被几个任务共享的变量</p>
<p>3)一个参数既可以是const还可以是volatile吗？解释为什么。<br>可以。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。</p>
<p>4）一个指针可以是volatile 吗？解释为什么。<br>可以。尽管这并不很常见。一个例子当中断服务子程序修该一个指向一个buffer的指针时。</p>
<p>下面的函数有什么错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int square(volatile int *ptr) &#123;</span><br><span class="line">	return *ptr * *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是答案：<br>这段代码有点变态。这段代码的目的是用来返指针<code>*ptr</code>指向值的平方，但是，由于<code>*ptr</code>指向一个<code>volatile</code>型参数，编译器将产生类似下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int square(volatile int *ptr)&#123;</span><br><span class="line">	int a,b;</span><br><span class="line">	a = *ptr;</span><br><span class="line">	b = *ptr;</span><br><span class="line">	return a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于<code>*ptr</code>的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">long square(volatile int *ptr)&#123;</span><br><span class="line">int a;</span><br><span class="line">a = *ptr;</span><br><span class="line">return a * a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>static const等等的用法，（能说出越多越好）（重点）<br>首先说说const的用法（绝对不能说是常数）</li>
</ol>
<p>1）在定义的时候必须进行初始化</p>
<p>2）指针可以是const指针，也可以是指向const对象的指针</p>
<p>3）定义为const的形参，即在函数内部是不能被修改的</p>
<p>4）类的成员函数可以被声明为常成员函数，不能修改类的成员变量</p>
<p>5）类的成员函数可以返回的是常对象，即被const声明的对象</p>
<p>6）类的成员变量是常成员变量不能在声明时初始化，必须在构造函数的列表里进行初始化</p>
<p>（注：千万不要说const是个常数，会被认为是外行人的！！！！哪怕说个只读也行）</p>
<p>下面的声明都是什么意思？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const int a; a是一个常整型数</span><br><span class="line">int const a; a是一个常整型数</span><br><span class="line">const int *a; a是一个指向常整型数的指针，整型数是不可修改的，但指针可以</span><br><span class="line">int * const a; a为指向整型数的常指针，指针指向的整型数可以修改，但指针是不可修改的</span><br><span class="line">int const * a const; a是一个指向常整型数的常指针，指针指向的整型数是不可修改的，同时指针也是不可修改的</span><br></pre></td></tr></table></figure></p>
<p>通过给优化器一些附加的信息，使用关键字const也许能产生更紧凑的代码。合理地使用关键字const可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少bug的出现。</p>
<p>Const如何做到只读？</p>
<p>这些在编译期间完成，对于内置类型，如int， 编译器可能使用常数直接替换掉对此变量的引用。而对于结构体不一定。</p>
<p>再说说static的用法（三个明显的作用一定要答出来）</p>
<p>1）在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。<br>2）在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。<br>3）在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用<br>4）类内的static成员变量属于整个类所拥有，不能在类内进行定义，只能在类的作用域内进行定义<br>5）类内的static成员函数属于整个类所拥有，不能包含this指针，只能调用static成员函数</p>
<p>static全局变量与普通的全局变量有什么区别?static局部变量和普通局部变量有什么区别?static函数与普通函数有什么区别?</p>
<p>static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;<br>static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；<br>static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝</p>
<ol start="4">
<li>extern C作用</li>
</ol>
<p>告诉编译器该段代码以C语言进行编译。</p>
<ol start="5">
<li>指针和引用的区别</li>
</ol>
<p>1）引用是直接访问，指针是间接访问。<br>2）引用是变量的别名，本身不单独分配自己的内存空间，而指针有自己的内存空间<br>3）引用绑定内存空间（必须赋初值），是一个变量别名不能更改绑定，可以改变对象的值。</p>
<p>总的来说：引用既具有指针的效率，又具有变量使用的方便性和直观性</p>
<ol start="6">
<li>关于静态内存分配和动态内存分配的区别及过程</li>
</ol>
<p>1) 静态内存分配是在编译时完成的，不占用CPU资源；动态分配内存运行时完成，分配与释放需要占用CPU资源；<br>2)静态内存分配是在栈上分配的，动态内存是堆上分配的；<br>3)动态内存分配需要指针或引用数据类型的支持，而静态内存分配不需要；<br>4)静态内存分配是按计划分配，在编译前确定内存块的大小，动态内存分配运行时按需分配。<br>5)静态分配内存是把内存的控制权交给了编译器，动态内存把内存的控制权交给了程序员；<br>6)静态分配内存的运行效率要比动态分配内存的效率要高，因为动态内存分配与释放需要额外的开销；动态内存管理水平严重依赖于程序员的水平，处理不当容易造成内存泄漏。</p>
<ol start="7">
<li>头文件中的 ifndef/define/endif 干什么用？</li>
</ol>
<p>预处理，防止头文件被重复使用，包括pragma once都是这样的</p>
<ol start="8">
<li><p>宏定义求两个元素的最小值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define MIN(A,B) （（A） &lt;= (B) ? (A) : (B))</span><br></pre></td></tr></table></figure>
</li>
<li><p>分别设置和清除一个整数的第三位？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define BIT3 (0x1&lt;&lt;3)</span><br><span class="line"></span><br><span class="line">static int a;</span><br><span class="line"></span><br><span class="line">void set_bit3(void)&#123; </span><br><span class="line">    a |= BIT3;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void clear_bit3(void)&#123; </span><br><span class="line">    a &amp;= ~BIT3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用预处理指令#define 声明一个常数，用以表明1年中有多少秒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL</span><br></pre></td></tr></table></figure>
</li>
<li><p>预处理器标识#error的目的是什么？</p>
</li>
</ol>
<p>抛出错误提示，标识外部宏是否被定义!</p>
<ol start="12">
<li>嵌入式系统中经常要用到无限循环，你怎么样用C编写死循环呢？</li>
</ol>
<p>记住这是第一方案！！！！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一些程序员更喜欢如下方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(;;)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>汇编语言的无线循环是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Loop:</span><br><span class="line">...</span><br><span class="line">goto Loop;</span><br></pre></td></tr></table></figure></p>
<ol start="13">
<li>用变量a给出下面的定义</li>
</ol>
<p>一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数 <code>int (*a[10])(int);</code></p>
<ol start="14">
<li><p>中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标准C支持中断。具代表事实是，产生了一个新的关键字<code>__interrupt</code></p>
</li>
<li><p>memcpy函数的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy(void *dest, const void *src, size_t count) &#123;</span><br><span class="line">	char *tmp = dest;</span><br><span class="line">	const char *s = src;</span><br><span class="line"></span><br><span class="line">	while (count--)</span><br><span class="line">		*tmp++ = *s++;</span><br><span class="line"></span><br><span class="line">  	return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Strcpy函数实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char *strcpy(char *dst,const char *src) &#123; </span><br><span class="line">	assert(dst != NULL &amp;&amp; src != NULL); </span><br><span class="line">    char *ret = dst; </span><br><span class="line">    while((* dst++ = * src++) != &apos;\0&apos;) ; </span><br><span class="line">    return ret; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>strcat函数的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">char *strcat(char *strDes, const char *strSrc)&#123;</span><br><span class="line">	assert((strDes != NULL) &amp;&amp; (strSrc != NULL));</span><br><span class="line">	char *address = strDes;</span><br><span class="line">	while (*strDes != ‘\0′)</span><br><span class="line">		++ strDes;</span><br><span class="line"></span><br><span class="line">	while ((*strDes ++ = *strSrc ++) != ‘\0′);</span><br><span class="line">	return address;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>strncat实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char *strncat(char *strDes, const char *strSrc, int count)&#123;</span><br><span class="line">	assert((strDes != NULL) &amp;&amp; (strSrc != NULL));</span><br><span class="line">	char *address = strDes;</span><br><span class="line">	while (*strDes != ‘\0′)</span><br><span class="line">		++ strDes;</span><br><span class="line">	while (count — &amp;&amp; *strSrc != ‘\0′ )</span><br><span class="line">		*strDes ++ = *strSrc ++;</span><br><span class="line">	</span><br><span class="line">	*strDes = ‘\0′;</span><br><span class="line">	return address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>strcmp函数实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int strcmp(const char *str1,const char *str2)&#123;</span><br><span class="line"></span><br><span class="line">    /*不可用while(*str1++==*str2++)来比较，当不相等时仍会执行一次++，</span><br><span class="line">    return返回的比较值实际上是下一个字符。应将++放到循环体中进行。*/</span><br><span class="line"></span><br><span class="line">    while(*str1 == *str2)&#123;</span><br><span class="line">        if(*str1 == &apos;\0&apos;)</span><br><span class="line">            return 0;</span><br><span class="line">        ++str1;</span><br><span class="line">        ++str2;</span><br><span class="line">    &#125;</span><br><span class="line">    return *str1 - *str2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>strncmp实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int strncmp(const char *s, const char *t, int count)&#123;</span><br><span class="line">    assert((s != NULL) &amp;&amp; (t != NULL));</span><br><span class="line">    while (*s &amp;&amp; *t &amp;&amp; *s == *t &amp;&amp; count –) &#123;</span><br><span class="line">        ++ s;</span><br><span class="line">        ++ t;</span><br><span class="line">    &#125;</span><br><span class="line">    return (*s – *t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>strlen函数实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int strlen(const char *str)&#123;</span><br><span class="line">    assert(str != NULL);</span><br><span class="line">    int len = 0;</span><br><span class="line">    while (*str ++ != ‘\0′)</span><br><span class="line">        ++ len;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>strpbrk函数实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char * strpbrk(const char * cs,const char * ct)&#123;</span><br><span class="line">    const char *sc1,*sc2;</span><br><span class="line">    for( sc1 = cs; *sc1 != &apos;\0&apos;; ++sc1)&#123;</span><br><span class="line">        for( sc2 = ct; *sc2 != &apos;\0&apos;; ++sc2)&#123;</span><br><span class="line">            if (*sc1 == *sc2)&#123;</span><br><span class="line">                return (char *) sc1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>strstr函数实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char *strstr(const char *s1,const char *s2)&#123;</span><br><span class="line">	int len2;</span><br><span class="line">	if(!(len2=strlen(s2)))//此种情况下s2不能指向空，否则strlen无法测出长度，这条语句错误</span><br><span class="line">		return(char*)s1;</span><br><span class="line">	for(;*s1;++s1)</span><br><span class="line">	&#123;</span><br><span class="line">		if(*s1==*s2 &amp;&amp; strncmp(s1,s2,len2)==0)</span><br><span class="line">			return (char*)s1;</span><br><span class="line">	&#125;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>string实现（注意：赋值构造，operator=是关键）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class String&#123;</span><br><span class="line">public:</span><br><span class="line">	//普通构造函数</span><br><span class="line">	String(const char *str = NULL);</span><br><span class="line">	//拷贝构造函数</span><br><span class="line">	String(const String &amp;other);</span><br><span class="line">	//赋值函数</span><br><span class="line">	String &amp; operator=(String &amp;other) ;</span><br><span class="line">	//析构函数</span><br><span class="line">	~String(void);</span><br><span class="line">private:</span><br><span class="line">	char* m_str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>分别实现以上四个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//普通构造函数</span><br><span class="line"></span><br><span class="line">String::String(const char* str)&#123;</span><br><span class="line">    if(str==NULL) //如果str为NULL，存空字符串&#123;</span><br><span class="line">        m_str = new char[1]; //分配一个字节</span><br><span class="line">        *m_str = ‘\0′; //赋一个’\0′</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">       str = new char[strlen(str) + 1];//分配空间容纳str内容</span><br><span class="line">       strcpy(m_str, str); //复制str到私有成员m_str中</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//析构函数</span><br><span class="line"></span><br><span class="line">String::~String()&#123;</span><br><span class="line">    if(m_str!=NULL) //如果m_str不为NULL，释放堆内存&#123;</span><br><span class="line">        delete [] m_str;</span><br><span class="line">        m_str = NULL;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//拷贝构造函数</span><br><span class="line"></span><br><span class="line">String::String(const String &amp;other)&#123;</span><br><span class="line">    m_str = new char[strlen(other.m_str)+1]; //分配空间容纳str内容</span><br><span class="line">    strcpy(m_str, other.m_str); //复制other.m_str到私有成员m_str中 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//赋值函数</span><br><span class="line"></span><br><span class="line">String &amp; String::operator=(String &amp;other)&#123;</span><br><span class="line">    if(this == &amp;other) //若对象与other是同一个对象，直接返回本&#123;</span><br><span class="line">        return *this</span><br><span class="line">	&#125;</span><br><span class="line">    delete [] m_str; //否则，先释放当前对象堆内存</span><br><span class="line">    m_str = new char[strlen(other.m_str)+1]; //分配空间容纳str内容</span><br><span class="line">    strcpy(m_str, other.m_str); //复制other.m_str到私有成员m_str中</span><br><span class="line">    return *this；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="26">
<li>C语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 5, b = 7, c;</span><br><span class="line">c = a+++b; 等同于 c = a++ + b;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>因此, 这段代码持行后a = 6, b = 7, c = 12。</p>
<ol start="27">
<li>用struct关键字与class关键定义类以及继承的区别</li>
</ol>
<p>（1）定义类差别<br>struct关键字也可以实现类，用class和struct关键字定义类的唯一差别在于默认访问级别：默认情况下，struct成员的访问级别为public，而class成员的为private。语法使用也相同，直接将class改为struct即可。</p>
<p>（2）继承差别<br>使用class保留字的派生类默认具有private继承，而用struct保留字定义的类某人具有public继承。其它则没有任何区别。</p>
<p>主要点就两个：默认的访问级别和默认的继承级别 class都是private</p>
<ol start="28">
<li>派生类与虚函数概述</li>
</ol>
<p>(1) 派生类继承的函数不能定义为虚函数。虚函数是希望派生类重新定义。如果派生类没有重新定义某个虚函数，则在调用的时候会使用基类中定义的版本。</p>
<p>(2)派生类中函数的声明必须与基类中定义的方式完全匹配。</p>
<p>(3) 基类中声明为虚函数，则派生类也为虚函数。</p>
<ol start="29">
<li>虚函数与纯虚函数区别</li>
</ol>
<p>1）虚函数在子类里面也可以不重载的；但纯虚必须在子类去实现</p>
<p>2）带纯虚函数的类叫虚基类也叫抽象类，这种基类不能直接生成对象，只能被继承，重写虚函数后才能使用，运行时动态动态绑定！</p>
<ol start="30">
<li>深拷贝与浅拷贝<br>浅拷贝：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char ori[]=“hello”;</span><br><span class="line">char *copy=ori;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>深拷贝：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char ori[]=&quot;hello&quot;;  </span><br><span class="line">char *copy=new char[];  </span><br><span class="line">copy=ori;</span><br></pre></td></tr></table></figure></p>
<p>浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝，经深拷贝后的指针是指向两个不同地址的指针。</p>
<p>浅拷贝可能出现的问题：</p>
<p>1） 浅拷贝只是拷贝了指针，使得两个指针指向同一个地址，这样在对象块结束，调用函数析构的时，会造成同一份资源析构2次，即delete同一块内存2次，造成程序崩溃。</p>
<p>2） 浅拷贝使得两个指针都指向同一块内存，任何一方的变动都会影响到另一方。</p>
<p>3） 同一个空间，第二次释放失败，导致无法操作该空间，造成内存泄漏。</p>
<ol start="31">
<li>stl各容器的实现原理（必考）</li>
</ol>
<p>1) Vector顺序容器，是一个动态数组，支持随机插入、删除、查找等操作，在内存中是一块连续的空间。在原有空间不够情况下自动分配空间，增加为原来的两倍。vector随机存取效率高，但是在vector插入元素，需要移动的数目多，效率低下。</p>
<p>注：vector动态增加大小时是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对vector空间重新配置，指向原vector的所有迭代器就都失效了。</p>
<p>2) Map关联容器，以键值对的形式进行存储，方便进行查找。关键词起到索引的作用，值则表示与索引相关联的数据。红黑树的结构实现，插入删除等操作都在O(logn)时间内完成。</p>
<p>3) Set是关联容器，set每个元素只包含一个关键字。set支持高效的关键字检查是否在set中。set也是以红黑树的结构实现，支持高效插入、删除等操作。</p>
<ol start="32">
<li>哪些库函数属于高危函数，为什么？</li>
</ol>
<p>strcpy 赋值到目标区间可能会造成缓冲区溢出！</p>
<ol start="33">
<li><p>STL有7种主要容器：vector,list,deque,map,multimap,set,multiset</p>
</li>
<li><p>你如何理解MVC。简单举例来说明其应用。</p>
</li>
</ol>
<p>MVC模式是observer 模式的一个特例,现在很多都是java的一些框架，MFC的，PHP的。</p>
<ol start="35">
<li>C++特点是什么，多态实现机制？（面试问过）多态作用？两个必要条件？</li>
</ol>
<p>C++中多态机制主要体现在两个方面，一个是函数的重载，一个是接口的重写。接口多态指的是“一个接口多种形态”。每一个对象内部都有一个虚表指针，该虚表指针被初始化为本类的虚表。所以在程序中，不管你的对象类型如何转换，但该对象内部的虚表指针是固定的，所以呢，才能实现动态的对象函数调用，这就是C++多态性实现的原理。</p>
<p>多态的基础是继承，需要虚函数的支持，简单的多态是很简单的。子类继承父类大部分的资源，不能继承的有构造函数，析构函数，拷贝构造函数，operator=函数，友元函数等等</p>
<p>作用：</p>
<ul>
<li>隐藏实现细节，代码能够模块化；</li>
<li>接口重用：为了类在继承和派生的时候正确调用。</li>
</ul>
<p>必要条件：</p>
<ul>
<li>一个基类的指针或者引用指向派生类的对象</li>
<li>虚函数</li>
</ul>
<ol start="36">
<li>多重继承有什么问题? 怎样消除多重继承中的二义性?</li>
</ol>
<p>1)增加程序的复杂度，使程序的编写和维护比较困难，容易出错；<br>2)继承类和基类的同名函数产生了二义性，同名函数不知道调用基类还是继承类，C++中使用虚函数解决这个问题<br>3)继承过程中可能会继承一些不必要的数据，对于多级继承，可能会产生数据很长</p>
<p>可以使用成员限定符和虚函数解决多重继承中函数的二义性问题。</p>
<ol start="37">
<li><p>求两个数的乘积和商数，该作用由宏定义来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define product(a,b) ((a)*(b))</span><br><span class="line">#define divide(a,b)  ((a)/(b))</span><br></pre></td></tr></table></figure>
</li>
<li><p>什么叫静态关联，什么叫动态关联</p>
</li>
</ol>
<p>多态中，静态关联是程序在编译阶段就能确定实际执行动作，程序运行才能确定叫动态关联</p>
<ol start="39">
<li>什么叫智能指针?常用的智能指针有哪些？智能指针的实现？</li>
</ol>
<p>智能指针是一个存储指向动态分配（堆）对象指针的类，构造函数传入普通指针，析构函数释放指针。栈上分配，函数或程序结束自动释放，防止内存泄露。使用引用计数器，类与指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建，增加引用计数；对一个对象进行赋值时，减少引用计数，并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数，当引用计数减至0，则删除基础对象。</p>
<p>std::auto_ptr，不支持复制（拷贝构造函数）和赋值（operator =），编译不会提示出错。</p>
<p>C++11引入的unique_ptr， 也不支持复制和赋值，但比auto_ptr好，直接赋值会编译出错。</p>
<p>C++11或boost的shared_ptr，基于引用计数的智能指针。可随意赋值，直到内存的引用计数为0的时候这个内存会被释放。还有Weak_ptr</p>
<ol start="40">
<li>枚举与#define 宏的区别</li>
</ol>
<p>1）#define 宏常量是在预编译阶段进行简单替换。枚举常量则是在编译的时候确定其值。<br>2）可以调试枚举常量，但是不能调试宏常量。<br>3）枚举可以一次定义大量相关的常量，而#define 宏一次只能定义一个。</p>
<ol start="41">
<li><p>介绍一下函数的重载<br>重载是在不同类型上作不同运算而又用同样的名字的函数。重载函数至少在参数个数，参数类型，或参数顺序上有所不同。</p>
</li>
<li><p>派生新类的过程要经历三个步骤</p>
</li>
</ol>
<ul>
<li>吸收基类成员</li>
<li>改造基类成员</li>
<li>添加新成员</li>
</ul>
<ol start="43">
<li>面向对象的三个基本特征，并简单叙述之?</li>
</ol>
<ul>
<li>封装：将客观事物抽象成类，每个类对自身的数据和方法实行</li>
<li>继承</li>
<li>多态：允许一个基类的指针或引用指向一个派生类对象</li>
</ul>
<ol start="44">
<li>多态性体现都有哪些？动态绑定怎么实现？</li>
</ol>
<p>多态性是一个接口,多种实现，是面向对象的核心。 编译时多态性：通过重载函数实现。运行时多态性：通过虚函数实现,结合动态绑定。</p>
<ol start="45">
<li>虚函数，虚函数表里面内存如何分配？</li>
</ol>
<p>编译时若基类中有虚函数，编译器为该的类创建一个一维数组的虚表，存放是每个虚函数的地址。基类和派生类都包含虚函数时，这两个类都建立一个虚表。构造函数中进行虚表的创建和虚表指针的初始化。在构造子类对象时，要先调用父类的构造函数，初始化父类对象的虚表指针，该虚表指针指向父类的虚表。执行子类的构造函数时，子类对象的虚表指针被初始化，指向自身的虚表。每一个类都有虚表。虚表可以继承，如果子类没有重写虚函数，那么子类虚表中仍然会有该函数的地址，只不过这个地址指向的是基类的虚函数实现。派生类的虚表中虚函数地址的排列顺序和基类的虚表中虚函数地址排列顺序相同。</p>
<p>当用一个指针/引用调用一个函数的时候，被调用的函数是取决于这个指针/引用的类型。即如果这个指针/引用是基类对象的指针/引用就调用基类的方法；如果指针/引用是派生类对象的指针/引用就调用派生类的方法，当然如果派生类中没有此方法，就会向上到基类里面去寻找相应的方法。这些调用在编译阶段就确定了。当涉及到多态性的时候，采用了虚函数和动态绑定，此时的调用就不会在编译时候确定而是在运行时确定。不在单独考虑指针/引用的类型而是看指针/引用的对象的类型来判断函数的调用，根据对象中虚指针指向的虚表中的函数的地址来确定调用哪个函数。</p>
<ol start="46">
<li>纯虚函数如何定义？含有纯虚函数的类称为什么？为什么析构函数要定义成虚函数？</li>
</ol>
<p>纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。纯虚函数是虚函数再加上= 0。virtual void fun ()=0。含有纯虚函数的类称为抽象类在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。如果析构函数不是虚函数，那么释放内存时候，编译器会使用静态联编，认为p就是一个基类指针，调用基类析构函数，这样子类对象的内存没有释放，造成内存泄漏。定义成虚函数以后，就会动态联编，先调用子类析构函数，再基类。</p>
<ol start="47">
<li>C++中哪些不能是虚函数？</li>
</ol>
<p>1）普通函数只能重载，不能被重写，因此编译器会在编译时绑定函数。<br>2）构造函数是知道全部信息才能创建对象，然而虚函数允许只知道部分信息。<br>3）内联函数在编译时被展开，虚函数在运行时才能动态绑定函数。<br>4）友元函数 因为不可以被继承。<br>5）静态成员函数 只有一个实体，不能被继承。父类和子类共有。</p>
<ol start="48">
<li>类型转换有哪些？各适用什么环境？dynamic_cast转换失败时，会出现什么情况(对指针，返回NULL.对引用，抛出bad_cast异常)？</li>
</ol>
<p>静态类型转换，static_cast，基本类型之间和具有继承关系的类型。<br>例子A,double类型转换成int。B,将子类对象转换成基类对象。<br>常量类型转换，const_cast, 去除指针变量的常量属性。<br>无法将非指针的常量转换为普通变量。<br>动态类型转换，dynamic_cast，运行时进行转换分析的，并非在编译时进行。dynamic_cast转换符只能用于含有虚函数的类。dynamic_cast用于类层次间的向上转换和向下转换，还可以用于类间的交叉转换。在类层次间进行向上转换，即子类转换为父类，此时完成的功能和static_cast是相同的，因为编译器默认向上转换总是安全的。向下转换时，dynamic_cast具有类型检查的功能，更加安全。类间的交叉转换指的是子类的多个父类之间指针或引用的转换。该函数只能在继承类对象的指针之间或引用之间进行类型转换，或者有虚函数的类。</p>
<ol start="49">
<li><p>如何判断一段程序是由C 编译程序还是由C++编译程序编译的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef __cplusplus</span><br><span class="line">cout&lt;&lt;&quot;C++&quot;;</span><br><span class="line">#else</span><br><span class="line">cout&lt;&lt;&quot;c&quot;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么要用static_cast转换而不用c语言中的转换？<br><code>static_cast</code>转换，它会检查类型看是否能转换，有类型安全检查。<br>比如，这个在C++中合法，但是确实错误的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A* a= new A;</span><br><span class="line">B* b = (B*)a;</span><br></pre></td></tr></table></figure>
</li>
<li><p>操作符重载（+操作符），具体如何去定义？<br>除了类属关系运算符<code>.</code>、成员指针运算符<code>*</code>、作用域运算符<code>::</code>、<code>sizeof</code>运算符和三目运算符<code>?:</code>。以外，C++中的所有运算符都可以重载。<br><code>&lt;返回类型说明符&gt; operator &lt;运算符符号&gt;(&lt;参数表&gt;){}</code><br>重载为类的成员函数和重载为类的非成员函数。参数个数会不同，应为this指针。</p>
</li>
<li><p>内存对齐的原则？ </p>
</li>
</ol>
<ul>
<li>结构体的大小为最大成员的整数倍。</li>
<li>成员首地址的偏移量为其类型大小整数倍。</li>
</ul>
<ol start="53">
<li>内联函数与宏定义的区别？<br>内联函数是用来消除函数调用时的时间开销。频繁被调用的短小函数非常受益。</li>
</ol>
<ul>
<li>宏定义不检查函数参数，返回值什么的，只是展开，相对来说，内联函数会检查参数类型，所以更安全。</li>
<li>宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的</li>
</ul>
<ol start="54">
<li><p>动态分配对象和静态分配对象的区别？<br>动态分配就是用运算符new来创建一个类的对象，在堆上分配内存。<br>静态分配就是A a;这样来由编译器来创建一个对象，在栈上分配内存。</p>
</li>
<li><p>explicit是干什么用的 ?<br>构造器 ，可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生。explicit是用来防止外部非正规的拷贝构造的，要想不存在传值的隐式转换问题。</p>
</li>
<li><p>内存溢出有那些因素？<br>(1) 使用非类型安全(non-type-safe)的语言如 C/C++ 等。<br>(2) 以不可靠的方式存取或者复制内存缓冲区。<br>(3) 编译器设置的内存缓冲区太靠近关键数据结构。</p>
</li>
<li><p>new与malloc的区别，delete和free的区别？</p>
</li>
</ol>
<ul>
<li>malloc/free是C/C++语言的标准库函数，new/delete是C++的运算符</li>
<li>new能够自动分配空间大小，malloc传入参数。</li>
<li>new/delete能进行对对象进行构造和析构函数的调用进而对内存进行更加详细的工作，而malloc/free不能。</li>
</ul>
<p>既然new/delete的功能完全覆盖了malloc/free，为什么C++还保留malloc/free呢？因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。</p>
<ol start="58">
<li>必须使用初始化列表初始化数据成员的情况</li>
</ol>
<ul>
<li>是对象的情况；</li>
<li>const修饰的类成员；</li>
<li>引用成员数据；</li>
</ul>
<p>类成员变量的初始化不是按照初始化表顺序被初始化，是按照在类中声明的顺序被初始化的。</p>
<ol start="59">
<li>深入谈谈堆和栈</li>
</ol>
<p>1).分配和管理方式不同 ：<br>       堆是动态分配的，其空间的分配和释放都由程序员控制。<br>      栈由编译器自动管理。栈有两种分配方式：静态分配和动态分配。静态分配由编译器完成，比如局部变量的分配。动态分配由alloca()函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无须手工控制。<br>2).产生碎片不同<br>        对堆来说，频繁的new/delete或者malloc/free势必会造成内存空间的不连续，造成大量的碎片，使程序效率降低。<br>        对栈而言，则不存在碎片问题，因为栈是先进后出的队列，永远不可能有一个内存块从栈中间弹出。<br>3).生长方向不同<br>      堆是向着内存地址增加的方向增长的，从内存的低地址向高地址方向增长。<br>     栈是向着内存地址减小的方向增长，由内存的高地址向低地址方向增长。</p>
<ol start="60">
<li><p>内存的静态分配和动态分配的区别？<br>时间不同。静态分配发生在程序编译和连接时。动态分配则发生在程序调入和执行时。<br>空间不同。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。alloca，可以从栈里动态分配内存，不用担心内存泄露问题，当函数返回时，通过alloca申请的内存就会被自动释放掉。</p>
</li>
<li><p>模版怎么实现？模版作用？<br>实现：<code>template void swap(T&amp; a, T&amp; b){}</code><br>作用：将算法与具体对象分离，与类型无关，通用，节省精力</p>
</li>
<li><p>多重类构造和析构的顺序</p>
</li>
</ol>
<p>记住析构函数的调用顺序与构造函数是相反的。</p>
<ol start="63">
<li>迭代器删除元素的会发生什么？</li>
</ol>
<p>迭代器失效</p>
<ol start="64">
<li>静态成员函数和数据成员有什么意义？<br>1）非静态数据成员，每个对象都有自己的拷贝。而静态数据成员被当作是类的成员，是该类的所有对象所共有的，在程序中只分配一次内存只有一份拷贝，所以对象都共享，值对每个对象都是一样的，它的值可以更新。</li>
</ol>
<p>2）静态数据成员存储在全局数据区，所以不能在类声明中定义，应该在类外定义。由于它不属于特定的类对象，在没有产生类对象时作用域就可见，即在没有产生类的实例时，我们就可以操作它。</p>
<p>3）静态成员函数与静态数据成员一样，都是在类的内部实现，属于类定义的一部分。因为普通成员函数总是具体的属于具体对象的，每个有this指针。静态成员函数没有this指针，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数。静态成员之间可以互相访问，包括静态成员函数访问静态数据成员和访问静态成员函数；</p>
<p>4）非静态成员函数可以任意地访问静态成员函数和静态数据成员；</p>
<p>5）没有this指针的额外开销，静态成员函数与类的全局函数相比，速度上会有少许的增长；</p>
<p>6）调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)为一个类的对象或指向类对象的指调用静态成员函数。</p>
<ol start="65">
<li>sizeof一个类求大小（注意成员变量，函数，虚函数，继承等等对大小的影响）</li>
</ol>
<p>以下运行环境都是一般的，在32位编译环境中<br>基本数据类型的sizeof<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;sizeof(char)&lt;&lt;endl;                     结果是1</span><br><span class="line">cout&lt;&lt;sizeof(int)&lt;&lt;endl;                        结果是4</span><br><span class="line">cout&lt;&lt;sizeof(unsigned int)&lt;&lt;endl; 结果是4 </span><br><span class="line">cout&lt;&lt;sizeof(long int)&lt;&lt;endl;                结果是4</span><br><span class="line">cout&lt;&lt;sizeof(short int)&lt;&lt;endl;               结果是2</span><br><span class="line">cout&lt;&lt;sizeof(float)&lt;&lt;endl;                     结果是4</span><br><span class="line">cout&lt;&lt;sizeof(double)&lt;&lt;endl;                 结果是8</span><br></pre></td></tr></table></figure></p>
<p>指针变量的sizeof<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char *pc =&quot;abc&quot;;</span><br><span class="line">sizeof( pc ); // 结果为4</span><br><span class="line">sizeof(*pc);     // 结果为1</span><br><span class="line">int *pi;</span><br><span class="line">sizeof( pi ); //结果为4</span><br><span class="line">sizeof(*pi);     //结果为4</span><br><span class="line">char **ppc = &amp;pc;  </span><br><span class="line">sizeof( ppc ); // 结果为4   </span><br><span class="line">sizeof( *ppc ); // 结果为4     </span><br><span class="line">sizeof( **ppc ); // 结果为1</span><br><span class="line">void (*pf)();// 函数指针</span><br><span class="line">sizeof( pf );// 结果为4</span><br></pre></td></tr></table></figure></p>
<p>数组的sizeof数组的sizeof值等于数组所占用的内存字节数，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char a1[] = &quot;abc&quot;;</span><br><span class="line">int a2[3];</span><br><span class="line">sizeof( a1 ); // 结果为4，字符 末尾还存在一个NULL终止符</span><br><span class="line">sizeof( a2 ); // 结果为3*4=12（依赖于int）</span><br></pre></td></tr></table></figure></p>
<p>写到这里，提一问，下面的c3，c4值应该是多少呢<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void foo3(char a3[3])</span><br><span class="line">&#123;</span><br><span class="line">	int c3 = sizeof( a3 ); // c3 == 4</span><br><span class="line">&#125;</span><br><span class="line">void foo4(char a4[])</span><br><span class="line">&#123;</span><br><span class="line">	int c4 = sizeof( a4 ); // c4 == 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也许当你试图回答c4的值时已经意识到c3答错了，是的，c3!=3。这里函数参数a3已不再是数组类型，而是蜕变成指针，相当于<code>char* a3</code>，为什么仔细想想就不难明白，我们调用函数foo1时，程序会在栈上分配一个大小为3的数组吗不会！数组是“传址”的，调用者只需将实参的地址传递过去，所以a3自然为指针类型<code>char*</code>，c3的值也就为4。</p>
<p>结构体的sizeof<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct MyStruct</span><br><span class="line">&#123;</span><br><span class="line">	double dda1;</span><br><span class="line">	char dda;</span><br><span class="line">	int type</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>//结果为16，为上面的结构分配空间的时候，VC根据成员变量出现的顺序和对齐方式，先为第一个成员dda1分配空间，其起始地址跟结构的起始地址相同（刚好偏移量0刚好为sizeof(double)的倍数），该成员变量占用sizeof(double)=8个字节；接下来为第二个成员dda分配空间，这时下一个可以分配的地址对于结构的起始地址的偏移量为8，是sizeof(char)的倍数，所以把dda存放在偏移量为8的地方满足对齐方式，该成员变量占用sizeof(char)=1个字节；接下来为第三个成员type分配空间，这时下一个可以分配的地址对于结构的起始地址的偏移量为9，不是sizeof(int)=4的倍数，为了满足对齐方式对偏移量的约束问题，VC自动填充3个字节（这三个字节没有放什么东西），这时下一个可以分配的地址对于结构的起始地址的偏移量为12，刚好是sizeof(int)=4的倍数，所以把type存放在偏移量为12的地方，该成员变量占用sizeof(int)=4个字节；这时整个结构的成员变量已经都分配了空间，总的占用的空间大小为：8+1+3+4=16，刚好为结构的字节边界数（即结构中占用最大空间的类型所占用的字节数sizeof(double)=8）的倍数，所以没有空缺的字节需要填充。所以整个结构的大小为：sizeof(MyStruct)=8+1+3+4=16，其中有3个字节是VC自动填充的，没有放任何有意义的东西。</p>
<p>含位域结构体的sizeof<br>示例1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct BF1</span><br><span class="line">&#123;</span><br><span class="line">char f1 : 3;</span><br><span class="line">char f2 : 4;</span><br><span class="line">char f3 : 5;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>位域类型为char，第1个字节仅能容纳下f1和f2，所以f2被压缩到第1个字节中，而f3只能从下一个字节开始。因此sizeof(BF1)的结果为2。</p>
<p>含有联合体的结构体的sizeof<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct s1</span><br><span class="line">&#123;</span><br><span class="line">	char *ptr,ch;                   //有指针变成4＋4</span><br><span class="line">	union A            //后面跟了A定义了一个类型,不占内存，而后面不跟A,是声明了结构体的一个成员,占内存,</span><br><span class="line">	&#123;</span><br><span class="line">	    short a,b;</span><br><span class="line">	    unsigned int c:2, d:1;</span><br><span class="line">	&#125;;</span><br><span class="line">	struct s1* next;                //指针占4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样是8＋4＝12个字节<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct s1</span><br><span class="line">&#123;</span><br><span class="line">	char *ptr,ch;                          </span><br><span class="line">	union                      //联合体是结构体的成员，占内存，并且最大类型是unsigned int，占4</span><br><span class="line">	&#123;</span><br><span class="line">	     short a,b;</span><br><span class="line">	     unsigned int c:2, d:1;</span><br><span class="line">	&#125;;</span><br><span class="line">	struct s1* next;                        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样是8＋4＋4＝16个字节</p>
<p>结构体体含有结构体的sizeof<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct S1</span><br><span class="line">    &#123;</span><br><span class="line">     char c;</span><br><span class="line">     int i;</span><br><span class="line">    &#125;;</span><br><span class="line">struct S3</span><br><span class="line">    &#123;</span><br><span class="line">     char c1;</span><br><span class="line">     S1 s;</span><br><span class="line">     char c2;</span><br><span class="line">    &#125;;</span><br><span class="line">cout&lt;&lt;sizeof(S3);      //S3=16</span><br></pre></td></tr></table></figure></p>
<p>S1的最宽简单成员的类型为int，S3在考虑最宽简单类型成员时是将S1“打散”看的，<br>所以S3的最宽简单类型为int，这样，通过S3定义的变量，其存储空间首地址需要被4整<br>除，整个sizeof(S3)的值也应该被4整除。<br>c1的偏移量为0，s的偏移量呢这时s是一个整体，它作为结构体变量也满足前面三个<br>准则，所以其大小为8，偏移量为4，c1与s之间便需要3个填充字节，而c2与s之间就不需<br>要了，所以c2的偏移量为12，算上c2的大小为13，13是不能被4整除的，这样末尾还得补<br>上3个填充字节。最后得到sizeof(S3)的值为16。</p>
<p>带有#pragma pack的sizeof<br>它是用来调整结构体对齐方式的，不同编译器名称和用法略有不同，VC6中通过#pragma pack实现，也可以直接修改/Zp编译开关。#pragma pack的基本用法为：#pragma pack( n )，n为字节对齐<br>数，其取值为1、2、4、8、16，默认是8，如果这个值比结构体成员的sizeof值小，那么该成员的偏移量应该以此值为准，即是说，结构体成员的偏移量应该取二者的最小值，</p>
<p>再看示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#pragma pack(push) // 将当前pack设置压栈保存</span><br><span class="line">#pragma pack(2)// 必须在结构体定义之前使用</span><br><span class="line">struct S1</span><br><span class="line">&#123;</span><br><span class="line">	char c;</span><br><span class="line">	int i;</span><br><span class="line">&#125;;</span><br><span class="line">struct S3</span><br><span class="line">&#123;</span><br><span class="line">	char c1;</span><br><span class="line">	S1 s;</span><br><span class="line">	char c2</span><br><span class="line">&#125;;</span><br><span class="line">#pragma pack(pop) // 恢复先前的pack设置</span><br></pre></td></tr></table></figure></p>
<p>计算sizeof(S1)时，min(2, sizeof(i))的值为2，所以i的偏移量为2，加上sizeof(i)<br>等于6，能够被2整除，所以整个S1的大小为6。<br>同样，对于sizeof(S3)，s的偏移量为2，c2的偏移量为8，加上sizeof(c2)等于9，不能<br>被2整除，添加一个填充字节，所以sizeof(S3)等于10。</p>
<p>空结构体的sizeof<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct S5 &#123; &#125;;</span><br><span class="line">sizeof( S5 ); // 结果为1</span><br></pre></td></tr></table></figure></p>
<p>类的sizeof<br>类的sizeof值等于类中成员变量所占用的内存字节数。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int b;</span><br><span class="line">	float c;</span><br><span class="line">	char d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	A object;</span><br><span class="line">	cout &lt;&lt; &quot;sizeof(object) is &quot; &lt;&lt; sizeof(object) &lt;&lt; endl;</span><br><span class="line">	return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果为12（我的机器上sizeof(float)值为4，字节对其前面已经讲过）。</p>
<p>不过需要注意的是，如果类中存在静态成员变量，结果又会是什么样子呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	static int a;</span><br><span class="line">	int b;</span><br><span class="line">	float c;</span><br><span class="line">	char d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A object;</span><br><span class="line">	cout &lt;&lt; &quot;sizeof(object) is &quot; &lt;&lt; sizeof(object) &lt;&lt; endl;</span><br><span class="line">	return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>16？不对。结果仍然是12.</p>
<p>因为在程序编译期间，就已经为static变量在静态存储区域分配了内存空间，并且这块内存在程序的整个运行期间都存在。</p>
<p>而每次声明了类A的一个对象的时候，为该对象在堆上，根据对象的大小分配内存。</p>
<p>如果类A中包含成员函数，那么又会是怎样的情况呢？看下面的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	static int a;</span><br><span class="line">	int b;</span><br><span class="line">	float c;</span><br><span class="line">	char d;</span><br><span class="line">	int add(int x,int y)</span><br><span class="line">	&#123;</span><br><span class="line">		return x+y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A object;</span><br><span class="line">	cout &lt;&lt; &quot;sizeof(object) is &quot; &lt;&lt; sizeof(object) &lt;&lt; endl;</span><br><span class="line">	b = object.add(3,4);</span><br><span class="line">	cout &lt;&lt; &quot;sizeof(object) is &quot; &lt;&lt; sizeof(object) &lt;&lt; endl;</span><br><span class="line">	return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果仍为12。 </p>
<p>因为只有非静态类成员变量在新生成一个object的时候才需要自己的副本。<br>所以每个非静态成员变量在生成新object需要内存，而function是不需要的。</p>
<ol start="66">
<li><p>请用C/C++实现字符串反转（不调用库函数）”abc”类型的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">char *reverse_str(char *str) &#123;</span><br><span class="line">    if(NULL == str) &#123; //字符串为空直接返回</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">    char *begin;</span><br><span class="line">    char *end;</span><br><span class="line">    begin = end = str;</span><br><span class="line"> </span><br><span class="line">    while(*end != &apos;\0&apos;) &#123; //end指向字符串的末尾</span><br><span class="line">        end++;</span><br><span class="line">    &#125;</span><br><span class="line">    --end;</span><br><span class="line"> </span><br><span class="line">    char temp;</span><br><span class="line">    while(begin &lt; end) &#123; //交换两个字符</span><br><span class="line">        temp = *begin;</span><br><span class="line">        *begin = *end;</span><br><span class="line">        *end = temp;</span><br><span class="line">        begin++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    return str; //返回结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>写一个函数，将字符串翻转，翻转方式如下：“I am a student”反转成“student a am I”，不借助任何库函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void revesal(char * start, char* end)&#123;</span><br><span class="line">    char *temp_s = start;</span><br><span class="line">    char *temp_e = end;</span><br><span class="line">    while(temp_s &lt; temp_e)&#123;</span><br><span class="line">        char temp= *temp_s;</span><br><span class="line">        *temp_s= *temp_e;</span><br><span class="line">        *temp_e = temp;</span><br><span class="line">        ++temp_s;</span><br><span class="line">        --temp_e;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void revesal_str(char *str)&#123;</span><br><span class="line">    if(str == NULL)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char *start = str;</span><br><span class="line">    char *end = str;</span><br><span class="line"></span><br><span class="line">    while(*++end !=&apos;\0&apos;);</span><br><span class="line">    revesal(start, end-1);</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    char *sub_start = str;</span><br><span class="line">    while(start &lt; end + 1 )&#123;</span><br><span class="line">        if(*start == &apos; &apos; || *start == &apos;\0&apos;)&#123;</span><br><span class="line">            char *temp = start - 1;</span><br><span class="line">            revesal(sub_start,temp);</span><br><span class="line">            while(*++start ==&apos; &apos;);</span><br><span class="line">            sub_start = start;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        ++start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>析构函数可以抛出异常吗？为什么不能抛出异常？除了资源泄露，还有其他需考虑的因素吗？<br>C++标准指明析构函数不能、也不应该抛出异常。C++异常处理模型最大的特点和优势就是对C++中的面向对象提供了最强大的无缝支持。那么如果对象在运行期间出现了异常，C++异常处理模型有责任清除那些由于出现异常所导致的已经失效了的对象(也即对象超出了它原来的作用域)，并释放对象原来所分配的资源， 这就是调用这些对象的析构函数来完成释放资源的任务，所以从这个意义上说，析构函数已经变成了异常处理的一部分。</p>
</li>
</ol>
<p>1）如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。</p>
<p>2）通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。</p>
<ol start="69">
<li>拷贝构造函数作用及用途？什么时候需要自定义拷贝构造函数？</li>
</ol>
<p>一般如果构造函数中存在动态内存分配，则必须定义拷贝构造函数。否则，可能会导致两个对象成员指向同一地址，出现“指针悬挂问题”。</p>
<ol start="70">
<li>100万个32位整数，如何最快找到中位数。能保证每个数是唯一的，如何实现O(N)算法？</li>
</ol>
<p>1).内存足够时：快排</p>
<p>2).内存不足时：分桶法：化大为小，把所有数划分到各个小区间，把每个数映射到对应的区间里，对每个区间中数的个数进行计数，数一遍各个区间，看看中位数落在哪个区间，若够小，使用基于内存的算法，否则 继续划分</p>
<ol start="71">
<li><p>OFFSETOF(s, m)的宏定义，s是结构类型，m是s的成员，求m在s中的偏移量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define OFFSETOF（s, m） size_t（&amp;((s*)0)-&gt;m）</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++虚函数是如何实现的？<br>使用虚函数表。 C++对象使用虚表， 如果是基类的实例，对应位置存放的是基类的函数指针；如果是继承类，对应位置存放的是继承类的函数指针（如果在继承类有实现）。所以 ，当使用基类指针调用对象方法时，也会根据具体的实例，调用到继承类的方法。 </p>
</li>
<li><p>C++的虚函数有什么作用？<br>虚函数作用是实现多态，虚函数其实是实现封装，使得使用者不需要关心实现的细节。在很多设计模式中都是这样用法，例如Factory、Bridge、Strategy模式。</p>
</li>
<li><p>MFC中CString是类型安全类吗，为什么？</p>
</li>
</ol>
<p>不是，其他数据类型转换到CString可以使用CString的成员函数Format来转换</p>
<ol start="74">
<li>动态链接库的两种使用方法及特点？<br>1)．载入时动态链接，模块非常明确调用某个导出函数，使得他们就像本地函数一样。这需要链接时链接那些函数所在DLL的导入库，导入库向系统提供了载入DLL时所需的信息及DLL函数定位。 </li>
</ol>
<p>2)运行时动态链接。</p>
<h1 id="服务器编程"><a href="#服务器编程" class="headerlink" title="服务器编程"></a>服务器编程</h1><ol>
<li>多线程和多进程的区别（重点 必须从cpu调度，上下文切换，数据共享，多核cup利用率，资源占用，等等各方面回答，然后有一个问题必须会被问到：哪些东西是一个线程私有的？答案中必须包含寄存器，否则悲催）！</li>
</ol>
<p>1）进程数据是分开的:共享复杂，需要用IPC，同步简单；多线程共享进程数据：共享简单，同步复杂<br>2）进程创建销毁、切换复杂，速度慢 ；线程创建销毁、切换简单，速度快<br>3）进程占用内存多， CPU利用率低；线程占用内存少， CPU利用率高<br>4）进程编程简单，调试简单；线程 编程复杂，调试复杂<br>5）进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉<br>6）进程适应于多核、多机分布；线程适用于多核</p>
<p>线程所私有的：</p>
<p>线程id、寄存器的值、栈、线程的优先级和调度策略、线程的私有数据、信号屏蔽字、errno变量、</p>
<ol start="2">
<li>多线程锁的种类有哪些？</li>
</ol>
<p>a.互斥锁（mutex）b.递归锁 c.自旋锁 d.读写锁</p>
<ol start="3">
<li>自旋锁和互斥锁的区别？</li>
</ol>
<p>当锁被其他线程占用时，其他线程并不是睡眠状态，而是不停的消耗CPU，获取锁；互斥锁则不然，保持睡眠，直到互斥锁被释放激活。</p>
<p>自旋锁，递归调用容易造成死锁，对长时间才能获得到锁的情况，使用自旋锁容易造成CPU效率低，只有内核可抢占式或SMP情况下才真正需要自旋锁。</p>
<ol start="4">
<li>进程间通信和线程间通信</li>
</ol>
<p>1）.管道 2）消息队列 3)共享内存 4)信号量 5)套接字 6)条件变量</p>
<ol start="5">
<li><p>多线程程序架构，线程数量应该如何设置？</p>
<p>应尽量和CPU核数相等或者为CPU核数+1的个数</p>
</li>
<li><p>什么是原子操作，gcc提供的原子操作原语，使用这些原语如何实现读写锁？</p>
</li>
</ol>
<p>原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch。</p>
<ol start="7">
<li>网络编程设计模式，reactor/proactor/半同步半异步模式？</li>
</ol>
<p>reactor模式：同步阻塞I/O模式，注册对应读写事件处理器，等待事件发生进而调用事件处理器处理事件。 proactor模式：异步I/O模式。Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的，Reactor中需要应用程序自己读取或者写入数据，Proactor模式中，应用程序不需要进行实际读写过程。</p>
<p>Reactor是：</p>
<p>主线程往epoll内核上注册socket读事件，主线程调用epoll_wait等待socket上有数据可读，当socket上有数据可读的时候，主线程把socket可读事件放入请求队列。睡眠在请求队列上的某个工作线程被唤醒，处理客户请求，然后往epoll内核上注册socket写请求事件。主线程调用epoll_wait等待写请求事件，当有事件可写的时候，主线程把socket可写事件放入请求队列。睡眠在请求队列上的工作线程被唤醒，处理客户请求。</p>
<p>Proactor:</p>
<p>主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读完成后如何通知应用程序，主线程继续处理其他逻辑，当socket上的数据被读入用户缓冲区后，通过信号告知应用程序数据已经可以使用。应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后调用aio_write函数向内核注册socket写完成事件，并告诉内核写缓冲区的位置，以及写完成时如何通知应用程序。主线程处理其他逻辑。当用户缓存区的数据被写入socket之后内核向应用程序发送一个信号，以通知应用程序数据已经发送完毕。应用程序预先定义的数据处理函数就会完成工作。</p>
<p>半同步半异步模式：</p>
<p>上层的任务（如：数据库查询，文件传输）使用同步I/O模型，简化了编写并行程序的难度。<br>而底层的任务（如网络控制器的中断处理）使用异步I/O模型，提供了执行效率。</p>
<ol start="8">
<li>有一个计数器，多个线程都需要更新，会遇到什么问题，原因是什么，应该如何做？如何优化？</li>
</ol>
<p>有可能一个线程更新的数据已经被另外一个线程更新了，更新的数据就会出现异常，可以加锁，保证数据更新只会被一个线程完成。</p>
<ol start="9">
<li>如果select返回可读，结果只读到0字节，什么情况？</li>
</ol>
<p>某个套接字集合中没有准备好，可能会select内存用FD_CLR清为0.</p>
<ol start="10">
<li>connect可能会长时间阻塞，怎么解决?</li>
</ol>
<p>1.使用定时器；（最常用也最有效的一种方法）<br>2.采用非阻塞模式：设置非阻塞，返回之后用select检测状态。</p>
<ol start="11">
<li>keepalive 是什么东西？如何使用？</li>
</ol>
<p>keepalive，是在TCP中一个可以检测死连接的机制。</p>
<p>1）.如果主机可达，对方就会响应ACK应答，就认为是存活的。<br>2）.如果可达，但应用程序退出，对方就发RST应答，发送TCP撤消连接。<br>3）.如果可达，但应用程序崩溃，对方就发FIN消息。<br>4）.如果对方主机不响应ack, rst，继续发送直到超时，就撤消连接。默认二个小时。</p>
<ol start="12">
<li>socket什么情况下可读？</li>
</ol>
<p>1.socket接收缓冲区中已经接收的数据的字节数大于等于socket接收缓冲区低潮限度的当前值;对这样的socket的读操作不会阻塞,并返回一个大于0的值(准备好读入的数据的字节数).<br>2.连接的读一半关闭(即:接收到对方发过来的FIN的TCP连接),并且返回0;<br>3.socket收到了对方的connect请求已经完成的连接数为非0.这样的soocket处于可读状态；<br>4.异常的情况下socket的读操作将不会阻塞,并且返回一个错误(-1)。</p>
<ol start="13">
<li>udp调用connect有什么作用？</li>
</ol>
<p>1).因为UDP可以是一对一，多对一，一对多，或者多对多的通信，所以每次调用sendto()/recvfrom()时都必须指定目标IP和端口号。通过调用connect()建立一个端到端的连接，就可以和TCP一样使用send()/recv()传递数据，而不需要每次都指定目标IP和端口号。但是它和TCP不同的是它没有三次握手的过程。</p>
<p>2).可以通过在已建立连接的UDP套接字上，调用connect()实现指定新的IP地址和端口号以及断开连接。</p>
<ol start="14">
<li>socket编程，如果client断电了，服务器如何快速知道？</li>
</ol>
<p>使用定时器（适合有数据流动的情况）；</p>
<p>使用socket选项SO_KEEPALIVE（适合没有数据流动的情况）; </p>
<p>1）、自己编写心跳包程序,简单的说就是自己的程序加入一条线程,定时向对端发送数据包,查看是否有ACK,根据ACK的返回情况来管理连接。此方法比较通用,一般使用业务层心跳处理,灵活可控,但改变了现有的协议;<br>2）、使用TCP的keepalive机制,UNIX网络编程不推荐使用SO_KEEPALIVE来做心）跳检测。<br>keepalive原理:TCP内嵌有心跳包,以服务端为例,当server检测到超过一定时间(/proc/sys/net/ipv4/tcp_keepalive_time 7200 即2小时)没有数据传输,那么会向client端发送一个keepalive packet。</p>
<h1 id="liunx操作系统"><a href="#liunx操作系统" class="headerlink" title="liunx操作系统"></a>liunx操作系统</h1><ol>
<li>熟练netstat tcpdump ipcs ipcrm</li>
</ol>
<p>netstat:检查网络状态，tcpdump:截获数据包，ipcs:检查共享内存，ipcrm:解除共享内存</p>
<ol start="2">
<li>共享内存段被映射进进程空间之后，存在于进程空间的什么位置？共享内存段最大限制是多少？</li>
</ol>
<p>将一块内存映射到两个或者多个进程地址空间。通过指针访问该共享内存区。一般通过mmap将文件映射到进程地址共享区。</p>
<p>存在于进程数据段，最大限制是0x2000000Byte</p>
<ol start="3">
<li>ELF是什么？其大小与程序中全局变量的是否初始化有什么关系（注意未初始化的数据放在bss段）</li>
</ol>
<p>可执行连接格式。可以减少重新编程重新编译的代码。</p>
<ol start="4">
<li>动态链接和静态链接的区别？</li>
</ol>
<p>动态链接是只建立一个引用的接口，而真正的代码和数据存放在另外的可执行模块中，在可执行文件运行时再装入；而静态链接是把所有的代码和数据都复制到本模块中，运行时就不再需要库了</p>
<ol start="5">
<li>32位系统一个进程最多有多少堆内存</li>
</ol>
<p>32位意味着4G的寻址空间，Linux把它分为两部分：最高的1G(虚拟地址从0xC0000000到0xffffffff)用做内核本身，成为“系统空间”，而较低的3G字节（从0x00000000到0xbffffff）用作各进程的“用户空间”。每个进程可以使用的用户空间是3G。虽然各个进程拥有其自己的3G用户空间，系统空间却由所有的进程共享。从具体进程的角度看，则每个进程都拥有4G的虚拟空间，较低的3G为自己的用户空间，最高的1G为所有进程以及内核共享的系统空间。实际上有人做过测试也就2G左右。</p>
<ol start="6">
<li>写一个c程序辨别系统是64位 or 32位<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void* number =  0;      printf(&quot;%d\n&quot;,sizeof(&amp;number));</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>输出8就是64位 输出4就是32位的 根据逻辑地址判断的</p>
<ol start="7">
<li><p>写一个c程序辨别系统是大端or小端字节序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">union&#123; </span><br><span class="line">	short value; </span><br><span class="line">	char a[sizeof(short)];</span><br><span class="line">&#125;test;</span><br><span class="line"></span><br><span class="line">test.value= 0x0102;</span><br><span class="line"></span><br><span class="line">if((test.a[0] == 1) &amp;&amp; (test.a[1] == 2)) </span><br><span class="line">	cout &lt;&lt; &quot;big&quot;&lt;&lt;endl; else cout &lt;&lt; &quot;little&quot;  &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
</li>
<li><p>信号：列出常见的信号，信号怎么处理？</p>
</li>
</ol>
<p>1).进程终止的信号 2).跟踪进程的信号 3).与进程例外事件相关的信号等</p>
<p>对于信号的处理或者执行相关的操作进行处理或者直接忽略</p>
<ol start="9">
<li>i++ 是否原子操作?并解释为什么?</li>
</ol>
<p>答案肯定不是原子操作，i++主要看三个步骤</p>
<p>首先把数据从内存放到寄存器上，在寄存器上进行自增处理，放回到寄存器上，每个步骤都可能会被中断分离开！</p>
<ol start="10">
<li>说出你所知道的各类linux系统的各类同步机制（重点），什么是死锁？如何避免死锁（每个技术面试官必问）</li>
</ol>
<p>1).原子操作 2).信号量（其实就是互斥锁也就是锁的机制）3).读写信号量（就是读写锁） 4）.自旋锁  5.内核锁 6）.顺序锁</p>
<p>死锁就是几个进程申请资源，出现了循环等待的情况！</p>
<p>避免死锁的方法：</p>
<p>1）.资源是互斥的 2）.不可抢占 3）占有且申请 4）.循环等待</p>
<ol start="11">
<li>如何实现守护进程？</li>
</ol>
<p>1）创建子进程，父进程退出</p>
<p>2）在子进程中创建新会话</p>
<p>3）改变当前目录为根目</p>
<p>4）重设文件权限掩码</p>
<p>5) 关闭文件描述符</p>
<p>6) 守护进程退出处理</p>
<p>当用户需要外部停止守护进程运行时，往往会使用 kill命令停止该守护进程。所以，守护进程中需要编码来实现kill发出的signal信号处理，达到进程的正常退出。</p>
<ol start="12">
<li>linux的任务调度机制是什么？</li>
</ol>
<p>Linux 分实时进程和普通进程，实时进程应该先于普通进程而运行。实时进程：</p>
<p>1） FIFO(先来先服务调度)<br>2） RR（时间片轮转调度）。</p>
<p>每个进程有两个优先级（动态优先级和实时优先级），实时优先级就是用来衡量实时进程是否值得运行的。 非实时进程有两种优先级，一种是静态优先级，另一种是动态优先级。实时进程又增加了第三种优先级，实时优先级。优先级越高，得到CPU时间的机会也就越大。</p>
<ol start="13">
<li><p>标准库函数和系统调用的区别？<br>系统调用：是操作系统为用户态运行的进程和硬件设备(如CPU、磁盘、打印机等)进行交互提供的一组接口，即就是设置在应用程序和硬件设备之间的一个接口层。inux内核是单内核，结构紧凑，执行速度快，各个模块之间是直接调用的关系。linux系统上到下依次是用户进程-&gt;linux内核-&gt;硬件。其中系统调用接口是位于Linux内核中的，整个linux系统从上到下可以是：用户进程-&gt;系统调用接口-&gt;linux内核子系统-&gt;硬件，也就是说Linux内核包括了系统调用接口和内核子系统两部分；或者从下到上可以是：物理硬件-&gt;OS内核-&gt;OS服务-&gt;应用程序，操作系统起到“承上启下”作用，向下管理物理硬件，向上为操作系服务和应用程序提供接口，这里的接口就是系统调用了。<br>库函数：把函数放到库里。是把一些常用到的函数编完放到一个lib文件里，供别人用。别人用的时候把它所在的文件名用#include&lt;&gt;加到里面就可以了。一类是c语言标准规定的库函数，一类是编译器特定的库函数。<br>系统调用是为了方便使用操作系统的接口，而库函数则是为了人们编程的方便。</p>
</li>
<li><p>系统如何将一个信号通知到进程？</p>
</li>
</ol>
<p>内核给进程发送信号，是在进程所在的进程表项的信号域设置对应的信号的位。进程处理信号的时机就是从内核态即将返回用户态度的时候。执行用户自定义的信号处理函数的方法很巧妙。把该函数的地址放在用户栈栈顶，进程从内核返回到用户态的时候，先弹出信号处理函数地址，于是就去执行信号处理函数了，然后再弹出，才是返回进入内核时的状态。</p>
<ol start="15">
<li>fork()一子进程程后父进程的全局变量能不能使用？</li>
</ol>
<p>fork后子进程将会拥有父进程的几乎一切资源，父子进程的都各自有自己的全局变量。不能通用，不同于线程。对于线程，各个线程共享全局变量。</p>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><ol>
<li>使用udp和tcp进程网络传输，为什么tcp能保证包是发送顺序，而 udp无法保证？</li>
</ol>
<p>因为TCP发送的数据包是按序号发送，有确认机制和丢失重传机制，而udp是不可靠的发送机制，发送的对应端口的数据包不是按顺序发送的。</p>
<ol start="2">
<li>epoll哪些触发模式，有啥区别？（必须非常详尽的解释水平触发和边缘触发的区别，以及边缘触发在编程中要做哪些更多的确认）</li>
</ol>
<p>epoll有EPOLLLT和EPOLLET两种触发模式，LT是默认的模式，ET是“高速”模式。LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作，而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值。</p>
<p>也就是说在LT模式的情况下一定要确认收发的数据包的buffer是不是足够大如果收发数据包大小大于buffer的大小的时候就可能会出现数据丢失的情况。</p>
<ol start="3">
<li>tcp与udp的区别（必问）为什么TCP要叫做数据流？</li>
</ol>
<p>1）．基于连接与无连接<br>2）．对系统资源的要求（TCP较多，UDP少）<br>3）．UDP程序结构较简单<br>4）．流模式与数据报模式<br>5）．TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证<br>6）.TCP有拥塞控制和流量控制，UDP没有</p>
<p>TCP提供的是面向连接、可靠的字节流服务。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。</p>
<p>是一个简单的面向数据报的运输层协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快</p>
<ol start="4">
<li>流量控制和拥塞控制的实现机制</li>
</ol>
<p>网络拥塞现象是指到达通信子网中某一部分的分组数量过多,使得该部分网络来不及处理,以致引起这部分乃至整个网络性能下降的现象,严重时甚至会导致网络通信业务陷入停顿,即出现死锁现象。拥塞控制是处理网络拥塞现象的一种机制。数据的传送与接收过程当中很可能出现收方来不及接收的情况,这时就需要对发方进行控制,以免数据丢失。</p>
<ol start="5">
<li>滑动窗口的实现机制</li>
</ol>
<p>滑动窗口机制，窗口的大小并不是固定的而是根据我们之间的链路的带宽的大小，这个时候链路是否拥护塞。接受方是否能处理这么多数据了。  滑动窗口协议，是TCP使用的一种流量控制方法。该协议允许发送方在停止并等待确认前可以连续发送多个分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输。 </p>
<ol start="6">
<li>epoll和select的区别？</li>
</ol>
<p>1）select在一个进程中打开的最大fd是有限制的，由FD_SETSIZE设置，默认值是2048。不过 epoll则没有这个限制，内存越大，fd上限越大，1G内存都能达到大约10w左右。</p>
<p>2）select的轮询机制是系统会去查找每个fd是否数据已准备好，当fd很多的时候，效率当然就直线下降了，epoll采用基于事件的通知方式，一旦某个fd数据就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，高效。 </p>
<p>3）select还是epoll都需要内核把FD消息通知给用户空间，epoll是通过内核于用户空间mmap同一块内存实现的，而select则做了不必要的拷贝</p>
<ol start="7">
<li>网络中，如果客户端突然掉线或者重启，服务器端怎么样才能立刻知道？</li>
</ol>
<p>若客户端掉线或者重新启动，服务器端会收到复位信号，每一种tcp/ip得实现不一样，控制机制也不一样。</p>
<ol start="8">
<li>TTL是什么？有什么用处，通常那些工具会用到它？ping? traceroute? ifconfig? netstat?</li>
</ol>
<p>TTL是Time To Live，每经过一个路由就会被减去一，如果它变成0，包会被丢掉。它的主要目的是防止包在有回路的网络上死转，浪费网络资源。ping和traceroute用到它。</p>
<ol start="9">
<li>linux的五种IO模式/异步模式.</li>
</ol>
<p>1）同步阻塞I/O<br>2）同步非阻塞I/O<br>3）同步I/O复用模型<br>4） 同步信号驱动I/O<br>5） 异步I/O模型</p>
<ol start="10">
<li>请说出http协议的优缺点.</li>
</ol>
<ul>
<li>支持客户/服务器模式。</li>
<li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径，通信速度很快。</li>
<li>灵活：HTTP允许传输任意类型的数据对象。</li>
<li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，导致每次连接传送的数据量增大。缺点就是不够安全，可以使用https完成使用</li>
</ul>
<ol start="11">
<li>NAT类型，UDP穿透原理。</li>
</ol>
<p>1）Full cone NAT （全克隆nat）:一对一NAT一旦一个内部地址（iAddr:port1）映射到外部地址（eAddr:port2）。</p>
<p>2）Address-Restricted cone NAT（地址受限克隆nat）:任意外部主机（hostAddr:any）都能通过给eAddr:port2发包到达iAddr:port1的前提是：iAddr:port1之前发送过包到hostAddr:any. “any”也就是说端口不受限制</p>
<p>3). Port-Restricted cone NAT:内部地址（iAddr:port1）映射到外部地址（eAddr:port2），所有发自iAddr:port1的包都经eAddr:port2向外发送。一个外部主机（hostAddr:port3）能够发包到达iAddr:port1的前提是：iAddr:port1之前发送过包到hostAddr:port3.</p>
<p>4). Symmetric NAT（对称NAT）:同内部IP与port的请求到一个特定目的地的IP地址和端口，映射到一个独特的外部来源的IP地址和端口。同一个内部主机发出一个信息包到不同的目的端，不同的映射使用外部主机收到了一封包从一个内部主机可以送一封包回来</p>
<ol start="12">
<li>大规模连接上来，并发模型怎么设计</li>
</ol>
<p>Epoll+线程池（epoll可以采用libevent处理）</p>
<ol start="13">
<li>流量控制与拥塞控制的区别，节点计算机怎样感知网络拥塞了？<br>拥塞控制是把整体看成一个处理对象的，流量控制是对单个的节点。</li>
</ol>
<p>感知的手段应该不少，比如在TCP协议里，TCP报文的重传本身就可以作为拥塞的依据。依据这样的原理， 应该可以设计出很多手段。</p>
<h1 id="算法和数据结构"><a href="#算法和数据结构" class="headerlink" title="算法和数据结构"></a>算法和数据结构</h1><ol>
<li>给定一个单向链表（长度未知），请设计一个既节省时间又节省空间的算法来找出该链表中的倒数第m个元素。实现这个算法，并为可能出现的特例情况安排好处理措施。“倒数第m个元素”是这样规定的：当m=0时，链表的最后一个元素将被返回。</li>
</ol>
<p>解决问题方法思路如下：</p>
<p>方法一、如果我们知道链表的长度n，查找倒数第m个元素，也就是查找正序的第（n -  m）个元素（这里的序号只是为了分析，可能跟题目不一定正确的符合）。那么这样来说就简单很多。首先遍历链表得到链表长度，然后重新遍历一次，查找正数第（n-m）个元素。时间复杂度大约是O(2n)。</p>
<p>方法二、我们是不是可以提供一个辅助存储空间，是的我们在遍历到链表结束的时候可以回溯到倒数第m个元素。比如用一个支持随机访问的容器记录链表每一个节点的地址。那么这样的就可以只遍历一次链表就能得到结果。时间复杂度大约是O(n)，但是我们是用空间换取时间的，辅助存储空间的大小由m决定，如果m过大也是不可取的。</p>
<p>方法三、头结点指针为当前指针，尾节点指针为拖后指针。开始的时候当前指针和拖后指针初始化为链表的头结点，首先我们让当前指针遍历到第m个元素，拖后指针不变；然后同步更新当前指针和拖后指针；直到当前指针为链表结尾。这样我们就能保证当前指针和拖尾指针之间的距离是m。</p>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Node* FindMToLastNode(Node* pHead, int m)  &#123;  </span><br><span class="line">    // 查找到第m个元素  </span><br><span class="line">    Node* pCurrent = pHead;  </span><br><span class="line">    for (int i = 0; i &lt; m; ++i)  </span><br><span class="line">    &#123;  </span><br><span class="line">        if (pCurrent)  </span><br><span class="line">        &#123;  </span><br><span class="line">            pCurrent = pCurrent-&gt;next;  </span><br><span class="line">        &#125;  </span><br><span class="line">        else  </span><br><span class="line">        &#123;  </span><br><span class="line">           return NULL;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    Node* pFind = pHead;  </span><br><span class="line">    while (pCurrent)   &#123;  </span><br><span class="line">        pFind        = pFind-&gt;next;  </span><br><span class="line">        pCurrent    = pCurrent-&gt;next;  </span><br><span class="line">    &#125;   </span><br><span class="line">    return pFind;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>给定一个单向链表（长度未知），请遍历一次就找到中间的指针，假设该链表存储在只读存储器，不能被修改</li>
</ol>
<p>设置两个指针，一个每次移动两个位置，一个每次移动一个位置，当第一个指针到达尾节点时，第二个指针就达到了中间节点的位置</p>
<p>处理链表问题时，”快行指针“是一种很常见的技巧，快行指针指的是同时用两个指针来迭代访问链表，只不过其中一个比另一个超前一些。快指针往往先行几步，或与慢指针相差固定的步数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">node *create()  &#123;  </span><br><span class="line">    node *p1, *p2, *head;  </span><br><span class="line">    int cycle = 1, x;  </span><br><span class="line">    head = (node*)malloc(sizeof(node));  </span><br><span class="line">    p1 = head;  </span><br><span class="line">    while (cycle)  </span><br><span class="line">    &#123;         </span><br><span class="line">        cout &lt;&lt; &quot;please input an integer: &quot;;  </span><br><span class="line">        cin &gt;&gt; x;  </span><br><span class="line">        if (x != 0)  </span><br><span class="line">        &#123;  </span><br><span class="line">            p2 = (node*)malloc(sizeof(node));  </span><br><span class="line">            p2-&gt;data = x;  </span><br><span class="line">            p1-&gt;next = p2;  </span><br><span class="line">            p1 = p2;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        else  </span><br><span class="line">        &#123;  </span><br><span class="line">            cycle = 0;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    head = head-&gt;next;  </span><br><span class="line">    p1-&gt;next = NULL;  </span><br><span class="line">    return head;  </span><br><span class="line">&#125;  </span><br><span class="line">void findmid(node* head)  &#123;  </span><br><span class="line">    node *p1, *p2, *mid;  </span><br><span class="line">    p1 = head;  </span><br><span class="line">    p2 = head;  </span><br><span class="line">  </span><br><span class="line">    while (p1-&gt;next-&gt;next != NULL)  </span><br><span class="line">    &#123;     </span><br><span class="line">        p1 = p1-&gt;next-&gt;next;  </span><br><span class="line">        p2 = p2-&gt;next;  </span><br><span class="line">        mid = p2;  </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="3">
<li>将一个数组生成二叉排序树</li>
</ol>
<p>排序，选数组中间的一个元素作为根节点，左边的元素构造左子树，右边的节点构造有子树。</p>
<ol start="4">
<li>查找数组中第k大的数字？</li>
</ol>
<p>因为快排每次将数组划分为两组加一个枢纽元素，每一趟划分你只需要将k与枢纽元素的下标进行比较，如果比枢纽元素下标大就从右边的子数组中找，如果比枢纽元素下标小从左边的子数组中找，如果一样则就是枢纽元素，找到，如果需要从左边或者右边的子数组中再查找的话，只需要递归一边查找即可，无需像快排一样两边都需要递归，所以复杂度必然降低。</p>
<p>最差情况如下：假设快排每次都平均划分，但是都不在枢纽元素上找到第k大第一趟快排没找到，时间复杂度为O(n)，第二趟也没找到，时间复杂度为O(n/2)，第k趟找到，时间复杂度为O(n/2k)，所以总的时间复杂度为O(n(1+1/2+….+1/2k))=O(n)，明显比冒泡快，虽然递归深度是一样的，但是每一趟时间复杂度降低。</p>
<ol start="5">
<li>红黑树的定义和解释？B树的基本性质？</li>
</ol>
<p>红黑树：</p>
<p>性质1. 节点是红色或黑色。<br>性质2. 根节点是黑色。<br>性质3. 每个叶子结点都带有两个空的黑色结点（被称为黑哨兵），如果一个结点n的只有一个左孩子，那么n的右孩子是一个黑哨兵；如果结点n只有一个右孩子，那么n的左孩子是一个黑哨兵。<br>性质4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)<br>性质5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p>
<p>B树：</p>
<ul>
<li>所有非叶子结点至多拥有两个儿子（Left和Right）；</li>
<li>所有结点存储一个关键字；</li>
<li>非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；</li>
</ul>
<ol start="6">
<li>常见的加密算法？</li>
</ol>
<p>对称式加密就是加密和解密使用同一个密钥。<br>非对称式加密就是加密和解密所使用的不是同一个密钥，通常有两个密钥，称为“公钥”和“私钥”，它们两个必需配对使用。<br>DES：对称算法，数据加密标准，速度较快，适用于加密大量数据的场合；<br>MD5的典型应用是对一段Message产生fingerprint(指纹)，以防止被“篡改”。<br>RSA是第一个既能用于数据加密也能用于数字签名的算法。</p>
<ol start="7">
<li>https?</li>
</ol>
<p>HTTP下加入SSL层，HTTPS的安全基础是SSL。</p>
<ol start="8">
<li>简述一致性hash算法。</li>
</ol>
<p>1）首先求memcached服务器（节点）的哈希值，并将其配置到0～232的圆（continuum）。</p>
<p>2）然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。</p>
<p>3）然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过232仍然找不到服务器，就会保存到第一台memcached服务器上。</p>
<ol start="9">
<li>描述一种hash table的实现方法</li>
</ol>
<p>1） 除法散列法: p ，令 h(k ) = k mod p ，这里， p 如果选取的是比较大的素数，效果比较好。而且此法非常容易实现，因此是最常用的方法。最直观的一种，上图使用的就是这种散列法，公式： index = value % 16，求模数其实是通过一个除法运算得到的。</p>
<p>2） 平方散列法 :求index频繁的操作，而乘法的运算要比除法来得省时。公式： index = (value * value) &gt;&gt; 28 （右移，除以2^28。记法：左移变大，是乘。右移变小，是除）</p>
<p>3） 数字选择法:如果关键字的位数比较多，超过长整型范围而无法直接运算，可以选择其中数字分布比较均匀的若干位，所组成的新的值作为关键字或者直接作为函数值。</p>
<p>4） 斐波那契（Fibonacci）散列法:平方散列法的缺点是显而易见的，通过找到一个理想的乘数index = (value * 2654435769) &gt;&gt; 28</p>
<p>冲突处理：令数组元素个数为 S ，则当 h(k) 已经存储了元素的时候，依次探查 (h(k)+i) mod S , i=1,2,3…… ，直到找到空的存储单元为止（或者从头到尾扫描一圈仍未发现空单元，这就是哈希表已经满了，发生了错误。当然这是可以通过扩大数组范围避免的）。</p>
<ol start="10">
<li><p>各类树结构的实现和应用</p>
</li>
<li><p>hash，任何一个技术面试官必问（例如为什么一般hashtable的桶数会取一个素数？如何有效避免hash结果值的碰撞）</p>
</li>
</ol>
<p>不选素数的话可能会造成hash出值的范围和原定义的不一致</p>
<ol start="12">
<li>什么是平衡二叉树?</li>
</ol>
<p>左右子树都是平衡二叉树，而且左右子树的深度差值的约对值不大于1。</p>
<ol start="13">
<li>数组和链表的优缺点</li>
</ol>
<p>数组，在内存上给出了连续的空间。链表，内存地址上可以是不连续的，每个链表的节点包括原来的内存和下一个节点的信息(单向的一个，双向链表的话，会有两个)。</p>
<p>数组优于链表的:</p>
<p>A. 内存空间占用的少。<br>B. 数组内的数据可随机访问，但链表不具备随机访问性。<br>C. 查找速度快</p>
<p>链表优于数组的:</p>
<p>A. 插入与删除的操作方便。<br>B. 内存地址的利用率方面链表好。<br>C. 方便内存地址扩展。</p>
<ol start="14">
<li>4G的long型整数中找到一个最大的，如何做？</li>
</ol>
<p>每次从磁盘上尽量多读一些数到内存区，然后处理完之后再读入一批。减少IO次数，自然能够提高效率。分批读入选取最大数，再对缓存的最大数进行快排。 </p>
<ol start="15">
<li>有千万个string在内存怎么高速查找，插入和删除？</li>
</ol>
<p>对千万个string做hash，可以实现高速查找，找到了，插入和删除就很方便了。关键是如何做hash，对string做hash，要减少碰撞频率。</p>
<ol start="16">
<li>100亿个数，求最大的1万个数，并说出算法的时间复杂度<br>在内存中维护一个大小为10000的最小堆，每次从文件读一个数，与最小堆的堆顶元素比较，若比堆顶元素大，则替换掉堆顶元素，然后调整堆。最后剩下的堆内元素即为最大的1万个数，算法复杂度为O(NlogN)</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/13/Leetcode1104/" rel="next" title="Leetcode1104. Path In Zigzag Labelled Binary Tree">
                <i class="fa fa-chevron-left"></i> Leetcode1104. Path In Zigzag Labelled Binary Tree
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/24/Leetcode1160/" rel="prev" title="Leetcode1160. Find Words That Can Be Formed by Characters">
                Leetcode1160. Find Words That Can Be Formed by Characters <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">302</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#编程语言"><span class="nav-number">1.</span> <span class="nav-text">编程语言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#服务器编程"><span class="nav-number">2.</span> <span class="nav-text">服务器编程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#liunx操作系统"><span class="nav-number">3.</span> <span class="nav-text">liunx操作系统</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络编程"><span class="nav-number">4.</span> <span class="nav-text">网络编程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#算法和数据结构"><span class="nav-number">5.</span> <span class="nav-text">算法和数据结构</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
