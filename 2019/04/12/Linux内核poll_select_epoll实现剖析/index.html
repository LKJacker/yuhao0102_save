<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux,">










<meta name="description" content="poll/select/epoll的实现都是基于文件提供的poll方法(f_op-&amp;gt;poll)，该方法利用poll_table提供的_qproc方法向文件内部事件掩码_key对应的的一个或多个等待队列(wait_queue_head_t)上添加包含唤醒函数(wait_queue_t.func)的节点(wait_queue_t)，并检查文件当前就绪的状态返回给poll的调用者(依赖于文件的实现">
<meta name="keywords" content="Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核poll&#x2F;epoll&#x2F;select实现剖析">
<meta property="og:url" content="http://yoursite.com/2019/04/12/Linux内核poll_select_epoll实现剖析/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="poll/select/epoll的实现都是基于文件提供的poll方法(f_op-&amp;gt;poll)，该方法利用poll_table提供的_qproc方法向文件内部事件掩码_key对应的的一个或多个等待队列(wait_queue_head_t)上添加包含唤醒函数(wait_queue_t.func)的节点(wait_queue_t)，并检查文件当前就绪的状态返回给poll的调用者(依赖于文件的实现">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/78608ad5-89dd-319b-8c50-d7fa341ba9da.bmp">
<meta property="og:image" content="http://yoursite.com/img/7a411842-3615-3c89-aee0-3f5cfb36a044.bmp">
<meta property="og:updated_time" content="2019-04-29T06:26:24.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux内核poll&#x2F;epoll&#x2F;select实现剖析">
<meta name="twitter:description" content="poll/select/epoll的实现都是基于文件提供的poll方法(f_op-&amp;gt;poll)，该方法利用poll_table提供的_qproc方法向文件内部事件掩码_key对应的的一个或多个等待队列(wait_queue_head_t)上添加包含唤醒函数(wait_queue_t.func)的节点(wait_queue_t)，并检查文件当前就绪的状态返回给poll的调用者(依赖于文件的实现">
<meta name="twitter:image" content="http://yoursite.com/img/78608ad5-89dd-319b-8c50-d7fa341ba9da.bmp">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/04/12/Linux内核poll_select_epoll实现剖析/">





  <title>Linux内核poll/epoll/select实现剖析 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/12/Linux内核poll_select_epoll实现剖析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux内核poll/epoll/select实现剖析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-12T15:41:43+08:00">
                2019-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>poll/select/epoll的实现都是基于文件提供的poll方法(f_op-&gt;poll)，<br>该方法利用poll_table提供的_qproc方法向文件内部事件掩码_key对应的的一个或多个等待队列(wait_queue_head_t)上添加包含唤醒函数(wait_queue_t.func)的节点(wait_queue_t)，并检查文件当前就绪的状态返回给poll的调用者(依赖于文件的实现)。<br>当文件的状态发生改变时(例如网络数据包到达)，文件就会遍历事件对应的等待队列并调用回调函数(wait_queue_t.func)唤醒等待线程。</p>
<p>通常的file.f_ops.poll实现及相关结构体如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">struct file &#123;  </span><br><span class="line">    const struct file_operations    *f_op;  </span><br><span class="line">    spinlock_t          f_lock;  </span><br><span class="line">    // 文件内部实现细节  </span><br><span class="line">    void               *private_data;  </span><br><span class="line">#ifdef CONFIG_EPOLL  </span><br><span class="line">    /* Used by fs/eventpoll.c to link all the hooks to this file */  </span><br><span class="line">    struct list_head    f_ep_links;  </span><br><span class="line">    struct list_head    f_tfile_llink;  </span><br><span class="line">#endif /* #ifdef CONFIG_EPOLL */  </span><br><span class="line">    // 其他细节....  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">// 文件操作  </span><br><span class="line">struct file_operations &#123;  </span><br><span class="line">    // 文件提供给poll/select/epoll  </span><br><span class="line">    // 获取文件当前状态, 以及就绪通知接口函数  </span><br><span class="line">    unsigned int (*poll) (struct file *, struct poll_table_struct *);  </span><br><span class="line">    // 其他方法read/write 等... ...  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">// 通常的file.f_ops.poll 方法的实现  </span><br><span class="line">unsigned int file_f_op_poll (struct file *filp, struct poll_table_struct *wait)  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int mask = 0;  </span><br><span class="line">    wait_queue_head_t * wait_queue;  </span><br><span class="line">  </span><br><span class="line">    //1. 根据事件掩码wait-&gt;key_和文件实现filep-&gt;private_data 取得事件掩码对应的一个或多个wait queue head  </span><br><span class="line">    some_code();  </span><br><span class="line">  </span><br><span class="line">    // 2. 调用poll_wait 向获得的wait queue head 添加节点  </span><br><span class="line">    poll_wait(filp, wait_queue, wait);  </span><br><span class="line">  </span><br><span class="line">    // 3. 取得当前就绪状态保存到mask  </span><br><span class="line">    some_code();  </span><br><span class="line">  </span><br><span class="line">    return mask;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// select/poll/epoll 向文件注册就绪后回调节点的接口结构  </span><br><span class="line">typedef struct poll_table_struct &#123;  </span><br><span class="line">    // 向wait_queue_head 添加回调节点(wait_queue_t)的接口函数  </span><br><span class="line">    poll_queue_proc _qproc;  </span><br><span class="line">    // 关注的事件掩码, 文件的实现利用此掩码将等待队列传递给_qproc  </span><br><span class="line">    unsigned long   _key;  </span><br><span class="line">&#125; poll_table;  </span><br><span class="line">typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">// 通用的poll_wait 函数, 文件的f_ops-&gt;poll 通常会调用此函数  </span><br><span class="line">static inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)  </span><br><span class="line">&#123;  </span><br><span class="line">    if (p &amp;&amp; p-&gt;_qproc &amp;&amp; wait_address) &#123;  </span><br><span class="line">        // 调用_qproc 在wait_address 上添加节点和回调函数  </span><br><span class="line">        // 调用 poll_table_struct 上的函数指针向wait_address添加节点, 并设置节点的func  </span><br><span class="line">        // (如果是select或poll 则是 __pollwait, 如果是 epoll 则是 ep_ptable_queue_proc),  </span><br><span class="line">        p-&gt;_qproc(filp, wait_address, p);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">// wait_queue 头节点  </span><br><span class="line">typedef struct __wait_queue_head wait_queue_head_t;  </span><br><span class="line">struct __wait_queue_head &#123;  </span><br><span class="line">    spinlock_t lock;  </span><br><span class="line">    struct list_head task_list;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">// wait_queue 节点  </span><br><span class="line">typedef struct __wait_queue wait_queue_t;  </span><br><span class="line">struct __wait_queue &#123;  </span><br><span class="line">    unsigned int flags;  </span><br><span class="line">#define WQ_FLAG_EXCLUSIVE   0x01  </span><br><span class="line">    void *private;  </span><br><span class="line">    wait_queue_func_t func;  </span><br><span class="line">    struct list_head task_list;  </span><br><span class="line">&#125;;  </span><br><span class="line">typedef int (*wait_queue_func_t)(wait_queue_t *wait, unsigned mode, int flags, void *key);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">// 当文件的状态发生改变时, 文件会调用此函数，此函数通过调用wait_queue_t.func通知poll的调用者  </span><br><span class="line">// 其中key是文件当前的事件掩码  </span><br><span class="line">void __wake_up(wait_queue_head_t *q, unsigned int mode,  </span><br><span class="line">               int nr_exclusive, void *key)  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned long flags;  </span><br><span class="line">  </span><br><span class="line">    spin_lock_irqsave(&amp;q-&gt;lock, flags);  </span><br><span class="line">    __wake_up_common(q, mode, nr_exclusive, 0, key);  </span><br><span class="line">    spin_unlock_irqrestore(&amp;q-&gt;lock, flags);  </span><br><span class="line">&#125;  </span><br><span class="line">static void __wake_up_common(wait_queue_head_t *q, unsigned int mode,  </span><br><span class="line">                             int nr_exclusive, int wake_flags, void *key)  </span><br><span class="line">&#123;  </span><br><span class="line">    wait_queue_t *curr, *next;  </span><br><span class="line">    // 遍历并调用func 唤醒, 通常func会唤醒调用poll的线程  </span><br><span class="line">    list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list) &#123;  </span><br><span class="line">        unsigned flags = curr-&gt;flags;  </span><br><span class="line">  </span><br><span class="line">        if (curr-&gt;func(curr, mode, wake_flags, key) &amp;&amp;  </span><br><span class="line">                (flags &amp; WQ_FLAG_EXCLUSIVE) &amp;&amp; !--nr_exclusive) &#123;  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="poll-和-select"><a href="#poll-和-select" class="headerlink" title="poll 和 select"></a>poll 和 select</h1><p>poll和select的实现基本上是一致的，只是传递参数有所不同，他们的基本流程如下：</p>
<ol>
<li>复制用户数据到内核空间</li>
<li>估计超时时间</li>
<li>遍历每个文件并调用f_op-&gt;poll 取得文件当前就绪状态， 如果前面遍历的文件都没有就绪，向文件插入wait_queue节点</li>
<li>遍历完成后检查状态：<pre><code>a). 如果已经有就绪的文件转到5；
b). 如果有信号产生，重启poll或select（转到 1或3）；
c). 否则挂起进程等待超时或唤醒，超时或被唤醒后再次遍历所有文件取得每个文件的就绪状态
</code></pre></li>
<li>将所有文件的就绪状态复制到用户空间</li>
<li>清理申请的资源</li>
</ol>
<h2 id="关键结构体"><a href="#关键结构体" class="headerlink" title="关键结构体"></a>关键结构体</h2><p>下面是poll/select共用的结构体及其相关功能:</p>
<p>poll_wqueues 是 select/poll 对poll_table接口的具体化实现,其中的table, inline_index和inline_entries都是为了管理内存。<br>poll_table_entry 与一个文件相关联，用于管理插入到文件的wait_queue节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// select/poll 对poll_table的具体化实现  </span><br><span class="line">struct poll_wqueues &#123;  </span><br><span class="line">    poll_table pt;  </span><br><span class="line">    struct poll_table_page *table;     // 如果inline_entries 空间不足, 从poll_table_page 中分配  </span><br><span class="line">    struct task_struct *polling_task;  // 调用poll 或select 的进程  </span><br><span class="line">    int triggered;                     // 已触发标记  </span><br><span class="line">    int error;  </span><br><span class="line">    int inline_index;                  // 下一个要分配的inline_entrie 索引  </span><br><span class="line">    struct poll_table_entry inline_entries[N_INLINE_POLL_ENTRIES];//  </span><br><span class="line">&#125;;  </span><br><span class="line">// 帮助管理select/poll  申请的内存  </span><br><span class="line">struct poll_table_page &#123;  </span><br><span class="line">    struct poll_table_page  * next;       // 下一个 page  </span><br><span class="line">    struct poll_table_entry * entry;      // 指向第一个entries  </span><br><span class="line">    struct poll_table_entry entries[0];  </span><br><span class="line">&#125;;  </span><br><span class="line">// 与一个正在poll /select 的文件相关联,  </span><br><span class="line">struct poll_table_entry &#123;  </span><br><span class="line">    struct file *filp;               // 在poll/select中的文件  </span><br><span class="line">    unsigned long key;  </span><br><span class="line">    wait_queue_t wait;               // 插入到wait_queue_head_t 的节点  </span><br><span class="line">    wait_queue_head_t *wait_address; // 文件上的wait_queue_head_t 地址  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="公共函数"><a href="#公共函数" class="headerlink" title="公共函数"></a>公共函数</h2><p> 下面是poll/select公用的一些函数，这些函数实现了poll和select的核心功能。</p>
<p>poll_initwait 用于初始化poll_wqueues，</p>
<p>__pollwait 实现了向文件中添加回调节点的逻辑，</p>
<p>pollwake 当文件状态发生改变时，由文件调用，用来唤醒线程，</p>
<p>poll_get_entry，free_poll_entry，poll_freewait用来申请释放poll_table_entry 占用的内存，并负责释放文件上的wait_queue节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">// poll_wqueues 的初始化:  </span><br><span class="line">// 初始化 poll_wqueues , __pollwait会在文件就绪时被调用  </span><br><span class="line">void poll_initwait(struct poll_wqueues *pwq)  </span><br><span class="line">&#123;  </span><br><span class="line">    // 初始化poll_table, 相当于调用基类的构造函数  </span><br><span class="line">    init_poll_funcptr(&amp;pwq-&gt;pt, __pollwait);  </span><br><span class="line">    /* </span><br><span class="line">     * static inline void init_poll_funcptr(poll_table *pt, poll_queue_proc qproc) </span><br><span class="line">     * &#123; </span><br><span class="line">     *     pt-&gt;_qproc = qproc; </span><br><span class="line">     *     pt-&gt;_key   = ~0UL; </span><br><span class="line">     * &#125; </span><br><span class="line">     */  </span><br><span class="line">    pwq-&gt;polling_task = current;  </span><br><span class="line">    pwq-&gt;triggered = 0;  </span><br><span class="line">    pwq-&gt;error = 0;  </span><br><span class="line">    pwq-&gt;table = NULL;  </span><br><span class="line">    pwq-&gt;inline_index = 0;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// wait_queue设置函数  </span><br><span class="line">// poll/select 向文件wait_queue中添加节点的方法  </span><br><span class="line">static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,  </span><br><span class="line">                       poll_table *p)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct poll_wqueues *pwq = container_of(p, struct poll_wqueues, pt);  </span><br><span class="line">    struct poll_table_entry *entry = poll_get_entry(pwq);  </span><br><span class="line">    if (!entry) &#123;  </span><br><span class="line">        return;  </span><br><span class="line">    &#125;  </span><br><span class="line">    get_file(filp); //put_file() in free_poll_entry()  </span><br><span class="line">    entry-&gt;filp = filp;  </span><br><span class="line">    entry-&gt;wait_address = wait_address; // 等待队列头  </span><br><span class="line">    entry-&gt;key = p-&gt;key;  </span><br><span class="line">    // 设置回调为 pollwake  </span><br><span class="line">    init_waitqueue_func_entry(&amp;entry-&gt;wait, pollwake);  </span><br><span class="line">    entry-&gt;wait.private = pwq;  </span><br><span class="line">    // 添加到等待队列  </span><br><span class="line">    add_wait_queue(wait_address, &amp;entry-&gt;wait);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 在等待队列(wait_queue_t)上回调函数(func)  </span><br><span class="line">// 文件就绪后被调用，唤醒调用进程，其中key是文件提供的当前状态掩码  </span><br><span class="line">static int pollwake(wait_queue_t *wait, unsigned mode, int sync, void *key)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct poll_table_entry *entry;  </span><br><span class="line">    // 取得文件对应的poll_table_entry  </span><br><span class="line">    entry = container_of(wait, struct poll_table_entry, wait);  </span><br><span class="line">    // 过滤不关注的事件  </span><br><span class="line">    if (key &amp;&amp; !((unsigned long)key &amp; entry-&gt;key)) &#123;  </span><br><span class="line">        return 0;  </span><br><span class="line">    &#125;  </span><br><span class="line">    // 唤醒  </span><br><span class="line">    return __pollwake(wait, mode, sync, key);  </span><br><span class="line">&#125;  </span><br><span class="line">static int __pollwake(wait_queue_t *wait, unsigned mode, int sync, void *key)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct poll_wqueues *pwq = wait-&gt;private;  </span><br><span class="line">    // 将调用进程 pwq-&gt;polling_task 关联到 dummy_wait  </span><br><span class="line">    DECLARE_WAITQUEUE(dummy_wait, pwq-&gt;polling_task);  </span><br><span class="line">    smp_wmb();  </span><br><span class="line">    pwq-&gt;triggered = 1;// 标记为已触发  </span><br><span class="line">    // 唤醒调用进程  </span><br><span class="line">    return default_wake_function(&amp;dummy_wait, mode, sync, key);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 默认的唤醒函数,poll/select 设置的回调函数会调用此函数唤醒  </span><br><span class="line">// 直接唤醒等待队列上的线程,即将线程移到运行队列(rq)  </span><br><span class="line">int default_wake_function(wait_queue_t *curr, unsigned mode, int wake_flags,  </span><br><span class="line">                          void *key)  </span><br><span class="line">&#123;  </span><br><span class="line">    // 这个函数比较复杂, 这里就不具体分析了  </span><br><span class="line">    return try_to_wake_up(curr-&gt;private, mode, wake_flags);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>poll，select对poll_table_entry的申请和释放采用的是类似内存池的管理方式，先使用预分配的空间，预分配的空间不足时，分配一个内存页，使用内存页上的空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// 分配或使用已先前申请的 poll_table_entry,  </span><br><span class="line">static struct poll_table_entry *poll_get_entry(struct poll_wqueues *p) &#123;  </span><br><span class="line">    struct poll_table_page *table = p-&gt;table;  </span><br><span class="line">  </span><br><span class="line">    if (p-&gt;inline_index &lt; N_INLINE_POLL_ENTRIES) &#123;  </span><br><span class="line">        return p-&gt;inline_entries + p-&gt;inline_index++;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    if (!table || POLL_TABLE_FULL(table)) &#123;  </span><br><span class="line">        struct poll_table_page *new_table;  </span><br><span class="line">        new_table = (struct poll_table_page *) __get_free_page(GFP_KERNEL);  </span><br><span class="line">        if (!new_table) &#123;  </span><br><span class="line">            p-&gt;error = -ENOMEM;  </span><br><span class="line">            return NULL;  </span><br><span class="line">        &#125;  </span><br><span class="line">        new_table-&gt;entry = new_table-&gt;entries;  </span><br><span class="line">        new_table-&gt;next = table;  </span><br><span class="line">        p-&gt;table = new_table;  </span><br><span class="line">        table = new_table;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return table-&gt;entry++;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 清理poll_wqueues 占用的资源  </span><br><span class="line">void poll_freewait(struct poll_wqueues *pwq)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct poll_table_page * p = pwq-&gt;table;  </span><br><span class="line">    // 遍历所有已分配的inline poll_table_entry  </span><br><span class="line">    int i;  </span><br><span class="line">    for (i = 0; i &lt; pwq-&gt;inline_index; i++) &#123;  </span><br><span class="line">        free_poll_entry(pwq-&gt;inline_entries + i);  </span><br><span class="line">    &#125;  </span><br><span class="line">    // 遍历在poll_table_page上分配的inline poll_table_entry  </span><br><span class="line">    // 并释放poll_table_page  </span><br><span class="line">    while (p) &#123;  </span><br><span class="line">        struct poll_table_entry * entry;  </span><br><span class="line">        struct poll_table_page *old;  </span><br><span class="line">        entry = p-&gt;entry;  </span><br><span class="line">        do &#123;  </span><br><span class="line">            entry--;  </span><br><span class="line">            free_poll_entry(entry);  </span><br><span class="line">        &#125; while (entry &gt; p-&gt;entries);  </span><br><span class="line">        old = p;  </span><br><span class="line">        p = p-&gt;next;  </span><br><span class="line">        free_page((unsigned long) old);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">static void free_poll_entry(struct poll_table_entry *entry)  </span><br><span class="line">&#123;  </span><br><span class="line">    // 从等待队列中删除, 释放文件引用计数  </span><br><span class="line">    remove_wait_queue(entry-&gt;wait_address, &amp;entry-&gt;wait);  </span><br><span class="line">    fput(entry-&gt;filp);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="poll-select核心结构关系"><a href="#poll-select核心结构关系" class="headerlink" title="poll/select核心结构关系"></a>poll/select核心结构关系</h2><p>下图是 poll/select 实现公共部分的关系图，包含了与文件直接的关系，以及函数之间的依赖。<br><img src="/img/78608ad5-89dd-319b-8c50-d7fa341ba9da.bmp" alt></p>
<h1 id="poll的实现"><a href="#poll的实现" class="headerlink" title="poll的实现"></a>poll的实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line">// poll 使用的结构体  </span><br><span class="line">struct pollfd &#123;  </span><br><span class="line">    int fd;        // 描述符  </span><br><span class="line">    short events;  // 关注的事件掩码  </span><br><span class="line">    short revents; // 返回的事件掩码  </span><br><span class="line">&#125;;  </span><br><span class="line">// long sys_poll(struct pollfd *ufds, unsigned int nfds, long timeout_msecs)  </span><br><span class="line">SYSCALL_DEFINE3(poll, struct pollfd __user *, ufds, unsigned int, nfds,  </span><br><span class="line">                long, timeout_msecs)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct timespec end_time, *to = NULL;  </span><br><span class="line">    int ret;  </span><br><span class="line">    if (timeout_msecs &gt;= 0) &#123;  </span><br><span class="line">        to = &amp;end_time;  </span><br><span class="line">        // 将相对超时时间msec 转化为绝对时间  </span><br><span class="line">        poll_select_set_timeout(to, timeout_msecs / MSEC_PER_SEC,  </span><br><span class="line">                                NSEC_PER_MSEC * (timeout_msecs % MSEC_PER_SEC));  </span><br><span class="line">    &#125;  </span><br><span class="line">    // do sys poll  </span><br><span class="line">    ret = do_sys_poll(ufds, nfds, to);  </span><br><span class="line">    // do_sys_poll 被信号中断, 重新调用, 对使用者来说 poll 是不会被信号中断的.  </span><br><span class="line">    if (ret == -EINTR) &#123;  </span><br><span class="line">        struct restart_block *restart_block;  </span><br><span class="line">        restart_block = &amp;current_thread_info()-&gt;restart_block;  </span><br><span class="line">        restart_block-&gt;fn = do_restart_poll; // 设置重启的函数  </span><br><span class="line">        restart_block-&gt;poll.ufds = ufds;  </span><br><span class="line">        restart_block-&gt;poll.nfds = nfds;  </span><br><span class="line">        if (timeout_msecs &gt;= 0) &#123;  </span><br><span class="line">            restart_block-&gt;poll.tv_sec = end_time.tv_sec;  </span><br><span class="line">            restart_block-&gt;poll.tv_nsec = end_time.tv_nsec;  </span><br><span class="line">            restart_block-&gt;poll.has_timeout = 1;  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            restart_block-&gt;poll.has_timeout = 0;  </span><br><span class="line">        &#125;  </span><br><span class="line">        // ERESTART_RESTARTBLOCK 不会返回给用户进程,  </span><br><span class="line">        // 而是会被系统捕获, 然后调用 do_restart_poll,  </span><br><span class="line">        ret = -ERESTART_RESTARTBLOCK;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return ret;  </span><br><span class="line">&#125;  </span><br><span class="line">int do_sys_poll(struct pollfd __user *ufds, unsigned int nfds,  </span><br><span class="line">                struct timespec *end_time)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct poll_wqueues table;  </span><br><span class="line">    int err = -EFAULT, fdcount, len, size;  </span><br><span class="line">    /* 首先使用栈上的空间，节约内存，加速访问 */  </span><br><span class="line">    long stack_pps[POLL_STACK_ALLOC/sizeof(long)];  </span><br><span class="line">    struct poll_list *const head = (struct poll_list *)stack_pps;  </span><br><span class="line">    struct poll_list *walk = head;  </span><br><span class="line">    unsigned long todo = nfds;  </span><br><span class="line">    if (nfds &gt; rlimit(RLIMIT_NOFILE)) &#123;  </span><br><span class="line">        // 文件描述符数量超过当前进程限制  </span><br><span class="line">        return -EINVAL;  </span><br><span class="line">    &#125;  </span><br><span class="line">    // 复制用户空间数据到内核  </span><br><span class="line">    len = min_t(unsigned int, nfds, N_STACK_PPS);  </span><br><span class="line">    for (;;) &#123;  </span><br><span class="line">        walk-&gt;next = NULL;  </span><br><span class="line">        walk-&gt;len = len;  </span><br><span class="line">        if (!len) &#123;  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">        // 复制到当前的 entries  </span><br><span class="line">        if (copy_from_user(walk-&gt;entries, ufds + nfds-todo,  </span><br><span class="line">                           sizeof(struct pollfd) * walk-&gt;len)) &#123;  </span><br><span class="line">            goto out_fds;  </span><br><span class="line">        &#125;  </span><br><span class="line">        todo -= walk-&gt;len;  </span><br><span class="line">        if (!todo) &#123;  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">        // 栈上空间不足，在堆上申请剩余部分  </span><br><span class="line">        len = min(todo, POLLFD_PER_PAGE);  </span><br><span class="line">        size = sizeof(struct poll_list) + sizeof(struct pollfd) * len;  </span><br><span class="line">        walk = walk-&gt;next = kmalloc(size, GFP_KERNEL);  </span><br><span class="line">        if (!walk) &#123;  </span><br><span class="line">            err = -ENOMEM;  </span><br><span class="line">            goto out_fds;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    // 初始化 poll_wqueues 结构, 设置函数指针_qproc  为__pollwait  </span><br><span class="line">    poll_initwait(&amp;table);  </span><br><span class="line">    // poll  </span><br><span class="line">    fdcount = do_poll(nfds, head, &amp;table, end_time);  </span><br><span class="line">    // 从文件wait queue 中移除对应的节点, 释放entry.  </span><br><span class="line">    poll_freewait(&amp;table);  </span><br><span class="line">    // 复制结果到用户空间  </span><br><span class="line">    for (walk = head; walk; walk = walk-&gt;next) &#123;  </span><br><span class="line">        struct pollfd *fds = walk-&gt;entries;  </span><br><span class="line">        int j;  </span><br><span class="line">        for (j = 0; j &lt; len; j++, ufds++)  </span><br><span class="line">            if (__put_user(fds[j].revents, &amp;ufds-&gt;revents)) &#123;  </span><br><span class="line">                goto out_fds;  </span><br><span class="line">            &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    err = fdcount;  </span><br><span class="line">out_fds:  </span><br><span class="line">    // 释放申请的内存  </span><br><span class="line">    walk = head-&gt;next;  </span><br><span class="line">    while (walk) &#123;  </span><br><span class="line">        struct poll_list *pos = walk;  </span><br><span class="line">        walk = walk-&gt;next;  </span><br><span class="line">        kfree(pos);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return err;  </span><br><span class="line">&#125;  </span><br><span class="line">// 真正的处理函数  </span><br><span class="line">static int do_poll(unsigned int nfds,  struct poll_list *list,  </span><br><span class="line">                   struct poll_wqueues *wait, struct timespec *end_time)  </span><br><span class="line">&#123;  </span><br><span class="line">    poll_table* pt = &amp;wait-&gt;pt;  </span><br><span class="line">    ktime_t expire, *to = NULL;  </span><br><span class="line">    int timed_out = 0, count = 0;  </span><br><span class="line">    unsigned long slack = 0;  </span><br><span class="line">    if (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;  </span><br><span class="line">        // 已经超时,直接遍历所有文件描述符, 然后返回  </span><br><span class="line">        pt = NULL;  </span><br><span class="line">        timed_out = 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (end_time &amp;&amp; !timed_out) &#123;  </span><br><span class="line">        // 估计进程等待时间，纳秒  </span><br><span class="line">        slack = select_estimate_accuracy(end_time);  </span><br><span class="line">    &#125;  </span><br><span class="line">    // 遍历文件，为每个文件的等待队列添加唤醒函数(pollwake)  </span><br><span class="line">    for (;;) &#123;  </span><br><span class="line">        struct poll_list *walk;  </span><br><span class="line">        for (walk = list; walk != NULL; walk = walk-&gt;next) &#123;  </span><br><span class="line">            struct pollfd * pfd, * pfd_end;  </span><br><span class="line">            pfd = walk-&gt;entries;  </span><br><span class="line">            pfd_end = pfd + walk-&gt;len;  </span><br><span class="line">            for (; pfd != pfd_end; pfd++) &#123;  </span><br><span class="line">                // do_pollfd 会向文件对应的wait queue 中添加节点  </span><br><span class="line">                // 和回调函数(如果 pt 不为空)  </span><br><span class="line">                // 并检查当前文件状态并设置返回的掩码  </span><br><span class="line">                if (do_pollfd(pfd, pt)) &#123;  </span><br><span class="line">                    // 该文件已经准备好了.  </span><br><span class="line">                    // 不需要向后面文件的wait queue 中添加唤醒函数了.  </span><br><span class="line">                    count++;  </span><br><span class="line">                    pt = NULL;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        // 下次循环的时候不需要向文件的wait queue 中添加节点,  </span><br><span class="line">        // 因为前面的循环已经把该添加的都添加了  </span><br><span class="line">        pt = NULL;  </span><br><span class="line">  </span><br><span class="line">        // 第一次遍历没有发现ready的文件  </span><br><span class="line">        if (!count) &#123;  </span><br><span class="line">            count = wait-&gt;error;  </span><br><span class="line">            // 有信号产生  </span><br><span class="line">            if (signal_pending(current)) &#123;  </span><br><span class="line">                count = -EINTR;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        // 有ready的文件或已经超时  </span><br><span class="line">        if (count || timed_out) &#123;  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">        // 转换为内核时间  </span><br><span class="line">        if (end_time &amp;&amp; !to) &#123;  </span><br><span class="line">            expire = timespec_to_ktime(*end_time);  </span><br><span class="line">            to = &amp;expire;  </span><br><span class="line">        &#125;  </span><br><span class="line">        // 等待事件就绪, 如果有事件发生或超时，就再循  </span><br><span class="line">        // 环一遍，取得事件状态掩码并计数,  </span><br><span class="line">        // 注意此次循环中, 文件 wait queue 中的节点依然存在  </span><br><span class="line">        if (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack)) &#123;  </span><br><span class="line">            timed_out = 1;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return count;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">static inline unsigned int do_pollfd(struct pollfd *pollfd, poll_table *pwait)  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned int mask;  </span><br><span class="line">    int fd;  </span><br><span class="line">    mask = 0;  </span><br><span class="line">    fd = pollfd-&gt;fd;  </span><br><span class="line">    if (fd &gt;= 0) &#123;  </span><br><span class="line">        int fput_needed;  </span><br><span class="line">        struct file * file;  </span><br><span class="line">        // 取得fd对应的文件结构体  </span><br><span class="line">        file = fget_light(fd, &amp;fput_needed);  </span><br><span class="line">        mask = POLLNVAL;  </span><br><span class="line">        if (file != NULL) &#123;  </span><br><span class="line">            // 如果没有 f_op 或 f_op-&gt;poll 则认为文件始终处于就绪状态.  </span><br><span class="line">            mask = DEFAULT_POLLMASK;  </span><br><span class="line">            if (file-&gt;f_op &amp;&amp; file-&gt;f_op-&gt;poll) &#123;  </span><br><span class="line">                if (pwait) &#123;  </span><br><span class="line">                    // 设置关注的事件掩码  </span><br><span class="line">                    pwait-&gt;key = pollfd-&gt;events | POLLERR | POLLHUP;  </span><br><span class="line">                &#125;  </span><br><span class="line">                // 注册回调函数，并返回当前就绪状态，就绪后会调用pollwake  </span><br><span class="line">                mask = file-&gt;f_op-&gt;poll(file, pwait);  </span><br><span class="line">            &#125;  </span><br><span class="line">            mask &amp;= pollfd-&gt;events | POLLERR | POLLHUP; // 移除不需要的状态掩码  </span><br><span class="line">            fput_light(file, fput_needed);// 释放文件  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    pollfd-&gt;revents = mask; // 更新事件状态  </span><br><span class="line">    return mask;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">static long do_restart_poll(struct restart_block *restart_block)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct pollfd __user *ufds = restart_block-&gt;poll.ufds;  </span><br><span class="line">    int nfds = restart_block-&gt;poll.nfds;  </span><br><span class="line">    struct timespec *to = NULL, end_time;  </span><br><span class="line">    int ret;  </span><br><span class="line">    if (restart_block-&gt;poll.has_timeout) &#123;  </span><br><span class="line">        // 获取先前的超时时间  </span><br><span class="line">        end_time.tv_sec = restart_block-&gt;poll.tv_sec;  </span><br><span class="line">        end_time.tv_nsec = restart_block-&gt;poll.tv_nsec;  </span><br><span class="line">        to = &amp;end_time;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ret = do_sys_poll(ufds, nfds, to); // 重新调用 do_sys_poll  </span><br><span class="line">    if (ret == -EINTR) &#123;  </span><br><span class="line">        // 又被信号中断了, 再次重启  </span><br><span class="line">        restart_block-&gt;fn = do_restart_poll;  </span><br><span class="line">        ret = -ERESTART_RESTARTBLOCK;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return ret;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="select-实现"><a href="#select-实现" class="headerlink" title="select 实现"></a>select 实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;  </span><br><span class="line">    unsigned long *in, *out, *ex;  </span><br><span class="line">    unsigned long *res_in, *res_out, *res_ex;  </span><br><span class="line">&#125; fd_set_bits;  </span><br><span class="line">//  long sys_select(int n, fd_set *inp, fd_set *outp, fd_set *exp, struct timeval *tvp)  </span><br><span class="line">SYSCALL_DEFINE5(select, int, n, fd_set __user *, inp, fd_set __user *, outp,  </span><br><span class="line">                fd_set __user *, exp, struct timeval __user *, tvp)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct timespec end_time, *to = NULL;  </span><br><span class="line">    struct timeval tv;  </span><br><span class="line">    int ret;  </span><br><span class="line">    if (tvp) &#123;  </span><br><span class="line">        if (copy_from_user(&amp;tv, tvp, sizeof(tv))) &#123;  </span><br><span class="line">            return -EFAULT;  </span><br><span class="line">        &#125;  </span><br><span class="line">        // 计算超时时间  </span><br><span class="line">        to = &amp;end_time;  </span><br><span class="line">        if (poll_select_set_timeout(to,  </span><br><span class="line">                                    tv.tv_sec + (tv.tv_usec / USEC_PER_SEC),  </span><br><span class="line">                                    (tv.tv_usec % USEC_PER_SEC) * NSEC_PER_USEC)) &#123;  </span><br><span class="line">            return -EINVAL;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ret = core_sys_select(n, inp, outp, exp, to);  </span><br><span class="line">    // 复制剩余时间到用户空间  </span><br><span class="line">    ret = poll_select_copy_remaining(&amp;end_time, tvp, 1, ret);  </span><br><span class="line">    return ret;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int core_sys_select(int n, fd_set __user *inp, fd_set __user *outp,  </span><br><span class="line">                    fd_set __user *exp, struct timespec *end_time)  </span><br><span class="line">&#123;  </span><br><span class="line">    fd_set_bits fds;  </span><br><span class="line">    void *bits;  </span><br><span class="line">    int ret, max_fds;  </span><br><span class="line">    unsigned int size;  </span><br><span class="line">    struct fdtable *fdt;  </span><br><span class="line">    //小对象使用栈上的空间,节约内存, 加快访问速度  </span><br><span class="line">    long stack_fds[SELECT_STACK_ALLOC/sizeof(long)];  </span><br><span class="line">  </span><br><span class="line">    ret = -EINVAL;  </span><br><span class="line">    if (n &lt; 0) &#123;  </span><br><span class="line">        goto out_nofds;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    rcu_read_lock();  </span><br><span class="line">    // 取得进程对应的 fdtable  </span><br><span class="line">    fdt = files_fdtable(current-&gt;files);  </span><br><span class="line">    max_fds = fdt-&gt;max_fds;  </span><br><span class="line">    rcu_read_unlock();  </span><br><span class="line">    if (n &gt; max_fds) &#123;  </span><br><span class="line">        n = max_fds;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    size = FDS_BYTES(n);  </span><br><span class="line">    bits = stack_fds;  </span><br><span class="line">    if (size &gt; sizeof(stack_fds) / 6) &#123;  </span><br><span class="line">        // 栈上的空间不够, 申请内存, 全部使用堆上的空间  </span><br><span class="line">        ret = -ENOMEM;  </span><br><span class="line">        bits = kmalloc(6 * size, GFP_KERNEL);  </span><br><span class="line">        if (!bits) &#123;  </span><br><span class="line">            goto out_nofds;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    fds.in     = bits;  </span><br><span class="line">    fds.out    = bits +   size;  </span><br><span class="line">    fds.ex     = bits + 2*size;  </span><br><span class="line">    fds.res_in  = bits + 3*size;  </span><br><span class="line">    fds.res_out = bits + 4*size;  </span><br><span class="line">    fds.res_ex  = bits + 5*size;  </span><br><span class="line">  </span><br><span class="line">    // 复制用户空间到内核  </span><br><span class="line">    if ((ret = get_fd_set(n, inp, fds.in)) ||  </span><br><span class="line">            (ret = get_fd_set(n, outp, fds.out)) ||  </span><br><span class="line">            (ret = get_fd_set(n, exp, fds.ex))) &#123;  </span><br><span class="line">        goto out;  </span><br><span class="line">    &#125;  </span><br><span class="line">    // 初始化fd set  </span><br><span class="line">    zero_fd_set(n, fds.res_in);  </span><br><span class="line">    zero_fd_set(n, fds.res_out);  </span><br><span class="line">    zero_fd_set(n, fds.res_ex);  </span><br><span class="line">  </span><br><span class="line">    ret = do_select(n, &amp;fds, end_time);  </span><br><span class="line">  </span><br><span class="line">    if (ret &lt; 0) &#123;  </span><br><span class="line">        goto out;  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (!ret) &#123;  </span><br><span class="line">        // 该返回值会被系统捕获, 并以同样的参数重新调用sys_select()  </span><br><span class="line">        ret = -ERESTARTNOHAND;  </span><br><span class="line">        if (signal_pending(current)) &#123;  </span><br><span class="line">            goto out;  </span><br><span class="line">        &#125;  </span><br><span class="line">        ret = 0;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 复制到用户空间  </span><br><span class="line">    if (set_fd_set(n, inp, fds.res_in) ||  </span><br><span class="line">            set_fd_set(n, outp, fds.res_out) ||  </span><br><span class="line">            set_fd_set(n, exp, fds.res_ex)) &#123;  </span><br><span class="line">        ret = -EFAULT;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">out:  </span><br><span class="line">    if (bits != stack_fds) &#123;  </span><br><span class="line">        kfree(bits);  </span><br><span class="line">    &#125;  </span><br><span class="line">out_nofds:  </span><br><span class="line">    return ret;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int do_select(int n, fd_set_bits *fds, struct timespec *end_time)  </span><br><span class="line">&#123;  </span><br><span class="line">    ktime_t expire, *to = NULL;  </span><br><span class="line">    struct poll_wqueues table;  </span><br><span class="line">    poll_table *wait;  </span><br><span class="line">    int retval, i, timed_out = 0;  </span><br><span class="line">    unsigned long slack = 0;  </span><br><span class="line">  </span><br><span class="line">    rcu_read_lock();  </span><br><span class="line">    // 检查fds中fd的有效性, 并获取当前最大的fd  </span><br><span class="line">    retval = max_select_fd(n, fds);  </span><br><span class="line">    rcu_read_unlock();  </span><br><span class="line">  </span><br><span class="line">    if (retval &lt; 0) &#123;  </span><br><span class="line">        return retval;  </span><br><span class="line">    &#125;  </span><br><span class="line">    n = retval;  </span><br><span class="line">  </span><br><span class="line">    // 初始化 poll_wqueues 结构, 设置函数指针_qproc    为__pollwait  </span><br><span class="line">    poll_initwait(&amp;table);  </span><br><span class="line">    wait = &amp;table.pt;  </span><br><span class="line">    if (end_time &amp;&amp; !end_time-&gt;tv_sec &amp;&amp; !end_time-&gt;tv_nsec) &#123;  </span><br><span class="line">        wait = NULL;  </span><br><span class="line">        timed_out = 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    if (end_time &amp;&amp; !timed_out) &#123;  </span><br><span class="line">        // 估计需要等待的时间.  </span><br><span class="line">        slack = select_estimate_accuracy(end_time);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    retval = 0;  </span><br><span class="line">    for (;;) &#123;  </span><br><span class="line">        unsigned long *rinp, *routp, *rexp, *inp, *outp, *exp;  </span><br><span class="line">  </span><br><span class="line">        inp = fds-&gt;in;  </span><br><span class="line">        outp = fds-&gt;out;  </span><br><span class="line">        exp = fds-&gt;ex;  </span><br><span class="line">        rinp = fds-&gt;res_in;  </span><br><span class="line">        routp = fds-&gt;res_out;  </span><br><span class="line">        rexp = fds-&gt;res_ex;  </span><br><span class="line">        // 遍历所有的描述符, i 文件描述符  </span><br><span class="line">        for (i = 0; i &lt; n; ++rinp, ++routp, ++rexp) &#123;  </span><br><span class="line">            unsigned long in, out, ex, all_bits, bit = 1, mask, j;  </span><br><span class="line">            unsigned long res_in = 0, res_out = 0, res_ex = 0;  </span><br><span class="line">            const struct file_operations *f_op = NULL;  </span><br><span class="line">            struct file *file = NULL;  </span><br><span class="line">            // 检查当前的 slot 中的描述符  </span><br><span class="line">            in = *inp++;  </span><br><span class="line">            out = *outp++;  </span><br><span class="line">            ex = *exp++;  </span><br><span class="line">            all_bits = in | out | ex;  </span><br><span class="line">            if (all_bits == 0) &#123; // 没有需要监听的描述符, 下一个slot  </span><br><span class="line">                i += __NFDBITS;  </span><br><span class="line">                continue;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            for (j = 0; j &lt; __NFDBITS; ++j, ++i, bit &lt;&lt;= 1) &#123;  </span><br><span class="line">                int fput_needed;  </span><br><span class="line">                if (i &gt;= n) &#123;  </span><br><span class="line">                    break;  </span><br><span class="line">                &#125;  </span><br><span class="line">                // 不需要监听描述符 i  </span><br><span class="line">                if (!(bit &amp; all_bits)) &#123;  </span><br><span class="line">                    continue;  </span><br><span class="line">                &#125;  </span><br><span class="line">                // 取得文件结构  </span><br><span class="line">                file = fget_light(i, &amp;fput_needed);  </span><br><span class="line">                if (file) &#123;  </span><br><span class="line">                    f_op = file-&gt;f_op;  </span><br><span class="line">                    // 没有 f_op 的话就认为一直处于就绪状态  </span><br><span class="line">                    mask = DEFAULT_POLLMASK;  </span><br><span class="line">                    if (f_op &amp;&amp; f_op-&gt;poll) &#123;  </span><br><span class="line">                        // 设置等待事件的掩码  </span><br><span class="line">                        wait_key_set(wait, in, out, bit);  </span><br><span class="line">                        /* </span><br><span class="line">                        static inline void wait_key_set(poll_table *wait, unsigned long in, </span><br><span class="line">                        unsigned long out, unsigned long bit) </span><br><span class="line">                        &#123; </span><br><span class="line">                        wait-&gt;_key = POLLEX_SET;// (POLLPRI) </span><br><span class="line">                        if (in &amp; bit) </span><br><span class="line">                        wait-&gt;_key |= POLLIN_SET;//(POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP | POLLERR) </span><br><span class="line">                        if (out &amp; bit) </span><br><span class="line">                        wait-&gt;_key |= POLLOUT_SET;//POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR) </span><br><span class="line">                        &#125; </span><br><span class="line">                        */  </span><br><span class="line">                        // 获取当前的就绪状态, 并添加到文件的对应等待队列中  </span><br><span class="line">                        mask = (*f_op-&gt;poll)(file, wait);  </span><br><span class="line">                        // 和poll完全一样  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    fput_light(file, fput_needed);  </span><br><span class="line">                    // 释放文件  </span><br><span class="line">                    // 检查文件 i 是否已有事件就绪，  </span><br><span class="line">                    if ((mask &amp; POLLIN_SET) &amp;&amp; (in &amp; bit)) &#123;  </span><br><span class="line">                        res_in |= bit;  </span><br><span class="line">                        retval++;  </span><br><span class="line">                        // 如果已有就绪事件就不再向其他文件的  </span><br><span class="line">                        // 等待队列中添加回调函数  </span><br><span class="line">                        wait = NULL;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    if ((mask &amp; POLLOUT_SET) &amp;&amp; (out &amp; bit)) &#123;  </span><br><span class="line">                        res_out |= bit;  </span><br><span class="line">                        retval++;  </span><br><span class="line">                        wait = NULL;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    if ((mask &amp; POLLEX_SET) &amp;&amp; (ex &amp; bit)) &#123;  </span><br><span class="line">                        res_ex |= bit;  </span><br><span class="line">                        retval++;  </span><br><span class="line">                        wait = NULL;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (res_in) &#123;  </span><br><span class="line">                *rinp = res_in;  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (res_out) &#123;  </span><br><span class="line">                *routp = res_out;  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (res_ex) &#123;  </span><br><span class="line">                *rexp = res_ex;  </span><br><span class="line">            &#125;  </span><br><span class="line">            cond_resched();  </span><br><span class="line">        &#125;  </span><br><span class="line">        wait = NULL; // 该添加回调函数的都已经添加了  </span><br><span class="line">        if (retval || timed_out || signal_pending(current)) &#123;  </span><br><span class="line">            break;   // 信号发生，监听事件就绪或超时  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (table.error) &#123;  </span><br><span class="line">            retval = table.error; // 产生错误了  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">        // 转换到内核时间  </span><br><span class="line">        if (end_time &amp;&amp; !to) &#123;  </span><br><span class="line">            expire = timespec_to_ktime(*end_time);  </span><br><span class="line">            to = &amp;expire;  </span><br><span class="line">        &#125;  </span><br><span class="line">        // 等待直到超时, 或由回调函数唤醒, 超时后会再次遍历文件描述符  </span><br><span class="line">        if (!poll_schedule_timeout(&amp;table, TASK_INTERRUPTIBLE,  </span><br><span class="line">                                   to, slack)) &#123;  </span><br><span class="line">            timed_out = 1;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    poll_freewait(&amp;table);  </span><br><span class="line">  </span><br><span class="line">    return retval;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="epoll实现"><a href="#epoll实现" class="headerlink" title="epoll实现"></a>epoll实现</h1><p>epoll 的实现比poll/select 复杂一些，这是因为：</p>
<ol>
<li>epoll_wait, epoll_ctl 的调用完全独立开来,内核需要锁机制对这些操作进行保护，并且需要持久的维护添加到epoll的文件</li>
<li>epoll本身也是文件，也可以被poll/select/epoll监视，这可能导致epoll之间循环唤醒的问题</li>
<li>单个文件的状态改变可能唤醒过多监听在其上的epoll，产生唤醒风暴</li>
</ol>
<p>epoll各个功能的实现要非常小心面对这些问题，使得复杂度大大增加。</p>
<h2 id="epoll的核心数据结构"><a href="#epoll的核心数据结构" class="headerlink" title="epoll的核心数据结构"></a>epoll的核心数据结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">// epoll的核心实现对应于一个epoll描述符  </span><br><span class="line">struct eventpoll &#123;  </span><br><span class="line">    spinlock_t lock;  </span><br><span class="line">    struct mutex mtx;  </span><br><span class="line">    wait_queue_head_t wq; // sys_epoll_wait() 等待在这里  </span><br><span class="line">    // f_op-&gt;poll()  使用的, 被其他事件通知机制利用的wait_address  </span><br><span class="line">    wait_queue_head_t poll_wait;  </span><br><span class="line">    /* 已就绪的需要检查的epitem 列表 */  </span><br><span class="line">    struct list_head rdllist;  </span><br><span class="line">    /* 保存所有加入到当前epoll的文件对应的epitem*/  </span><br><span class="line">    struct rb_root rbr;  </span><br><span class="line">    // 当正在向用户空间复制数据时, 产生的可用文件  </span><br><span class="line">    struct epitem *ovflist;  </span><br><span class="line">    /* The user that created the eventpoll descriptor */  </span><br><span class="line">    struct user_struct *user;  </span><br><span class="line">    struct file *file;  </span><br><span class="line">    /*优化循环检查，避免循环检查中重复的遍历 */  </span><br><span class="line">    int visited;  </span><br><span class="line">    struct list_head visited_list_link;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 对应于一个加入到epoll的文件  </span><br><span class="line">struct epitem &#123;  </span><br><span class="line">    // 挂载到eventpoll 的红黑树节点  </span><br><span class="line">    struct rb_node rbn;  </span><br><span class="line">    // 挂载到eventpoll.rdllist 的节点  </span><br><span class="line">    struct list_head rdllink;  </span><br><span class="line">    // 连接到ovflist 的指针  </span><br><span class="line">    struct epitem *next;  </span><br><span class="line">    /* 文件描述符信息fd + file, 红黑树的key */  </span><br><span class="line">    struct epoll_filefd ffd;  </span><br><span class="line">    /* Number of active wait queue attached to poll operations */  </span><br><span class="line">    int nwait;  </span><br><span class="line">    // 当前文件的等待队列(eppoll_entry)列表  </span><br><span class="line">    // 同一个文件上可能会监视多种事件,  </span><br><span class="line">    // 这些事件可能属于不同的wait_queue中  </span><br><span class="line">    // (取决于对应文件类型的实现),  </span><br><span class="line">    // 所以需要使用链表  </span><br><span class="line">    struct list_head pwqlist;  </span><br><span class="line">    // 当前epitem 的所有者  </span><br><span class="line">    struct eventpoll *ep;  </span><br><span class="line">    /* List header used to link this item to the &amp;quot;struct file&amp;quot; items list */  </span><br><span class="line">    struct list_head fllink;  </span><br><span class="line">    /* epoll_ctl 传入的用户数据 */  </span><br><span class="line">    struct epoll_event event;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">struct epoll_filefd &#123;  </span><br><span class="line">    struct file *file;  </span><br><span class="line">    int fd;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">// 与一个文件上的一个wait_queue_head 相关联，因为同一文件可能有多个等待的事件，这些事件可能使用不同的等待队列  </span><br><span class="line">struct eppoll_entry &#123;  </span><br><span class="line">    // List struct epitem.pwqlist  </span><br><span class="line">    struct list_head llink;  </span><br><span class="line">    // 所有者  </span><br><span class="line">    struct epitem *base;  </span><br><span class="line">    // 添加到wait_queue 中的节点  </span><br><span class="line">    wait_queue_t wait;  </span><br><span class="line">    // 文件wait_queue 头  </span><br><span class="line">    wait_queue_head_t *whead;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">// 用户使用的epoll_event  </span><br><span class="line">struct epoll_event &#123;  </span><br><span class="line">    __u32 events;  </span><br><span class="line">    __u64 data;  </span><br><span class="line">&#125; EPOLL_PACKED;</span><br></pre></td></tr></table></figure>
<h2 id="文件系统初始化和epoll-create"><a href="#文件系统初始化和epoll-create" class="headerlink" title="文件系统初始化和epoll_create"></a>文件系统初始化和epoll_create</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">// epoll 文件系统的相关实现  </span><br><span class="line">// epoll 文件系统初始化, 在系统启动时会调用  </span><br><span class="line">  </span><br><span class="line">static int __init eventpoll_init(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct sysinfo si;  </span><br><span class="line">  </span><br><span class="line">    si_meminfo(&amp;si);  </span><br><span class="line">    // 限制可添加到epoll的最多的描述符数量  </span><br><span class="line">  </span><br><span class="line">    max_user_watches = (((si.totalram - si.totalhigh) / 25) &lt;&lt; PAGE_SHIFT) /  </span><br><span class="line">                       EP_ITEM_COST;  </span><br><span class="line">    BUG_ON(max_user_watches &lt; 0);  </span><br><span class="line">  </span><br><span class="line">    // 初始化递归检查队列  </span><br><span class="line">   ep_nested_calls_init(&amp;poll_loop_ncalls);  </span><br><span class="line">    ep_nested_calls_init(&amp;poll_safewake_ncalls);  </span><br><span class="line">    ep_nested_calls_init(&amp;poll_readywalk_ncalls);  </span><br><span class="line">    // epoll 使用的slab分配器分别用来分配epitem和eppoll_entry  </span><br><span class="line">    epi_cache = kmem_cache_create(&quot;eventpoll_epi&quot;, sizeof(struct epitem),  </span><br><span class="line">                                  0, SLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);  </span><br><span class="line">    pwq_cache = kmem_cache_create(&quot;eventpoll_pwq&quot;,  </span><br><span class="line">                                  sizeof(struct eppoll_entry), 0, SLAB_PANIC, NULL);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">SYSCALL_DEFINE1(epoll_create, int, size)  </span><br><span class="line">&#123;  </span><br><span class="line">    if (size &lt;= 0) &#123;  </span><br><span class="line">        return -EINVAL;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return sys_epoll_create1(0);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">SYSCALL_DEFINE1(epoll_create1, int, flags)  </span><br><span class="line">&#123;  </span><br><span class="line">    int error, fd;  </span><br><span class="line">    struct eventpoll *ep = NULL;  </span><br><span class="line">    struct file *file;  </span><br><span class="line">  </span><br><span class="line">    /* Check the EPOLL_* constant for consistency.  */  </span><br><span class="line">    BUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);  </span><br><span class="line">  </span><br><span class="line">    if (flags &amp; ~EPOLL_CLOEXEC) &#123;  </span><br><span class="line">        return -EINVAL;  </span><br><span class="line">    &#125;  </span><br><span class="line">    /* </span><br><span class="line">     * Create the internal data structure (&quot;struct eventpoll&quot;). </span><br><span class="line">     */  </span><br><span class="line">    error = ep_alloc(&amp;ep);  </span><br><span class="line">    if (error &lt; 0) &#123;  </span><br><span class="line">        return error;  </span><br><span class="line">    &#125;  </span><br><span class="line">    /* </span><br><span class="line">     * Creates all the items needed to setup an eventpoll file. That is, </span><br><span class="line">     * a file structure and a free file descriptor. </span><br><span class="line">     */  </span><br><span class="line">    fd = get_unused_fd_flags(O_RDWR | (flags &amp; O_CLOEXEC));  </span><br><span class="line">    if (fd &lt; 0) &#123;  </span><br><span class="line">         error = fd;  </span><br><span class="line">         goto out_free_ep;  </span><br><span class="line">      &#125;  </span><br><span class="line">      // 设置epfd的相关操作，由于epoll也是文件也提供了poll操作  </span><br><span class="line">    file = anon_inode_getfile(&quot;[eventpoll]&quot;, &amp;eventpoll_fops, ep,  </span><br><span class="line">                              O_RDWR | (flags &amp; O_CLOEXEC));  </span><br><span class="line">    if (IS_ERR(file)) &#123;  </span><br><span class="line">        error = PTR_ERR(file);  </span><br><span class="line">        goto out_free_fd;  </span><br><span class="line">    &#125;  </span><br><span class="line">    fd_install(fd, file);  </span><br><span class="line">    ep-&gt;file = file;  </span><br><span class="line">    return fd;  </span><br><span class="line">  </span><br><span class="line">out_free_fd:  </span><br><span class="line">    put_unused_fd(fd);  </span><br><span class="line">out_free_ep:  </span><br><span class="line">    ep_free(ep);  </span><br><span class="line">    return error;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="epoll中的递归死循环和深度检查"><a href="#epoll中的递归死循环和深度检查" class="headerlink" title="epoll中的递归死循环和深度检查"></a>epoll中的递归死循环和深度检查</h2><h3 id="递归深度检测-ep-call-nested"><a href="#递归深度检测-ep-call-nested" class="headerlink" title="递归深度检测(ep_call_nested)"></a>递归深度检测(ep_call_nested)</h3><p>epoll本身也是文件，也可以被poll/select/epoll监视，如果epoll之间互相监视就有可能导致死循环。epoll的实现中，所有可能产生递归调用的函数都由函函数ep_call_nested进行包裹，递归调用过程中出现死循环或递归过深就会打破死循环和递归调用直接返回。该函数的实现依赖于一个外部的全局链表nested_call_node(不同的函数调用使用不同的节点)，每次调用可能发生递归的函数(nproc)就向链表中添加一个包含当前函数调用上下文ctx(进程，CPU，或epoll文件)和处理的对象标识cookie的节点，通过检测是否有相同的节点就可以知道是否发生了死循环，检查链表中同一上下文包含的节点个数就可以知道递归的深度。以下就是这一过程的源码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">struct nested_call_node &#123;  </span><br><span class="line">    struct list_head llink;  </span><br><span class="line">    void *cookie;   // 函数运行标识, 任务标志  </span><br><span class="line">    void *ctx;      // 运行环境标识  </span><br><span class="line">&#125;;  </span><br><span class="line">struct nested_calls &#123;  </span><br><span class="line">    struct list_head tasks_call_list;  </span><br><span class="line">    spinlock_t lock;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">// 全局的不同调用使用的链表  </span><br><span class="line">// 死循环检查和唤醒风暴检查链表  </span><br><span class="line">static nested_call_node poll_loop_ncalls;  </span><br><span class="line">// 唤醒时使用的检查链表  </span><br><span class="line">static nested_call_node poll_safewake_ncalls;  </span><br><span class="line">// 扫描readylist 时使用的链表  </span><br><span class="line">static nested_call_node poll_readywalk_ncalls;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">// 限制epoll 中直接或间接递归调用的深度并防止死循环  </span><br><span class="line">// ctx: 任务运行上下文(进程, CPU 等)  </span><br><span class="line">// cookie: 每个任务的标识  </span><br><span class="line">// priv: 任务运行需要的私有数据  </span><br><span class="line">// 如果用面向对象语言实现应该就会是一个wapper类  </span><br><span class="line">static int ep_call_nested(struct nested_calls *ncalls, int max_nests,  </span><br><span class="line">                          int (*nproc)(void *, void *, int), void *priv,  </span><br><span class="line">                          void *cookie, void *ctx)  </span><br><span class="line">&#123;  </span><br><span class="line">    int error, call_nests = 0;  </span><br><span class="line">    unsigned long flags;  </span><br><span class="line">    struct list_head *lsthead = &amp;ncalls-&gt;tasks_call_list;  </span><br><span class="line">    struct nested_call_node *tncur;  </span><br><span class="line">    struct nested_call_node tnode;  </span><br><span class="line">    spin_lock_irqsave(&amp;ncalls-&gt;lock, flags);  </span><br><span class="line">    // 检查原有的嵌套调用链表ncalls, 查看是否有深度超过限制的情况  </span><br><span class="line">    list_for_each_entry(tncur, lsthead, llink) &#123;  </span><br><span class="line">        // 同一上下文中(ctx)有相同的任务(cookie)说明产生了死循环  </span><br><span class="line">        // 同一上下文的递归深度call_nests 超过限制  </span><br><span class="line">        if (tncur-&gt;ctx == ctx &amp;&amp;  </span><br><span class="line">                (tncur-&gt;cookie == cookie || ++call_nests &gt; max_nests)) &#123;  </span><br><span class="line">            error = -1;  </span><br><span class="line">        &#125;  </span><br><span class="line">        goto out_unlock;  </span><br><span class="line">    &#125;  </span><br><span class="line">    /* 将当前的任务请求添加到调用列表*/  </span><br><span class="line">    tnode.ctx = ctx;  </span><br><span class="line">    tnode.cookie = cookie;  </span><br><span class="line">    list_add(&amp;tnode.llink, lsthead);  </span><br><span class="line">    spin_unlock_irqrestore(&amp;ncalls-&gt;lock, flags);  </span><br><span class="line">    /* nproc 可能会导致递归调用(直接或间接)ep_call_nested </span><br><span class="line">         * 如果发生递归调用, 那么在此函数返回之前, </span><br><span class="line">         * ncalls 又会被加入额外的节点, </span><br><span class="line">         * 这样通过前面的检测就可以知道递归调用的深度 </span><br><span class="line">      */  </span><br><span class="line">    error = (*nproc)(priv, cookie, call_nests);  </span><br><span class="line">    /* 从链表中删除当前任务*/  </span><br><span class="line">    spin_lock_irqsave(&amp;ncalls-&gt;lock, flags);  </span><br><span class="line">    list_del(&amp;tnode.llink);  </span><br><span class="line">out_unlock:  </span><br><span class="line">    spin_unlock_irqrestore(&amp;ncalls-&gt;lock, flags);  </span><br><span class="line">    return error;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="循环检测-ep-loop-check"><a href="#循环检测-ep-loop-check" class="headerlink" title="循环检测(ep_loop_check)"></a>循环检测(ep_loop_check)</h3><p>循环检查(ep_loop_check)，该函数递归调用ep_loop_check_proc利用ep_call_nested来实现epoll之间相互监视的死循环。因为ep_call_nested中已经对死循环和过深的递归做了检查，实际的ep_loop_check_proc的实现只是递归调用自己。其中的visited_list和visited标记完全是为了优化处理速度，如果没有visited_list和visited标记函数也是能够工作的。该函数中得上下文就是当前的进程，cookie就是正在遍历的epoll结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">static LIST_HEAD(visited_list);  </span><br><span class="line">// 检查 file (epoll)和ep 之间是否有循环  </span><br><span class="line">static int ep_loop_check(struct eventpoll *ep, struct file *file)  </span><br><span class="line">&#123;  </span><br><span class="line">    int ret;  </span><br><span class="line">    struct eventpoll *ep_cur, *ep_next;  </span><br><span class="line">  </span><br><span class="line">    ret = ep_call_nested(&amp;poll_loop_ncalls, EP_MAX_NESTS,  </span><br><span class="line">                         ep_loop_check_proc, file, ep, current);  </span><br><span class="line">    /* 清除链表和标志 */  </span><br><span class="line">    list_for_each_entry_safe(ep_cur, ep_next, &amp;visited_list,  </span><br><span class="line">                             visited_list_link) &#123;  </span><br><span class="line">        ep_cur-&gt;visited = 0;  </span><br><span class="line">        list_del(&amp;ep_cur-&gt;visited_list_link);  </span><br><span class="line">    &#125;  </span><br><span class="line">    return ret;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)  </span><br><span class="line">&#123;  </span><br><span class="line">    int error = 0;  </span><br><span class="line">    struct file *file = priv;  </span><br><span class="line">    struct eventpoll *ep = file-&gt;private_data;  </span><br><span class="line">    struct eventpoll *ep_tovisit;  </span><br><span class="line">    struct rb_node *rbp;  </span><br><span class="line">    struct epitem *epi;  </span><br><span class="line">  </span><br><span class="line">    mutex_lock_nested(&amp;ep-&gt;mtx, call_nests + 1);  </span><br><span class="line">    // 标记当前为已遍历  </span><br><span class="line">    ep-&gt;visited = 1;  </span><br><span class="line">    list_add(&amp;ep-&gt;visited_list_link, &amp;visited_list);  </span><br><span class="line">    // 遍历所有ep 监视的文件  </span><br><span class="line">    for (rbp = rb_first(&amp;ep-&gt;rbr); rbp; rbp = rb_next(rbp)) &#123;  </span><br><span class="line">        epi = rb_entry(rbp, struct epitem, rbn);  </span><br><span class="line">        if (unlikely(is_file_epoll(epi-&gt;ffd.file))) &#123;  </span><br><span class="line">            ep_tovisit = epi-&gt;ffd.file-&gt;private_data;  </span><br><span class="line">            // 跳过先前已遍历的, 避免循环检查  </span><br><span class="line">            if (ep_tovisit-&gt;visited) &#123;  </span><br><span class="line">                continue;  </span><br><span class="line">            &#125;  </span><br><span class="line">            // 所有ep监视的未遍历的epoll  </span><br><span class="line">            error = ep_call_nested(&amp;poll_loop_ncalls, EP_MAX_NESTS,  </span><br><span class="line">                                   ep_loop_check_proc, epi-&gt;ffd.file,  </span><br><span class="line">                                   ep_tovisit, current);  </span><br><span class="line">            if (error != 0) &#123;  </span><br><span class="line">                break;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            // 文件不在tfile_check_list 中, 添加  </span><br><span class="line">            // 最外层的epoll 需要检查子epoll监视的文件  </span><br><span class="line">            if (list_empty(&amp;epi-&gt;ffd.file-&gt;f_tfile_llink))  </span><br><span class="line">                list_add(&amp;epi-&gt;ffd.file-&gt;f_tfile_llink,  </span><br><span class="line">                         &amp;tfile_check_list);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    mutex_unlock(&amp;ep-&gt;mtx);  </span><br><span class="line">  </span><br><span class="line">    return error;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="唤醒风暴检测（reverse-path-check）"><a href="#唤醒风暴检测（reverse-path-check）" class="headerlink" title="唤醒风暴检测（reverse_path_check）"></a>唤醒风暴检测（reverse_path_check）</h3><p> 当文件状态发生改变时，会唤醒监听在其上的epoll文件，而这个epoll文件还可能唤醒其他的epoll文件，这种连续的唤醒就形成了一个唤醒路径，所有的唤醒路径就形成了一个有向图。如果文件对应的epoll唤醒有向图的节点过多，那么文件状态的改变就会唤醒所有的这些epoll(可能会唤醒很多进程，这样的开销是很大的)，而实际上一个文件经过少数epoll处理以后就可能从就绪转到未就绪，剩余的epoll虽然认为文件已就绪而实际上经过某些处理后已不可用。epoll的实现中考虑到了此问题，在每次添加新文件到epoll中时，就会首先检查是否会出现这样的唤醒风暴。</p>
<p>该函数的实现逻辑是这样的，递归调用reverse_path_check_proc遍历监听在当前文件上的epoll文件，在reverse_pach_check_proc中统计并检查不同路径深度上epoll的个数，从而避免产生唤醒风暴。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#define PATH_ARR_SIZE 5  </span><br><span class="line">// 在EPOLL_CTL_ADD 时, 检查是否有可能产生唤醒风暴  </span><br><span class="line">// epoll 允许的单个文件的唤醒深度小于5, 例如  </span><br><span class="line">// 一个文件最多允许唤醒1000个深度为1的epoll描述符,  </span><br><span class="line">//允许所有被单个文件直接唤醒的epoll描述符再次唤醒的epoll描述符总数是500  </span><br><span class="line">//  </span><br><span class="line">  </span><br><span class="line">// 深度限制  </span><br><span class="line">static const int path_limits[PATH_ARR_SIZE] = &#123; 1000, 500, 100, 50, 10 &#125;;  </span><br><span class="line">// 计算出来的深度  </span><br><span class="line">static int path_count[PATH_ARR_SIZE];  </span><br><span class="line">  </span><br><span class="line">static int path_count_inc(int nests)  </span><br><span class="line">&#123;  </span><br><span class="line">    /* Allow an arbitrary number of depth 1 paths */  </span><br><span class="line">    if (nests == 0) &#123;  </span><br><span class="line">        return 0;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    if (++path_count[nests] &gt; path_limits[nests]) &#123;  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">static void path_count_init(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    int i;  </span><br><span class="line">  </span><br><span class="line">    for (i = 0; i &lt; PATH_ARR_SIZE; i++) &#123;  </span><br><span class="line">        path_count[i] = 0;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// 唤醒风暴检查函数  </span><br><span class="line">static int reverse_path_check(void)  </span><br><span class="line">&#123;  </span><br><span class="line">    int error = 0;  </span><br><span class="line">    struct file *current_file;  </span><br><span class="line">  </span><br><span class="line">    /* let&apos;s call this for all tfiles */  </span><br><span class="line">    // 遍历全局tfile_check_list 中的文件, 第一级  </span><br><span class="line">    list_for_each_entry(current_file, &amp;tfile_check_list, f_tfile_llink) &#123;  </span><br><span class="line">        // 初始化  </span><br><span class="line">        path_count_init();  </span><br><span class="line">        // 限制递归的深度, 并检查每个深度上唤醒的epoll 数量  </span><br><span class="line">        error = ep_call_nested(&amp;poll_loop_ncalls, EP_MAX_NESTS,  </span><br><span class="line">                               reverse_path_check_proc, current_file,  </span><br><span class="line">                               current_file, current);  </span><br><span class="line">        if (error) &#123;  </span><br><span class="line">            break;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return error;  </span><br><span class="line">&#125;  </span><br><span class="line">static int reverse_path_check_proc(void *priv, void *cookie, int call_nests)  </span><br><span class="line">&#123;  </span><br><span class="line">    int error = 0;  </span><br><span class="line">    struct file *file = priv;  </span><br><span class="line">    struct file *child_file;  </span><br><span class="line">    struct epitem *epi;  </span><br><span class="line">  </span><br><span class="line">    list_for_each_entry(epi, &amp;file-&gt;f_ep_links, fllink) &#123;  </span><br><span class="line">        // 遍历监视file 的epoll  </span><br><span class="line">        child_file = epi-&gt;ep-&gt;file;  </span><br><span class="line">        if (is_file_epoll(child_file)) &#123;  </span><br><span class="line">            if (list_empty(&amp;child_file-&gt;f_ep_links)) &#123;  </span><br><span class="line">                // 没有其他的epoll监视当前的这个epoll,  </span><br><span class="line">                // 已经是叶子了  </span><br><span class="line">                if (path_count_inc(call_nests)) &#123;  </span><br><span class="line">                    error = -1;  </span><br><span class="line">                    break;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; else &#123;  </span><br><span class="line">                // 遍历监视这个epoll 文件的epoll,  </span><br><span class="line">                // 递归调用  </span><br><span class="line">                error = ep_call_nested(&amp;poll_loop_ncalls,  </span><br><span class="line">                                       EP_MAX_NESTS,  </span><br><span class="line">                                       reverse_path_check_proc,  </span><br><span class="line">                                       child_file, child_file,  </span><br><span class="line">                                       current);  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (error != 0) &#123;  </span><br><span class="line">                break;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            // 不是epoll , 不可能吧?  </span><br><span class="line">            printk(KERN_ERR &quot;reverse_path_check_proc: &quot;  </span><br><span class="line">                   &quot;file is not an ep!\n&quot;);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return error;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="epoll-的唤醒过程"><a href="#epoll-的唤醒过程" class="headerlink" title="epoll 的唤醒过程"></a>epoll 的唤醒过程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static void ep_poll_safewake(wait_queue_head_t *wq)  </span><br><span class="line">&#123;  </span><br><span class="line">    int this_cpu = get_cpu();  </span><br><span class="line">  </span><br><span class="line">    ep_call_nested(&amp;poll_safewake_ncalls, EP_MAX_NESTS,  </span><br><span class="line">                   ep_poll_wakeup_proc, NULL, wq, (void *) (long) this_cpu);  </span><br><span class="line">  </span><br><span class="line">    put_cpu();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">static int ep_poll_wakeup_proc(void *priv, void *cookie, int call_nests)  </span><br><span class="line">&#123;  </span><br><span class="line">    ep_wake_up_nested((wait_queue_head_t *) cookie, POLLIN,  </span><br><span class="line">                      1 + call_nests);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">static inline void ep_wake_up_nested(wait_queue_head_t *wqueue,  </span><br><span class="line">                                     unsigned long events, int subclass)  </span><br><span class="line">&#123;  </span><br><span class="line">    // 这回唤醒所有正在等待此epfd 的select/epoll/poll 等  </span><br><span class="line">    // 如果唤醒的是epoll 就可能唤醒其他的epoll, 产生连锁反应  </span><br><span class="line">    // 这个很可能在中断上下文中被调用  </span><br><span class="line">    wake_up_poll(wqueue, events);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">// long epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);  </span><br><span class="line">  </span><br><span class="line">SYSCALL_DEFINE4(epoll_ctl, int, epfd, int, op, int, fd,  </span><br><span class="line">                struct epoll_event __user *, event)  </span><br><span class="line">&#123;  </span><br><span class="line">    int error;  </span><br><span class="line">    int did_lock_epmutex = 0;  </span><br><span class="line">    struct file *file, *tfile;  </span><br><span class="line">    struct eventpoll *ep;  </span><br><span class="line">    struct epitem *epi;  </span><br><span class="line">    struct epoll_event epds;  </span><br><span class="line">  </span><br><span class="line">    error = -EFAULT;  </span><br><span class="line">    if (ep_op_has_event(op) &amp;&amp;  </span><br><span class="line">            // 复制用户空间数据到内核  </span><br><span class="line">            copy_from_user(&amp;epds, event, sizeof(struct epoll_event))) &#123;  </span><br><span class="line">        goto error_return;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 取得 epfd 对应的文件  </span><br><span class="line">    error = -EBADF;  </span><br><span class="line">    file = fget(epfd);  </span><br><span class="line">    if (!file) &#123;  </span><br><span class="line">        goto error_return;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 取得目标文件  </span><br><span class="line">    tfile = fget(fd);  </span><br><span class="line">    if (!tfile) &#123;  </span><br><span class="line">        goto error_fput;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 目标文件必须提供 poll 操作  </span><br><span class="line">    error = -EPERM;  </span><br><span class="line">    if (!tfile-&gt;f_op || !tfile-&gt;f_op-&gt;poll) &#123;  </span><br><span class="line">        goto error_tgt_fput;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 添加自身或epfd 不是epoll 句柄  </span><br><span class="line">    error = -EINVAL;  </span><br><span class="line">    if (file == tfile || !is_file_epoll(file)) &#123;  </span><br><span class="line">        goto error_tgt_fput;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 取得内部结构eventpoll  </span><br><span class="line">    ep = file-&gt;private_data;  </span><br><span class="line">  </span><br><span class="line">    // EPOLL_CTL_MOD 不需要加全局锁 epmutex  </span><br><span class="line">    if (op == EPOLL_CTL_ADD || op == EPOLL_CTL_DEL) &#123;  </span><br><span class="line">        mutex_lock(&amp;epmutex);  </span><br><span class="line">        did_lock_epmutex = 1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    if (op == EPOLL_CTL_ADD) &#123;  </span><br><span class="line">        if (is_file_epoll(tfile)) &#123;  </span><br><span class="line">            error = -ELOOP;  </span><br><span class="line">            // 目标文件也是epoll 检测是否有循环包含的问题  </span><br><span class="line">            if (ep_loop_check(ep, tfile) != 0) &#123;  </span><br><span class="line">                goto error_tgt_fput;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; else  </span><br><span class="line">        &#123;  </span><br><span class="line">            // 将目标文件添加到 epoll 全局的tfile_check_list 中  </span><br><span class="line">            list_add(&amp;tfile-&gt;f_tfile_llink, &amp;tfile_check_list);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    mutex_lock_nested(&amp;ep-&gt;mtx, 0);  </span><br><span class="line">  </span><br><span class="line">    // 以tfile 和fd 为key 在rbtree 中查找文件对应的epitem  </span><br><span class="line">    epi = ep_find(ep, tfile, fd);  </span><br><span class="line">  </span><br><span class="line">    error = -EINVAL;  </span><br><span class="line">    switch (op) &#123;  </span><br><span class="line">    case EPOLL_CTL_ADD:  </span><br><span class="line">        if (!epi) &#123;  </span><br><span class="line">            // 没找到, 添加额外添加ERR HUP 事件  </span><br><span class="line">            epds.events |= POLLERR | POLLHUP;  </span><br><span class="line">            error = ep_insert(ep, &amp;epds, tfile, fd);  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            error = -EEXIST;  </span><br><span class="line">        &#125;  </span><br><span class="line">        // 清空文件检查列表  </span><br><span class="line">        clear_tfile_check_list();  </span><br><span class="line">        break;  </span><br><span class="line">    case EPOLL_CTL_DEL:  </span><br><span class="line">        if (epi) &#123;  </span><br><span class="line">            error = ep_remove(ep, epi);  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            error = -ENOENT;  </span><br><span class="line">        &#125;  </span><br><span class="line">        break;  </span><br><span class="line">    case EPOLL_CTL_MOD:  </span><br><span class="line">        if (epi) &#123;  </span><br><span class="line">            epds.events |= POLLERR | POLLHUP;  </span><br><span class="line">            error = ep_modify(ep, epi, &amp;epds);  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">            error = -ENOENT;  </span><br><span class="line">        &#125;  </span><br><span class="line">        break;  </span><br><span class="line">    &#125;  </span><br><span class="line">    mutex_unlock(&amp;ep-&gt;mtx);  </span><br><span class="line">  </span><br><span class="line">error_tgt_fput:  </span><br><span class="line">    if (did_lock_epmutex) &#123;  </span><br><span class="line">        mutex_unlock(&amp;epmutex);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    fput(tfile);  </span><br><span class="line">error_fput:  </span><br><span class="line">    fput(file);  </span><br><span class="line">error_return:  </span><br><span class="line">  </span><br><span class="line">    return error;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EPOLL-CTL-ADD-实现"><a href="#EPOLL-CTL-ADD-实现" class="headerlink" title="EPOLL_CTL_ADD 实现"></a>EPOLL_CTL_ADD 实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">// EPOLL_CTL_ADD  </span><br><span class="line">static int ep_insert(struct eventpoll *ep, struct epoll_event *event,  </span><br><span class="line">                     struct file *tfile, int fd)  </span><br><span class="line">&#123;  </span><br><span class="line">    int error, revents, pwake = 0;  </span><br><span class="line">    unsigned long flags;  </span><br><span class="line">    long user_watches;  </span><br><span class="line">    struct epitem *epi;  </span><br><span class="line">    struct ep_pqueue epq;  </span><br><span class="line">    /* </span><br><span class="line">    struct ep_pqueue &#123; </span><br><span class="line">        poll_table pt; </span><br><span class="line">        struct epitem *epi; </span><br><span class="line">    &#125;; </span><br><span class="line">    */  </span><br><span class="line">  </span><br><span class="line">    // 增加监视文件数  </span><br><span class="line">    user_watches = atomic_long_read(&amp;ep-&gt;user-&gt;epoll_watches);  </span><br><span class="line">    if (unlikely(user_watches &gt;= max_user_watches)) &#123;  </span><br><span class="line">        return -ENOSPC;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // 分配初始化 epi  </span><br><span class="line">    if (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL))) &#123;  </span><br><span class="line">        return -ENOMEM;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;rdllink);  </span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;fllink);  </span><br><span class="line">    INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);  </span><br><span class="line">    epi-&gt;ep = ep;  </span><br><span class="line">    // 初始化红黑树中的key  </span><br><span class="line">    ep_set_ffd(&amp;epi-&gt;ffd, tfile, fd);  </span><br><span class="line">    // 直接复制用户结构  </span><br><span class="line">    epi-&gt;event = *event;  </span><br><span class="line">    epi-&gt;nwait = 0;  </span><br><span class="line">    epi-&gt;next = EP_UNACTIVE_PTR;  </span><br><span class="line">  </span><br><span class="line">    // 初始化临时的 epq  </span><br><span class="line">    epq.epi = epi;  </span><br><span class="line">    init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);  </span><br><span class="line">    // 设置事件掩码  </span><br><span class="line">    epq.pt._key = event-&gt;events;  </span><br><span class="line">    //  内部会调用ep_ptable_queue_proc, 在文件对应的wait queue head 上  </span><br><span class="line">    // 注册回调函数, 并返回当前文件的状态  </span><br><span class="line">    revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);  </span><br><span class="line">  </span><br><span class="line">    // 检查错误  </span><br><span class="line">    error = -ENOMEM;  </span><br><span class="line">    if (epi-&gt;nwait &lt; 0) &#123; // f_op-&gt;poll 过程出错  </span><br><span class="line">        goto error_unregister;  </span><br><span class="line">    &#125;  </span><br><span class="line">    // 添加当前的epitem 到文件的f_ep_links 链表  </span><br><span class="line">    spin_lock(&amp;tfile-&gt;f_lock);  </span><br><span class="line">    list_add_tail(&amp;epi-&gt;fllink, &amp;tfile-&gt;f_ep_links);  </span><br><span class="line">    spin_unlock(&amp;tfile-&gt;f_lock);  </span><br><span class="line">  </span><br><span class="line">    // 插入epi 到rbtree  </span><br><span class="line">    ep_rbtree_insert(ep, epi);  </span><br><span class="line">  </span><br><span class="line">    /* now check if we&apos;ve created too many backpaths */  </span><br><span class="line">    error = -EINVAL;  </span><br><span class="line">    if (reverse_path_check()) &#123;  </span><br><span class="line">        goto error_remove_epi;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);  </span><br><span class="line">  </span><br><span class="line">    /* 文件已经就绪插入到就绪链表rdllist */  </span><br><span class="line">    if ((revents &amp; event-&gt;events) &amp;&amp; !ep_is_linked(&amp;epi-&gt;rdllink)) &#123;  </span><br><span class="line">        list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        if (waitqueue_active(&amp;ep-&gt;wq))  </span><br><span class="line">            // 通知sys_epoll_wait , 调用回调函数唤醒sys_epoll_wait 进程  </span><br><span class="line">        &#123;  </span><br><span class="line">            wake_up_locked(&amp;ep-&gt;wq);  </span><br><span class="line">        &#125;  </span><br><span class="line">        // 先不通知调用eventpoll_poll 的进程  </span><br><span class="line">        if (waitqueue_active(&amp;ep-&gt;poll_wait)) &#123;  </span><br><span class="line">            pwake++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);  </span><br><span class="line">  </span><br><span class="line">    atomic_long_inc(&amp;ep-&gt;user-&gt;epoll_watches);  </span><br><span class="line">  </span><br><span class="line">    if (pwake)  </span><br><span class="line">        // 安全通知调用eventpoll_poll 的进程  </span><br><span class="line">    &#123;  </span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">  </span><br><span class="line">error_remove_epi:  </span><br><span class="line">    spin_lock(&amp;tfile-&gt;f_lock);  </span><br><span class="line">    // 删除文件上的 epi  </span><br><span class="line">    if (ep_is_linked(&amp;epi-&gt;fllink)) &#123;  </span><br><span class="line">        list_del_init(&amp;epi-&gt;fllink);  </span><br><span class="line">    &#125;  </span><br><span class="line">    spin_unlock(&amp;tfile-&gt;f_lock);  </span><br><span class="line">  </span><br><span class="line">    // 从红黑树中删除  </span><br><span class="line">    rb_erase(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr);  </span><br><span class="line">  </span><br><span class="line">error_unregister:  </span><br><span class="line">    // 从文件的wait_queue 中删除, 释放epitem 关联的所有eppoll_entry  </span><br><span class="line">    ep_unregister_pollwait(ep, epi);  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * We need to do this because an event could have been arrived on some </span><br><span class="line">     * allocated wait queue. Note that we don&apos;t care about the ep-&gt;ovflist </span><br><span class="line">     * list, since that is used/cleaned only inside a section bound by &quot;mtx&quot;. </span><br><span class="line">     * And ep_insert() is called with &quot;mtx&quot; held. </span><br><span class="line">     */  </span><br><span class="line">    // TODO:  </span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);  </span><br><span class="line">    if (ep_is_linked(&amp;epi-&gt;rdllink)) &#123;  </span><br><span class="line">        list_del_init(&amp;epi-&gt;rdllink);  </span><br><span class="line">    &#125;  </span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);  </span><br><span class="line">  </span><br><span class="line">    // 释放epi  </span><br><span class="line">    kmem_cache_free(epi_cache, epi);  </span><br><span class="line">  </span><br><span class="line">    return error;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EPOLL-CTL-DEL"><a href="#EPOLL-CTL-DEL" class="headerlink" title="EPOLL_CTL_DEL"></a>EPOLL_CTL_DEL</h3><p>EPOLL_CTL_DEL 的实现调用的是 ep_remove 函数，函数只是清除ADD时， 添加的各种结构，EPOLL_CTL_MOD 的实现调用的是ep_modify，在ep_modify中用新的事件掩码调用f_ops-&gt;poll，检测事件是否已可用，如果可用就直接唤醒epoll，这两个的实现与EPOLL_CTL_ADD 类似，代码上比较清晰，这里就不具体分析了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static int ep_remove(struct eventpoll *ep, struct epitem *epi)  </span><br><span class="line">&#123;  </span><br><span class="line">    unsigned long flags;  </span><br><span class="line">    struct file *file = epi-&gt;ffd.file;  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * Removes poll wait queue hooks. We _have_ to do this without holding </span><br><span class="line">     * the &quot;ep-&gt;lock&quot; otherwise a deadlock might occur. This because of the </span><br><span class="line">     * sequence of the lock acquisition. Here we do &quot;ep-&gt;lock&quot; then the wait </span><br><span class="line">     * queue head lock when unregistering the wait queue. The wakeup callback </span><br><span class="line">     * will run by holding the wait queue head lock and will call our callback </span><br><span class="line">     * that will try to get &quot;ep-&gt;lock&quot;. </span><br><span class="line">     */  </span><br><span class="line">    ep_unregister_pollwait(ep, epi);  </span><br><span class="line">  </span><br><span class="line">    /* Remove the current item from the list of epoll hooks */  </span><br><span class="line">    spin_lock(&amp;file-&gt;f_lock);  </span><br><span class="line">    if (ep_is_linked(&amp;epi-&gt;fllink))  </span><br><span class="line">        list_del_init(&amp;epi-&gt;fllink);  </span><br><span class="line">    spin_unlock(&amp;file-&gt;f_lock);  </span><br><span class="line">  </span><br><span class="line">    rb_erase(&amp;epi-&gt;rbn, &amp;ep-&gt;rbr);  </span><br><span class="line">  </span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);  </span><br><span class="line">    if (ep_is_linked(&amp;epi-&gt;rdllink))  </span><br><span class="line">        list_del_init(&amp;epi-&gt;rdllink);  </span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);  </span><br><span class="line">  </span><br><span class="line">    /* At this point it is safe to free the eventpoll item */  </span><br><span class="line">    kmem_cache_free(epi_cache, epi);  </span><br><span class="line">  </span><br><span class="line">    atomic_long_dec(&amp;ep-&gt;user-&gt;epoll_watches);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * Modify the interest event mask by dropping an event if the new mask </span><br><span class="line"> * has a match in the current file status. Must be called with &quot;mtx&quot; held. </span><br><span class="line"> */  </span><br><span class="line">static int ep_modify(struct eventpoll *ep, struct epitem *epi, struct epoll_event *event)  </span><br><span class="line">&#123;  </span><br><span class="line">    int pwake = 0;  </span><br><span class="line">    unsigned int revents;  </span><br><span class="line">    poll_table pt;  </span><br><span class="line">  </span><br><span class="line">    init_poll_funcptr(&amp;pt, NULL);  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * Set the new event interest mask before calling f_op-&gt;poll(); </span><br><span class="line">     * otherwise we might miss an event that happens between the </span><br><span class="line">     * f_op-&gt;poll() call and the new event set registering. </span><br><span class="line">     */  </span><br><span class="line">    epi-&gt;event.events = event-&gt;events;  </span><br><span class="line">    pt._key = event-&gt;events;  </span><br><span class="line">    epi-&gt;event.data = event-&gt;data; /* protected by mtx */  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * Get current event bits. We can safely use the file* here because </span><br><span class="line">     * its usage count has been increased by the caller of this function. </span><br><span class="line">     */  </span><br><span class="line">    revents = epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, &amp;pt);  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * If the item is &quot;hot&quot; and it is not registered inside the ready </span><br><span class="line">     * list, push it inside. </span><br><span class="line">     */  </span><br><span class="line">    if (revents &amp; event-&gt;events) &#123;  </span><br><span class="line">        spin_lock_irq(&amp;ep-&gt;lock);  </span><br><span class="line">        if (!ep_is_linked(&amp;epi-&gt;rdllink)) &#123;  </span><br><span class="line">            list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);  </span><br><span class="line">  </span><br><span class="line">            /* Notify waiting tasks that events are available */  </span><br><span class="line">            if (waitqueue_active(&amp;ep-&gt;wq))  </span><br><span class="line">                wake_up_locked(&amp;ep-&gt;wq);  </span><br><span class="line">            if (waitqueue_active(&amp;ep-&gt;poll_wait))  </span><br><span class="line">                pwake++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        spin_unlock_irq(&amp;ep-&gt;lock);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* We have to call this outside the lock */  </span><br><span class="line">    if (pwake)  </span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">epoll_wait实现 </span><br><span class="line">*/  </span><br><span class="line">  </span><br><span class="line">SYSCALL_DEFINE4(epoll_wait, int, epfd, struct epoll_event __user *, events,  </span><br><span class="line">                int, maxevents, int, timeout)  </span><br><span class="line">&#123;  </span><br><span class="line">    int error;  </span><br><span class="line">    struct file *file;  </span><br><span class="line">    struct eventpoll *ep;  </span><br><span class="line">  </span><br><span class="line">    // 检查输入数据有效性  </span><br><span class="line">    if (maxevents &lt;= 0 || maxevents &gt; EP_MAX_EVENTS) &#123;  </span><br><span class="line">        return -EINVAL;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    if (!access_ok(VERIFY_WRITE, events, maxevents * sizeof(struct epoll_event))) &#123;  </span><br><span class="line">        error = -EFAULT;  </span><br><span class="line">        goto error_return;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /* Get the &quot;struct file *&quot; for the eventpoll file */  </span><br><span class="line">    error = -EBADF;  </span><br><span class="line">    file = fget(epfd);  </span><br><span class="line">    if (!file) &#123;  </span><br><span class="line">        goto error_return;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    error = -EINVAL;  </span><br><span class="line">    if (!is_file_epoll(file)) &#123;  </span><br><span class="line">        goto error_fput;  </span><br><span class="line">    &#125;  </span><br><span class="line">    // 取得ep 结构  </span><br><span class="line">    ep = file-&gt;private_data;  </span><br><span class="line">  </span><br><span class="line">    // 等待事件  </span><br><span class="line">    error = ep_poll(ep, events, maxevents, timeout);  </span><br><span class="line">  </span><br><span class="line">error_fput:  </span><br><span class="line">    fput(file);  </span><br><span class="line">error_return:  </span><br><span class="line">  </span><br><span class="line">    return error;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,  </span><br><span class="line">                   int maxevents, long timeout)  </span><br><span class="line">&#123;  </span><br><span class="line">    int res = 0, eavail, timed_out = 0;  </span><br><span class="line">    unsigned long flags;  </span><br><span class="line">    long slack = 0;  </span><br><span class="line">    wait_queue_t wait;  </span><br><span class="line">    ktime_t expires, *to = NULL;  </span><br><span class="line">  </span><br><span class="line">    if (timeout &gt; 0) &#123;  </span><br><span class="line">        // 转换为内核时间  </span><br><span class="line">        struct timespec end_time = ep_set_mstimeout(timeout);  </span><br><span class="line">  </span><br><span class="line">        slack = select_estimate_accuracy(&amp;end_time);  </span><br><span class="line">        to = &amp;expires;  </span><br><span class="line">        *to = timespec_to_ktime(end_time);  </span><br><span class="line">    &#125; else if (timeout == 0) &#123;  </span><br><span class="line">        // 已经超时直接检查readylist  </span><br><span class="line">        timed_out = 1;  </span><br><span class="line">        spin_lock_irqsave(&amp;ep-&gt;lock, flags);  </span><br><span class="line">        goto check_events;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">fetch_events:  </span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);  </span><br><span class="line">  </span><br><span class="line">    // 没有可用的事件，ready list 和ovflist 都为空  </span><br><span class="line">    if (!ep_events_available(ep)) &#123;  </span><br><span class="line">  </span><br><span class="line">        // 添加当前进程的唤醒函数  </span><br><span class="line">        init_waitqueue_entry(&amp;wait, current);  </span><br><span class="line">        __add_wait_queue_exclusive(&amp;ep-&gt;wq, &amp;wait);  </span><br><span class="line">  </span><br><span class="line">        for (;;) &#123;  </span><br><span class="line">            /* </span><br><span class="line">             * We don&apos;t want to sleep if the ep_poll_callback() sends us </span><br><span class="line">             * a wakeup in between. That&apos;s why we set the task state </span><br><span class="line">             * to TASK_INTERRUPTIBLE before doing the checks. </span><br><span class="line">             */  </span><br><span class="line">            set_current_state(TASK_INTERRUPTIBLE);  </span><br><span class="line">            if (ep_events_available(ep) || timed_out) &#123;  </span><br><span class="line">                break;  </span><br><span class="line">            &#125;  </span><br><span class="line">            if (signal_pending(current)) &#123;  </span><br><span class="line">                res = -EINTR;  </span><br><span class="line">                break;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);  </span><br><span class="line">            // 挂起当前进程，等待唤醒或超时  </span><br><span class="line">            if (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS)) &#123;  </span><br><span class="line">                timed_out = 1;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            spin_lock_irqsave(&amp;ep-&gt;lock, flags);  </span><br><span class="line">        &#125;  </span><br><span class="line">      </span><br><span class="line">        __remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);  </span><br><span class="line">  </span><br><span class="line">        set_current_state(TASK_RUNNING);  </span><br><span class="line">    &#125;  </span><br><span class="line">check_events:  </span><br><span class="line">    // 再次检查是否有可用事件  </span><br><span class="line">    eavail = ep_events_available(ep);  </span><br><span class="line">  </span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * Try to transfer events to user space. In case we get 0 events and </span><br><span class="line">     * there&apos;s still timeout left over, we go trying again in search of </span><br><span class="line">     * more luck. </span><br><span class="line">     */  </span><br><span class="line">    if (!res &amp;&amp; eavail   </span><br><span class="line">            &amp;&amp; !(res = ep_send_events(ep, events, maxevents)) // 复制事件到用户空间  </span><br><span class="line">            &amp;&amp; !timed_out) // 复制事件失败并且没有超时，重新等待。  </span><br><span class="line">            &#123;  </span><br><span class="line">        goto fetch_events;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return res;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">static inline int ep_events_available(struct eventpoll *ep)  </span><br><span class="line">&#123;  </span><br><span class="line">    return !list_empty(&amp;ep-&gt;rdllist) || ep-&gt;ovflist != EP_UNACTIVE_PTR;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">struct ep_send_events_data &#123;  </span><br><span class="line">    int maxevents;  </span><br><span class="line">    struct epoll_event __user *events;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">static int ep_send_events(struct eventpoll *ep,  </span><br><span class="line">                          struct epoll_event __user *events, int maxevents)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct ep_send_events_data esed;  </span><br><span class="line">  </span><br><span class="line">    esed.maxevents = maxevents;  </span><br><span class="line">    esed.events = events;  </span><br><span class="line">  </span><br><span class="line">    return ep_scan_ready_list(ep, ep_send_events_proc, &amp;esed, 0);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">static int ep_send_events_proc(struct eventpoll *ep, struct list_head *head,  </span><br><span class="line">                               void *priv)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct ep_send_events_data *esed = priv;  </span><br><span class="line">    int eventcnt;  </span><br><span class="line">    unsigned int revents;  </span><br><span class="line">    struct epitem *epi;  </span><br><span class="line">    struct epoll_event __user *uevent;  </span><br><span class="line">  </span><br><span class="line">    // 遍历已就绪链表  </span><br><span class="line">    for (eventcnt = 0, uevent = esed-&gt;events;  </span><br><span class="line">            !list_empty(head) &amp;&amp; eventcnt &lt; esed-&gt;maxevents;) &#123;  </span><br><span class="line">        epi = list_first_entry(head, struct epitem, rdllink);  </span><br><span class="line">  </span><br><span class="line">        list_del_init(&amp;epi-&gt;rdllink);  </span><br><span class="line">        // 获取ready 事件掩码  </span><br><span class="line">        revents = epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, NULL) &amp;  </span><br><span class="line">                  epi-&gt;event.events;  </span><br><span class="line">  </span><br><span class="line">        /* </span><br><span class="line">         * If the event mask intersect the caller-requested one, </span><br><span class="line">         * deliver the event to userspace. Again, ep_scan_ready_list() </span><br><span class="line">         * is holding &quot;mtx&quot;, so no operations coming from userspace </span><br><span class="line">         * can change the item. </span><br><span class="line">         */  </span><br><span class="line">        if (revents) &#123;  </span><br><span class="line">            // 事件就绪, 复制到用户空间  </span><br><span class="line">            if (__put_user(revents, &amp;uevent-&gt;events) ||  </span><br><span class="line">                    __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) &#123;  </span><br><span class="line">                list_add(&amp;epi-&gt;rdllink, head);  </span><br><span class="line">                return eventcnt ? eventcnt : -EFAULT;  </span><br><span class="line">            &#125;  </span><br><span class="line">            eventcnt++;  </span><br><span class="line">            uevent++;  </span><br><span class="line">            if (epi-&gt;event.events &amp; EPOLLONESHOT) &#123;  </span><br><span class="line">                epi-&gt;event.events &amp;= EP_PRIVATE_BITS;  </span><br><span class="line">            &#125; else if (!(epi-&gt;event.events &amp; EPOLLET)) &#123;  </span><br><span class="line">                // 不是边缘模式, 再次添加到ready list,  </span><br><span class="line">                // 下次epoll_wait 时直接进入此函数检查ready list是否仍然继续  </span><br><span class="line">                list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);  </span><br><span class="line">            &#125;  </span><br><span class="line">            // 如果是边缘模式, 只有当文件状态发生改变时,  </span><br><span class="line">            // 才文件会再次触发wait_address 上wait_queue的回调函数,  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return eventcnt;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="eventpoll-poll"><a href="#eventpoll-poll" class="headerlink" title="eventpoll_poll"></a>eventpoll_poll</h2><p> 由于epoll自身也是文件系统，其描述符也可以被poll/select/epoll监视，因此需要实现poll方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">static const struct file_operations eventpoll_fops = &#123;  </span><br><span class="line">    .release = ep_eventpoll_release,  </span><br><span class="line">    .poll    = ep_eventpoll_poll,  </span><br><span class="line">    .llseek  = noop_llseek,  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">static unsigned int ep_eventpoll_poll(struct file *file, poll_table *wait)  </span><br><span class="line">&#123;  </span><br><span class="line">    int pollflags;  </span><br><span class="line">    struct eventpoll *ep = file-&gt;private_data;  </span><br><span class="line">    // 插入到wait_queue  </span><br><span class="line">    poll_wait(file, &amp;ep-&gt;poll_wait, wait);  </span><br><span class="line">    // 扫描就绪的文件列表, 调用每个文件上的poll 检测是否真的就绪,  </span><br><span class="line">    // 然后复制到用户空间  </span><br><span class="line">    // 文件列表中有可能有epoll文件, 调用poll的时候有可能会产生递归,  </span><br><span class="line">    // 调用所以用ep_call_nested 包装一下, 防止死循环和过深的调用  </span><br><span class="line">    pollflags = ep_call_nested(&amp;poll_readywalk_ncalls, EP_MAX_NESTS,  </span><br><span class="line">                               ep_poll_readyevents_proc, ep, ep, current);  </span><br><span class="line">    // static struct nested_calls poll_readywalk_ncalls;  </span><br><span class="line">    return pollflags != -1 ? pollflags : 0;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">static int ep_poll_readyevents_proc(void *priv, void *cookie, int call_nests)  </span><br><span class="line">&#123;  </span><br><span class="line">    return ep_scan_ready_list(priv, ep_read_events_proc, NULL, call_nests + 1);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">static int ep_scan_ready_list(struct eventpoll *ep,  </span><br><span class="line">                              int (*sproc)(struct eventpoll *,  </span><br><span class="line">                                      struct list_head *, void *),  </span><br><span class="line">                              void *priv,  </span><br><span class="line">                              int depth)  </span><br><span class="line">&#123;  </span><br><span class="line">    int error, pwake = 0;  </span><br><span class="line">    unsigned long flags;  </span><br><span class="line">    struct epitem *epi, *nepi;  </span><br><span class="line">    LIST_HEAD(txlist);  </span><br><span class="line">  </span><br><span class="line">    /* </span><br><span class="line">     * We need to lock this because we could be hit by </span><br><span class="line">     * eventpoll_release_file() and epoll_ctl(). </span><br><span class="line">     */  </span><br><span class="line">    mutex_lock_nested(&amp;ep-&gt;mtx, depth);  </span><br><span class="line">  </span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);  </span><br><span class="line">    // 移动rdllist 到新的链表txlist  </span><br><span class="line">    list_splice_init(&amp;ep-&gt;rdllist, &amp;txlist);  </span><br><span class="line">    // 改变ovflist 的状态, 如果ep-&gt;ovflist != EP_UNACTIVE_PTR,  </span><br><span class="line">    // 当文件激活wait_queue时，就会将对应的epitem加入到ep-&gt;ovflist  </span><br><span class="line">    // 否则将文件直接加入到ep-&gt;rdllist，  </span><br><span class="line">    // 这样做的目的是避免丢失事件  </span><br><span class="line">    // 这里不需要检查ep-&gt;ovflist 的状态，因为ep-&gt;mtx的存在保证此处的ep-&gt;ovflist  </span><br><span class="line">    // 一定是EP_UNACTIVE_PTR  </span><br><span class="line">    ep-&gt;ovflist = NULL;  </span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);  </span><br><span class="line">  </span><br><span class="line">    // 调用扫描函数处理txlist  </span><br><span class="line">    error = (*sproc)(ep, &amp;txlist, priv);  </span><br><span class="line">  </span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);  </span><br><span class="line">  </span><br><span class="line">    // 调用 sproc 时可能有新的事件，遍历这些新的事件将其插入到ready list  </span><br><span class="line">    for (nepi = ep-&gt;ovflist; (epi = nepi) != NULL;  </span><br><span class="line">            nepi = epi-&gt;next, epi-&gt;next = EP_UNACTIVE_PTR) &#123;  </span><br><span class="line">        // #define EP_UNACTIVE_PTR (void *) -1  </span><br><span class="line">        // epi 不在rdllist, 插入  </span><br><span class="line">        if (!ep_is_linked(&amp;epi-&gt;rdllink)) &#123;  </span><br><span class="line">            list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    // 还原ep-&gt;ovflist的状态  </span><br><span class="line">    ep-&gt;ovflist = EP_UNACTIVE_PTR;  </span><br><span class="line">  </span><br><span class="line">    // 将处理后的 txlist 链接到 rdllist  </span><br><span class="line">    list_splice(&amp;txlist, &amp;ep-&gt;rdllist);  </span><br><span class="line">  </span><br><span class="line">    if (!list_empty(&amp;ep-&gt;rdllist)) &#123;  </span><br><span class="line">        // 唤醒epoll_wait  </span><br><span class="line">        if (waitqueue_active(&amp;ep-&gt;wq)) &#123;  </span><br><span class="line">            wake_up_locked(&amp;ep-&gt;wq);  </span><br><span class="line">        &#125;  </span><br><span class="line">        // 当前的ep有其他的事件通知机制监控  </span><br><span class="line">        if (waitqueue_active(&amp;ep-&gt;poll_wait)) &#123;  </span><br><span class="line">            pwake++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);  </span><br><span class="line">  </span><br><span class="line">    mutex_unlock(&amp;ep-&gt;mtx);  </span><br><span class="line">  </span><br><span class="line">    if (pwake) &#123;  </span><br><span class="line">        // 安全唤醒外部的事件通知机制  </span><br><span class="line">        ep_poll_safewake(&amp;ep-&gt;poll_wait);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    return error;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">static int ep_read_events_proc(struct eventpoll *ep, struct list_head *head,  </span><br><span class="line">                               void *priv)  </span><br><span class="line">&#123;  </span><br><span class="line">    struct epitem *epi, *tmp;  </span><br><span class="line">    poll_table pt;  </span><br><span class="line">    init_poll_funcptr(&amp;pt, NULL);  </span><br><span class="line">    list_for_each_entry_safe(epi, tmp, head, rdllink) &#123;  </span><br><span class="line">        pt._key = epi-&gt;event.events;  </span><br><span class="line">        if (epi-&gt;ffd.file-&gt;f_op-&gt;poll(epi-&gt;ffd.file, &amp;pt) &amp;  </span><br><span class="line">                epi-&gt;event.events) &#123;  </span><br><span class="line">            return POLLIN | POLLRDNORM;  </span><br><span class="line">        &#125; else &#123;  </span><br><span class="line">             // 这个事件虽然在就绪列表中,  </span><br><span class="line">             // 但是实际上并没有就绪, 将他移除  </span><br><span class="line">         // 这有可能是水平触发模式中没有将文件从就绪列表中移除  </span><br><span class="line">         // 也可能是事件插入到就绪列表后有其他的线程对文件进行了操作  </span><br><span class="line">            list_del_init(&amp;epi-&gt;rdllink);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="epoll全景"><a href="#epoll全景" class="headerlink" title="epoll全景"></a>epoll全景</h2><p>以下是epoll使用的全部数据结构之间的关系图，采用的是一种类UML图，希望对理解epoll的内部实现有所帮助。<br><img src="/img/7a411842-3615-3c89-aee0-3f5cfb36a044.bmp" alt></p>
<h1 id="poll-select-epoll-对比"><a href="#poll-select-epoll-对比" class="headerlink" title="poll/select/epoll 对比"></a>poll/select/epoll 对比</h1><p>通过以上的分析可以看出，poll和select的实现基本是一致，只是用户到内核传递的数据格式有所不同，</p>
<p>select和poll即使只有一个描述符就绪，也要遍历整个集合。如果集合中活跃的描述符很少，遍历过程的开销就会变得很大，而如果集合中大部分的描述符都是活跃的，遍历过程的开销又可以忽略。</p>
<p>epoll的实现中每次只遍历活跃的描述符(如果是水平触发，也会遍历先前活跃的描述符)，在活跃描述符较少的情况下就会很有优势，在代码的分析过程中可以看到epoll的实现过于复杂并且其实现过程中需要同步处理(锁)，如果大部分描述符都是活跃的，epoll的效率可能不如select或poll。(参见epoll 和poll的性能测试 <a href="http://jacquesmattheij.com/Poll+vs+Epoll+once+again" target="_blank" rel="noopener">http://jacquesmattheij.com/Poll+vs+Epoll+once+again</a>)</p>
<p>select能够处理的最大fd无法超出FDSETSIZE。</p>
<p>select会复写传入的fd_set 指针，而poll对每个fd返回一个掩码，不更改原来的掩码，从而可以对同一个集合多次调用poll，而无需调整。</p>
<p>select对每个文件描述符最多使用3个bit，而poll采用的pollfd需要使用64个bit，epoll采用的 epoll_event则需要96个bit</p>
<p>如果事件需要循环处理select, poll 每一次的处理都要将全部的数据复制到内核，而epoll的实现中，内核将持久维护加入的描述符，减少了内核和用户复制数据的开销。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/12/select_poll_epoll之间的区别总结[整理]/" rel="next" title="select、poll、epoll之间的区别总结[整理]">
                <i class="fa fa-chevron-left"></i> select、poll、epoll之间的区别总结[整理]
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/17/Linux信号机制分析/" rel="prev" title="Linux信号（signal) 机制分析">
                Linux信号（signal) 机制分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">256</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#poll-和-select"><span class="nav-number">1.</span> <span class="nav-text">poll 和 select</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#关键结构体"><span class="nav-number">1.1.</span> <span class="nav-text">关键结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#公共函数"><span class="nav-number">1.2.</span> <span class="nav-text">公共函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#poll-select核心结构关系"><span class="nav-number">1.3.</span> <span class="nav-text">poll/select核心结构关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#poll的实现"><span class="nav-number">2.</span> <span class="nav-text">poll的实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#select-实现"><span class="nav-number">3.</span> <span class="nav-text">select 实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#epoll实现"><span class="nav-number">4.</span> <span class="nav-text">epoll实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll的核心数据结构"><span class="nav-number">4.1.</span> <span class="nav-text">epoll的核心数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统初始化和epoll-create"><span class="nav-number">4.2.</span> <span class="nav-text">文件系统初始化和epoll_create</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll中的递归死循环和深度检查"><span class="nav-number">4.3.</span> <span class="nav-text">epoll中的递归死循环和深度检查</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归深度检测-ep-call-nested"><span class="nav-number">4.3.1.</span> <span class="nav-text">递归深度检测(ep_call_nested)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环检测-ep-loop-check"><span class="nav-number">4.3.2.</span> <span class="nav-text">循环检测(ep_loop_check)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#唤醒风暴检测（reverse-path-check）"><span class="nav-number">4.3.3.</span> <span class="nav-text">唤醒风暴检测（reverse_path_check）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll-的唤醒过程"><span class="nav-number">4.4.</span> <span class="nav-text">epoll 的唤醒过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll-ctl"><span class="nav-number">4.5.</span> <span class="nav-text">epoll_ctl</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#EPOLL-CTL-ADD-实现"><span class="nav-number">4.5.1.</span> <span class="nav-text">EPOLL_CTL_ADD 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EPOLL-CTL-DEL"><span class="nav-number">4.5.2.</span> <span class="nav-text">EPOLL_CTL_DEL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll-wait"><span class="nav-number">4.6.</span> <span class="nav-text">epoll_wait</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#eventpoll-poll"><span class="nav-number">4.7.</span> <span class="nav-text">eventpoll_poll</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll全景"><span class="nav-number">4.8.</span> <span class="nav-text">epoll全景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#poll-select-epoll-对比"><span class="nav-number">5.</span> <span class="nav-text">poll/select/epoll 对比</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
