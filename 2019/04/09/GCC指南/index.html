<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux,">










<meta name="description" content="Glibc 安装指南(2.6.1 → 2.9)安装信息的来源http://www.gnu.org/software/libc/manual/html_node/System-Configuration.htmlhttp://www.gnu.org/software/libc/manual/html_node/Installation.htmlhttp://www.gnu.org/software/">
<meta name="keywords" content="Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="GCC指南">
<meta property="og:url" content="http://yoursite.com/2019/04/09/GCC指南/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Glibc 安装指南(2.6.1 → 2.9)安装信息的来源http://www.gnu.org/software/libc/manual/html_node/System-Configuration.htmlhttp://www.gnu.org/software/libc/manual/html_node/Installation.htmlhttp://www.gnu.org/software/">
<meta property="og:locale" content="zn-ch">
<meta property="og:updated_time" content="2022-10-01T03:57:46.229Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GCC指南">
<meta name="twitter:description" content="Glibc 安装指南(2.6.1 → 2.9)安装信息的来源http://www.gnu.org/software/libc/manual/html_node/System-Configuration.htmlhttp://www.gnu.org/software/libc/manual/html_node/Installation.htmlhttp://www.gnu.org/software/">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/04/09/GCC指南/">





  <title>GCC指南 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/09/GCC指南/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">GCC指南</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-09T19:45:03+08:00">
                2019-04-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Glibc-安装指南-2-6-1-→-2-9"><a href="#Glibc-安装指南-2-6-1-→-2-9" class="headerlink" title="Glibc 安装指南(2.6.1 → 2.9)"></a>Glibc 安装指南(2.6.1 → 2.9)</h1><h2 id="安装信息的来源"><a href="#安装信息的来源" class="headerlink" title="安装信息的来源"></a>安装信息的来源</h2><p><a href="http://www.gnu.org/software/libc/manual/html_node/System-Configuration.html" target="_blank" rel="noopener">http://www.gnu.org/software/libc/manual/html_node/System-Configuration.html</a><br><a href="http://www.gnu.org/software/libc/manual/html_node/Installation.html" target="_blank" rel="noopener">http://www.gnu.org/software/libc/manual/html_node/Installation.html</a><br><a href="http://www.gnu.org/software/libc/manual/html_node/Name-Service-Switch.html" target="_blank" rel="noopener">http://www.gnu.org/software/libc/manual/html_node/Name-Service-Switch.html</a></p>
<h2 id="要点提示"><a href="#要点提示" class="headerlink" title="要点提示"></a>要点提示</h2><p>编译Glibc的时候应该尽可能使用最新的内核头文件，至少要使用 2.6.16 以上版本的内核，先前的版本有一些缺陷会导致”make check”时一些与pthreads测试相关的项目失败。使用高版本内核头文件编译的Glibc二进制文件完全可以运行在较低版本的内核上，并且当你升级内核后新内核的特性仍然可以得到充分发挥而无需重新编译Glibc。但是如果编译时使用的头文件的版本较低，那么运行在更高版本的内核上时，新内核的特性就不能得到充分发挥。更多细节可以查看[八卦故事]内核头文件传奇的跟帖部分。</p>
<p>推荐使用GCC-4.1以上的版本编译，老版本的GCC可能会生成有缺陷的代码。</p>
<p>不要在运行中的系统上安装 Glibc，否则将会导致系统崩溃，至少应当将新 Glibc 安装到其他的单独目录，以保证不覆盖当前正在使用的 Glibc 。</p>
<p>Glibc 不能在源码目录中编译，它必须在一个额外分开的目录中编译。这样在编译发生错误的时候，就可以删除整个编译目录重新开始。</p>
<p>源码树下的Makeconfig文件中有许多用于特定目的的变量，你可以在编译目录下创建一个configparms文件来改写这些变量。执行make命令的时候configparms文件中的内容将会按照Makefile规则进行解析。比如可以通过在其中设置 CFLAGS LDFLAGS 环境变量来优化编译，设置 CC BUILD_CC AR RANLIB 来指定交叉编译环境。</p>
<p>需要注意的是有些测试项目假定是以非 root 身份执行的，因此我们强烈建议你使用非 root 身份编译和测试 Glibc 。</p>
<p>配置选项<br>下列选项皆为非默认值[特别说明的除外]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">--help</span><br><span class="line">--version</span><br><span class="line">--quiet</span><br><span class="line">--config-cache</span><br><span class="line">--no-create</span><br><span class="line">--srcdir=DIR</span><br><span class="line">--exec-prefix=EPREFIX</span><br><span class="line">--bindir=DIR</span><br><span class="line">--sbindir=DIR</span><br><span class="line">--libexecdir=DIR</span><br><span class="line">--sysconfdir=DIR</span><br><span class="line">--sharedstatedir=DIR</span><br><span class="line">--localstatedir=DIR</span><br><span class="line">--libdir=DIR</span><br><span class="line">--includedir=DIR</span><br><span class="line">--oldincludedir=DIR</span><br><span class="line">--datarootdir=DIR</span><br><span class="line">--datadir=DIR</span><br><span class="line">--infodir=DIR</span><br><span class="line">--localedir=DIR</span><br><span class="line">--mandir=DIR</span><br><span class="line">--docdir=DIR</span><br><span class="line">--htmldir=DIR</span><br><span class="line">--dvidir=DIR</span><br><span class="line">--pdfdir=DIR</span><br><span class="line">--psdir=DIR</span><br><span class="line">--build=BUILD</span><br><span class="line">--host=HOST</span><br></pre></td></tr></table></figure></p>
<p>这些选项的含义基本上通用于所有软件包，这里就不特别讲解了。需要注意的是：没有—target=TARGET选项。</p>
<p>—prefix=PREFIX<br>安装目录，默认为 /usr/local。Linux文件系统标准要求基本库必须位于 /lib 目录并且必须与根目录在同一个分区上，但是 /usr 可以在其他分区甚至是其他磁盘上。因此，如果在Linux平台上指定 —prefix=/usr ，那么基本库部分将自动安装到 /lib 目录下，而非基本库部分则会自动安装到 /usr/lib 目录中，同时将使用 /etc 作为配置目录，也就是等价于”slibdir=/lib sysconfdir=/etc”。但是如果保持默认值或指定其他目录，那么所有组件都间被安装到PREFIX目录下。</p>
<p>—disable-sanity-checks<br>真正禁用线程(仅在特殊环境下使用该选项)。</p>
<p>—enable-check-abi<br>在”make check”时执行”make check-abi”。[提示]在我的机器上始终导致check-abi-libm测试失败。</p>
<p>—disable-shared<br>不编译共享库(即使平台支持)。在支持 ELF 并且使用 GNU 连接器的系统上默认为enable 。[提示] —disable-static 选项实际上是不存在的，静态库总是被无条件的编译和安装。</p>
<p>—enable-profile<br>启用 profiling 信息相关的库文件编译。主要用于调试目的。</p>
<p>—enable-omitfp<br>编译时忽略帧指示器(使用 -fomit-frame-pointer 编译)，并采取一些其他优化措施。忽略帧指示器可以提高运行效率，但是调试将变得不可用，并且可能生成含有 bug 的代码。使用这个选项还将导致额外编译带有调试信息的非优化版本的静态库(库名称以”_g”结尾)。</p>
<p>—enable-bounded<br>启用运行时边界检查(比如数组越界)，这样会降低运行效率，但能防止某些溢出漏洞。</p>
<p>—disable-versioning<br>不在共享库对象中包含符号的版本信息。这样可以减小库的体积，但是将不兼容依赖于老版本 C 库的二进制程序。[提示]在我的机器上使用此选项总是导致编译失败。</p>
<p>—enable-oldest-abi=ABI<br>启用老版本的应用程序二进制接口支持。ABI是Glibc的版本号，只有明确指定版本号时此选项才有效。</p>
<p>—enable-stackguard-randomization<br>在程序启动时使用一个随机数初始化 __stack_chk_guard ，主要用来抵抗恶意攻击。</p>
<p>—enable-add-ons[=DIRS…]<br>为了减小软件包的复杂性，一些可选的libc特性被以单独的软件包发布，比如’linuxthreads’(现在已经被废弃了)，他们被称为’add-ons’。要使用这些额外的包，可以将他们解压到Glibc的源码树根目录下，然后使用此选项将DIR1,DIR2,…中的附加软件包包含进来。其中的”DIR”是附加软件包的目录名。默认值”yes”表示编译所有源码树根目录下找到的附加软件包。</p>
<p>—disable-hidden-plt<br>默认情况下隐藏仅供内部调用的函数，以避免这些函数被加入到过程链接表(PLT,Procedure Linkage Table)中，这样可以减小 PLT 的体积并将仅供内部使用的函数隐藏起来。而使用该选项将把这些函数暴露给外部用户。</p>
<p>—enable-bind-now<br>禁用”lazy binding”，也就是动态连接器在载入 DSO 时就解析所有符号(不管应用程序是否用得到)，默认行为是”lazy binding”，也就是仅在应用程序首次使用到的时候才对符号进行解析。因为在大多数情况下，应用程序并不需要使用动态库中的所有符号，所以默认的 “lazy binding”可以提高应用程序的加载性能并节约内存用量。然而，在两种情况下，”lazy binding”是不利的：①因为第一次调用DSO中的函数时，动态连接器要先拦截该调用来解析符号，所以初次引用DSO中的函数所花的时间比再次调用要花的时间长，但是某些应用程序不能容忍这种不可预知性。②如果一个错误发生并且动态连接器不能解析该符号，动态连接器将终止整个程序。在”lazy binding”方式下，这种情况可能发生在程序运行过程中的某个时候。某些应用程序也是不能容忍这种不可预知性的。通过关掉”lazy binding”方式，在应用程序接受控制权之前，让动态连接器在处理进程初始化期间就发现这些错误，而不要到运行时才出乱子。</p>
<p>—enable-static-nss<br>编译静态版本的NSS(Name Service Switch)库。仅在/etc/nsswitch.conf中只使用dns和files的情况下，NSS才能编译成静态库，并且你还需要在静态编译应用程序的时候明确的连接所有与NSS库相关的库才行[比如：gcc -static test.c -o test -Wl,-lc,-lnss_files,-lnss_dns,-lresolv]。不推荐使用此选项，因为连接到静态NSS库的程序不能动态配置以使用不同的名字数据库。</p>
<p>—disable-force-install<br>不强制安装当前新编译的版本(即使已存在的文件版本更新)。</p>
<p>—enable-kernel=VERSION<br>VERSION 的格式是 X.Y.Z，表示编译出来的 Glibc 支持的最低内核版本。VERSION 的值越高(不能超过内核头文件的版本)，加入的兼容性代码就越少，库的运行速度就越快。</p>
<p>—enable-all-warnings<br>在编译时显示所有编译器警告，也就是使用 -Wall 选项编译。</p>
<p>—with-gd<br>—with-gd-include</p>
<p>—with-gd-lib<br>指定libgd的安装目录(DIR/include和DIR/lib)。后两个选项分别指定包含文件和库目录。</p>
<p>—without-fp<br>仅在硬件没有浮点运算单元并且操作系统没有模拟的情况下使用。x86 与 x86_64 的 CPU 都有专门的浮点运算单元。而且 Linux 有 FPU 模拟。简单的说，不要 without 这个选项！因为它会导致许多问题！</p>
<p>—with-binutils=DIR<br>明确指定编译时使用的Binutils(as,ld)所在目录。</p>
<p>—with-elf<br>指定使用 ELF 对象格式，默认不使用。建议在支持 ELF 的 Linux 平台上明确指定此选项。</p>
<p>—with-selinux<br>—without-selinux<br>启用/禁用 SELinux 支持，默认值自动检测。</p>
<p>—with-xcoff<br>使用XCOFF对象格式(主要用于windows)。</p>
<p>—without-cvs<br>不访问CVS服务器。推荐使用该选项，特别对于从CVS下载的的版本。</p>
<p>—with-headers=DIR<br>指定内核头文件的所在目录，在Linux平台上默认是’/usr/include’。</p>
<p>—without-tls<br>禁止编译支持线程本地存储(TLS)的库。使用这个选项将导致兼容性问题。</p>
<p>—without-__thread<br>即使平台支持也不使用TSL特性。建议不要使用该选项。</p>
<p>—with-cpu=CPU<br>在 gcc 命令行中加入”-mcpu=CPU”。鉴于”-mcpu”已经被反对使用，所以建议不要设置该选项，或者设为 —without-cpu 。</p>
<h2 id="编译与测试"><a href="#编译与测试" class="headerlink" title="编译与测试"></a>编译与测试</h2><p>使用 make 命令编译，使用 make check 测试。如果 make check 没有完全成功，就千万不要使用这个编译结果。需要注意的是有些测试项目假定是以非 root 身份执行的，因此我们强烈建议你使用非 root 身份编译和测试。</p>
<p>测试中需要使用一些已经存在的文件(包括随后的安装过程)，比如 /etc/passwd, /etc/nsswitch.conf 之类。请确保这些文件中包含正确的内容。</p>
<p>安装与配置<br>使用 make install 命令安装。比如：make install LC_ALL=C</p>
<p>如果你打算将此 Glibc 安装为主 C 库，那么我们强烈建议你关闭系统，重新引导到单用户模式下安装。这样可以将可能的损害减小到最低。</p>
<p>安装后需要配置 GCC 以使其使用新安装的 C 库。最简单的办法是使用恰当 GCC 的编译选项(比如 -Wl,—dynamic-linker=/lib/ld-linux.so.2 )重新编译 GCC 。然后还需要修改 specs 文件(通常位于 /usr/lib/gcc-lib/TARGET/VERSION/specs )，这个工作有点像巫术，调整实例请参考 LFS 中的两次工具链调整。</p>
<p>可以在 make install 命令行使用’install_root’变量指定安装实际的安装目录(不同于 —prefix 指定的值)。这个在 chroot 环境下或者制作二进制包的时候通常很有用。’install_root’必须使用绝对路径。</p>
<p>被’grantpt’函数调用的辅助程序’/usr/libexec/pt_chown’以 setuid ‘root’ 安装。这个可能成为安全隐患。如果你的 Linux 内核支持’devptsfs’或’devfs’文件系统提供的 pty slave ，那么就不需要使用 pt_chown 程序。</p>
<p>安装完毕之后你还需要配置时区和 locale 。使用 localedef 来配置locale 。比如使用’localedef -i de_DE -f ISO-8859-1 de_DE’将 locale 设置为’de_DE.ISO-8859-1’。可以在编译目录中使用’make localedata/install-locales’命令配置所有可用的 locale ，但是一般不需要这么做。</p>
<p>时区使用’TZ’环境变量设置。tzselect 脚本可以帮助你选择正确的值。设置系统全局范围内的时区可以将 /etc/localtime 文件连接到 /usr/share/zoneinfo 目录下的正确文件上。比如对于中国人可以’ln -s /usr/share/zoneinfo/PRC /etc/localtime’。</p>
<h1 id="Binutils-安装指南-2-18-→-2-19-1"><a href="#Binutils-安装指南-2-18-→-2-19-1" class="headerlink" title="Binutils 安装指南(2.18 → 2.19.1)"></a>Binutils 安装指南(2.18 → 2.19.1)</h1><h2 id="安装信息的来源-1"><a href="#安装信息的来源-1" class="headerlink" title="安装信息的来源"></a>安装信息的来源</h2><p>源码包内的下列文件：各级目录下的configure脚本 　README　 {bfd,binutils,gas,gold,libiberty}/README<br>要点提示<br>如果想与GCC联合编译，那么可以将binutils包的内容解压到GCC的源码目录中(tar -xvf binutils-2.19.1.tar.bz2 —strip-components=1 -C gcc-4.3.3)，然后按照正常编译GCC的方法编译即可。这样做的好处之一是可以完整的将 GCC 与 Binutils 进行一次bootstrap。</p>
<p>推荐用一个新建的目录来编译，而不是在源码目录中。编译完毕后可以使用”make check”运行测试套件。这个测试套件依赖于DejaGnu软件包，而DejaGnu又依赖于expect，expect依赖于tcl。</p>
<p>如果只想编译 ld 可以使用”make all-ld”，如果只想编译 as 可以使用”make all-gas”。类似的还有 clean-ld clean-as distclean-ld distclean-as check-ld check-as 等。</p>
<p>配置选项<br>下列选项皆为非默认值[特别说明的除外]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">--help</span><br><span class="line">--version</span><br><span class="line">--quiet</span><br><span class="line">--config-cache</span><br><span class="line">--no-create</span><br><span class="line">--srcdir=DIR</span><br><span class="line">--prefix=PREFIX</span><br><span class="line">--exec-prefix=EPREFIX</span><br><span class="line">--bindir=DIR</span><br><span class="line">--sbindir=DIR</span><br><span class="line">--libexecdir=DIR</span><br><span class="line">--datadir=DIR</span><br><span class="line">--sysconfdir=DIR</span><br><span class="line">--sharedstatedir=DIR</span><br><span class="line">--localstatedir=DIR</span><br><span class="line">--libdir=DIR</span><br><span class="line">--includedir=DIR</span><br><span class="line">--oldincludedir=DIR</span><br><span class="line">--infodir=DIR</span><br><span class="line">--mandir=DIR</span><br><span class="line">--program-prefix=PREFIX</span><br><span class="line">--program-suffix=SUFFIX</span><br><span class="line">--program-transform-name=PROGRAM</span><br><span class="line">--build=BUILD</span><br><span class="line">--host=HOST</span><br><span class="line">--target=TARGET</span><br></pre></td></tr></table></figure></p>
<p>这些选项的含义基本上通用于所有软件包，这里就不特别讲解了。</p>
<p>—disable-nls<br>禁用本地语言支持(它允许按照非英语的本地语言显示警告和错误消息)。编译时出现”undefined reference to ‘libintl_gettext’”错误则必须禁用。</p>
<p>—disable-rpath<br>不在二进制文件中硬编码库文件的路径。</p>
<p>—disable-multilib<br>禁止编译适用于多重目标体系的库。例如，在x86_64平台上，默认既可以生成64位代码，也可以生成32位代码，若使用此选项，那么将只能生成64位代码。</p>
<p>—enable-cgen-maint=CGENDIR<br>编译cgen相关的文件[主要用于GDB调试]。</p>
<ul>
<li>—enable-shared[=PKG[,…]]</li>
<li>—disable-shared</li>
<li>—enable-static[=PKG[,…]]</li>
<li>—disable-static<br>允许/禁止编译共享或静态版本的库和可执行程序，全部可识别的PKG如下：binutils,gas,gprof,ld,bfd,opcodes,libiberty(仅支持作为静态库)。static在所有目录下的默认值都是”yes”；而shared在不同子目录下默认值不同，有些为”yes”(binutils,gas,gprof,ld)有些为”no”(bfd,opcodes,libiberty)。</li>
</ul>
<p>—enable-install-libbfd<br>—disable-install-libbfd<br>允许或禁止安装 libbfd 以及相关的头文件( libbfd 是二进制文件描述库,用于读写目标文件”.o”,被GDB/ld/as等程序使用)。本地编译或指定—enable-shared的情况下默认值为”yes”，否则默认值为”no”。</p>
<p>—enable-64-bit-bfd<br>让BFD支持64位目标，如果希望在32位平台上编译64程序就需要使用这个选项。如果指定的目标(TARGET)是64位则此选项默认打开，否则默认关闭(即使 —enable-targets=all 也是如此)。</p>
<p>—enable-elf-stt-common<br>允许BFD生成STT_COMMON类型的ELF符号。[2.19版本新增选项]</p>
<p>—enable-checking<br>—disable-checking<br>允许 as 执行运行时检查。正式发布版本默认禁用，快照版本默认启用。</p>
<p>—disable-werror<br>禁止将所有编译器警告当作错误看待(因为当编译器为GCC时默认使用-Werror)。</p>
<p>—enable-got=target|single|negative|multigot<br>指定GOT的处理模式。默认值是”target”。[2.19版本新增选项]</p>
<p>—enable-gold<br>使用gold代替GNU ld。gold是Google开发的连接器，2008年捐赠给FSF，目的是取代现有的GNU ld，但目前两者还不能完兼容。[2.19版本新增选项]</p>
<p>—enable-plugins<br>启用gold连接器的插件支持。[2.19版本新增选项]</p>
<p>—enable-threads<br>编译多线程版本的gold连接器。[2.19版本新增选项]</p>
<p>—with-lib-path=dir1:dir2…<br>指定编译出来的binutils工具(比如：ld)将来默认的库搜索路径，在绝大多数时候其默认值是”/lib:/usr/lib”。这个工作也可以通过设置 Makefile 中的 LIB_PATH 变量值完成。</p>
<p>—with-libiconv-prefix[=DIR]<br>—without-libiconv-prefix<br>在 DIR/include 目录中搜索 libiconv 头文件，在 DIR/lib 目录中搜索 libiconv 库文件。或者根本不使用 libiconv 库。</p>
<p>—with-libintl-prefix[=DIR]<br>—without-libintl-prefix<br>在 DIR/include 目录中搜索 libintl 头文件，在 DIR/lib 目录中搜索 libintl 库文件。或者根本不使用 libintl 库。</p>
<p>—with-mmap<br>使用mmap访问BFD输入文件。某些平台上速度较快，某些平台上速度较慢，某些平台上无法正常工作。</p>
<p>—with-pic<br>—without-pic<br>试图仅使用 PIC 或 non-PIC 对象，默认两者都使用。</p>
<p>以下选项仅在与GCC联合编译时才有意义，其含义与GCC相应选项的含义完全一样，默认值也相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">--enable-bootstrap</span><br><span class="line">--disable-bootstrap</span><br><span class="line">--enable-languages=lang1,lang2,...</span><br><span class="line">--enable-stage1-checking</span><br><span class="line">--enable-stage1-languages</span><br><span class="line">--disable-libada</span><br><span class="line">--disable-libgcj</span><br><span class="line">--disable-libgomp</span><br><span class="line">--disable-libmudflap</span><br><span class="line">--disable-libssp</span><br><span class="line">--enable-objc-gc</span><br><span class="line">--disable-cloog-version-check</span><br><span class="line">--disable-ppl-version-check</span><br><span class="line">--with-gnu-as</span><br><span class="line">--with-gnu-ld</span><br><span class="line">--with-gmp=GMPDIR</span><br><span class="line">--with-gmp-include=GMPINCDIR</span><br><span class="line">--with-gmp-lib=GMPLIBDIR</span><br><span class="line">--with-mpfr=MPFRDIR</span><br><span class="line">--with-mpfr-include=MPFRINCDIR</span><br><span class="line">--with-mpfr-lib=MPFRLIBDIR</span><br><span class="line">--with-cloog=CLOOGDIR</span><br><span class="line">--with-cloog_include=CLOOGINCDIR</span><br><span class="line">--with-cloog_lib=CLOOGLIBDIR</span><br><span class="line">--with-ppl=PPLDIR</span><br><span class="line">--with-ppl_include=PPLINCDIR</span><br><span class="line">--with-ppl_lib=PPLLIBDIR</span><br><span class="line">--with-stabs</span><br></pre></td></tr></table></figure></p>
<p>以下选项仅用于交叉编译环境</p>
<p>—enable-serial-[{host,target,build}-]configure<br>强制为 host, target, build 顺序配置子包，如果使用”all”则表示所有子包。</p>
<p>—with-sysroot=dir<br>将 dir 看作目标系统的根目录。目标系统的头文件、库文件、运行时对象都将被限定在其中。</p>
<p>—with-target-subdir=SUBDIR<br>为 target 在 SUBDIR 子目录中进行配置。</p>
<p>—with-newlib<br>将’newlib’(另一种标准C库，主要用于嵌入式环境)指定为目标系统的C库进行使用。</p>
<p>—with-build-sysroot=sysroot<br>在编译时将’sysroot’当作指定 build 平台的根目录看待。仅在已经使用了—with-sysroot选项的时候，该选项才有意义。</p>
<p>—with-build-subdir=SUBDIR<br>为 build 在 SUBDIR 子目录中进行配置。</p>
<p>—with-build-libsubdir=DIR<br>指定 build 平台的库文件目录。默认值是SUBDIR。</p>
<p>—with-build-time-tools=path<br>在给定的path中寻找用于编译Binutils自身的目标工具。该目录中必须包含 ar, as, ld, nm, ranlib, strip 程序，有时还需要包含 objdump 程序。例如，当编译Binutils的系统的文件布局和将来部署Binutils的目标系统不一致时就需要使用此选项。</p>
<p>—with-cross-host=HOST<br>这个选项已经被反对使用，应该使用—with-sysroot来代替其功能。<br>以下选项意义不大，一般不用考虑它们</p>
<p>—disable-dependency-tracking<br>禁止对Makefile规则的依赖性追踪。</p>
<p>—disable-largefile<br>禁止支持大文件。[2.19版本新增选项]</p>
<p>—disable-libtool-lock<br>禁止 libtool 锁定以加快编译速度(可能会导致并行编译的失败)</p>
<p>—disable-build-warnings<br>禁止显示编译时的编译器警告，也就是使用”-w”编译器选项进行编译。</p>
<p>—disable-fast-install<br>禁止为快速安装而进行优化。</p>
<p>—enable-maintainer-mode<br>启用无用的 make 规则和依赖性(它们有时会导致混淆)</p>
<p>—enable-commonbfdlib<br>—disable-commonbfdlib<br>允许或禁止编译共享版本的 BFD/opcodes/libiberty 库。分析configure脚本后发现这个选项事实上没有任何实际效果。</p>
<p>—enable-install-libiberty<br>安装 libiberty 的头文件(libiberty.h)，许多程序都会用到这个库中的函数(getopt,strerror,strtol,strtoul)。这个选项经过实验，没有实际效果(相当于disable)。</p>
<p>—enable-secureplt<br>使得binutils默认创建只读的 plt 项。相当于将来调用 gcc 时默认使用 -msecure-plt 选项。仅对 powerpc-linux 平台有意义。</p>
<p>—enable-targets=TARGET,TARGET,TARGET…<br>使BFD在默认格式之外再支持多种其它平台的二进制文件格式，”all”表示所有已知平台。在32位系统上，即使使用”all”也只能支持所有32位目标，除非同时使用 —enable-64-bit-bfd 选项。由于目前 gas 并不能使用内置的默认平台之外的其它目标，因此这个选项没什么实际意义。此选项在所有目录下都没有默认值。但对于2.19版本，此选项在gold子目录下的默认值是”all”。</p>
<p>—with-bugurl=URL<br>—without-bugurl<br>指定发送bug报告的URL/禁止发送bug报告。默认值是”<a href="http://www.sourceware.org/bugzilla/&quot;。" target="_blank" rel="noopener">http://www.sourceware.org/bugzilla/&quot;。</a></p>
<p>—with-datarootdir=DATADIR<br>将 DATADIR 用作数据根目录，默认值是[PREFIX/share]</p>
<p>—with-docdir=DOCDIR<br>—with-htmldir=HTMLDIR<br>—with-pdfdir=PDFDIR<br>指定各种文档的安装目录。DOCDIR默认值的默认值是DATADIR，HTMLDIR和PDFDIR的默认值是DOCDIR。</p>
<p>—with-included-gettext<br>使用软件包中自带的 GNU gettext 库。如果你已经使用了Glibc-2.0以上的版本，或者系统中已经安装了GNU gettext软件包，那么就没有必要使用这个选项。默认不使用。</p>
<p>—with-pkgversion=PKG<br>在 bfd 库中使用”PKG”代替默认的”GNU Binutils”作为版本字符串。比如你可以在其中嵌入编译时间或第多少次编译之类的信息。</p>
<p>—with-separate-debug-dir=DIR<br>在DIR中查找额外的全局debug信息，默认值：${libdir}/debug</p>
<p>—with-debug-prefix-map=’A=B C=D …’<br>在调试信息中建立 A-B,C-D, … 这样的映射关系。默认为空。[2.19版本新增选项]</p>
<h1 id="GCC-安装指南-4-3-→-4-4"><a href="#GCC-安装指南-4-3-→-4-4" class="headerlink" title="GCC 安装指南(4.3 → 4.4)"></a>GCC 安装指南(4.3 → 4.4)</h1><h2 id="要点提示-1"><a href="#要点提示-1" class="headerlink" title="要点提示"></a>要点提示</h2><p>从GCC-4.3起，安装GCC将依赖于GMP-4.1以上版本和MPFR-2.3.2以上版本。如果将这两个软件包分别解压到GCC源码树的根目录下，并分别命名为”gmp”和”mpfr”，那么GCC的编译程序将自动将两者与GCC一起编译。建议尽可能使用最新的GMP和MPFR版本。</p>
<p>推荐用一个新建的目录来编译GCC，而不是在源码目录中，这一点玩过LFS的兄弟都很熟悉了。另外，如果先前在编译中出现了错误，推荐使用 make distclean 命令进行清理，然后重新运行 configure 脚本进行配置，再在另外一个空目录中进行编译。</p>
<h2 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h2><p>[注意]这里仅包含适用于 C/C++ 语言编译器、十进制数字扩展库(libdecnumber)、在多处理机上编写并行程序的应用编程接口GOMP库(libgomp)、大杂烩的libiberty库、执行运行时边界检查的库(libmudflap)、保护堆栈溢出的库(libssp)、标准C++库(libstdc++) 相关的选项。也就是相当于 gcc-core 与 gcc-g++ 两个子包的选项。并不包括仅仅适用于其他语言的选项。</p>
<p>每一个 —enable 选项都有一个对应的 —disable 选项，同样，每一个 —with 选项也都用一个对应的 —without 选项。每一对选项中必有一个是默认值(依赖平台的不同而不同)。下面所列选项若未特别说明皆为非默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">--help</span><br><span class="line">--version</span><br><span class="line">--quiet</span><br><span class="line">--config-cache</span><br><span class="line">--no-create</span><br><span class="line">--srcdir=DIR</span><br><span class="line">--prefix=PREFIX</span><br><span class="line">--exec-prefix=EPREFIX</span><br><span class="line">--bindir=DIR</span><br><span class="line">--sbindir=DIR</span><br><span class="line">--libexecdir=DIR</span><br><span class="line">--datadir=DIR</span><br><span class="line">--sysconfdir=DIR</span><br><span class="line">--sharedstatedir=DIR</span><br><span class="line">--localstatedir=DIR</span><br><span class="line">--libdir=DIR</span><br><span class="line">--includedir=DIR</span><br><span class="line">--oldincludedir=DIR</span><br><span class="line">--infodir=DIR</span><br><span class="line">--mandir=DIR</span><br><span class="line">--program-prefix=PREFIX</span><br><span class="line">--program-suffix=SUFFIX</span><br><span class="line">--program-transform-name=PROGRAM</span><br><span class="line">--build=BUILD</span><br><span class="line">--host=HOST</span><br><span class="line">--target=TARGET</span><br></pre></td></tr></table></figure></p>
<p>这些选项的含义基本上通用于所有软件包，这里就不特别讲解了。</p>
<p>—disable-nls<br>禁用本地语言支持(它允许按照非英语的本地语言显示警告和错误消息)。编译时出现”undefined reference to ‘libintl_gettext’”错误则必须禁用。</p>
<p>—disable-rpath<br>不在二进制文件中硬编码库文件的路径。</p>
<p>—enable-bootstrap<br>—disable-bootstrap<br>“bootstrap”的意思是用第一次编译生成的程序来第二次编译自己，然后又用第二次编译生成的程序来第三次编译自己，最后比较第二次和第三次编译的结果，以确保编译器能毫无差错的编译自身，这通常表明编译是正确的。非交叉编译的情况下enable是默认值；交叉编译的情况下，disable是默认值。提示：stage2出来的结果是”最终结果”。</p>
<p>—enable-checking[=LIST]<br>该选项会在编译器内部生成一致性检查的代码，它并不改变编译器生成的二进制结果。这样导致编译时间增加，并且仅在使用GCC作为编译器的时候才有效，但是对输出结果没有影响。在”gcc”子目录下，对从CVS下载的版本默认值是”yes”(=assert,misc,tree,gc,rtlflag,runtime)，对于正式发布的版本则是”release”(=assert,runtime)，在”libgcc”子目录下，默认值始终是”no”。可以从 “assert,df,fold,gc,gcac,misc,rtlflag,rtl,runtime,tree,valgrind”中选择你想要检查的项目(逗号隔开的列表，”all”表示全部)，其中rtl,gcac,valgrind非常耗时。使用 —disable-checking 完全禁止这种检查会增加未能检测内部错误的风险，所以不建议这样做。</p>
<p>—enable-languages=lang1,lang2,…<br>只安装指定语言的编译器及其运行时库，可以使用的语言是：ada, c, c++, fortran, java, objc, obj-c++ ，若不指定则安装所有默认可用的语言(ada和obj-c++为非默认语言)。</p>
<p>—disable-multilib<br>禁止编译适用于多重目标体系的库。例如，在x86_64平台上，编译器默认既可以生成64位代码，也可以生成32位代码，若使用此选项，那么将只能生成64位代码。</p>
<p>—enable-shared[=PKG[,…]]<br>—disable-shared<br>—enable-static[=PKG[,…]]<br>—disable-static<br>允许/禁止编译共享或静态版本的库，全部可识别的库如下：libgcc,libstdc++,libffi,zlib,boehm-gc,ada,libada,libjava,libobjc,libiberty(仅支持作为静态库)。static在所有目录下的默认值都是”yes”；shared除了在libiberty目录下的默认值是”no”外，在其它目录下的默认值也都是”yes”。</p>
<p>—enable-decimal-float[=bid|dpd]<br>—disable-decimal-float<br>启用或禁用 libdecnumber 库符合 IEEE 754-2008 标准的 C 语言十进制浮点扩展，还可以进一步选择浮点格式(bid是i386与x86_64的默认值；dpd是PowerPC的默认值)。在 PowerPC/i386/x86_64 GNU/Linux 系统默认启用，在其他系统上默认禁用。</p>
<p>—disable-libgomp<br>不编译在多处理机上编写并行程序的应用编程接口GOMP库(libgomp)。</p>
<p>—disable-libmudflap<br>不编译执行运行时边界检查的库(libmudflap)。</p>
<p>—disable-libssp<br>不编译保护缓冲区溢出的运行时库。</p>
<p>—disable-symvers<br>禁用共享库对象中符号包含的版本信息。使用这个选项将导致 ABI 发生改变。禁用版本信息可以减小库的体积，但是将不兼容依赖于老版本库的二进制程序。它还会导致 libstdc++ 的 abi_check 测试失败，但你可以忽略这个失败。</p>
<p>—enable-threads=posix|aix|dce|gnat|mach|rtems|solaris|vxworks|win32|nks<br>—disable-threads<br>启用或禁用线程支持，若启用，则必须同时明确指定线程模型(不同平台支持的线程库并不相同，Linux现在一般使用posix)。这将对Objective-C编译器、运行时库，以及C++/Java等面向对象语言的异常处理产生影响。</p>
<p>—enable-version-specific-runtime-libs<br>将运行时库安装在编译器特定的子目录中(${libdir}/gcc-lib/${target_alias}/${gcc_version})，而不是默认的${libdir}目录中。另外，’libstdc++’的头文件将被安装在 ${libdir}/gcc-lib/${target_alias}/${gcc_version}/include/g++ 目录中(除非同时又指定了 —with-gxx-include-dir)。如果你打算同时安装几个不同版本的 GCC ，这个选项就很有用处了。当前，libgfortran,libjava,libmudflap,libstdc++,libobjc都支持该选项。</p>
<p>—enable-werror<br>—disable-werror<br>是否将所有编译器警告当作错误看待(使用-Werror来编译)。对于开发中的版本和快照默认为”yes”，对于正式发布的版本则默认为”no”。</p>
<p>—with-as=pathname<br>—with-ld=pathname<br>指定将来GCC使用的汇编器/连接器的位置，必须使用绝对路径。如果configure的默认查找过程找不到汇编器/连接器，就会需要该选项。或者系统中有多个汇编器/连接器，也需要它来指定使用哪一个。如果使用GNU的汇编器，那么你必须同时使用GNU连接器。</p>
<p>—with-datarootdir=DATADIR<br>将 DATADIR 用作数据根目录，默认值是[PREFIX/share]</p>
<p>—with-docdir=DOCDIR<br>—with-htmldir=HTMLDIR<br>—with-pdfdir=PDFDIR<br>指定各种文档的安装目录。DOCDIR默认值的默认值是DATADIR，HTMLDIR和PDFDIR的默认值是DOCDIR。</p>
<p>—with-gmp=GMPDIR<br>—with-gmp-include=GMPINCDIR<br>—with-gmp-lib=GMPLIBDIR<br>指定 GMP 库的安装目录/头文件目录/库目录。指定GMPDIR相当于同时指定了：GMPINCDIR=GMPDIR/include,GMPLIBDIR=GMPDIR/lib 。</p>
<p>—with-mpfr=MPFRDIR<br>—with-mpfr-include=MPFRINCDIR<br>—with-mpfr-lib=MPFRLIBDIR<br>指定 MPFR 库的安装目录/头文件目录/库目录。指定MPFRDIR相当于同时指定了：MPFRINCDIR=MPFRDIR/include,MPFRLIBDIR=MPFRDIR/lib 。</p>
<p>—with-cloog=CLOOGDIR<br>—with-cloog_include=CLOOGINCDIR<br>—with-cloog_lib=CLOOGLIBDIR<br>指定CLooG(Chunky Loop Generator)的安装目录/头文件目录/库目录。指定CLOOGDIR相当于同时指定了：CLOOGINCDIR=CLOOGDIR/include,CLOOGLIBDIR=CLOOGDIR/lib 。[GCC-4.4新增选项]</p>
<p>—with-ppl=PPLDIR<br>—with-ppl_include=PPLINCDIR<br>—with-ppl_lib=PPLLIBDIR<br>指定PPL(Parma Polyhedra Library)的安装目录/头文件目录/库目录。指定PPLDIR相当于同时指定了：PPLINCDIR=PPLDIR/include,PPLLIBDIR=PPLDIR/lib 。[GCC-4.4新增选项]</p>
<p>—with-gxx-include-dir=DIR<br>G++头文件的安装目录，默认为”prefix/include/c++/版本”。</p>
<p>—with-libiconv-prefix[=DIR]<br>—without-libiconv-prefix<br>在 DIR/include 目录中搜索 libiconv 头文件，在 DIR/lib 目录中搜索 libiconv 库文件。或者根本不使用 libiconv 库。</p>
<p>—with-libintl-prefix[=DIR]<br>—without-libintl-prefix<br>在 DIR/include 目录中搜索 libintl 头文件，在 DIR/lib 目录中搜索 libintl 库文件。或者根本不使用 libintl 库。</p>
<p>—with-local-prefix=DIR<br>指定本地包含文件的安装目录，不管如何设置—prefix，其默认值都为 /usr/local 。只有在系统已经建立了某些特定的目录规则，而不再是在 /usr/local/include 中查找本地安装的头文件的时候，该选项才使必须的。不能指定为 /usr ，也不能指定为安装GCC自身头文件的目录(默认为$libdir/gcc/$target/$version/include)，因为安装的头文件会和系统的头文件混合，从而造成冲突，导致不能编译某些程序。</p>
<p>—with-long-double-128<br>—without-long-double-128<br>指定long double类型为 128-bit 或 64-bit(等于double) 。基于 Glibc 2.4 或以上版本编译时默认为 128-bit ，其他情况默认为 64-bit ；但是可以使用这个选项强制指定。</p>
<p>—with-pic<br>—without-pic<br>试图仅使用 PIC 或 non-PIC 对象，默认两者都使用。</p>
<p>—with-slibdir=DIR<br>共享库(libgcc)的安装目录，默认等于 —libdir 的值。</p>
<p>—with-system-libunwind<br>使用系统中已经安装的libunwind库，默认自动检测。</p>
<p>—with-system-zlib<br>使用系统中的libz库，默认使用GCC自带的库。</p>
<p>以下选项仅适用于 C++ 语言：</p>
<p>—disable-c99<br>禁止支持 C99 标准。该选项将导致 ABI 接口发生改变。</p>
<p>—enable-cheaders=c|c_std|c_global<br>为 g++ 创建C语言兼容的头文件，默认为”c_global”。</p>
<p>—enable-clocale[=gnu|ieee_1003.1-2001|generic]<br>指定目标系统的 locale 模块，默认值为自动检测。建议明确设为”gnu”，否则可能会编译出 ABI 不兼容的 C++ 库。</p>
<p>—enable-clock-gettime[=yes|no|rt]<br>指明如何获取C++0x草案里面time.clock中clock_gettime()函数：”yes”表示在libc和libposix4库中检查(而libposix4在需要的时候还可能会链接到libstdc++)。”rt”表示还额外在librt库中查找，这一般并不是一个很好的选择，因为librt经常还会连接到libpthread上，从而使得单线程的程序产生不必要的锁定开销。默认值”no”则完全跳过这个检查。[GCC-4.4新增选项]</p>
<p>—enable-concept-checks<br>打开额外的实例化库模板编译时检查(以特定的模板形式)，这可以帮助用户在他们的程序运行之前就发现这些程序在何处违反了STL规则。</p>
<p>—enable-cstdio=PACKAGE<br>使用目标平台特定的 I/O 包，PACKAGE的默认值是”stdio”，也是唯一可用的值。使用这个选项将导致 ABI 接口发生改变。</p>
<p>—enable-cxx-flags=FLAGS<br>编译 libstdc++ 库文件时传递给编译器的编译标志，是一个引号界定的字符串。默认为空，表示使用环境变量 CXXFLAGS 的值。</p>
<p>—enable-fully-dynamic-string<br>该选项启用了一个特殊版本的 basic_string 来禁止在预处理的静态存储区域中放置空字符串的优化手段。参见 PR libstdc++/16612 获取更多细节。</p>
<p>—disable-hosted-libstdcxx<br>默认编译特定于主机环境的C++库。使用该选项将仅编译独立于主机环境的C++运行时库(前者的子集)。</p>
<p>—enable-libstdcxx-allocator[=new|malloc|mt|bitmap|pool]<br>指定目标平台特定的底层 std::allocator ，默认自动检测。使用这个选项将导致 ABI 接口发生改变。</p>
<p>—enable-libstdcxx-debug<br>额外编译调试版本的 libstdc++ 库文件，并默认安装在 ${libdir}/debug 目录中。</p>
<p>—enable-libstdcxx-debug-flags=FLAGS<br>编译调试版本的 libstdc++ 库文件时使用的编译器标志，默认为”-g3 -O0”</p>
<p>—disable-libstdcxx-pch<br>禁止创建预编译的 libstdc++ 头文件(stdc++.h.gch)，这个文件包含了所有标准 C++ 的头文件。该选项的默认值等于hosted-libstdcxx的值。</p>
<p>—disable-long-long<br>禁止使用模板支持’long long’类型。’long long’是 C99 新引进的类型，也是 GNU 对 C++98 标准的一个扩展。该选项将导致 ABI 接口发生改变。</p>
<p>—enable-sjlj-exceptions<br>强制使用旧式的 setjmp/longjmp 异常处理模型，使用这个选项将导致 ABI 接口发生改变。默认使用可以大幅降低二进制文件尺寸和内存占用的新式的 libunwind 库进行异常处理。建议不要使用此选项。</p>
<p>—disable-visibility<br>禁止 -fvisibility 编译器选项的使用(使其失效)。</p>
<p>—disable-wchar_t<br>禁止使用模板支持多字节字符类型’wchar_t’。该选项将导致 ABI 接口发生改变。</p>
<p>以下选项仅用于交叉编译：</p>
<p>—enable-serial-[{host,target,build}-]configure<br>强制为 host, target, build 顺序配置子包，如果使用”all”则表示所有子包。</p>
<p>—with-sysroot=DIR<br>将DIR看作目标系统的根目录。目标系统的头文件、库文件、运行时对象都将被限定在其中。其默认值是 ${gcc_tooldir}/sys-root 。</p>
<p>—with-target-subdir=SUBDIR<br>为 target 在 SUBDIR 子目录中进行配置。</p>
<p>—with-newlib<br>将’newlib’指定为目标系统的C库进行使用。这将导致 libgcc.a 中的 __eprintf 被忽略，因为它被假定为由’newlib’提供。</p>
<p>—with-build-subdir=SUBDIR<br>为 build 在 SUBDIR 子目录中进行配置。</p>
<p>—with-build-libsubdir=DIR<br>指定 build 平台的库文件目录。默认值是SUBDIR。</p>
<p>—with-build-sysroot=sysroot<br>在编译时将’sysroot’当作指定 build 平台的根目录看待。仅在已经使用了—with-sysroot选项的时候，该选项才有意义。</p>
<p>—with-build-time-tools=path<br>在给定的path中寻找用于编译GCC自身的目标工具。该目录中必须包含 ar, as, ld, nm, ranlib, strip 程序，有时还需要包含 objdump 程序。例如，当编译GCC的系统的文件布局和将来部署GCC的目标系统不一致时就需要使用此选项。</p>
<p>—with-cross-host=HOST<br>这个选项已经被反对使用，应该使用—with-sysroot来代替其功能。</p>
<h2 id="编译、测试、安装"><a href="#编译、测试、安装" class="headerlink" title="编译、测试、安装"></a>编译、测试、安装</h2><p>除了使用 CFLAGS,LDFLAGS 之外，还可以使用 LIBCFLAGS,LIBCXXFLAGS 控制库文件(由stage3编译)的编译器选项。可以在 make 命令行上使用 BOOT_CFLAGS,BOOT_LDFLAGS 来控制 stage2,stage3 的编译。可以使用 make bootstrap4 来增加步骤以避免 stage1 可能被错误编译所导致的错误。可以使用 make profiledbootstrap 在编译stage1时收集一些有用的统计信息，然后使用这些信息编译最终的二进制文件，这样可以提升编译器和相应库文件的执行效率。</p>
<p>编译完毕后可以使用”make check”运行测试套件，然后可以和<a href="http://gcc.gnu.org/buildstat.html里面列出来的结果进行对比，只要&quot;unexpected" target="_blank" rel="noopener">http://gcc.gnu.org/buildstat.html里面列出来的结果进行对比，只要&quot;unexpected</a> failures”不要太多就好说。这个测试套件依赖于DejaGnu软件包，而DejaGnu又依赖于expect，expect依赖于tcl。如果只想运行C++测试，可以使用”make check-g++”命令；如果只想运行C编译器测试，可以使用”make check-gcc”。还可以制定只运行某些单项测试：比如使用 make check RUNTESTFLAGS=”compile.exp -v” 运行编译测试。另一方面，GCC并不支持使用”make uninstall”进行卸载，建议你将GCC安装在一个特别的目录中，然后在不需要的时候直接删除这个目录。</p>
<p>因为GCC的安装依赖于GMP和MPFR，所以下面附上GMP和MPFR的安装信息，主要是configure选项。</p>
<h1 id="优化基本原理"><a href="#优化基本原理" class="headerlink" title="优化基本原理"></a>优化基本原理</h1><p>我们首先从三个方面来看与优化相关的内容：</p>
<p>从运行时的依赖关系来看，对性能有较大影响的组件有 kernel 和 glibc ，虽然这严格说来这不属于本文的话题，但是经过精心选择、精心配置、精心编译的内核与C库将对提高系统的运行速度起着基础性的作用。</p>
<p>从被编译的软件包来看，每个软件包的 configure 脚本都提供了许多配置选项，其中有许多选项是与性能息息相关的。比如，对于 Apache-2.2.6 而言，你可以使用 —enable-MODULE=static 将模块静态编译进核心，使用 —disable-MODULE 禁用不需要的模块，使用 —with-mpm=MPM 选择一个高效的多路处理模块，在不需要IPv6的情况下使用 —disable-ipv6 禁用IPv6支持，在不使用线程化的MPM时使用 —disable-threads 禁用线程支持，等等……这部分内容显然不可能在本文中进行完整的讲述，本文只能讲述与优化相关的通用选项。针对特定的软件包，请在编译前使用 configure —help 查看所有选项，并精心选择。</p>
<p>从编译过程自身来看，将源代码编译为二进制文件是在 Makefile 文件的指导下，由 make 程序调用一条条编译命令完成的。而将源代码编译为二进制文件又需要经过以下四个步骤：预处理(cpp) → 编译(gcc或g++) → 汇编(as) → 连接(ld) ；括号中表示每个阶段所使用的程序，它们分别属于 GCC 和 Binutils 软件包。显然的，优化应当从编译工具自身的选择以及控制编译工具的行为入手。</p>
<h1 id="编译工具的选择"><a href="#编译工具的选择" class="headerlink" title="编译工具的选择"></a>编译工具的选择</h1><p>对于编译工具自身的选择，在假定使用 Binutils 和 GCC 以及 Make 的前提下，没什么好说的，基本上新版本都能带来性能提升，同时比老版本对新硬件的支持更好，所以应当尽量选用新版本。不过追新也可能带来系统的不稳定，这就要针对实际情况进行权衡了。本文以 Binutils-2.18 和 GCC-4.2.2/GCC-4.3.0 以及 Make-3.81 为例进行说明。</p>
<h2 id="configure-选项"><a href="#configure-选项" class="headerlink" title="configure 选项"></a>configure 选项</h2><p>这里我们只讲解通用的”体系结构选项”，由于”特性选项”在每个软件包之间千差万别，所以不可能在此处进行讲解。</p>
<p>这部分内容很简单，并且其含义也是不言而喻的，下面只列出常用的值：</p>
<ul>
<li>i586-pc-linux-gnu</li>
<li>i686-pc-linux-gnu</li>
<li>x86_64-pc-linux-gnu</li>
<li>powerpc-unknown-linux-gnu</li>
<li>powerpc64-unknown-linux-gnu</li>
</ul>
<p>如果你实在不知道应当使用哪一个，那么就干脆不使用这几个选项，让 config.guess 脚本自己去猜吧，反正也挺准的。</p>
<h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><p>让我们先看看 Makefile 规则中的编译命令通常是怎么写的。大多数软件包遵守如下约定俗成的规范：</p>
<ol>
<li><p>首先从源代码生成目标文件(预处理,编译,汇编)，”-c”选项表示不执行链接步骤。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(CC) $(CPPFLAGS) $(CFLAGS) example.c   -c   -o example.o</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后将目标文件连接为最终的结果(连接)，”-o”选项用于指定输出文件的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(CC) $(LDFLAGS) example.o   -o example</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>有一些软件包一次完成四个步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(CC) $(CPPFLAGS) $(CFLAGS) $(LDFLAGS) example.c   -o example</span><br></pre></td></tr></table></figure></p>
<p>当然也有少数软件包不遵守这些约定俗成的规范，比如：</p>
<ol>
<li><p>有些在命令行中漏掉应有的Makefile变量(注意：有些遗漏是故意的)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(CC) $(CFLAGS) example.c    -c   -o example.o</span><br><span class="line">$(CC) $(CPPFLAGS) example.c  -c   -o example.o</span><br><span class="line">$(CC) example.o   -o example</span><br><span class="line">$(CC) example.c   -o example</span><br></pre></td></tr></table></figure>
</li>
<li><p>有些在命令行中增加了不必要的Makefile变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(CC) $(CFLAGS) $(LDFLAGS) example.o   -o example</span><br><span class="line">$(CC) $(CPPFLAGS) $(CFLAGS) $(LDFLAGS) example.c   -c   -o example.o</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>尽管将源代码编译为二进制文件的四个步骤由不同的程序(cpp,gcc/g++,as,ld)完成，但是事实上 cpp, as, ld 都是由 gcc/g++ 进行间接调用的。换句话说，控制了 gcc/g++ 就等于控制了所有四个步骤。从 Makefile 规则中的编译命令可以看出，编译工具的行为全靠 CC/CXX CPPFLAGS CFLAGS/CXXFLAGS LDFLAGS 这几个变量在控制。当然理论上控制编译工具行为的还应当有 AS ASFLAGS ARFLAGS 等变量，但是实践中基本上没有软件包使用它们。</p>
<p>那么我们如何控制这些变量呢？一种简易的做法是首先设置与这些 Makefile 变量同名的环境变量并将它们 export 为全局，然后运行 configure 脚本，大多数 configure 脚本会使用这同名的环境变量代替 Makefile 中的值。但是少数 configure 脚本并不这样做(比如GCC-3.4.6和Binutils-2.16.1的脚本就不传递LDFLAGS)，你必须手动编辑生成的 Makefile 文件，在其中寻找这些变量并修改它们的值，许多源码包在每个子文件夹中都有 Makefile 文件，真是一件很累人的事！</p>
<h2 id="CC-与-CXX"><a href="#CC-与-CXX" class="headerlink" title="CC 与 CXX"></a>CC 与 CXX</h2><p>这是 C 与 C++ 编译器命令。默认值一般是 “gcc” 与 “g++”。这个变量本来与优化没有关系，但是有些人因为担心软件包不遵守那些约定俗成的规范，害怕自己苦心设置的 CFLAGS/CXXFLAGS/LDFLAGS 之类的变量被忽略了，而索性将原本应当放置在其它变量中的选项一股老儿塞到 CC 或 CXX 中，比如：CC=”gcc -march=k8 -O2 -s”。这是一种怪异的用法，本文不提倡这种做法，而是提倡按照变量本来的含义使用变量。</p>
<h2 id="CPPFLAGS"><a href="#CPPFLAGS" class="headerlink" title="CPPFLAGS"></a>CPPFLAGS</h2><p>这是用于预处理阶段的选项。不过能够用于此变量的选项，看不出有哪个与优化相关。如果你实在想设一个，那就使用下面这两个吧：</p>
<ul>
<li><code>-DNDEBUG</code>：”NDEBUG”是一个标准的 ANSI 宏，表示不进行调试编译。</li>
<li><code>-D_FILE_OFFSET_BITS=64</code>：大多数包使用这个来提供大文件(&gt;2G)支持。</li>
</ul>
<h2 id="CFLAGS-与-CXXFLAGS"><a href="#CFLAGS-与-CXXFLAGS" class="headerlink" title="CFLAGS 与 CXXFLAGS"></a>CFLAGS 与 CXXFLAGS</h2><p>CFLAGS 表示用于 C 编译器的选项，CXXFLAGS 表示用于 C++ 编译器的选项。这两个变量实际上涵盖了编译和汇编两个步骤。大多数程序和库在编译时默认的优化级别是”2”(使用”-O2”选项)并且带有调试符号来编译，也就是 CFLAGS=”-O2 -g”, CXXFLAGS=$CFLAGS 。事实上，”-O2”已经启用绝大多数安全的优化选项了。另一方面，由于大部分选项可以同时用于这两个变量，所以仅在最后讲述只能用于其中一个变量的选项。</p>
<p>先说说”-O3”在”-O2”基础上增加的几项：</p>
<ul>
<li>-finline-functions：允许编译器选择某些简单的函数在其被调用处展开，比较安全的选项，特别是在CPU二级缓存较大时建议使用。</li>
<li>-funswitch-loops：将循环体中不改变值的变量移动到循环体之外。</li>
<li>-fgcse-after-reload：为了清除多余的溢出，在重载之后执行一个额外的载入消除步骤。</li>
</ul>
<p>另外：</p>
<ul>
<li>-fomit-frame-pointer:对于不需要栈指针的函数就不在寄存器中保存指针，因此可以忽略存储和检索地址的代码，同时对许多函数提供一个额外的寄存器。所有”-O”级别都打开它，但仅在调试器可以不依靠栈指针运行时才有效。在AMD64平台上此选项默认打开，但是在x86平台上则默认关闭。建议显式的设置它。</li>
<li>-falign-functions=N</li>
<li>-falign-jumps=N</li>
<li>-falign-loops=N</li>
<li>-falign-labels=N：这四个对齐选项在”-O2”中打开，其中的根据不同的平台N使用不同的默认值。如果你想指定不同于默认值的N，也可以单独指定。比如，对于L2-cache&gt;=1M的cpu而言，指定 -falign-functions=64 可能会获得更好的性能。建议在指定了 -march 的时候不明确指定这里的值。</li>
</ul>
<p>调试选项：</p>
<p>-fprofile-arcs<br>在使用这一选项编译程序并运行它以创建包含每个代码块的执行次数的文件后，程序可以再次使用 -fbranch-probabilities 编译，文件中的信息可以用来优化那些经常选取的分支。如果没有这些信息，gcc将猜测哪个分支将被经常运行以进行优化。这类优化信息将会存放在一个以源文件为名字的并以”.da”为后缀的文件中。<br>全局选项：</p>
<p>-pipe<br>在编译过程的不同阶段之间使用管道而非临时文件进行通信，可以加快编译速度。建议使用。<br>目录选项：</p>
<p>—sysroot=dir<br>将dir作为逻辑根目录。比如编译器通常会在 /usr/include 和 /usr/lib 中搜索头文件和库，使用这个选项后将在 dir/usr/include 和 dir/usr/lib 目录中搜索。如果使用这个选项的同时又使用了 -isysroot 选项，则此选项仅作用于库文件的搜索路径，而 -isysroot 选项将作用于头文件的搜索路径。这个选项与优化无关，但是在 CLFS 中有着神奇的作用。<br>代码生成选项：</p>
<p>-fno-bounds-check<br>关闭所有对数组访问的边界检查。该选项将提高数组索引的性能，但当超出数组边界时，可能会造成不可接受的行为。</p>
<p>-freg-struct-return<br>如果struct和union足够小就通过寄存器返回，这将提高较小结构的效率。如果不够小，无法容纳在一个寄存器中，将使用内存返回。建议仅在完全使用GCC编译的系统上才使用。</p>
<p>-fpic<br>生成可用于共享库的位置独立代码。所有的内部寻址均通过全局偏移表完成。要确定一个地址，需要将代码自身的内存位置作为表中一项插入。该选项产生可以在共享库中存放并从中加载的目标模块。</p>
<p>-fstack-check<br>为防止程序栈溢出而进行必要的检测，仅在多线程环境中运行时才可能需要它。</p>
<p>-fvisibility=hidden<br>设置默认的ELF镜像中符号的可见性为隐藏。使用这个特性可以非常充分的提高连接和加载共享库的性能，生成更加优化的代码，提供近乎完美的API输出和防止符号碰撞。我们强烈建议你在编译任何共享库的时候使用该选项。参见 -fvisibility-inlines-hidden 选项。<br>硬件体系结构相关选项[仅仅针对x86与x86_64]：</p>
<p>-march=cpu-type<br>为特定的cpu-type编译二进制代码(不能在更低级别的cpu上运行)。Intel可以用：pentium2, pentium3(=pentium3m), pentium4(=pentium4m), pentium-m, prescott, nocona, core2(GCC-4.3新增) 。AMD可以用：k6-2(=k6-3), athlon(=athlon-tbird), athlon-xp(=athlon-mp), k8(=opteron=athlon64=athlon-fx)</p>
<p>-mfpmath=sse<br>P3和athlon-xp级别及以上的cpu支持”sse”标量浮点指令。仅建议在P4和K8以上级别的处理器上使用该选项。</p>
<p>-malign-double<br>将double, long double, long long对齐于双字节边界上；有助于生成更高速的代码，但是程序的尺寸会变大，并且不能与未使用该选项编译的程序一起工作。</p>
<p>-m128bit-long-double<br>指定long double为128位，pentium以上的cpu更喜欢这种标准，并且符合x86-64的ABI标准，但是却不附合i386的ABI标准。</p>
<p>-mregparm=N<br>指定用于传递整数参数的寄存器数目(默认不使用寄存器)。0&lt;=N&lt;=3 ；注意：当N&gt;0时你必须使用同一参数重新构建所有的模块，包括所有的库。</p>
<p>-msseregparm<br>使用SSE寄存器传递float和double参数和返回值。注意：当你使用了这个选项以后，你必须使用同一参数重新构建所有的模块，包括所有的库。</p>
<ul>
<li><code>-mmmx</code></li>
<li><code>-msse</code></li>
<li><code>-msse2</code></li>
<li><code>-msse3</code></li>
<li><code>-m3dnow</code></li>
<li><code>-mssse3(没写错!GCC-4.3新增)</code></li>
<li><code>-msse4.1(GCC-4.3新增)</code></li>
<li><code>-msse4.2(GCC-4.3新增)</code></li>
<li><code>-msse4(含4.1和4.2,GCC-4.3新增)</code><br>是否使用相应的扩展指令集以及内置函数，按照自己的cpu选择吧！</li>
</ul>
<p>-maccumulate-outgoing-args<br>指定在函数引导段中计算输出参数所需最大空间，这在大部分现代cpu中是较快的方法；缺点是会明显增加二进制文件尺寸。</p>
<p>-mthreads<br>支持Mingw32的线程安全异常处理。对于依赖于线程安全异常处理的程序，必须启用这个选项。使用这个选项时会定义”-D_MT”，它将包含使用选项”-lmingwthrd”连接的一个特殊的线程辅助库，用于为每个线程清理异常处理数据。</p>
<p>-minline-all-stringops<br>默认时GCC只将确定目的地会被对齐在至少4字节边界的字符串操作内联进程序代码。该选项启用更多的内联并且增加二进制文件的体积，但是可以提升依赖于高速 memcpy, strlen, memset 操作的程序的性能。</p>
<p>-minline-stringops-dynamically<br>GCC-4.3新增。对未知尺寸字符串的小块操作使用内联代码，而对大块操作仍然调用库函数，这是比”-minline-all-stringops”更聪明的策略。决定策略的算法可以通过”-mstringop-strategy”控制。</p>
<p>-momit-leaf-frame-pointer<br>不为叶子函数在寄存器中保存栈指针，这样可以节省寄存器，但是将会使调试变的困难。注意：不要与 -fomit-frame-pointer 同时使用，因为会造成代码效率低下。</p>
<p>-m64<br>生成专门运行于64位环境的代码，不能运行于32位环境，仅用于x86_64[含EMT64]环境。</p>
<p>-mcmodel=small<br>[默认值]程序和它的符号必须位于2GB以下的地址空间。指针仍然是64位。程序可以静态连接也可以动态连接。仅用于x86_64[含EMT64]环境。</p>
<p>-mcmodel=kernel<br>内核运行于2GB地址空间之外。在编译linux内核时必须使用该选项！仅用于x86_64[含EMT64]环境。</p>
<p>-mcmodel=medium<br>程序必须位于2GB以下的地址空间，但是它的符号可以位于任何地址空间。程序可以静态连接也可以动态连接。注意：共享库不能使用这个选项编译！仅用于x86_64[含EMT64]环境。</p>
<p>-fforce-addr<br>必须将地址复制到寄存器中才能对他们进行运算。由于所需地址通常在前面已经加载到寄存器中了，所以这个选项可以改进代码。</p>
<p>-finline-limit=n<br>对伪指令数超过n的函数，编译程序将不进行内联展开，默认为600。增大此值将增加编译时间和编译内存用量并且生成的二进制文件体积也会变大，此值不宜太大。</p>
<p>-fmerge-all-constants<br>试图将跨编译单元的所有常量值和数组合并在一个副本中。但是标准C/C++要求每个变量都必须有不同的存储位置，所以该选项可能会导致某些不兼容的行为。</p>
<p>-fgcse-sm<br>在全局公共子表达式消除之后运行存储移动，以试图将存储移出循环。gcc-3.4中曾属于”-O2”级别的选项。</p>
<p>-fgcse-las<br>在全局公共子表达式消除之后消除多余的在存储到同一存储区域之后的加载操作。gcc-3.4中曾属于”-O2”级别的选项。</p>
<p>-floop-optimize<br>已废除(GCC-4.1曾包含在”-O1”中)。</p>
<p>-floop-optimize2<br>使用改进版本的循环优化器代替原来”-floop-optimize”。该优化器将使用不同的选项(-funroll-loops, -fpeel-loops, -funswitch-loops, -ftree-loop-im)分别控制循环优化的不同方面。目前这个新版本的优化器尚在开发中，并且生成的代码质量并不比以前的版本高。已废除，仅存在于GCC-4.1之前的版本中。</p>
<p>-funsafe-loop-optimizations<br>假定循环不会溢出，并且循环的退出条件不是无穷。这将可以在一个比较广的范围内进行循环优化，即使优化器自己也不能断定这样做是否正确。</p>
<p>-fsched-spec-load<br>允许一些装载指令执行一些投机性的动作。</p>
<p>-ftree-loop-linear<br>在trees上进行线型循环转换。它能够改进缓冲性能并且允许进行更进一步的循环优化。</p>
<p>-fivopts<br>在trees上执行归纳变量优化。</p>
<p>-ftree-vectorize<br>在trees上执行循环向量化。</p>
<p>-ftracer<br>执行尾部复制以扩大超级块的尺寸，它简化了函数控制流，从而允许其它的优化措施做的更好。据说挺有效。</p>
<p>-funroll-loops<br>仅对循环次数能够在编译时或运行时确定的循环进行展开，生成的代码尺寸将变大，执行速度可能变快也可能变慢。</p>
<p>-fprefetch-loop-arrays<br>生成数组预读取指令，对于使用巨大数组的程序可以加快代码执行速度，适合数据库相关的大型软件等。具体效果如何取决于代码。</p>
<p>-fweb<br>建立经常使用的缓存器网络，提供更佳的缓存器使用率。gcc-3.4中曾属于”-O3”级别的选项。</p>
<p>-ffast-math<br>违反IEEE/ANSI标准以提高浮点数计算速度，是个危险的选项，仅在编译不需要严格遵守IEEE规范且浮点计算密集的程序考虑采用。</p>
<p>-fsingle-precision-constant<br>将浮点常量作为单精度常量对待，而不是隐式地将其转换为双精度。</p>
<p>-fbranch-probabilities<br>在使用 -fprofile-arcs 选项编译程序并执行它来创建包含每个代码块执行次数的文件之后，程序可以利用这一选项再次编译，文件中所产生的信息将被用来优化那些经常发生的分支代码。如果没有这些信息，gcc将猜测那一分支可能经常发生并进行优化。这类优化信息将会存放在一个以源文件为名字的并以”.da”为后缀的文件中。</p>
<p>-frename-registers<br>试图驱除代码中的假依赖关系，这个选项对具有大量寄存器的机器很有效。gcc-3.4中曾属于”-O3”级别的选项。</p>
<ul>
<li>-fbranch-target-load-optimize</li>
<li>-fbranch-target-load-optimize2<br>在执行序启动以及结尾之前执行分支目标缓存器加载最佳化。</li>
</ul>
<p>-fstack-protector<br>在关键函数的堆栈中设置保护值。在返回地址和返回值之前，都将验证这个保护值。如果出现了缓冲区溢出，保护值不再匹配，程序就会退出。程序每次运行，保护值都是随机的，因此不会被远程猜出。</p>
<p>-fstack-protector-all<br>同上，但是在所有函数的堆栈中设置保护值。</p>
<p>—param max-gcse-memory=xxM<br>执行GCSE优化使用的最大内存量(xxM)，太小将使该优化无法进行，默认为50M。</p>
<p>—param max-gcse-passes=n<br>执行GCSE优化的最大迭代次数，默认为 1。<br>传递给汇编器的选项：</p>
<p>-Wa,options<br>options是一个或多个由逗号分隔的可以传递给汇编器的选项列表。其中的每一个均可作为命令行选项传递给汇编器。</p>
<p>-Wa,—strip-local-absolute<br>从输出符号表中移除局部绝对符号。</p>
<p>-Wa,-R<br>合并数据段和正文段，因为不必在数据段和代码段之间转移，所以它可能会产生更短的地址移动。</p>
<p>-Wa,—64<br>设置字长为64bit，仅用于x86_64，并且仅对ELF格式的目标文件有效。此外，还需要使用”—enable-64-bit-bfd”选项编译的BFD支持。</p>
<p>-Wa,-march=CPU<br>按照特定的CPU进行优化：pentiumiii, pentium4, prescott, nocona, core, core2; athlon, sledgehammer, opteron, k8 。<br>仅可用于 CFLAGS 的选项：</p>
<p>-fhosted<br>按宿主环境编译，其中需要有完整的标准库，入口必须是main()函数且具有int型的返回值。内核以外几乎所有的程序都是如此。该选项隐含设置了 -fbuiltin，且与 -fno-freestanding 等价。</p>
<p>-ffreestanding<br>按独立环境编译，该环境可以没有标准库，且对main()函数没有要求。最典型的例子就是操作系统内核。该选项隐含设置了 -fno-builtin，且与 -fno-hosted 等价。<br>仅可用于 CXXFLAGS 的选项：</p>
<p>-fno-enforce-eh-specs<br>C++标准要求强制检查异常违例，但是该选项可以关闭违例检查，从而减小生成代码的体积。该选项类似于定义了”NDEBUG”宏。</p>
<p>-fno-rtti<br>如果没有使用’dynamic_cast’和’typeid’，可以使用这个选项禁止为包含虚方法的类生成运行时表示代码，从而节约空间。此选项对于异常处理无效(仍然按需生成rtti代码)。</p>
<p>-ftemplate-depth-n<br>将最大模版实例化深度设为’n’，符合标准的程序不能超过17，默认值为500。</p>
<p>-fno-optional-diags<br>禁止输出诊断消息，C++标准并不需要这些消息。</p>
<p>-fno-threadsafe-statics<br>GCC自动在访问C++局部静态变量的代码上加锁，以保证线程安全。如果你不需要线程安全，可以使用这个选项。</p>
<p>-fvisibility-inlines-hidden<br>默认隐藏所有内联函数，从而减小导出符号表的大小，既能缩减文件的大小，还能提高运行性能，我们强烈建议你在编译任何共享库的时候使用该选项。参见 -fvisibility=hidden 选项。</p>
<h2 id="LDFLAGS"><a href="#LDFLAGS" class="headerlink" title="LDFLAGS"></a>LDFLAGS</h2><p>LDFLAGS 是传递给连接器的选项。这是一个常被忽视的变量，事实上它对优化的影响也是很明显的。</p>
<p>-s<br>删除可执行程序中的所有符号表和所有重定位信息。其结果与运行命令 strip 所达到的效果相同，这个选项是比较安全的。</p>
<p>-Wl,options<br>options是由一个或多个逗号分隔的传递给链接器的选项列表。其中的每一个选项均会作为命令行选项提供给链接器。</p>
<p>-Wl,-On<br>当n&gt;0时将会优化输出，但是会明显增加连接操作的时间，这个选项是比较安全的。</p>
<p>-Wl,—exclude-libs=ALL<br>不自动导出库中的符号，也就是默认将库中的符号隐藏。</p>
<p>-Wl,-m<emulation><br>仿真<emulation>连接器，当前ld所有可用的仿真可以通过”ld -V”命令获取。默认值取决于ld的编译时配置。</emulation></emulation></p>
<p>-Wl,—sort-common<br>把全局公共符号按照大小排序后放到适当的输出节，以防止符号间因为排布限制而出现间隙。</p>
<p>-Wl,-x<br>删除所有的本地符号。</p>
<p>-Wl,-X<br>删除所有的临时本地符号。对于大多数目标平台，就是所有的名字以’L’开头的本地符号。</p>
<p>-Wl,-zcomberloc<br>组合多个重定位节并重新排布它们，以便让动态符号可以被缓存。</p>
<p>-Wl,—enable-new-dtags<br>在ELF中创建新式的”dynamic tags”，但在老式的ELF系统上无法识别。</p>
<p>-Wl,—as-needed<br>移除不必要的符号引用，仅在实际需要的时候才连接，可以生成更高效的代码。</p>
<p>-Wl,—no-define-common<br>限制对普通符号的地址分配。该选项允许那些从共享库中引用的普通符号只在主程序中被分配地址。这会消除在共享库中的无用的副本的空间，同时也防止了在有多个指定了搜索路径的动态模块在进行运行时符号解析时引起的混乱。</p>
<p>-Wl,—hash-style=gnu<br>使用gnu风格的符号散列表格式。它的动态链接性能比传统的sysv风格(默认)有较大提升，但是它生成的可执行程序和库与旧的Glibc以及动态链接器不兼容。<br>最后说两个与优化无关的系统环境变量，因为会影响GCC编译程序的方式，下面两个是咱中国人比较关心的：</p>
<h2 id="LANG"><a href="#LANG" class="headerlink" title="LANG"></a>LANG</h2><p>指定编译程序使用的字符集，可用于创建宽字符文件、串文字、注释；默认为英文。[目前只支持日文”C-JIS,C-SJIS,C-EUCJP”，不支持中文]</p>
<p>LC_ALL<br>指定多字节字符的字符分类，主要用于确定字符串的字符边界以及编译程序使用何种语言发出诊断消息；默认设置与LANG相同。中文相关的几项：”zh_CN.GB2312 , zh_CN.GB18030 , zh_CN.GBK , zh_CN.UTF-8 , zh_TW.BIG5”。</p>
<hr>
<p>title: GCC编译参数<br>date: 2019-04-23 22:41:39<br>tags:</p>
<pre><code>- Linux
</code></pre><hr>
<p>GNU CC(简称gcc)是GNU项目中符合ANSI C标准的编译系统，能够编译用C、C++、Object C、Jave等多种语言编写的程序。gcc又可以作为交叉编译工具，它能够在当前CPU平台上为多种不同体系结构的硬件平台开发软件，非常适合在嵌入式领域的开发编译，如常用的arm-linux-gcc交叉编译工具</p>
<p>通常后跟一些选项和文件名来使用 GCC 编译器。gcc 命令的基本用法如下:</p>
<pre><code>gcc [options] [filenames]

选项指定编译器怎样进行编译。
</code></pre><h1 id="gcc-编译流程"><a href="#gcc-编译流程" class="headerlink" title="gcc 编译流程"></a>gcc 编译流程</h1><h2 id="预处理-Pre-Processing"><a href="#预处理-Pre-Processing" class="headerlink" title="预处理-Pre-Processing"></a>预处理-Pre-Processing</h2><p>gcc  -E  test.c  -o  test.i    //.i文件</p>
<h2 id="编译-Compiling"><a href="#编译-Compiling" class="headerlink" title="编译-Compiling"></a>编译-Compiling</h2><p>gcc  -S  test.i  -o   test.s  //.s文件 </p>
<h2 id="汇编-Assembling-o文件"><a href="#汇编-Assembling-o文件" class="headerlink" title="汇编-Assembling         //.o文件"></a>汇编-Assembling         //.o文件</h2><p>gcc  -c  test.s  -o  test.o</p>
<h2 id="链接-Linking-bin文件"><a href="#链接-Linking-bin文件" class="headerlink" title="链接-Linking           //bin文件"></a>链接-Linking           //bin文件</h2><p>gcc  test.o  -o  test</p>
<h1 id="gcc工程惯用"><a href="#gcc工程惯用" class="headerlink" title="gcc工程惯用"></a>gcc工程惯用</h1><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>gcc  -c  test.c          //.o文件，汇编</p>
<p>gcc  -o  test  test.c  //bin可执行文件</p>
<p>gcc   test.c             //a.out可执行文件</p>
<p>如果是c++ 直接将gcc改为g++即可。</p>
<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><ol>
<li>-E参数 选项指示编译器仅对输入文件进行预处理。当这个选项被使用时, 预处理器的输出被送到标准输出而不是储存在文件里.</li>
<li>-S参数 编译选项告诉 GCC 在为 C 代码产生了汇编语言文件后停止编译。 GCC 产生的汇编语言文件的缺省扩展名是 .s 。</li>
<li>-c参数 选项告诉 GCC 仅把源代码编译为目标代码。缺省时 GCC 建立的目标代码文件有一个 .o 的扩展名。</li>
<li>-o参数 编译选项来为将产生的可执行文件用指定的文件名。</li>
<li>-O参数 选项告诉 GCC 对源代码进行基本优化。这些优化在大多数情况下都会使程序执行的更快。 -O2 选项告诉GCC 产生尽可能小和尽可能快的代码。 如-O2，-O3，-On（n 常为0—3）；-O  主要进行跳转和延迟退栈两种优化；-O2 除了完成-O1的优化之外，还进行一些额外的调整工作，如指令调整等。-O3 则包括循环展开和其他一些与处理特性相关的优化工作。选项将使编译的速度比使用 -O 时慢， 但通常产生的代码执行速度会更快。</li>
<li>调试选项-g和-pg。-g 选项告诉 GCC 产生能被 GNU 调试器使用的调试信息以便调试你的程序。GCC 提供了一个很多其他 C 编译器里没有的特性, 在 GCC 里你能使-g 和 -O (产生优化代码)联用。-pg 选项告诉 GCC 在编译好的程序里加入额外的代码。运行程序时, 产生 gprof 用的剖析信息以显示你的程序的耗时情况。</li>
<li>-l参数和-L参数。-l参数就是用来指定程序要链接的库，-l参数紧接着就是库名，那么库名跟真正的库文件名有什么关系呢？就拿数学库来说，他的库名是m，他的库文件名是libm.so，很容易看出，把库文件名的头lib和尾.so去掉就是库名了。如：<code>gcc  xxx.c   -lm( 动态数学库)  -lpthread</code></li>
</ol>
<p>好了现在我们知道怎么得到库名了，比如我们自已要用到一个第三方提供的库名字叫libtest.so，那么我们只要把libtest.so拷贝到 /usr/lib里，编译时加上-ltest参数，我们就能用上libtest.so库了（当然要用libtest.so库里的函数，我们还需要与 libtest.so配套的头文件）。放在/lib和/usr/lib和/usr/local/lib里的库直接用-l参数就能链接了，但如果库文件没放在这三个目录里，而是放在其他目录里， 这时我们只用-l参数的话，链接还是会出错，出错信息大概是：“/usr/bin/ld: cannot find-lxxx”，也就是链接 程序ld在那3个目录里找不到libxxx.so，这时另外一个参数-L就派上用场了，比如常用的X11的库，它放在/usr/X11R6/lib目录 下，我们编译时就要用-L/usr/X11R6/lib -lX11参数，-L参数跟着的是库文件所在的目录名。再比如我们把libtest.so放在/aaa/bbb/ccc目录下，那链接参数就是-L/aaa/bbb/ccc -ltest</p>
<p>另外，大部分libxxxx.so只是一个链接，以RH9为例，比如libm.so它链接到/lib/libm.so.x，/lib/libm.so.6 又链接到/lib/libm-2.3.2.so，如果没有这样的链接，还是会出错，因为ld只会找libxxxx.so，所以如果你要用到xxxx库，而只有libxxxx.so.x或者libxxxx-x.x.x.so，做一个链接就可以了ln -s libxxxx-x.x.x.so libxxxx.so手工来写链接参数总是很麻烦的，还好很多库开发包提供了生成链接参数的程序，名字一般叫xxxx-config，一般放在/usr/bin目录下，比如 gtk1.2的链接参数生成程序是gtk-config，执行gtk-config —libs就能得到以下输出”-L/usr/lib -L/usr/X11R6/lib -lgtk -lgdk -rdynamic -lgmodule -lglib -ldl -lXi -lXext -lX11 -lm”，这就是编译一个gtk1.2程序所需的gtk链接参数，xxx-config除了—libs参数外还有一个参数是—cflags用来生成头文件包含目录的，也就是-I参数，在下面我们将会讲到。你可以试试执行gtk-config —libs —cflags，看看输出结果。</p>
<p>现在的问题就是怎样用这些输出结果了，最笨的方法就是复制粘贴或者照抄，聪明的办法是在编译命令行里加入这个<code>xxxx-config --libs --cflags</code>，比如编译一个gtk程序：gcc gtktest.c <code>gtk-config --libs --cflags</code>这样差不多了。注意`不是单引号，而是1键左边那个键。</p>
<p>除了xxx-config以外，现在新的开发包一般都用pkg-config来生成链接参数，使用方法跟xxx-config类似，但xxx-config是针对特定的开发包，但pkg-config包含很多开发包的链接参数的生成，用pkg-config —list-all命令可以列出所支持的所有开发包，pkg-config的用法就是pkg-config pagName —libs —cflags，其中pagName是包名，是pkg-config—list-all里列出名单中的一个，比如gtk1.2的名字就是gtk+， pkg-config gtk+ —libs —cflags的作用跟gtk-config —libs —cflags是一样的。比如：</p>
<p>gcc gtktest.c <code>pkg-config gtk+ --libs --cflags</code>。</p>
<p>8） -include和-I参数</p>
<p>-include用来包含头文件，但一般情况下包含头文件都在源码里用＃i nclude xxxxxx实现，-include参数很少用。-I参数是用来指定头文件目录，/usr/include目录一般是不用指定的，gcc知道去那里找，但 是如果头文件不在/usr/icnclude里我们就要用-I参数指定了，比如头文件放在/myinclude目录里，那编译命令行就要加上-I/myinclude参数了，如果不加你会得到一个”xxxx.h: No such file or directory”的错误。-I参数可以用相对路径，比如头文件在当前目录，可以用-I.来指定。上面我们提到的—cflags参数就是用来生成-I参数的。</p>
<p>9）-Wall、-w 和 -v参数</p>
<ul>
<li>-Wall 打印出gcc提供的警告信息</li>
<li>-w     关闭所有警告信息</li>
<li>-v      列出所有编译步骤</li>
</ul>
<p>10) -m64 64位</p>
<p>11) -shared 将-fPIC生成的位置无关的代码作为动态库，一般情况下，-fPIC和-shared都是一起使用的。生成SO文件，共享库<br>    -static 此选项将禁止使用动态库，所以，编译出来的东西，一般都很大，也不需要什么动态连接库，就可以运行</p>
<h1 id="几个相关的环境变量"><a href="#几个相关的环境变量" class="headerlink" title="几个相关的环境变量"></a>几个相关的环境变量</h1><p>PKG_CONFIG_PATH：用来指定pkg-config用到的pc文件的路径，默认是/usr/lib/pkgconfig，pc文件是文本文件，扩展名是.pc，里面定义开发包的安装路径，Libs参数和Cflags参数等等。</p>
<ul>
<li>CC：用来指定c编译器。</li>
<li>CXX：用来指定cxx编译器。</li>
<li>LIBS：跟上面的—libs作用差不多。</li>
<li>CFLAGS:跟上面的—cflags作用差不多。</li>
<li>CC，CXX，LIBS，CFLAGS手动编译时一般用不上，在做configure时有时用到，一般情况下不用管。</li>
</ul>
<p>环境变量设定方法：export  ENV_NAME=xxxxxxxxxxxxxxxxx</p>
<h1 id="关于交叉编译"><a href="#关于交叉编译" class="headerlink" title="关于交叉编译"></a>关于交叉编译</h1><p>交叉编译通俗地讲就是在一种平台上编译出能运行在体系结构不同的另一种平台上，比如在我们地PC平台(X86 CPU)上编译出能运行在arm CPU平台上的程序，编译得到的程序在X86 CPU平台上是不能运行的，必须放到arm  CPU 平台上才能运行。当然两个平台用的都是linux。这种方法在异平台移植和嵌入式开发时用得非常普遍。相对与交叉编译，我们平常做的编译就叫本地编译，也 就是在当前平台编译，编译得到的程序也是在本地执行。用来编译这种程序的编译器就叫交叉编译器，相对来说，用来做本地编译的就叫本地编译器，一般用的都是gcc，但这种gcc跟本地的gcc编译器是不一样的，需要在编译gcc时用特定的configure参数才能得到支持交叉编译的gcc。为了不跟本地编译器混淆，交叉编译器的名字一般都有前缀，比如armc-xxxx-linux-gnu-gcc，arm-xxxx-linux-gnu- g++ 等等</p>
<p>交叉编译器的使用方法</p>
<p>  使用方法跟本地的gcc差不多，但有一点特殊的是：必须用-L和-I参数指定编译器用arm系统的库和头文件，不能用本地(X86)的库（头文件有时可以用本地的）。</p>
<p>例子：</p>
<p>arm-xxxx-linux-gnu-gcc test.c -L/path/to/sparcLib -I/path/to/armInclude</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/09/管理处理器的亲和性affinity/" rel="next" title="管理处理器的亲和性（affinity）">
                <i class="fa fa-chevron-left"></i> 管理处理器的亲和性（affinity）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/09/深入理解软件包的配置、编译与安装/" rel="prev" title="深入理解软件包的配置、编译与安装">
                深入理解软件包的配置、编译与安装 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">249</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Glibc-安装指南-2-6-1-→-2-9"><span class="nav-number">1.</span> <span class="nav-text">Glibc 安装指南(2.6.1 → 2.9)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#安装信息的来源"><span class="nav-number">1.1.</span> <span class="nav-text">安装信息的来源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#要点提示"><span class="nav-number">1.2.</span> <span class="nav-text">要点提示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译与测试"><span class="nav-number">1.3.</span> <span class="nav-text">编译与测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Binutils-安装指南-2-18-→-2-19-1"><span class="nav-number">2.</span> <span class="nav-text">Binutils 安装指南(2.18 → 2.19.1)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#安装信息的来源-1"><span class="nav-number">2.1.</span> <span class="nav-text">安装信息的来源</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GCC-安装指南-4-3-→-4-4"><span class="nav-number">3.</span> <span class="nav-text">GCC 安装指南(4.3 → 4.4)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#要点提示-1"><span class="nav-number">3.1.</span> <span class="nav-text">要点提示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置选项"><span class="nav-number">3.2.</span> <span class="nav-text">配置选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译、测试、安装"><span class="nav-number">3.3.</span> <span class="nav-text">编译、测试、安装</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#优化基本原理"><span class="nav-number">4.</span> <span class="nav-text">优化基本原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#编译工具的选择"><span class="nav-number">5.</span> <span class="nav-text">编译工具的选择</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#configure-选项"><span class="nav-number">5.1.</span> <span class="nav-text">configure 选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译选项"><span class="nav-number">5.2.</span> <span class="nav-text">编译选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CC-与-CXX"><span class="nav-number">5.3.</span> <span class="nav-text">CC 与 CXX</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPPFLAGS"><span class="nav-number">5.4.</span> <span class="nav-text">CPPFLAGS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CFLAGS-与-CXXFLAGS"><span class="nav-number">5.5.</span> <span class="nav-text">CFLAGS 与 CXXFLAGS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LDFLAGS"><span class="nav-number">5.6.</span> <span class="nav-text">LDFLAGS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LANG"><span class="nav-number">5.7.</span> <span class="nav-text">LANG</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#gcc-编译流程"><span class="nav-number">6.</span> <span class="nav-text">gcc 编译流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#预处理-Pre-Processing"><span class="nav-number">6.1.</span> <span class="nav-text">预处理-Pre-Processing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译-Compiling"><span class="nav-number">6.2.</span> <span class="nav-text">编译-Compiling</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#汇编-Assembling-o文件"><span class="nav-number">6.3.</span> <span class="nav-text">汇编-Assembling         //.o文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链接-Linking-bin文件"><span class="nav-number">6.4.</span> <span class="nav-text">链接-Linking           //bin文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#gcc工程惯用"><span class="nav-number">7.</span> <span class="nav-text">gcc工程惯用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#编译"><span class="nav-number">7.1.</span> <span class="nav-text">编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用参数"><span class="nav-number">7.2.</span> <span class="nav-text">常用参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#几个相关的环境变量"><span class="nav-number">8.</span> <span class="nav-text">几个相关的环境变量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#关于交叉编译"><span class="nav-number">9.</span> <span class="nav-text">关于交叉编译</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
