<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-flash.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="原文：https://www.cnblogs.com/Commence/p/5785912.html malloc只是C标准库中提供的一个普通函数 而且很多很多人都对malloc的具体实现机制不是很了解。  关于malloc以及相关的几个函数123456#include &amp;lt;stdlib.h&amp;gt;(Linux下)void *malloc(size_t size);void free(void">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="malloc 函数详解">
<meta property="og:url" content="http://yoursite.com/2019/04/20/malloc函数详解/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="原文：https://www.cnblogs.com/Commence/p/5785912.html malloc只是C标准库中提供的一个普通函数 而且很多很多人都对malloc的具体实现机制不是很了解。  关于malloc以及相关的几个函数123456#include &amp;lt;stdlib.h&amp;gt;(Linux下)void *malloc(size_t size);void free(void">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/051536255466644.png">
<meta property="og:image" content="http://yoursite.com/img/051536281096429.png">
<meta property="og:image" content="http://yoursite.com/img/051536262965015.png">
<meta property="og:image" content="http://yoursite.com/img/051536255788401.png">
<meta property="og:image" content="http://yoursite.com/img/051536261875516.png">
<meta property="og:image" content="http://yoursite.com/img/051536258592317.png">
<meta property="og:image" content="http://yoursite.com/img/051536268121159.png">
<meta property="og:updated_time" content="2019-04-20T15:20:29.351Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="malloc 函数详解">
<meta name="twitter:description" content="原文：https://www.cnblogs.com/Commence/p/5785912.html malloc只是C标准库中提供的一个普通函数 而且很多很多人都对malloc的具体实现机制不是很了解。  关于malloc以及相关的几个函数123456#include &amp;lt;stdlib.h&amp;gt;(Linux下)void *malloc(size_t size);void free(void">
<meta name="twitter:image" content="http://yoursite.com/img/051536255466644.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/04/20/malloc函数详解/">





  <title>malloc 函数详解 | Hao Yu's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/20/malloc函数详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">malloc 函数详解</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-20T22:48:30+08:00">
                2019-04-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>原文：<a href="https://www.cnblogs.com/Commence/p/5785912.html" target="_blank" rel="noopener">https://www.cnblogs.com/Commence/p/5785912.html</a></p>
<p>malloc只是C标准库中提供的一个普通函数</p>
<p>而且很多很多人都对malloc的具体实现机制不是很了解。</p>
<ol>
<li>关于malloc以及相关的几个函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;(Linux下)</span><br><span class="line"></span><br><span class="line">void *malloc(size_t size);</span><br><span class="line">void free(void *ptr);</span><br><span class="line">void *calloc(size_t nmemb, size_t size);</span><br><span class="line">void *realloc(void *ptr, size_t size);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>也可以这样认为（window下）原型：extern void *malloc(unsigned int num_bytes);<br>头文件：#include &lt;malloc.h&gt;或者#include &lt;alloc.h&gt;两者的内容是完全一样的。</p>
<p>如果分配成功：则返回指向被分配内存空间的指针，不然，返回空指针NULL。当内存不再使用的时候，应使用free（）函数将内存块释放掉。void <em>,表示未确定类型的指针。C，C++规定，void </em>类型可以强转为任何其他类型的的指针。</p>
<p>malloc returns a void pointer to the allocated space, or NULL if there is insufficient memory available. To return a pointer to a type other than void, use a type cast on the return value. The storage space pointed to by the return value is guaranteed to be suitably aligned for storage of any type of object. If size is 0, malloc allocates a zero-length item in the heap and returns a valid pointer to that item. Always check the return from malloc, even if the amount of memory requested is small.</p>
<p>关于void *的其他说法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void * p1;</span><br><span class="line">int *p2;</span><br><span class="line">p1 = p2;</span><br></pre></td></tr></table></figure></p>
<p>就是说其他任意类型都可以直接赋值给它，无需进行强转，但是反过来不可以。</p>
<p>malloc：</p>
<ul>
<li>malloc分配的内存大小至少为size参数所指定的字节数</li>
<li>malloc的返回值是一个指针，指向一段可用内存的起始地址</li>
<li>多次调用malloc所分配的地址不能有重叠部分，除非某次malloc所分配的地址被释放掉</li>
<li>malloc应该尽快完成内存分配并返回（不能使用NP-hard的内存分配算法）</li>
<li>实现malloc时应同时实现内存大小调整和内存释放函数（realloc和free）</li>
</ul>
<p>malloc和free函数是配对的，如果申请后不释放就是内存泄露;如果无故释放那就是什么都没有做，释放只能释放一次，如果释放两次及两次以上会出现错误（但是释放空指针例外，释放空指针其实也等于什么都没有做，所以，释放多少次都是可以的）</p>
<ol start="2">
<li>malloc和new </li>
</ol>
<p>new返回指定类型的指针，并且可以自动计算所需要的大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int *p;</span><br><span class="line">p = new int;   //返回类型为int *类型，分配的大小为sizeof(int)</span><br><span class="line">p = new int[100];    //返回类型为int *类型，分配的大小为sizeof(int) * 100</span><br></pre></td></tr></table></figure></p>
<p>而malloc则必须由我们计算字节数，并且在返回的时候强转成实际指定类型的指针。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *p;</span><br><span class="line">p = (int *)malloc(sizeof(int));</span><br></pre></td></tr></table></figure></p>
<ol>
<li>malloc的返回是void <em>,如果我们写成了: p = malloc(sizeof(int));间接的说明了（将void </em>转化给了int *,这不合理）</li>
<li>malloc的实参是sizeof(int),用于指明一个整形数据需要的大小，如果我们写成：<code>p =  （int *）malloc(1)</code>,那么可以看出：只是申请了一个字节的空间，如果向里面存放了一个整数的话，将会占用额外的3个字节，可能会改变原有内存空间中的数据；</li>
<li>malloc只管分配内存，并不能对其进行初始化，所以得到的一片新内存中，其值将是随机的。一般意义上：我们习惯性的将其初始化为NULL。当然,也可以用memset函数的。</li>
</ol>
<p>简单的说：</p>
<p>malloc 函数其实就是在内存中：找一片指定大小的空间，然后将这个空间的首地址给一个指针变量，这里的指针变量可以是一个单独的指针，也可以是一个数组的首地址， 这要看malloc函数中参数size的具体内容。我们这里malloc分配的内存空间在逻辑上是连续的，而在物理上可以不连续。我们作为程序员，关注的 是逻辑上的连续，其它的，操作系统会帮着我们处理的。</p>
<p>下面我们聊聊malloc的具体实现机制：</p>
<h1 id="Linux内存管理"><a href="#Linux内存管理" class="headerlink" title="Linux内存管理"></a>Linux内存管理</h1><h2 id="虚拟内存地址与物理内存地址"><a href="#虚拟内存地址与物理内存地址" class="headerlink" title="虚拟内存地址与物理内存地址"></a>虚拟内存地址与物理内存地址</h2><p>为了简单，现代操作系统在处理内存地址时，普遍采用虚拟内存地址技术。即在汇编程序（或机器语言）层面，当涉及内存地址时， 都是使用虚拟内存地址。采用这种技术时，每个进程仿佛自己独享一片2N字节的内存，其中N是机器位数。例如在64位CPU和64位操作系统下，每个进程的 虚拟地址空间为264Byte。</p>
<p>这种虚拟地址空间的作用主要是简化程序的编写及方便操作系统对进程间内存的隔离管理，真实中的进程不太可能（也用不到）如此大的内存空间，实际能用到的内存取决于物理内存大小。</p>
<p>由于在机器语言层面都是采用虚拟地址，当实际的机器码程序涉及到内存操作时，需要根据当前进程运行的实际上下文将虚拟地址转换为物理内存地址，才能实现对真实内存数据的操作。这个转换一般由一个叫MMU（Memory Management Unit）的硬件完成。</p>
<h2 id="页与地址构成"><a href="#页与地址构成" class="headerlink" title="页与地址构成"></a>页与地址构成</h2><p>在现代操作系统中，不论是虚拟内存还是物理内存，都不是以字节为单位进行管理的，而是以页（Page）为单位。一个内存页是一段固定大小的连续内存地址的总称，具体到Linux中，典型的内存页大小为4096Byte（4K）。</p>
<p>所以内存地址可以分为页号和页内偏移量。下面以64位机器，4G物理内存，4K页大小为例，虚拟内存地址和物理内存地址的组成如下：<br><img src="/img/051536255466644.png" alt></p>
<p>上面是虚拟内存地址，下面是物理内存地址。由于页大小都是4K，所以页内便宜都是用低12位表示，而剩下的高地址表示页号。</p>
<p>MMU映射单位并不是字节，而是页，这个映射通过查一个常驻内存的数据结构页表来实现。现在计算机具体的内存地址映射比较复杂，为了加快速度会引入一系列缓存和优化，例如TLB等机制。下面给出一个经过简化的内存地址翻译示意图，虽然经过了简化，但是基本原理与现代计算机真实的情况的一致的。<br><img src="/img/051536281096429.png" alt></p>
<h2 id="内存页与磁盘页"><a href="#内存页与磁盘页" class="headerlink" title="内存页与磁盘页"></a>内存页与磁盘页</h2><p>我们知道一般将内存看做磁盘的的缓存，有时MMU在工作时，会发现页表表明某个内存页不在物理内存中，此时会触发一个缺页异 常（Page Fault），此时系统会到磁盘中相应的地方将磁盘页载入到内存中，然后重新执行由于缺页而失败的机器指令。关于这部分，因为可以看做对malloc实现 是透明的，所以不再详细讲述，有兴趣的可以参考《深入理解计算机系统》相关章节。<br>附上一张在维基百科找到的更加符合真实地址翻译的流程供大家参考，这张图加入了TLB和缺页异常的流程。<br><img src="/img/051536262965015.png" alt></p>
<h1 id="Linux进程级内存管理"><a href="#Linux进程级内存管理" class="headerlink" title="Linux进程级内存管理"></a>Linux进程级内存管理</h1><h2 id="内存排布"><a href="#内存排布" class="headerlink" title="内存排布"></a>内存排布</h2><p>明白了虚拟内存和物理内存的关系及相关的映射机制，下面看一下具体在一个进程内是如何排布内存的。</p>
<p>以Linux 64位系统为例。理论上，64bit内存地址可用空间为0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，这是个相当庞大的空间，Linux实际上只用了其中一小部分（256T）。</p>
<p>根据Linux内核相关文档描述，Linux64位操作系统仅使用低47位，高17位做扩展（只能是全0或全1）。所以，实际用到的地址为空间为0x0000000000000000 ~ 0x00007FFFFFFFFFFF和0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF，其中前面为用户空间（User Space），后者为内核空间（Kernel Space）。图示如下：<br><img src="/img/051536255788401.png" alt></p>
<p>对用户来说，主要关注的空间是User Space。将User Space放大后，可以看到里面主要分为如下几段：</p>
<ul>
<li>Code：这是整个用户空间的最低地址部分，存放的是指令（也就是程序所编译成的可执行机器码）</li>
<li>Data：这里存放的是初始化过的全局变量</li>
<li>BSS：这里存放的是未初始化的全局变量</li>
<li>Heap：堆，这是我们本文重点关注的地方，堆自低地址向高地址增长，后面要讲到的brk相关的系统调用就是从这里分配内存</li>
<li>Mapping Area：这里是与mmap系统调用相关的区域。大多数实际的malloc实现会考虑通过mmap分配较大块的内存区域，本文不讨论这种情况。这个区域自高地址向低地址增长</li>
<li>Stack：这是栈区域，自高地址向低地址增长</li>
</ul>
<h2 id="Heap内存模型"><a href="#Heap内存模型" class="headerlink" title="Heap内存模型"></a>Heap内存模型</h2><p>一般来说，malloc所申请的内存主要从Heap区域分配（本文不考虑通过mmap申请大块内存的情况）。</p>
<p>由上文知道，进程所面对的虚拟内存地址空间，只有按页映射到物理内存地址，才能真正使用。受物理存储容量限制，整个堆虚拟内存空间不可能全部映射到实际的物理内存。Linux对堆的管理示意如下：<br><img src="/img/051536261875516.png" alt></p>
<p>Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。</p>
<h2 id="brk与sbrk"><a href="#brk与sbrk" class="headerlink" title="brk与sbrk"></a>brk与sbrk</h2><p>由上文知道，要增加一个进程实际的可用堆大小，就需要将break指针向高地址移动。Linux通过brk和sbrk系统调用操作break指针。两个系统调用的原型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int brk(void *addr);</span><br><span class="line">void *sbrk(intptr_t increment);</span><br></pre></td></tr></table></figure></p>
<p>brk将break指针直接设置为某个地址，而sbrk将break从当前位置移动increment所指定的增量。brk 在执行成功时返回0，否则返回-1并设置errno为ENOMEM；sbrk成功时返回break移动之前所指向的地址，否则返回(void *)-1。</p>
<p>一个小技巧是，如果将increment设置为0，则可以获得当前break的地址。</p>
<p>另外需要注意的是，由于Linux是按页进行内存映射的，所以如果break被设置为没有按页大小对齐，则系统实际上会在最 后映射一个完整的页，从而实际已映射的内存空间比break指向的地方要大一些。但是使用break之后的地址是很危险的（尽管也许break之后确实有 一小块可用内存地址）。</p>
<h2 id="资源限制与rlimit"><a href="#资源限制与rlimit" class="headerlink" title="资源限制与rlimit"></a>资源限制与rlimit</h2><p>　　系统对每一个进程所分配的资源不是无限的，包括可映射的内存空间，因此每个进程有一个rlimit表示当前进程可用的资源上限。这个限制可以通过getrlimit系统调用得到，下面代码获取当前进程虚拟内存空间的rlimit：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">    struct rlimit *limit = (struct rlimit *)malloc(sizeof(struct rlimit));</span><br><span class="line">    getrlimit(RLIMIT_AS, limit);</span><br><span class="line">    printf(&quot;soft limit: %ld, hard limit: %ld\n&quot;, limit-&gt;rlim_cur, limit-&gt;rlim_max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中rlimit是一个结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct rlimit &#123;</span><br><span class="line">rlim_t rlim_cur; /* Soft limit */</span><br><span class="line">rlim_t rlim_max; /* Hard limit (ceiling for rlim_cur) */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>每种资源有软限制和硬限制，并且可以通过setrlimit对rlimit进行有条件设置。其中硬限制作为软限制的上限，非特权进程只能设置软限制，且不能超过硬限制。</p>
<h1 id="实现malloc"><a href="#实现malloc" class="headerlink" title="实现malloc"></a>实现malloc</h1><h2 id="玩具实现"><a href="#玩具实现" class="headerlink" title="玩具实现"></a>玩具实现</h2><p>在正式开始讨论malloc的实现前，我们可以利用上述知识实现一个简单但几乎没法用于真实的玩具malloc，权当对上面知识的复习：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* 一个玩具malloc */</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">void *malloc(size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    void *p;</span><br><span class="line">    p = sbrk(0);</span><br><span class="line">    if (sbrk(size) == (void *)-1)</span><br><span class="line">        return NULL;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个malloc每次都在当前break的基础上增加size所指定的字节数，并将之前break的地址返回。这个malloc由于对所分配的内存缺乏记录，不便于内存释放，所以无法用于真实场景。</p>
<h2 id="正式实现"><a href="#正式实现" class="headerlink" title="正式实现"></a>正式实现</h2><p>下面严肃点讨论malloc的实现方案。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>首先我们要确定所采用的数据结构。一个简单可行方案是将堆内存空间以块（Block）的形式组织起来，每个块由meta区和 数据区组成，meta区记录数据块的元信息（数据区大小、空闲标志位、指针等等），数据区是真实分配的内存区域，并且数据区的第一个字节地址即为 malloc返回的地址。</p>
<p>可以用如下结构体定义一个block：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct s_block *t_block;</span><br><span class="line">struct s_block &#123;</span><br><span class="line">    size_t size; /* 数据区大小 */</span><br><span class="line">    t_block next; /* 指向下个块的指针 */</span><br><span class="line">    int free; /* 是否是空闲块 */</span><br><span class="line">    int padding; /* 填充4字节，保证meta块长度为8的倍数 */</span><br><span class="line">    char data[1] /* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>　　由于我们只考虑64位机器，为了方便，我们在结构体最后填充一个int，使得结构体本身的长度为8的倍数，以便内存对齐。示意图如下：<br><img src="/img/051536258592317.png" alt></p>
<h3 id="寻找合适的block"><a href="#寻找合适的block" class="headerlink" title="寻找合适的block"></a>寻找合适的block</h3><p>现在考虑如何在block链中查找合适的block。一般来说有两种查找算法：</p>
<p>First fit：从头开始，使用第一个数据区大小大于要求size的块所谓此次分配的块<br>Best fit：从头开始，遍历所有块，使用数据区大小大于size且差值最小的块作为此次分配的块<br>　　两种方法各有千秋，best fit具有较高的内存使用率（payload较高），而first fit具有更好的运行效率。这里我们采用first fit算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* First fit */</span><br><span class="line">t_block find_block(t_block *last, size_t size) &#123;</span><br><span class="line">t_block b = first_block;</span><br><span class="line">while(b &amp;&amp; !(b-&gt;free &amp;&amp; b-&gt;size &gt;= size)) &#123;</span><br><span class="line">    *last = b;</span><br><span class="line">    b = b-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>find_block从frist_block开始，查找第一个符合要求的block并返回block起始地址，如果找不到 这返回NULL。这里在遍历时会更新一个叫last的指针，这个指针始终指向当前遍历的block。这是为了如果找不到合适的block而开辟新 block使用的，具体会在接下来的一节用到。</p>
<h3 id="开辟新的block"><a href="#开辟新的block" class="headerlink" title="开辟新的block"></a>开辟新的block</h3><p>如果现有block都不能满足size的要求，则需要在链表最后开辟一个新的block。这里关键是如何只使用sbrk创建一个struct：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define BLOCK_SIZE 24 /* 由于存在虚拟的data字段，sizeof不能正确计算meta长度，这里手工设置 */</span><br><span class="line"> </span><br><span class="line">t_block extend_heap(t_block last, size_t s) &#123;</span><br><span class="line">    t_block b;</span><br><span class="line">    b = sbrk(0);</span><br><span class="line">    if(sbrk(BLOCK_SIZE + s) == (void *)-1)</span><br><span class="line">        return NULL;  </span><br><span class="line">    b-&gt;size = s;</span><br><span class="line">    b-&gt;next = NULL;</span><br><span class="line">    if(last)</span><br><span class="line">        last-&gt;next = b;</span><br><span class="line">    b-&gt;free = 0;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="分裂block"><a href="#分裂block" class="headerlink" title="分裂block"></a>分裂block</h3><p>First fit有一个比较致命的缺点，就是可能会让很小的size占据很大的一块block，此时，为了提高payload，应该在剩余数据区足够大的情况下，将其分裂为一个新的block，示意如下：<br><img src="/img/051536268121159.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void split_block(t_block b, size_t s) &#123;</span><br><span class="line">    t_block new;</span><br><span class="line">    new = b-&gt;data + s;</span><br><span class="line">    new-&gt;size = b-&gt;size - s - BLOCK_SIZE ;</span><br><span class="line">    new-&gt;next = b-&gt;next;</span><br><span class="line">    new-&gt;free = 1;</span><br><span class="line">    b-&gt;size = s;</span><br><span class="line">    b-&gt;next = new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="malloc的实现"><a href="#malloc的实现" class="headerlink" title="malloc的实现"></a>malloc的实现</h3><p>有了上面的代码，我们可以利用它们整合成一个简单但初步可用的malloc。注意首先我们要定义个block链表的头first_block，初始化为NULL；另外，我们需要剩余空间至少有BLOCK_SIZE + 8才执行分裂操作。</p>
<p>由于我们希望malloc分配的数据区是按8字节对齐，所以在size不为8的倍数时，我们需要将size调整为大于size的最小的8的倍数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">size_t align8(size_t s) &#123;</span><br><span class="line">    if(s &amp; 0x7 == 0)</span><br><span class="line">        return s;</span><br><span class="line">    return ((s &gt;&gt; 3) + 1) &lt;&lt; 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#define BLOCK_SIZE 24</span><br><span class="line">void *first_block=NULL;</span><br><span class="line"> </span><br><span class="line">/* other functions... */</span><br><span class="line"> </span><br><span class="line">void *malloc(size_t size) &#123;</span><br><span class="line">    t_block b, last;</span><br><span class="line">    size_t s;</span><br><span class="line">    /* 对齐地址 */</span><br><span class="line">    s = align8(size);</span><br><span class="line">    if(first_block) &#123;</span><br><span class="line">        /* 查找合适的block */</span><br><span class="line">        last = first_block;</span><br><span class="line">        b = find_block(&amp;last, s);</span><br><span class="line">    if(b) &#123;</span><br><span class="line">        /* 如果可以，则分裂 */</span><br><span class="line">        if ((b-&gt;size - s) &gt;= ( BLOCK_SIZE + 8))</span><br><span class="line">            split_block(b, s);</span><br><span class="line">        b-&gt;free = 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        /* 没有合适的block，开辟一个新的 */</span><br><span class="line">        b = extend_heap(last, s);</span><br><span class="line">        if(!b)</span><br><span class="line">            return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        b = extend_heap(NULL, s);</span><br><span class="line">        if(!b)</span><br><span class="line">            return NULL;</span><br><span class="line">        first_block = b;</span><br><span class="line">    &#125;</span><br><span class="line">    return b-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="calloc的实现"><a href="#calloc的实现" class="headerlink" title="calloc的实现"></a>calloc的实现</h3><p>有了malloc，实现calloc只要两步：</p>
<ol>
<li>malloc一段内存</li>
<li>将数据区内容置为0<br>由于我们的数据区是按8字节对齐的，所以为了提高效率，我们可以每8字节一组置0，而不是一个一个字节设置。我们可以通过新建一个size_t指针，将内存区域强制看做size_t类型来实现。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void *calloc(size_t number, size_t size) &#123;</span><br><span class="line">    size_t *new;</span><br><span class="line">    size_t s8, i;</span><br><span class="line">    new = malloc(number * size);</span><br><span class="line">    if(new) &#123;</span><br><span class="line">        s8 = align8(number * size) &gt;&gt; 3;</span><br><span class="line">        for(i = 0; i &lt; s8; i++)</span><br><span class="line">        new[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="free的实现"><a href="#free的实现" class="headerlink" title="free的实现"></a>free的实现</h3><p>free的实现并不像看上去那么简单，这里我们要解决两个关键问题：</p>
<ol>
<li>如何验证所传入的地址是有效地址，即确实是通过malloc方式分配的数据区首地址</li>
<li>如何解决碎片问题<br>首先我们要保证传入free的地址是有效的，这个有效包括两方面：</li>
</ol>
<ul>
<li>地址应该在之前malloc所分配的区域内，即在first_block和当前break指针范围内</li>
<li>这个地址确实是之前通过我们自己的malloc分配的</li>
</ul>
<p>第一个问题比较好解决，只要进行地址比较就可以了，关键是第二个问题。这里有两种解决方案：一是在结构体内埋一个magic number字段，free之前通过相对偏移检查特定位置的值是否为我们设置的magic number，另一种方法是在结构体内增加一个magic pointer，这个指针指向数据区的第一个字节（也就是在合法时free时传入的地址），我们在free前检查magic pointer是否指向参数所指地址。这里我们采用第二种方案：</p>
<p>首先我们在结构体中增加magic pointer（同时要修改BLOCK_SIZE）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct s_block *t_block;</span><br><span class="line">struct s_block &#123;</span><br><span class="line">    size_t size; /* 数据区大小 */</span><br><span class="line">    t_block next; /* 指向下个块的指针 */</span><br><span class="line">    int free; /* 是否是空闲块 */</span><br><span class="line">    int padding; /* 填充4字节，保证meta块长度为8的倍数 */</span><br><span class="line">    void *ptr; /* Magic pointer，指向data */</span><br><span class="line">    char data[1] /* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后我们定义检查地址合法性的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">t_block get_block(void *p) &#123;</span><br><span class="line">    char *tmp;</span><br><span class="line">    tmp = p;</span><br><span class="line">    return (p = tmp -= BLOCK_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int valid_addr(void *p) &#123;</span><br><span class="line">    if(first_block) &#123;</span><br><span class="line">        if(p &gt; first_block &amp;&amp; p &lt; sbrk(0)) &#123;</span><br><span class="line">            return p == (get_block(p))-&gt;ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当多次malloc和free后，整个内存池可能会产生很多碎片block，这些block很小，经常无法使用，甚至出现许多碎片连在一起，虽然总体能满足某此malloc要求，但是由于分割成了多个小block而无法fit，这就是碎片问题。</p>
<p>　　一个简单的解决方式时当free某个block时，如果发现它相邻的block也是free的，则将block和相邻block合并。为了满足这个实现，需要将s_block改为双向链表。修改后的block结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct s_block *t_block;</span><br><span class="line">struct s_block &#123;</span><br><span class="line">    size_t size; /* 数据区大小 */</span><br><span class="line">    t_block prev; /* 指向上个块的指针 */</span><br><span class="line">    t_block next; /* 指向下个块的指针 */</span><br><span class="line">    int free; /* 是否是空闲块 */</span><br><span class="line">    int padding; /* 填充4字节，保证meta块长度为8的倍数 */</span><br><span class="line">    void *ptr; /* Magic pointer，指向data */</span><br><span class="line">    char data[1] /* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>合并方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t_block fusion(t_block b) &#123;</span><br><span class="line">    if (b-&gt;next &amp;&amp; b-&gt;next-&gt;free) &#123;</span><br><span class="line">        b-&gt;size += BLOCK_SIZE + b-&gt;next-&gt;size;</span><br><span class="line">        b-&gt;next = b-&gt;next-&gt;next;</span><br><span class="line">        if(b-&gt;next)</span><br><span class="line">            b-&gt;next-&gt;prev = b;</span><br><span class="line">    &#125;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有了上述方法，free的实现思路就比较清晰了：首先检查参数地址的合法性，如果不合法则不做任何事；否则，将此block 的free标为1，并且在可以的情况下与后面的block进行合并。如果当前是最后一个block，则回退break指针释放进程内存，如果当前 block是最后一个block，则回退break指针并设置first_block为NULL。实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void free(void *p) &#123;</span><br><span class="line">    t_block b;</span><br><span class="line">    if(valid_addr(p)) &#123;</span><br><span class="line">        b = get_block(p);</span><br><span class="line">        b-&gt;free = 1;</span><br><span class="line">        if(b-&gt;prev &amp;&amp; b-&gt;prev-&gt;free)</span><br><span class="line">            b = fusion(b-&gt;prev);</span><br><span class="line">        if(b-&gt;next)</span><br><span class="line">            fusion(b);</span><br><span class="line">        else &#123;</span><br><span class="line">            if(b-&gt;prev)</span><br><span class="line">                b-&gt;prev-&gt;prev = NULL;</span><br><span class="line">            else</span><br><span class="line">                first_block = NULL;</span><br><span class="line">            brk(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="realloc的实现"><a href="#realloc的实现" class="headerlink" title="realloc的实现"></a>realloc的实现</h3><p>为了实现realloc，我们首先要实现一个内存复制方法。如同calloc一样，为了效率，我们以8字节为单位进行复制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void copy_block(t_block src, t_block dst) &#123;</span><br><span class="line">    size_t *sdata, *ddata;</span><br><span class="line">    size_t i;</span><br><span class="line">    sdata = src-&gt;ptr;</span><br><span class="line">    ddata = dst-&gt;ptr;</span><br><span class="line">    for(i = 0; (i * 8) &lt; src-&gt;size &amp;&amp; (i * 8) &lt; dst-&gt;size; i++)</span><br><span class="line">        ddata[i] = sdata[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们开始实现realloc。一个简单（但是低效）的方法是malloc一段内存，然后将数据复制过去。但是我们可以做的更高效，具体可以考虑以下几个方面：</p>
<ul>
<li>如果当前block的数据区大于等于realloc所要求的size，则不做任何操作</li>
<li>如果新的size变小了，考虑split</li>
<li>如果当前block的数据区不能满足size，但是其后继block是free的，并且合并后可以满足，则考虑做合并</li>
</ul>
<p>下面是realloc的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void *realloc(void *p, size_t size) &#123;</span><br><span class="line">    size_t s;</span><br><span class="line">    t_block b, new;</span><br><span class="line">    void *newp;</span><br><span class="line">    if (!p)</span><br><span class="line">        /* 根据标准库文档，当p传入NULL时，相当于调用malloc */</span><br><span class="line">        return malloc(size);</span><br><span class="line">    if(valid_addr(p)) &#123;</span><br><span class="line">        s = align8(size);</span><br><span class="line">        b = get_block(p);</span><br><span class="line">        if(b-&gt;size &gt;= s) &#123;</span><br><span class="line">            if(b-&gt;size - s &gt;= (BLOCK_SIZE + 8))</span><br><span class="line">                split_block(b,s);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            /* 看是否可进行合并 */</span><br><span class="line">            if(b-&gt;next &amp;&amp; b-&gt;next-&gt;free</span><br><span class="line">            &amp;&amp; (b-&gt;size + BLOCK_SIZE + b-&gt;next-&gt;size) &gt;= s) &#123;</span><br><span class="line">                fusion(b);</span><br><span class="line">                if(b-&gt;size - s &gt;= (BLOCK_SIZE + 8))</span><br><span class="line">                    split_block(b, s);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                /* 新malloc */</span><br><span class="line">                newp = malloc (s);</span><br><span class="line">                if (!newp)</span><br><span class="line">                    return NULL;</span><br><span class="line">                new = get_block(newp);</span><br><span class="line">                copy_block(b, new);</span><br><span class="line">                free(p);</span><br><span class="line">                return(newp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return (p);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="遗留问题和优化"><a href="#遗留问题和优化" class="headerlink" title="遗留问题和优化"></a>遗留问题和优化</h2><p>以上是一个较为简陋，但是初步可用的malloc实现。还有很多遗留的可能优化点，例如：</p>
<p>同时兼容32位和64位系统<br>在分配较大快内存时，考虑使用mmap而非sbrk，这通常更高效<br>可以考虑维护多个链表而非单个，每个链表中的block大小均为一个范围内，例如8字节链表、16字节链表、24-32字节链表等等。此时可以根据size到对应链表中做分配，可以有效减少碎片，并提高查询block的速度<br>可以考虑链表中只存放free的block，而不存放已分配的block，可以减少查找block的次数，提高效率<br>还有很多可能的优化，这里不一一赘述。下面附上一些参考文献，有兴趣的同学可以更深入研究。</p>
<h1 id="其它参考"><a href="#其它参考" class="headerlink" title="其它参考"></a>其它参考</h1><p>Computer Systems: A Programmer’s Perspective, 2/E一书有许多值得参考的地方</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/20/Leetcode961-N-Repeated-Element-in-Size-2N-Array/" rel="next" title="Leetcode961. N-Repeated Element in Size 2N Array">
                <i class="fa fa-chevron-left"></i> Leetcode961. N-Repeated Element in Size 2N Array
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/21/Leetcode72-Edit-Distance/" rel="prev" title="Leetcode72. Edit Distance">
                Leetcode72. Edit Distance <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">87</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="450" src="//music.163.com/outchain/player?type=0&id=101039122&auto=0&height=430">
          </iframe>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux内存管理"><span class="nav-number">1.</span> <span class="nav-text">Linux内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟内存地址与物理内存地址"><span class="nav-number">1.1.</span> <span class="nav-text">虚拟内存地址与物理内存地址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#页与地址构成"><span class="nav-number">1.2.</span> <span class="nav-text">页与地址构成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存页与磁盘页"><span class="nav-number">1.3.</span> <span class="nav-text">内存页与磁盘页</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux进程级内存管理"><span class="nav-number">2.</span> <span class="nav-text">Linux进程级内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内存排布"><span class="nav-number">2.1.</span> <span class="nav-text">内存排布</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Heap内存模型"><span class="nav-number">2.2.</span> <span class="nav-text">Heap内存模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#brk与sbrk"><span class="nav-number">2.3.</span> <span class="nav-text">brk与sbrk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#资源限制与rlimit"><span class="nav-number">2.4.</span> <span class="nav-text">资源限制与rlimit</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实现malloc"><span class="nav-number">3.</span> <span class="nav-text">实现malloc</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#玩具实现"><span class="nav-number">3.1.</span> <span class="nav-text">玩具实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正式实现"><span class="nav-number">3.2.</span> <span class="nav-text">正式实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构"><span class="nav-number">3.2.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寻找合适的block"><span class="nav-number">3.2.2.</span> <span class="nav-text">寻找合适的block</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开辟新的block"><span class="nav-number">3.2.3.</span> <span class="nav-text">开辟新的block</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分裂block"><span class="nav-number">3.2.4.</span> <span class="nav-text">分裂block</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc的实现"><span class="nav-number">3.2.5.</span> <span class="nav-text">malloc的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#calloc的实现"><span class="nav-number">3.2.6.</span> <span class="nav-text">calloc的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free的实现"><span class="nav-number">3.2.7.</span> <span class="nav-text">free的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#realloc的实现"><span class="nav-number">3.2.8.</span> <span class="nav-text">realloc的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#遗留问题和优化"><span class="nav-number">3.3.</span> <span class="nav-text">遗留问题和优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#其它参考"><span class="nav-number">4.</span> <span class="nav-text">其它参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
