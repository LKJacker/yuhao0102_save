<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Leetcode,">










<meta name="description" content="Leetcode901. Online Stock SpanWrite a class StockSpanner which collects daily price quotes for some stock, and returns the  span  of that stock’s price for the current day. The span of the stock’s pri">
<meta name="keywords" content="Leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode901 - 950">
<meta property="og:url" content="http://yoursite.com/2019/04/26/Leetcode901_950/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Leetcode901. Online Stock SpanWrite a class StockSpanner which collects daily price quotes for some stock, and returns the  span  of that stock’s price for the current day. The span of the stock’s pri">
<meta property="og:locale" content="zn-ch">
<meta property="og:updated_time" content="2021-09-26T02:21:28.399Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode901 - 950">
<meta name="twitter:description" content="Leetcode901. Online Stock SpanWrite a class StockSpanner which collects daily price quotes for some stock, and returns the  span  of that stock’s price for the current day. The span of the stock’s pri">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/04/26/Leetcode901_950/">





  <title>Leetcode901 - 950 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/26/Leetcode901_950/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode901 - 950</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-26T20:41:39+08:00">
                2019-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Leetcode901-Online-Stock-Span"><a href="#Leetcode901-Online-Stock-Span" class="headerlink" title="Leetcode901. Online Stock Span"></a>Leetcode901. Online Stock Span</h1><p>Write a class StockSpanner which collects daily price quotes for some stock, and returns the  span  of that stock’s price for the current day.</p>
<p>The span of the stock’s price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today’s price.</p>
<p>For example, if the price of a stock over the next 7 days were [100, 80, 60, 70, 60, 75, 85], then the stock spans would be [1, 1, 1, 2, 1, 4, 6].</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;StockSpanner&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[],[100],[80],[60],[70],[60],[75],[85]]</span><br><span class="line">Output: [null,1,1,1,2,1,4,6]</span><br><span class="line">Explanation:</span><br><span class="line">First, S = StockSpanner() is initialized.  Then:</span><br><span class="line">S.next(100) is called and returns 1,</span><br><span class="line">S.next(80) is called and returns 1,</span><br><span class="line">S.next(60) is called and returns 1,</span><br><span class="line">S.next(70) is called and returns 2,</span><br><span class="line">S.next(60) is called and returns 1,</span><br><span class="line">S.next(75) is called and returns 4,</span><br><span class="line">S.next(85) is called and returns 6.</span><br></pre></td></tr></table></figure></p>
<p>Note that (for example) S.next(75) returned 4, because the last 4 prices (including today’s price of 75) were less than or equal to today’s price.</p>
<p>Note:</p>
<ul>
<li>Calls to StockSpanner.next(int price)will have 1 &lt;= price &lt;= 10^5.</li>
<li>There will be at most 10000 calls to StockSpanner.next per test case.</li>
<li>There will be at most 150000 calls to StockSpanner.next across all test cases.</li>
<li>The total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages.</li>
</ul>
<p>这道题定义了一个 StockSpanner 的类，有一个 next 函数，每次给当天的股价，让我们返回之前连续多少天都是小于等于当前股价。</p>
<p>可以找连续递增的子数组的长度么，其实也是不行的，就拿题目中的例子来说吧 [100, 80, 60, 70, 60, 75, 85]，数字 75 前面有三天是比它小的，但是这三天不是有序的，是先增后减的，那怎么办呢？我们先从简单的情况分析，假如当前的股价要小于前一天的，那么连续性直接被打破了，所以此时直接返回1就行了。但是假如大于等于前一天股价的话，情况就比较 tricky 了，因为此时所有小于等于前一天股价的天数肯定也是小于等于当前的，那么我们就需要知道是哪一天的股价刚好大于前一天的股价，然后用这一天的股价跟当前的股价进行比较，若大于当前股价，说明当前的连续天数就是前一天的连续天数加1，而若小于当前股价，我们又要重复这个过程，去比较刚好大于之前那个的股价。所以我们需要知道对于每一天，往前推刚好大于当前股价的是哪一天，用一个数组 pre，其中 pre[i] 表示从第i天往前推刚好大于第i天的股价的是第 pre[i] 天。接下来看如何实现 next 函数，首先将当前股价加入 nums 数组，然后前一天在数组中的位置就是 (int)nums.size()-2。再来想想 corner case 的情况，假如当前是数组中的第0天，前面没有任何股价了，我们的 pre[0] 就赋值为 -1 就行了，怎么知道当前是否是第0天，就看 pre 数组是否为空。再有就是由于i要不断去 pre 数组中找到之前的天数，所以最终i是有可能到达 pre[0] 的，那么就要判断当i为 -1 时，也要停止循环。循环的最后一个条件就是当之前的股价小于等当前的估计 price 时，才进行循环，这个前面讲过了，循环内部就是将 pre[i] 赋值给i，这样就完成了跳到之前天的操作。while 循环结束后要将i加入到 pre 数组，因为这个i就是从当前天往前推，一个大于当前股价的那一天，有了这个i，就可以计算出连续天数了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StockSpanner() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        nums.push_back(price);</span><br><span class="line">        <span class="keyword">int</span> i = (<span class="keyword">int</span>)nums.size() - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pre.empty() &amp;&amp; i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &lt;= price) &#123;</span><br><span class="line">            i = pre[i];</span><br><span class="line">        &#125;</span><br><span class="line">        pre.push_back(i);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)pre.size() - <span class="number">1</span> - i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, pre;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们还可以使用栈来做，里面放一个 pair 对儿，分别是当前的股价和之前比其小的连续天数。在 next 函数中，使用一个 cnt 变量，初始化为1。还是要个 while 循环，其实核心的本质都是一样的，循环的条件首先是栈不能为空，并且栈顶元素的股价小于等于当前股价，那么 cnt 就加上栈顶元素的连续天数，可以感受到跟上面解法在这里的些许不同之处了吧，之前是一直找到第一个大于当前股价的天数在数组中的位置，然后相减得到连续天数，这里是在找的过程中直接累加连续天数，最终都可以得到正确的结果，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StockSpanner() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!st.empty() &amp;&amp; st.top().first &lt;= price) &#123;</span><br><span class="line">            cnt += st.top().second; st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        st.push(&#123;price, cnt&#125;);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; st;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode904-Fruit-Into-Baskets"><a href="#Leetcode904-Fruit-Into-Baskets" class="headerlink" title="Leetcode904. Fruit Into Baskets"></a>Leetcode904. Fruit Into Baskets</h1><p>In a row of trees, the i-th tree produces fruit with type tree[i].</p>
<p>You start at any tree of your choice, then repeatedly perform the following steps:</p>
<p>Add one piece of fruit from this tree to your baskets.  If you cannot, stop.<br>Move to the next tree to the right of the current tree.  If there is no tree to the right, stop.<br>Note that you do not have any choice after the initial choice of starting tree: you must perform step 1, then step 2, then back to step 1, then step 2, and so on until you stop.</p>
<p>You have two baskets, and each basket can carry any quantity of fruit, but you want each basket to only carry one type of fruit each.</p>
<p>What is the total amount of fruit you can collect with this procedure?</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can collect [1,2,1].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,2,2]</span><br><span class="line">Output: 3 Explanation: We can collect [1,2,2].</span><br><span class="line">If we started at the first tree, we would only collect [0, 1].</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,2,2]</span><br><span class="line">Output: 4 Explanation: We can collect [2,3,2,2].</span><br><span class="line">If we started at the first tree, we would only collect [1, 2].</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,3,3,1,2,1,1,2,3,3,4]</span><br><span class="line">Output: 5  Explanation: We can collect [1,2,1,1,2].</span><br><span class="line">If we started at the first tree or the eighth tree, we would only collect 4 fruits.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= tree.length &lt;= 40000</li>
<li>0 &lt;= tree[i] &lt; tree.length</li>
</ul>
<p>这道题说是给了我们一排树，每棵树产的水果种类是 tree[i]，说是现在有两种操作，第一种是将当前树的水果加入果篮中，若不能加则停止；第二种是移动到下一个树，若没有下一棵树，则停止。现在我们有两个果篮，可以从任意一个树的位置开始，但是必须按顺序执行操作一和二，问我们最多能收集多少个水果。说实话这道题的题目描述确实不太清晰，博主看了很多遍才明白意思，论坛上也有很多吐槽的帖子，但实际上这道题的本质就是从任意位置开始，若最多只能收集两种水果，问最多能收集多少个水果。那么再进一步提取，其实就是最多有两个不同字符的最长子串的长度，跟之前那道 Longest Substring with At Most Two Distinct Characters 一模一样，只不过换了一个背景，代码基本都可以直接使用的，博主感觉这样出题有点不太好吧，完全重复了。之前那题的四种解法这里完全都可以使用，先来看第一种，使用一个 HashMap 来记录每个水果出现次数，当 HashMap 中当映射数量超过两个的时候，我们需要删掉一个映射，做法是滑动窗口的左边界 start 的水果映射值减1，若此时减到0了，则删除这个映射，否则左边界右移一位。当映射数量回到两个的时候，用当前窗口的大小来更新结果 res 即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="built_in">vector</span>&amp; tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, start = <span class="number">0</span>, n = tree.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; fruitCnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ++fruitCnt[tree[i]];</span><br><span class="line">            <span class="keyword">while</span> (fruitCnt.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--fruitCnt[tree[start]] == <span class="number">0</span>) &#123;</span><br><span class="line">                    fruitCnt.erase(tree[start]);</span><br><span class="line">                &#125;</span><br><span class="line">                ++start;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, i - start + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们除了用 HashMap 来映射字符出现的个数，我们还可以映射每个数字最新的坐标，比如题目中的例子 [0,1,2,2]，遇到第一个0，映射其坐标0，遇到1，映射其坐标1，当遇到2时，映射其坐标2，每次我们都判断当前 HashMap 中的映射数，如果大于2的时候，那么需要删掉一个映射，我们还是从 start=0 时开始向右找，看每个字符在 HashMap 中的映射值是否等于当前坐标 start，比如0，HashMap 此时映射值为0，等于 left 的0，那么我们把0删掉，start 自增1，再更新结果，以此类推直至遍历完整个数组，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="built_in">vector</span>&amp; tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, start = <span class="number">0</span>, n = tree.size();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; fruitPos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            fruitPos[tree[i]] = i;</span><br><span class="line">            <span class="keyword">while</span> (fruitPos.size() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fruitPos[tree[start]] == start) &#123;</span><br><span class="line">                    fruitPos.erase(tree[start]);</span><br><span class="line">                &#125;</span><br><span class="line">                ++start;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, i - start + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>后来又在网上看到了一种解法，这种解法是维护一个滑动窗口 sliding window，指针 left 指向起始位置，right 指向 window 的最后一个位置，用于定位 left 的下一个跳转位置，思路如下：</p>
<ul>
<li>若当前字符和前一个字符相同，继续循环。</li>
<li>若不同，看当前字符和 right 指的字符是否相同：</li>
<li>若相同，left 不变，右边跳到 i - 1。</li>
<li>若不同，更新结果，left 变为 right+1，right 变为 i - 1。</li>
</ul>
<p>最后需要注意在循环结束后，我们还要比较结果 res 和 n - left 的大小，返回大的，这是由于如果数组是 [5,3,5,2,1,1,1]，那么当 left=3 时，i=5,6 的时候，都是继续循环，当i加到7时，跳出了循环，而此时正确答案应为 [2,1,1,1] 这4个数字，而我们的结果 res 只更新到了 [5,3,5] 这3个数字，所以我们最后要判断 n - left 和结果 res 的大小。</p>
<p>另外需要说明的是这种解法仅适用于于不同字符数为2个的情况，如果为k个的话，还是需要用上面两种解法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">0</span>, right = <span class="number">-1</span>, n = tree.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree[i] == tree[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &gt;= <span class="number">0</span> &amp;&amp; tree[right] != tree[i]) &#123;</span><br><span class="line">                res = max(res, i - left);</span><br><span class="line">                left = right + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            right = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(n - left, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>还有一种不使用 HashMap 的解法，这里我们使用若干个变量，其中 cur 为当前最长子数组的长度，a和b为当前候选的两个不同的水果种类，cntB 为水果b的连续个数。我们遍历所有数字，假如遇到的水果种类是a和b中的任意一个，那么 cur 可以自增1，否则 cntB 自增1，因为若是新水果种类的话，默认已经将a种类淘汰了，此时候选水果由类型b和这个新类型水果构成，所以当前长度是 cntB+1。然后再来更新 cntB，假如当前水果种类是b的话，cntB 自增1，否则重置为1，因为 cntB 统计的就是水果种类b的连续个数。然后再来判断，若当前种类不是b，则此时a赋值为b， b赋值为新种类。最后不要忘了用 cur 来更新结果 res，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalFruit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, cur = <span class="number">0</span>, cntB = <span class="number">0</span>, a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fruit : tree) &#123;</span><br><span class="line">            cur = (fruit == a || fruit == b) ? cur + <span class="number">1</span> : cntB + <span class="number">1</span>;</span><br><span class="line">            cntB = (fruit == b) ? cntB + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (b != fruit) &#123;</span><br><span class="line">                a = b; b = fruit;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode905-Sort-Array-By-Parity"><a href="#Leetcode905-Sort-Array-By-Parity" class="headerlink" title="Leetcode905. Sort Array By Parity"></a>Leetcode905. Sort Array By Parity</h1><p>Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A.</p>
<p>You may return any answer array that satisfies this condition.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,2,4]</span><br><span class="line">Output: [2,4,3,1]</span><br><span class="line">The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= A.length &lt;= 5000<br>0 &lt;= A[i] &lt;= 5000</p>
<p>将奇数和偶数分类。。。简单</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortArrayByParity(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] % <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; A.size(); j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(A[j] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">int</span> temp = A[j];</span><br><span class="line">                        A[j] = A[i];</span><br><span class="line">                        A[i] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode908-Smallest-Range-I"><a href="#Leetcode908-Smallest-Range-I" class="headerlink" title="Leetcode908. Smallest Range I"></a>Leetcode908. Smallest Range I</h1><p>Given an array A of integers, for each integer A[i] we may choose any x with -K &lt;= x &lt;= K, and add x to A[i]. After this process, we have some array B. Return the smallest possible difference between the maximum value of B and the minimum value of B.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1], K = 0</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: B = [1]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [0,10], K = 2</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: B = [2,8]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,3,6], K = 3</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: B = [3,3,3] or B = [4,4,4]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 10000</li>
<li>0 &lt;= A[i] &lt;= 10000</li>
<li>0 &lt;= K &lt;= 10000</li>
</ul>
<p>给了一个非负数的数组，和一个非负数K，说是数组中的每一个数字都可以加上 [-K, K] 范围内的任意一个数字，问新数组的最大值最小值之间的差值最小是多少。这道题的难度是 Easy，理论上应该是可以无脑写代码的，但其实很容易想的特别复杂。本题的解题标签是 Math，这种类型的题目基本上就是一种脑筋急转弯的题目，有时候一根筋转不过来就怎么也做不出来。首先来想，既然是要求新数组的最大值和最小值之间的关系，那么肯定是跟原数组的最大值最小值有着某种联系，原数组的最大值最小值我们可以很容易的得到，只要找出了跟新数组之间的联系，问题就能迎刃而解了。题目中说了每个数字都可以加上 [-K, K] 范围内的数字，当然最大值最小值也可以，如何让二者之间的差值最小呢？当然是让最大值尽可能变小，最小值尽可能变大了，所以最大值 mx 要加上 -K，而最小值 mn 要加上K，然后再做减法，即 (mx-K)-(mn+K) = mx-mn+2K，这就是要求的答案啦。</p>
<p>只要找到数组A 最大值和最小值的差，然后和2k比较即可得到结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">smallestRangeI</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// find max and min</span></span><br><span class="line">        <span class="keyword">int</span> maxx = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> minn = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;maxx)</span><br><span class="line">                maxx = A[i];</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;minn)</span><br><span class="line">                minn = A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minn+K &gt;= maxx-K)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> maxx - minn - <span class="number">2</span> * K;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode909-Snakes-and-Ladders"><a href="#Leetcode909-Snakes-and-Ladders" class="headerlink" title="Leetcode909. Snakes and Ladders"></a>Leetcode909. Snakes and Ladders</h1><p>On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row.  For example, for a 6 x 6 board, the numbers are written as follows:</p>
<p>You start on square 1 of the board (which is always in the last row and first column).  Each move, starting from square x, consists of the following:</p>
<ul>
<li>You choose a destination square S with number x+1, x+2, x+3, x+4, x+5, or x+6, provided this number is &lt;= N*N.<br>(This choice simulates the result of a standard 6-sided die roll: ie., there are always at most 6 destinations, regardless of the size of the board.)</li>
<li>If S has a snake or ladder, you move to the destination of that snake or ladder.  Otherwise, you move to S.</li>
</ul>
<p>A board square on row r and column c has a “snake or ladder” if board[r][c] != -1.  The destination of that snake or ladder is board[r][c].</p>
<p>Note that you only take a snake or ladder at most once per move: if the destination to a snake or ladder is the start of another snake or ladder, you do not continue moving.  (For example, if the board is [[4,-1],[-1,3]], and on the first move your destination square is 2, then you finish your first move at 3, because you do notcontinue moving to 4.)</p>
<p>Return the least number of moves required to reach square N*N.  If it is not possible, return -1.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Input: [</span><br><span class="line">[-1,-1,-1,-1,-1,-1],</span><br><span class="line">[-1,-1,-1,-1,-1,-1],</span><br><span class="line">[-1,-1,-1,-1,-1,-1],</span><br><span class="line">[-1,35,-1,-1,13,-1],</span><br><span class="line">[-1,-1,-1,-1,-1,-1],</span><br><span class="line">[-1,15,-1,-1,-1,-1]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation:</span><br><span class="line">At the beginning, you start at square 1 [at row 5, column 0].</span><br><span class="line">You decide to move to square 2, and must take the ladder to square 15.</span><br><span class="line">You then decide to move to square 17 (row 3, column 5), and must take the snake to square 13.</span><br><span class="line">You then decide to move to square 14, and must take the ladder to square 35.</span><br><span class="line">You then decide to move to square 36, ending the game.</span><br><span class="line">It can be shown that you need at least 4 moves to reach the N*N-th square, so the answer is 4.</span><br></pre></td></tr></table></figure></p>
<p>这道题给了一个 NxN 大小的二维数组，从左下角从1开始，蛇形游走，到左上角或者右上角到数字为 NxN，中间某些位置会有梯子，就如同传送门一样，直接可以到达另外一个位置。现在就如同玩大富翁 Big Rich Man 一样，有一个骰子，可以走1到6内的任意一个数字，现在奢侈一把，有无限个遥控骰子，每次都可以走1到6以内指定的步数，问最小能用几步快速到达终点 NxN 位置。博主刚开始做这道题的时候，看是求极值，以为是一道动态规划 Dynamic Programming 的题，结果发现木有办法重现子问题，没法写出状态转移方程，只得作罢。但其实博主忽略了一点，求最小值还有一大神器，广度优先搜索 BFS，最直接的应用就是在迷宫遍历的问题中，求从起点到终点的最少步数，也可以用在更 general 的场景，只要是存在确定的状态转移的方式，可能也可以使用。这道题基本就是类似迷宫遍历的问题，可以走的1到6步可以当作六个方向，这样就可以看作是一个迷宫了，唯一要特殊处理的就是遇见梯子的情况，要跳到另一个位置。这道题还有另一个难点，就是数字标号和数组的二维坐标的转换，这里起始点是在二维数组的左下角，且是1，而代码中定义的二维数组的 (0, 0) 点是在左上角，需要转换一下，还有就是这道题的数字是蛇形环绕的，即当行号是奇数的时候，是从右往左遍历的，转换的时候要注意一下。</p>
<p>初始时将数字1放入，然后还需要一个 visited 数组，大小为 nxn+1。在 while 循环中进行层序遍历，取出队首数字，判断若等于 nxn 直接返回结果 res。否则就要遍历1到6内的所有数字i，则 num+i 就是下一步要走的距离，需要将其转为数组的二维坐标位置，这个操作放到一个单独的子函数中，后边再讲。有了数组的坐标，就可以看该位置上是否有梯子，有的话，需要换成梯子能到达的位置，没有的话还是用 num+i。有了下一个位置，再看 visited 中的值，若已经访问过了直接跳过，否则标记为 true，并且加入队列 queue 中即可，若 while 循环退出了，表示无法到达终点，返回 -1。将数字标号转为二维坐标位置的子函数也不算难，首先应将数字标号减1，因为这里是从1开始的，而代码中的二维坐标是从0开始的，然后除以n得到横坐标，对n取余得到纵坐标。但这里得到的横纵坐标都还不是正确的，因为前面说了数字标记是蛇形环绕的，当行号是奇数的时候，列数需要翻转一下，即用 n-1 减去当前列数。又因为代码中的二维数组起点位置在左上角，同样需要翻转一样，这样得到的才是正确的横纵坐标，返回即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">snakesAndLadders</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = board.size(), res = <span class="number">0</span>;</span><br><span class="line">        len = len*len;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q&#123;&#123;<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(len + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s; i ++) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span> (num == len)</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span> &amp;&amp; num + i &lt;= len; ++i) &#123;</span><br><span class="line">                    <span class="keyword">int</span> next = getBoardValue(board, num + i);</span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="number">-1</span>) next = num + i;</span><br><span class="line">                    <span class="keyword">if</span> (visited[next]) <span class="keyword">continue</span>;</span><br><span class="line">                    visited[next] = <span class="literal">true</span>;</span><br><span class="line">                    q.push(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getBoardValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = board.size(), x = (i - <span class="number">1</span>) / len, y = (i - <span class="number">1</span>) % len;</span><br><span class="line">        <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">1</span>) y = len - <span class="number">1</span> - y;</span><br><span class="line">        x = len - <span class="number">1</span> - x;</span><br><span class="line">        <span class="keyword">return</span> board[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode911-Online-Election"><a href="#Leetcode911-Online-Election" class="headerlink" title="Leetcode911. Online Election"></a>Leetcode911. Online Election</h1><p>In an election, the i-th vote was cast for <code>persons[i]</code> at time <code>times[i]</code>.</p>
<p>Now, we would like to implement the following query function: <code>TopVotedCandidate.q(int t)</code> will return the number of the person that was leading the election at time t.</p>
<p>Votes cast at time t will count towards our query.  In the case of a tie, the most recent vote (among tied candidates) wins.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;TopVotedCandidate&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;,&quot;q&quot;], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]]</span><br><span class="line">Output: [null,0,1,1,0,0,1]</span><br><span class="line">Explanation:</span><br><span class="line">At time 3, the votes are [0], and 0 is leading.</span><br><span class="line">At time 12, the votes are [0,1,1], and 1 is leading.</span><br><span class="line">At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)</span><br><span class="line">This continues for 3 more queries at time 15, 24, and 8.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= persons.length = times.length &lt;= 5000</li>
<li>0 &lt;= persons[i] &lt;= persons.length</li>
<li>times is a strictly increasing array with all elements in [0, 10^9].</li>
<li><code>TopVotedCandidate.q</code> is called at most 10000 times per test case.</li>
<li><code>TopVotedCandidate.q(int t)</code> is always called with t &gt;= times[0].</li>
</ul>
<p>这道题是关于线上选举的问题，这里给了两个数组 persons 和 times，表示在某个时间点<code>times[i]</code>，i这个人把选票投给了 <code>persons[i]</code>，现在有一个q函数，输入时间点t，让返回在时间点t时得票最多的人，当得票数相等时，返回最近得票的人。因为查询需求的时间点是任意的，在某个查询时间点可能并没有投票发生，但需要知道当前的票王，当然最傻的办法就是每次都从开头统计到当前时间点，找出票王，但这种方法大概率会超时，正确的方法实际上是要在某个投票的时间点，都统计出当前的票王，然后在查询的时候，查找刚好大于查询时间点的下一个投票时间点，返回前一个时间点的票王即可，所以这里可以使用一个 TreeMap 来建立投票时间点和当前票王之间的映射。如何统计每个投票时间点的票王呢，可以使用一个 count 数组，其中<code>count[i]</code>就表示当前i获得的票数，还需要一个变量 lead，表示当前的票王。现在就可以开始遍历所有的投票了，对于每个投票，将票数加到 count 中对应的人身上，然后跟 lead 比较，若当前人的票数大于等于 lead 的票数，则 lead 更换为当前人，同时建立当前时间点和票王之间的映射。在查询的时候，由于时间点是有序的，所以可以使用二分搜索法，由于使用的是 TreeMap，具有自动排序的功能，可以直接用<code>upper_bound</code>来查找第一个比t大的投票时间，然后再返回上一个投票时间点的票王即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopVotedCandidate</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TopVotedCandidate(<span class="built_in">vector</span>&amp; persons, <span class="built_in">vector</span>&amp; times) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = persons.size(), lead = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++count[persons[i]] &gt;= count[lead]) &#123;</span><br><span class="line">                lead = persons[i];</span><br><span class="line">            &#125;</span><br><span class="line">            m[times[i]] = lead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">q</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (--m.upper_bound(t))-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们也可以用 HashMap 来取代 TreeMap，但因为 HashMap 无法进行时间点的排序，不好使用二分搜索法了，所以就需要记录投票时间数组 times，保存在一个私有变量中。在查询函数中自己来写二分搜索法，查找第一个大于目标值的数。由于要返回上一个投票时间点，所以要记得减1，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopVotedCandidate</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TopVotedCandidate(<span class="built_in">vector</span>&amp; persons, <span class="built_in">vector</span>&amp; times) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = persons.size(), lead = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; count(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;times = times;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++count[persons[i]] &gt;= count[lead]) &#123;</span><br><span class="line">                lead = persons[i];</span><br><span class="line">            &#125;</span><br><span class="line">            m[times[i]] = lead;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">q</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = times.size();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (times[mid] &lt;= t) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m[times[right - <span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">    <span class="built_in">vector</span> times;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode912-Sort-an-Array"><a href="#Leetcode912-Sort-an-Array" class="headerlink" title="Leetcode912. Sort an Array"></a>Leetcode912. Sort an Array</h1><p>Given an array of integers nums, sort the array in ascending order.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,2,3,1]</span><br><span class="line">Output: [1,2,3,5]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,1,1,2,0,0]</span><br><span class="line">Output: [0,0,1,1,2,5]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 10000</li>
<li>-50000 &lt;= A[i] &lt;= 50000</li>
</ul>
<p>这道题让我们给数组排序，常见排序方法有很多，插入排序，选择排序，堆排序，快速排序，冒泡排序，归并排序，桶排序等等。它们的时间复杂度不尽相同，这道题貌似对于平方级复杂度的排序方法会超时，所以只能使用那些速度比较快的排序方法啦。题目给定了每个数字的范围是 [-50000, 50000]，并不是特别大，这里可以使用记数排序 Count Sort，建立一个大小为 100001 的数组 count，然后统计 nums 中每个数字出现的个数，然后再从0遍历到 100000，对于每个遍历到的数字i，若个数不为0，则加入 count 数组中对应个数的 i-50000 到结果数组中，这里的 50000 是 offset，因为数组下标不能为负数，在开始统计个数的时候，每个数字都加上了 50000，那么最后组成有序数组的时候就要减去，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span> <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), j = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n), count(<span class="number">100001</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) ++count[num + <span class="number">50000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count[i]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res[j++] = i - <span class="number">50000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面是快速排序。快排的精髓在于选一个 pivot，然后将所有小于 pivot 的数字都放在左边，大于 pivot 的数字都放在右边，等于的话放哪边都行。但是此时左右两边的数组各自都不一定是有序的，需要再各自调用相同的递归，直到细分到只有1个数字的时候，再返回的时候就都是有序的了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        quick(nums, <span class="number">0</span>, (<span class="keyword">int</span>)nums.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quick</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[(start+end)/<span class="number">2</span>], i = start, j = end;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= j &amp;&amp; nums[i] &lt; pivot)</span><br><span class="line">                i ++;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= j &amp;&amp; nums[j] &gt; pivot)</span><br><span class="line">                j --;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">                swap(nums[i], nums[j]);</span><br><span class="line">                i ++;</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        quick(nums, start, j);</span><br><span class="line">        quick(nums, i, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode914-X-of-a-Kind-in-a-Deck-of-Cards"><a href="#Leetcode914-X-of-a-Kind-in-a-Deck-of-Cards" class="headerlink" title="Leetcode914. X of a Kind in a Deck of Cards"></a>Leetcode914. X of a Kind in a Deck of Cards</h1><p>In a deck of cards, each card has an integer written on it.</p>
<p>Return true if and only if you can choose X &gt;= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:</p>
<p>Each group has exactly X cards.<br>All the cards in each group have the same integer.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: deck = [1,2,3,4,4,3,2,1]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Possible partition [1,1],[2,2],[3,3],[4,4].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: deck = [1,1,1,2,2,2,3,3]</span><br><span class="line">Output: false´</span><br><span class="line">Explanation: No possible partition.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: deck = [1]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: No possible partition.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: deck = [1,1]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Possible partition [1,1].</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: deck = [1,1,2,2,2,2]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Possible partition [1,1],[2,2],[2,2].</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= deck.length &lt;= 10^4</li>
<li>0 &lt;= deck[i] &lt; 10^4 </li>
</ul>
<p>1、这道题给定一个vector，vector中存放着卡牌的数字，比如1、2、3、4这样子，你需要把这些卡牌分成多组。要求同一组中的卡牌数字一致，并且每一组中的卡牌张数一样。比如123321，你就可以分成[1,1]，[2,2]，[3,3]。如果可以这样分组，并且组中卡牌张数大于等于2，那么返回true，否则返回false。限制卡牌数字在[0,10000)，vector中的卡牌张数在[1,10000]。</p>
<p>2、我们最开始可以用vector也可以用map，来存放各个数字的卡牌各有多少张。（笔者一开始的错误想法：这里用先排序后遍历的做法，有点傻，因为排序O(nlogn)的时间复杂度太高了，还不如直接遍历。）得到各个数字卡牌的张数之后，我们需要看一下是否可以分组。这里有个地方要注意下，比如卡牌1有4张，卡牌2有6张，是否可以分组呢？可以的，每组2张就可以了，卡牌1有2组，卡牌2有3组。也就是说，我们要求各种数字卡牌的张数的最大公约数，看一下最大公约数是否大于等于2。而不能简单地看各种数字卡牌的张数是否一致。</p>
<p>但是求集体的最大公约数太麻烦了，还不如直接从2开始，判断所有数字可不可以整除2。如果可以，那么返回true。如果不行，看一下是否可以整除3……继续判断，一直到最小的张数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deck)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deck.size(); i ++)</span><br><span class="line">            mapp[deck[i]] ++;</span><br><span class="line">        <span class="keyword">int</span> minn = <span class="number">9999999</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = mapp.begin(); it != mapp.end(); it ++)</span><br><span class="line">            minn = min(minn, it-&gt;second);</span><br><span class="line">        <span class="keyword">int</span> flag;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= minn; i ++) &#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it = mapp.begin(); it != mapp.end(); it ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(it-&gt;second % i != <span class="number">0</span>) &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode915-Partition-Array-into-Disjoint-Intervals"><a href="#Leetcode915-Partition-Array-into-Disjoint-Intervals" class="headerlink" title="Leetcode915. Partition Array into Disjoint Intervals"></a>Leetcode915. Partition Array into Disjoint Intervals</h1><p>Given an array A, partition it into two (contiguous) subarrays left and right so that:</p>
<ul>
<li>Every element in left is less than or equal to every element in right.</li>
<li>left and right are non-empty.</li>
<li>left has the smallest possible size.</li>
</ul>
<p>Return the length of left after such a partitioning.  It is guaranteed that such a partitioning exists.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,0,3,8,6]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: left = [5,0,3], right = [8,6]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,1,0,6,12]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: left = [1,1,1,0], right = [6,12]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>2 &lt;= A.length &lt;= 30000</li>
<li>0 &lt;= A[i] &lt;= 10^6</li>
<li>It is guaranteed there is at least one way to partition A as described.</li>
</ul>
<p>这道题说是给了一个数组A，让我们分成两个相邻的子数组 left 和 right，使得 left 中的所有数字小于等于 right 中的，并限定了每个输入数组必定会有这么一个分割点，让返回数组 left 的长度。这道题并不算一道难题，当然最简单并暴力的方法就是遍历所有的分割点，然后去验证左边的数组是否都小于等于右边的数，这种写法估计会超时，这里就不去实现了。直接来想优化解法吧，由于分割成的 left 和 right 数组本身不一定是有序的，只是要求 left 中的最大值要小于等于 right 中的最小值，只要这个条件满足了，一定就是符合题意的分割。left 数组的最大值很好求，在遍历数组的过程中就可以得到，而 right 数组的最小值怎么求呢？其实可以反向遍历数组，并且使用一个数组 backMin，其中 backMin[i] 表示在范围 [i, n-1] 范围内的最小值，有了这个数组后，再正向遍历一次数组，每次更新当前最大值 curMax，这就是范围 [0, i] 内的最大值，通过 backMin 数组快速得到范围 [i+1, n-1] 内的最小值，假如 left 的最大值小于等于 right 的最小值，则 i+1 就是 left 的长度，直接返回即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partitionDisjoint</span><span class="params">(<span class="built_in">vector</span>&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size(), curMax = INT_MIN;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; backMin(n, A.back());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            backMin[i] = min(backMin[i + <span class="number">1</span>], A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            curMax = max(curMax, A[i]);</span><br><span class="line">            <span class="keyword">if</span> (curMax &lt;= backMin[i + <span class="number">1</span>]) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面来看论坛上的主流解法，只需要一次遍历即可，并且不需要额外的空间，这里使用三个变量，partitionIdx 表示分割点的位置，preMax 表示 left 中的最大值，curMax 表示当前的最大值。思路是遍历每个数字，更新当前最大值 curMax，并且判断若当前数字 A[i] 小于 preMax，说明这个数字也一定是属于 left 数组的，此时整个遍历到的区域应该都是属于 left 的，所以 preMax 要更新为 curMax，并且当前位置也就是潜在的分割点，所以 partitionIdx 更新为i。由于题目中限定了一定会有分割点，所以这种方法是可以得到正确结果的，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partitionDisjoint</span><span class="params">(<span class="built_in">vector</span>&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> partitionIdx = <span class="number">0</span>, preMax = A[<span class="number">0</span>], curMax = preMax;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.size(); ++i) &#123;</span><br><span class="line">            curMax = max(curMax, A[i]);</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; preMax) &#123;</span><br><span class="line">                preMax = curMax;</span><br><span class="line">                partitionIdx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> partitionIdx + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode916-Word-Subsets"><a href="#Leetcode916-Word-Subsets" class="headerlink" title="Leetcode916. Word Subsets"></a>Leetcode916. Word Subsets</h1><p>We are given two arrays A and B of words.  Each word is a string of lowercase letters.</p>
<p>Now, say that word b is a subset of word a if every letter in b occurs in a, including multiplicity.  For example, “wrr” is a subset of “warrior”, but is not a subset of “world”.</p>
<p>Now say a word a from A is  universal  if for every b in B, b is a subset of a.</p>
<p>Return a list of all universal words in A.  You can return the words in any order.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;e&quot;,&quot;o&quot;]</span><br><span class="line">Output: [&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;l&quot;,&quot;e&quot;]</span><br><span class="line">Output: [&quot;apple&quot;,&quot;google&quot;,&quot;leetcode&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;e&quot;,&quot;oo&quot;]</span><br><span class="line">Output: [&quot;facebook&quot;,&quot;google&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;lo&quot;,&quot;eo&quot;]</span><br><span class="line">Output: [&quot;google&quot;,&quot;leetcode&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [&quot;amazon&quot;,&quot;apple&quot;,&quot;facebook&quot;,&quot;google&quot;,&quot;leetcode&quot;], B = [&quot;ec&quot;,&quot;oc&quot;,&quot;ceo&quot;]</span><br><span class="line">Output: [&quot;facebook&quot;,&quot;leetcode&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length, B.length &lt;= 10000</li>
<li>1 &lt;= A[i].length, B[i].length &lt;= 10</li>
<li>A[i] and B[i] consist only of lowercase letters.</li>
<li>All words in A[i] are unique: there isn’t i != j with A[i] == A[j].</li>
</ul>
<p>这道题定义了两个单词之间的一种子集合关系，就是说假如单词b中的每个字母都在单词a中出现了（包括重复字母），就说单词b是单词a的子集合。现在给了两个单词集合A和B，让找出集合A中的所有满足要求的单词，使得集合B中的所有单词都是其子集合。配合上题目中给的一堆例子，意思并不难理解，根据子集合的定义关系，其实就是说若单词a中的每个字母的出现次数都大于等于单词b中每个字母的出现次数，单词b就一定是a的子集合。现在由于集合B中的所有单词都必须是A中某个单词的子集合，那么其实只要对于每个字母，都统计出集合B中某个单词中出现的最大次数，比如对于这个例子，<code>B=[“eo”,”oo”]</code>，其中e最多出现1次，而o最多出现2次，那么只要集合A中有单词的e出现不少1次，o出现不少于2次，则集合B中的所有单词一定都是其子集合。这就是本题的解题思路，这里使用一个大小为 26 的一维数组 charCnt 来统计集合B中每个字母的最大出现次数，而将统计每个单词的字母次数的操作放到一个子函数 helper 中，当 charCnt 数组更新完毕后，下面就开始检验集合A中的所有单词了。对于每个遍历到的单词，还是要先统计其每个字母的出现次数，然后跟 charCnt 中每个位置上的数字比较，只要均大于等于 charCnt 中的数字，就可以加入到结果 res 中了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; wordSubsets(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words1, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words2) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; char_num(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words2.size(); i ++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t = helper(words2[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j ++)</span><br><span class="line">                char_num[j] = max(char_num[j], t[j]);   </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words1.size(); i ++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t = helper(words1[i]);</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j ++)</span><br><span class="line">                <span class="keyword">if</span> (t[j] &lt; char_num[j])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">26</span>)</span><br><span class="line">                res.push_back(words1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; helper(<span class="built_in">string</span> a) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length(); i ++)</span><br><span class="line">            res[a[i] - <span class="string">'a'</span>] ++;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode917-Reverse-Only-Letters"><a href="#Leetcode917-Reverse-Only-Letters" class="headerlink" title="Leetcode917. Reverse Only Letters"></a>Leetcode917. Reverse Only Letters</h1><p>Given a string S, return the “reversed” string where all characters that are not a letter stay in the same place, and all letters reverse their positions.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;ab-cd&quot;</span><br><span class="line">Output: &quot;dc-ba&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;a-bC-dEf-ghIj&quot;</span><br><span class="line">Output: &quot;j-Ih-gfE-dCba&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;Test1ng-Leet=code-Q!&quot;</span><br><span class="line">Output: &quot;Qedo1ct-eeLg=ntse-T!&quot;</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>S.length &lt;= 100</li>
<li>33 &lt;= S[i].ASCIIcode &lt;= 122 </li>
<li>S doesn’t contain \ or “</li>
</ul>
<p>给定一个字符串 S，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isletter</span><span class="params">(<span class="keyword">char</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((b &gt;= <span class="string">'a'</span> &amp;&amp; b &lt;= <span class="string">'z'</span>) || (b &gt;= <span class="string">'A'</span> &amp;&amp; b &lt;= <span class="string">'Z'</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseOnlyLetters</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = S.length();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isletter(S[i]))</span><br><span class="line">                i ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!isletter(S[j]))</span><br><span class="line">                j --;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">char</span> c = S[i];</span><br><span class="line">                S[i] = S[j];</span><br><span class="line">                S[j] = c;</span><br><span class="line">                i ++;</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode918-Maximum-Sum-Circular-Subarray"><a href="#Leetcode918-Maximum-Sum-Circular-Subarray" class="headerlink" title="Leetcode918. Maximum Sum Circular Subarray"></a>Leetcode918. Maximum Sum Circular Subarray</h1><p>Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C.</p>
<p>Here, a  circular array  means the end of the array connects to the beginning of the array.  (Formally, <code>C[i] = A[i]</code>when <code>0 &lt;= i &lt; A.length</code>, and <code>C[i+A.length] = C[i]</code> when <code>i &gt;= 0</code>.)</p>
<p>Also, a subarray may only include each element of the fixed buffer A at most once.  (Formally, for a subarray <code>C[i], C[i+1], ..., C[j]</code>, there does not exist <code>i &lt;= k1, k2 &lt;= j</code> with <code>k1 % A.length = k2 % A.length</code>.)</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,-2,3,-2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Subarray [3] has maximum sum 3</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,-3,5]</span><br><span class="line">Output: 10 Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,-1,2,-1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,-2,2,-3]</span><br><span class="line">Output: 3 Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [-2,-3,-1]</span><br><span class="line">Output: -1 Explanation: Subarray [-1] has maximum sum -1</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>-30000 &lt;= A[i] &lt;= 30000</li>
<li>1 &lt;= A.length &lt;= 30000</li>
</ul>
<p>这道题让求环形子数组的最大和，既然是子数组，则意味着必须是相连的数字，而由于环形数组的存在，说明可以首尾相连，这样的话，最长子数组的范围可以有两种情况，一种是正常的，数组中的某一段子数组，另一种是分为两段的，即首尾相连的。对于第一种情况，其实就是之前那道题 Maximum Subarray 的做法，对于第二种情况，需要转换一下思路，除去两段的部分，中间剩的那段子数组其实是和最小的子数组，只要用之前的方法求出子数组的最小和，用数组总数字和一减，同样可以得到最大和。两种情况的最大和都要计算出来，取二者之间的较大值才是真正的和最大的子数组。但是这里有个 corner case 需要注意一下，假如数组中全是负数，那么和最小的子数组就是原数组本身，则求出的差值是0，而第一种情况求出的和最大的子数组也应该是负数，那么二者一比较，返回0就不对了，所以这种特殊情况需要单独处理一下，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(<span class="built_in">vector</span>&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, mn = INT_MAX, mx = INT_MIN, curMax = <span class="number">0</span>, curMin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : A) &#123;</span><br><span class="line">            curMin = min(curMin + num, num);</span><br><span class="line">            mn = min(mn, curMin);</span><br><span class="line">            curMax = max(curMax + num, num);</span><br><span class="line">            mx = max(mx, curMax);</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (sum - mn == <span class="number">0</span>) ? mx : max(mx, sum - mn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode921-Minimum-Add-to-Make-Parentheses-Valid"><a href="#Leetcode921-Minimum-Add-to-Make-Parentheses-Valid" class="headerlink" title="Leetcode921. Minimum Add to Make Parentheses Valid"></a>Leetcode921. Minimum Add to Make Parentheses Valid</h1><p>Given a string S of ‘(‘ and ‘)’ parentheses, we add the minimum number of parentheses ( ‘(‘ or ‘)’, and in any positions ) so that the resulting parentheses string is valid.</p>
<p>Formally, a parentheses string is valid if and only if:</p>
<p>It is the empty string, or<br>It can be written as AB (A concatenated with B), where A and B are valid strings, or<br>It can be written as (A), where A is a valid string.<br>Given a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;())&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(((&quot;</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()))((&quot;</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>S.length &lt;= 1000<br>S only consists of ‘(‘ and ‘)’ characters.</p>
<p>一道变形的括号匹配，这里注意如果res为负数的话，要及时纠正成正的且也要在最终结果加一，如上边的Example4的样子，如果只是按照栈的做法，结果是0，是错的，其实要加4个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minAddToMakeValid</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>,result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.size();i++)</span><br><span class="line">            <span class="keyword">if</span>(S[i]==<span class="string">'('</span>)</span><br><span class="line">                res++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res--;</span><br><span class="line">                <span class="keyword">if</span>(res&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    res=<span class="number">0</span>;</span><br><span class="line">                    result++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> result+res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode922-Sort-Array-By-Parity-II"><a href="#Leetcode922-Sort-Array-By-Parity-II" class="headerlink" title="Leetcode922. Sort Array By Parity II"></a>Leetcode922. Sort Array By Parity II</h1><p>Given an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even.</p>
<p>Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even.</p>
<p>You may return any answer array that satisfies this condition.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [4,2,5,7]</span><br><span class="line">Output: [4,5,2,7]</span><br></pre></td></tr></table></figure></p>
<p>Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.</p>
<p>Note:</p>
<p>2 &lt;= A.length &lt;= 20000<br>A.length % 2 == 0<br>0 &lt;= A[i] &lt;= 1000</p>
<p>首先，将所有偶数元素放在正确的位置就足够了，因为所有奇数元素也都在正确的位置。 所以我们只关注A [0]，A [2]，A [4]，……</p>
<p>理想情况下，我们希望有一些分区，左边的所有内容都已经正确，右边的所有内容都是未定的。<br>实际上，如果我们把它分成两个切片，即偶数= A [0]，A [2]，A [4]，……和奇数= A [1]，A [3]，A [5]，这个想法是有效的， ….我们的不变量将是偶数切片中的所有小于i的位置都是正确的，并且奇数切片中小于j的所有位置都是正确的。</p>
<p>对于每个偶数，让我们使A[i]也为偶数。 为此，我们将从奇数切片中提取一个元素。 我们将j传递到奇数切片，直到找到偶数元素，然后交换。 我们的不变量得以维持，因此算法是正确的。</p>
<p>就是说对每一个偶数位置的奇数，在奇数位置找一个偶数，然后交换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortArrayByParityII(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i += <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(A[j] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                    j += <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">int</span> temp = A[i];</span><br><span class="line">                A[i] = A[j];</span><br><span class="line">                A[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode925-Long-Pressed-Name"><a href="#Leetcode925-Long-Pressed-Name" class="headerlink" title="Leetcode925. Long Pressed Name"></a>Leetcode925. Long Pressed Name</h1><p>Your friend is typing his name into a keyboard.  Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times.</p>
<p>You examine the typed characters of the keyboard.  Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: name = &quot;alex&quot;, typed = &quot;aaleex&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: &apos;a&apos; and &apos;e&apos; in &apos;alex&apos; were long pressed.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: name = &quot;saeed&quot;, typed = &quot;ssaaedd&quot;</span><br><span class="line">Output: false</span><br><span class="line">Explanation: &apos;e&apos; must have been pressed twice, but it wasn&apos;t in the typed output.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: name = &quot;leelee&quot;, typed = &quot;lleeelee&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: name = &quot;laiden&quot;, typed = &quot;laiden&quot;</span><br><span class="line">Output: true</span><br><span class="line">Explanation: It&apos;s not necessary to long press any character.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= name.length &lt;= 1000</li>
<li>1 &lt;= typed.length &lt;= 1000</li>
<li>The characters of name and typed are lowercase letters.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLongPressedName</span><span class="params">(<span class="built_in">string</span> name, <span class="built_in">string</span> typed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(name[<span class="number">0</span>] != typed[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> count1, count2, i, j;</span><br><span class="line">        <span class="keyword">int</span> length1 = name.length(), length2 = typed.length();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt; length1 || j &lt; length2; i ++, j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(name[i<span class="number">-1</span>] != typed[j<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            count1 = <span class="number">1</span>;</span><br><span class="line">            count2 = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(name[i] == name[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                count1 ++;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(typed[j] == typed[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                count2 ++;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="built_in">cout</span>&lt;&lt; count1 &lt;&lt; <span class="string">" "</span> &lt;&lt; count2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(count2 &lt; count1)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(name[length1<span class="number">-1</span>] != typed[length2<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不简单……边界条件很多，而且很麻烦。</p>
<h1 id="Leetcode929-Unique-Email-Addresses"><a href="#Leetcode929-Unique-Email-Addresses" class="headerlink" title="Leetcode929. Unique Email Addresses"></a>Leetcode929. Unique Email Addresses</h1><p>Every email consists of a local name and a domain name, separated by the @ sign. For example, in <a href="mailto:alice@leetcode.com" target="_blank" rel="noopener">alice@leetcode.com</a>, alice is the local name, and leetcode.com is the domain name. Besides lowercase letters, these emails may contain ‘.’s or ‘+’s.</p>
<p>If you add periods (‘.’) between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name.  For example, “<a href="mailto:alice.z@leetcode.com" target="_blank" rel="noopener">alice.z@leetcode.com</a>“ and “<a href="mailto:alicez@leetcode.com" target="_blank" rel="noopener">alicez@leetcode.com</a>“ forward to the same email address.  (Note that this rule does not apply for domain names.)</p>
<p>If you add a plus (‘+’) in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example <a href="mailto:m.y+name@email.com" target="_blank" rel="noopener">m.y+name@email.com</a> will be forwarded to <a href="mailto:my@email.com" target="_blank" rel="noopener">my@email.com</a>.  (Again, this rule does not apply for domain names.)</p>
<p>It is possible to use both of these rules at the same time.</p>
<p>Given a list of emails, we send one email to each address in the list.  How many different addresses actually receive mails? </p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: &quot;testemail@leetcode.com&quot; and &quot;testemail@lee.tcode.com&quot; actually receive mails</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= emails[i].length &lt;= 100</li>
<li>1 &lt;= emails.length &lt;= 100</li>
<li>Each emails[i] contains exactly one ‘@’ character.</li>
<li>All local and domain names are non-empty.</li>
<li>Local names do not start with a ‘+’ character.</li>
</ul>
<p>字符串处理，如果一个email地址里有点(‘.’)的话，就忽略这个点，如果有加号(‘+’)，忽略这个加号到(‘@’)之间的字符。判断一共有几个一样的email地址。不难，但是涉及字符串处理的话总归有些麻烦的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numUniqueEmails</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; emails)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> result[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line">        <span class="built_in">memset</span>(result,<span class="string">'\0'</span>,<span class="keyword">sizeof</span>(result));</span><br><span class="line">        <span class="keyword">int</span> result_len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;emails.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> temp[<span class="number">100</span>];</span><br><span class="line">            <span class="built_in">memset</span>(temp,<span class="string">'\0'</span>,<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">int</span> temp_len = <span class="number">0</span>, k=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;emails[i].length(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(emails[i][j]==<span class="string">'.'</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(emails[i][j]==<span class="string">'+'</span> || emails[i][j]==<span class="string">'@'</span> )</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    temp[temp_len++]=emails[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(j=emails[i].find(<span class="string">'@'</span>); j&lt;emails[i].length(); j++)</span><br><span class="line">                temp[temp_len++]=emails[i][j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;result_len; k++)</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(result[k],temp)==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(k==result_len)</span><br><span class="line">                <span class="built_in">memcpy</span>(result[result_len++], temp, <span class="keyword">sizeof</span>(temp));</span><br><span class="line">            <span class="built_in">memset</span>(temp,<span class="string">'\0'</span>,<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result_len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我的另一种做法，用set去重<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numUniqueEmails</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; emails)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; emails.size(); i ++) &#123;</span><br><span class="line">            <span class="built_in">string</span> temp;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; emails[i].size(); j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(emails[i][j] == <span class="string">'+'</span> || emails[i][j] == <span class="string">'@'</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(emails[i][j] == <span class="string">'.'</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                temp += emails[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(emails[i][j] != <span class="string">'@'</span>)</span><br><span class="line">                j ++;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt; emails[i].size(); j ++) &#123;</span><br><span class="line">                temp += emails[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            result.insert(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>解析：<br>For each email address, convert it to the canonical address that actually receives the mail. This involves a few steps:</p>
<ul>
<li>Separate the email address into a local part and the rest of the address.</li>
<li>If the local part has a ‘+’ character, remove it and everything beyond it from the local part.</li>
<li>Remove all the zeros from the local part.</li>
<li>The canonical address is local + rest.</li>
</ul>
<p>After, we can count the number of unique canonical addresses with a Set structure.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numUniqueEmails</span><span class="params">(String[] emails)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; seen = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span> (String email: emails) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = email.indexOf(<span class="string">'@'</span>);</span><br><span class="line">            String local = email.substring(<span class="number">0</span>, i);</span><br><span class="line">            String rest = email.substring(i);</span><br><span class="line">            <span class="keyword">if</span> (local.contains(<span class="string">"+"</span>)) &#123;</span><br><span class="line">                local = local.substring(<span class="number">0</span>, local.indexOf(<span class="string">'+'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            local = local.replaceAll(<span class="string">"."</span>, <span class="string">""</span>);</span><br><span class="line">            seen.add(local + rest);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> seen.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode933-Number-of-Recent-Calls"><a href="#Leetcode933-Number-of-Recent-Calls" class="headerlink" title="Leetcode933. Number of Recent Calls"></a>Leetcode933. Number of Recent Calls</h1><p>Write a class RecentCounter to count recent requests. It has only one method: ping(int t), where t represents some time in milliseconds. Return the number of pings that have been made from 3000 milliseconds ago until now. Any ping with time in [t - 3000, t] will count, including the current ping. It is guaranteed that every call to ping uses a strictly larger value of t than before.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: inputs = [&quot;RecentCounter&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;], inputs = [[],[1],[100],[3001],[3002]]</span><br><span class="line">Output: [null,1,2,3,3]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>Each test case will have at most 10000 calls to ping.</li>
<li>Each test case will call ping with strictly increasing values of t.</li>
<li>Each call to ping will have 1 &lt;= t &lt;= 10^9.</li>
</ul>
<p>行吧，我是没看懂这个题是什么意思。。。只是判断t和3000的关系。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    RecentCounter() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ping</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        q.push(t);</span><br><span class="line">        <span class="keyword">while</span>(q.front()&lt;t<span class="number">-3000</span>)</span><br><span class="line">            q.pop();</span><br><span class="line">        <span class="keyword">return</span> q.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode937-Reorder-Data-in-Log-Files"><a href="#Leetcode937-Reorder-Data-in-Log-Files" class="headerlink" title="Leetcode937. Reorder Data in Log Files"></a>Leetcode937. Reorder Data in Log Files</h1><p>You have an array of logs.  Each log is a space delimited string of words.</p>
<p>For each log, the first word in each log is an alphanumeric identifier.  Then, either:</p>
<ul>
<li>Each word after the identifier will consist only of lowercase letters, or;</li>
<li>Each word after the identifier will consist only of digits.<br>We will call these two varieties of logs letter-logs and digit-logs.  It is guaranteed that each log has at least one word after its identifier.</li>
</ul>
<p>Reorder the logs so that all of the letter-logs come before any digit-log.  The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.  The digit-logs should be put in their original order.</p>
<p>Return the final order of the logs.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: logs = [&quot;dig1 8 1 5 1&quot;,&quot;let1 art can&quot;,&quot;dig2 3 6&quot;,&quot;let2 own kit dig&quot;,&quot;let3 art zero&quot;]</span><br><span class="line">Output: [&quot;let1 art can&quot;,&quot;let3 art zero&quot;,&quot;let2 own kit dig&quot;,&quot;dig1 8 1 5 1&quot;,&quot;dig2 3 6&quot;]</span><br></pre></td></tr></table></figure></p>
<p>对于每条日志，其第一个字为字母数字标识符。然后，要么：标识符后面的每个字将仅由小写字母组成，或标识符后面的每个字将仅由数字组成。</p>
<p>将这两种日志分别称为字母日志和数字日志。保证每个日志在其标识符后面至少有一个字。将日志重新排序，使得所有字母日志都排在数字日志之前。字母日志按字母顺序排序，忽略标识符，标识符仅用于表示关系。数字日志应该按原来的顺序排列。返回日志的最终顺序。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ii = <span class="number">0</span>, jj = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a[ii ++] != <span class="string">' '</span>) ;</span><br><span class="line">        <span class="keyword">while</span>(b[jj ++] != <span class="string">' '</span>) ;</span><br><span class="line">        <span class="keyword">return</span> a.substr(ii, a.length() - ii + <span class="number">1</span>) &lt;= b.substr(jj, b.length() - jj + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 这里要比较后边所有的，不能比较一个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; reorderLogFiles(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; logs) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> len = logs.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; flag(len, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ii = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(logs[i][ii ++] != <span class="string">' '</span>) ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; logs[i][ii] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">'a'</span> &lt;= logs[i][ii] &amp;&amp; logs[i][ii] &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">                res.push_back(logs[i]);</span><br><span class="line">                flag[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(res.begin(), res.end(), cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> t : res)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; t &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag[i])</span><br><span class="line">                res.push_back(logs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode938-Range-Sum-of-BST"><a href="#Leetcode938-Range-Sum-of-BST" class="headerlink" title="Leetcode938. Range Sum of BST"></a>Leetcode938. Range Sum of BST</h1><p>Given the root node of a binary search tree, return the sum of values of all nodes with value between L and R (inclusive).</p>
<p>The binary search tree is guaranteed to have unique values.<br>一棵树，给定了根节点，再给一个范围（L，R），求这棵二叉树中在这个范围内的数的和，太简单了。。。直接递归查找，没难度，还奇怪呢这么简单的题还标着个medium。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: root = [10,5,15,3,7,null,18], L = 7, R = 15</span><br><span class="line">Output: 32</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val &gt;= L &amp;&amp; root-&gt;val &lt;= R)</span><br><span class="line">                <span class="keyword">return</span> root-&gt;val + rangeSumBST(root-&gt;left,L,R)+rangeSumBST(root-&gt;right,L,R);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> rangeSumBST(root-&gt;left,L,R)+rangeSumBST(root-&gt;right,L,R);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Note:</p>
<p>The number of nodes in the tree is at most 10000.<br>The final answer is guaranteed to be less than 2^31.</p>
<h1 id="Leetcode941-941-Valid-Mountain-Array"><a href="#Leetcode941-941-Valid-Mountain-Array" class="headerlink" title="Leetcode941. 941. Valid Mountain Array"></a>Leetcode941. 941. Valid Mountain Array</h1><p>Given an array A of integers, return true if and only if it is a valid mountain array.</p>
<p>Recall that A is a mountain array if and only if:</p>
<ul>
<li>A.length &gt;= 3</li>
<li>There exists some i with 0 &lt; i &lt; A.length - 1 such that:<ul>
<li>A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i]</li>
<li>A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]</li>
</ul>
</li>
</ul>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,5,5]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,3,2,1]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validMountainArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(A.size() &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; A.size()<span class="number">-1</span>; i ++)</span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt;= A[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || i == A.size()<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; A.size()<span class="number">-1</span>; i ++)</span><br><span class="line">            <span class="keyword">if</span>(A[i] &lt;= A[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(i != A.size() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode942-DI-String-Match"><a href="#Leetcode942-DI-String-Match" class="headerlink" title="Leetcode942. DI String Match"></a>Leetcode942. DI String Match</h1><p>Given a string S that only contains “I” (increase) or “D” (decrease), let<code>N = S.length</code>.</p>
<p>Return any permutation A of [0, 1, …, N] such that for all<code>i = 0, ..., N-1</code>:</p>
<p>If S[i] == “I”, then A[i] &lt; A[i+1]<br>If S[i] == “D”, then A[i] &gt; A[i+1]</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;IDID&quot;</span><br><span class="line">Output: [0,4,1,3,2]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;III&quot;</span><br><span class="line">Output: [0,1,2,3]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;DDI&quot;</span><br><span class="line">Output: [3,2,0,1]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= S.length &lt;= 10000<br>S only contains characters “I” or “D”.</p>
<p>题目的意思是，将字符串与数组一一对应，因为数组多一位，不考虑这一位。剩下的位置，如果字符串写的是‘I’，那么该位置上的数应该比右边所有的数都小。而如果是‘D’，则是比右边的都大。现在需要找到其中任意一组。</p>
<p>其实这个题是一个贪心，并且有点dp的感觉。感觉这个题解不唯一，其实还是比较简单能够证明反例。评论有人提出了解法证明，可以看一下：</p>
<p>只需要证明，对于任何 &gt; 或者 &lt; , 算法的规则都能满足。<br>△N = max-min; 由于每次遇到一个符号，△N-1。<br>当符号为“ &lt;   &lt;   &lt;”: max–可以保证符号的正确性。<br>当符号为“ &gt;   &gt;   &gt;”: min++可以保住符号的正确性。<br>当符号为“ ……&lt;   &gt;   &lt; “:  任意时刻max和min开始比较，是否满足 min &lt; max?<br>答案是：YES! 由于符号的数量为N，最开始△N = N。由于至少出现一对大于号和小于号 , min(△N)= 1，仍然满足min &lt; max;<br>综上，得证。</p>
<p>因为每一位对应的数字只有两种情况：比右边所有数都大，或者都小。那么我们可以设定两个值，初始的话：low = 0，high = N。这样，从左开始遍历字符串，碰见一个字符，如果是‘I’，那么就直接赋值low，同时low++。这样，‘I’右边所有的数，一定是都比这个位置大的。因为此时low&gt;a[i]，同时high &gt; low。</p>
<p>反而言之，碰见‘D’，直接赋值hight，同时high–。这样所有的数就一定比这个小了。大概就是这样，在O(n)的时间复杂度下就能构造出答案数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; diStringMatch(<span class="built_in">string</span> S) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(S.size()+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>,high=S.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S[i]==<span class="string">'I'</span>)</span><br><span class="line">                res[i]=low++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res[i]=high--;</span><br><span class="line">        &#125;</span><br><span class="line">        res[S.size()]=low;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode944-Delete-Columns-to-Make-Sorted"><a href="#Leetcode944-Delete-Columns-to-Make-Sorted" class="headerlink" title="Leetcode944. Delete Columns to Make Sorted"></a>Leetcode944. Delete Columns to Make Sorted</h1><p>We are given an array A of N lowercase letter strings, all of the same length.</p>
<p>Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.</p>
<p>For example, if we have an array A = [“abcdef”,”uvwxyz”] and deletion indices {0, 2, 3}, then the final array after deletions is [“bef”, “vyz”], and the remaining columns of A are [“b”,”v”], [“e”,”y”], and [“f”,”z”].  (Formally, the c-th column is [A[0][c], A[1][c], …, A[A.length-1][c]].)</p>
<p>Suppose we chose a set of deletion indices D such that after deletions, each remaining column in A is in non-decreasing sorted order.</p>
<p>Return the minimum possible value of D.length.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;cba&quot;,&quot;daf&quot;,&quot;ghi&quot;]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Explanation:<br>After choosing D = {1}, each column [“c”,”d”,”g”] and [“a”,”f”,”i”] are in non-decreasing sorted order.<br>If we chose D = {}, then a column [“b”,”a”,”h”] would not be in non-decreasing sorted order.<br>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
<p>Explanation: D = {}<br>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;zyx&quot;,&quot;wvu&quot;,&quot;tsr&quot;]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Explanation: D = {0, 1, 2}</p>
<p>Note:</p>
<p>1 &lt;= A.length &lt;= 100<br>1 &lt;= A[i].length &lt;= 1000</p>
<p>字符串数组 A 中的每个字符串元素的长度相同，统计index个数，这个index 的要求是 A[i].charAt(index)，i=0,1,2,3,4 组成的 字符序列 不是严格递增。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDeletionSize</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> isize=A.size();</span><br><span class="line">        <span class="keyword">int</span> jsize=A[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;jsize;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;isize<span class="number">-1</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i][j]&gt;A[i+<span class="number">1</span>][j])&#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode949-Largest-Time-for-Given-Digits"><a href="#Leetcode949-Largest-Time-for-Given-Digits" class="headerlink" title="Leetcode949. Largest Time for Given Digits"></a>Leetcode949. Largest Time for Given Digits</h1><p>Given an array of 4 digits, return the largest 24 hour time that can be made. The smallest 24 hour time is 00:00, and the largest is 23:59.  Starting from 00:00, a time is larger if more time has elapsed since midnight. Return the answer as a string of length 5.  If no valid time can be made, return an empty string.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4]</span><br><span class="line">Output: &quot;23:41&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,5,5,5]</span><br><span class="line">Output: &quot;&quot;</span><br></pre></td></tr></table></figure></p>
<p>使用STL中的全排列生成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestTimeFromDigits</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        sort(A.begin(), A.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>( (A[<span class="number">0</span>] &lt;= <span class="number">1</span> || (A[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; A[<span class="number">1</span>] &lt; <span class="number">4</span>)) &amp;&amp; A[<span class="number">2</span>] &lt; <span class="number">6</span>) &#123;</span><br><span class="line">                <span class="built_in">stringstream</span> ss;</span><br><span class="line">                ss &lt;&lt; A[<span class="number">0</span>] &lt;&lt; A[<span class="number">1</span>] &lt;&lt; <span class="string">":"</span> &lt;&lt; A[<span class="number">2</span>] &lt;&lt; A[<span class="number">3</span>];</span><br><span class="line">                <span class="keyword">return</span> ss.str();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(prev_permutation(A.begin(), A.end()));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode950-Reveal-Cards-In-Increasing-Order"><a href="#Leetcode950-Reveal-Cards-In-Increasing-Order" class="headerlink" title="Leetcode950. Reveal Cards In Increasing Order"></a>Leetcode950. Reveal Cards In Increasing Order</h1><p>In a deck of cards, every card has a unique integer.  You can order the deck in any order you want.</p>
<p>Initially, all the cards start face down (unrevealed) in one deck.</p>
<p>Now, you do the following steps repeatedly, until all cards are revealed:</p>
<p>Take the top card of the deck, reveal it, and take it out of the deck.<br>If there are still cards in the deck, put the next top card of the deck at the bottom of the deck.<br>If there are still unrevealed cards, go back to step 1.  Otherwise, stop.<br>Return an ordering of the deck that would reveal the cards in increasing order.</p>
<p>The first entry in the answer is considered to be the top of the deck.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input: [17,13,11,2,3,5,7]</span><br><span class="line">Output: [2,13,3,11,5,17,7]</span><br><span class="line">Explanation: </span><br><span class="line">We get the deck in the order [17,13,11,2,3,5,7] (this order doesn&apos;t matter), and reorder it.</span><br><span class="line">After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck.</span><br><span class="line">We reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13].</span><br><span class="line">We reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11].</span><br><span class="line">We reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17].</span><br><span class="line">We reveal 7, and move 13 to the bottom.  The deck is now [11,17,13].</span><br><span class="line">We reveal 11, and move 17 to the bottom.  The deck is now [13,17].</span><br><span class="line">We reveal 13, and move 17 to the bottom.  The deck is now [17].</span><br><span class="line">We reveal 17.</span><br><span class="line">Since all the cards revealed are in increasing order, the answer is correct.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= A.length &lt;= 1000<br>1 &lt;= A[i] &lt;= 10^6<br>A[i] != A[j] for all i != j</p>
<p>woc什么乱七八糟的题，这个确实没懂。</p>
<p>从牌组顶部抽一张牌，显示它，然后将其从牌组中移出。<br>如果牌组中仍有牌，则将下一张处于牌组顶部的牌放在牌组的底部。<br>如果仍有未显示的牌，那么返回步骤 1。否则，停止行动。<br>得到的序列要求是递增序列。</p>
<p>例如 1 3 2 通过上述变换，可以得到1 2 3，满足题目要求。</p>
<p>解法是：1 2 3 通过上述变换，可以得到 1 3 2，即这道题的解。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; deckRevealedIncreasing(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deck) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(deck.size());</span><br><span class="line">        sort(deck.begin(),deck.end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;deck.size();i++)</span><br><span class="line">            q.push(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;deck.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = q.front();</span><br><span class="line">            res[temp]=deck[i];</span><br><span class="line">            q.pop();</span><br><span class="line">            </span><br><span class="line">            temp = q.front();</span><br><span class="line">            q.push(temp);</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/24/Linux_awk命令详解/" rel="next" title="Linux awk命令详解">
                <i class="fa fa-chevron-left"></i> Linux awk命令详解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/29/可重入和不可重入/" rel="prev" title="可重入和不可重入">
                可重入和不可重入 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">310</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode901-Online-Stock-Span"><span class="nav-number">1.</span> <span class="nav-text">Leetcode901. Online Stock Span</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode904-Fruit-Into-Baskets"><span class="nav-number">2.</span> <span class="nav-text">Leetcode904. Fruit Into Baskets</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode905-Sort-Array-By-Parity"><span class="nav-number">3.</span> <span class="nav-text">Leetcode905. Sort Array By Parity</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode908-Smallest-Range-I"><span class="nav-number">4.</span> <span class="nav-text">Leetcode908. Smallest Range I</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode909-Snakes-and-Ladders"><span class="nav-number">5.</span> <span class="nav-text">Leetcode909. Snakes and Ladders</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode911-Online-Election"><span class="nav-number">6.</span> <span class="nav-text">Leetcode911. Online Election</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode912-Sort-an-Array"><span class="nav-number">7.</span> <span class="nav-text">Leetcode912. Sort an Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode914-X-of-a-Kind-in-a-Deck-of-Cards"><span class="nav-number">8.</span> <span class="nav-text">Leetcode914. X of a Kind in a Deck of Cards</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode915-Partition-Array-into-Disjoint-Intervals"><span class="nav-number">9.</span> <span class="nav-text">Leetcode915. Partition Array into Disjoint Intervals</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode916-Word-Subsets"><span class="nav-number">10.</span> <span class="nav-text">Leetcode916. Word Subsets</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode917-Reverse-Only-Letters"><span class="nav-number">11.</span> <span class="nav-text">Leetcode917. Reverse Only Letters</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode918-Maximum-Sum-Circular-Subarray"><span class="nav-number">12.</span> <span class="nav-text">Leetcode918. Maximum Sum Circular Subarray</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode921-Minimum-Add-to-Make-Parentheses-Valid"><span class="nav-number">13.</span> <span class="nav-text">Leetcode921. Minimum Add to Make Parentheses Valid</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode922-Sort-Array-By-Parity-II"><span class="nav-number">14.</span> <span class="nav-text">Leetcode922. Sort Array By Parity II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode925-Long-Pressed-Name"><span class="nav-number">15.</span> <span class="nav-text">Leetcode925. Long Pressed Name</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode929-Unique-Email-Addresses"><span class="nav-number">16.</span> <span class="nav-text">Leetcode929. Unique Email Addresses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode933-Number-of-Recent-Calls"><span class="nav-number">17.</span> <span class="nav-text">Leetcode933. Number of Recent Calls</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode937-Reorder-Data-in-Log-Files"><span class="nav-number">18.</span> <span class="nav-text">Leetcode937. Reorder Data in Log Files</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode938-Range-Sum-of-BST"><span class="nav-number">19.</span> <span class="nav-text">Leetcode938. Range Sum of BST</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode941-941-Valid-Mountain-Array"><span class="nav-number">20.</span> <span class="nav-text">Leetcode941. 941. Valid Mountain Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode942-DI-String-Match"><span class="nav-number">21.</span> <span class="nav-text">Leetcode942. DI String Match</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode944-Delete-Columns-to-Make-Sorted"><span class="nav-number">22.</span> <span class="nav-text">Leetcode944. Delete Columns to Make Sorted</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode949-Largest-Time-for-Given-Digits"><span class="nav-number">23.</span> <span class="nav-text">Leetcode949. Largest Time for Given Digits</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode950-Reveal-Cards-In-Increasing-Order"><span class="nav-number">24.</span> <span class="nav-text">Leetcode950. Reveal Cards In Increasing Order</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
