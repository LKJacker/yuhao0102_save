<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux,">










<meta name="description" content="来源：https://www.cnblogs.com/jiqingwu/p/elf_format_research_01.html ELF文件解析（一）：Segment和SectionELF 是Executable and Linking Format的缩写，即可执行和可链接的格式，是Unix/Linux系统ABI (Application Binary Interface)规范的一部分。 Uni">
<meta name="keywords" content="Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="ELF文件格式">
<meta property="og:url" content="http://yoursite.com/2019/04/23/elf文件格式/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="来源：https://www.cnblogs.com/jiqingwu/p/elf_format_research_01.html ELF文件解析（一）：Segment和SectionELF 是Executable and Linking Format的缩写，即可执行和可链接的格式，是Unix/Linux系统ABI (Application Binary Interface)规范的一部分。 Uni">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/417313-20181012154909093-954664315.png">
<meta property="og:image" content="http://yoursite.com/img/417313-20181022201440705-1728299314.png">
<meta property="og:image" content="http://yoursite.com/img/417313-20181022201527605-1024038352.png">
<meta property="og:image" content="http://yoursite.com/img/417313-20181029104008898-1703340645.png">
<meta property="og:image" content="http://yoursite.com/img/6cc27e57-5159-31ee-bc69-8392eeb4731a.png">
<meta property="og:image" content="http://yoursite.com/img/609d893b-f125-31bf-93a7-4a57c06e36de.png">
<meta property="og:image" content="http://yoursite.com/img/e4c15bdc-2db0-3e42-8176-081f454e25fc.png">
<meta property="og:image" content="http://yoursite.com/img/aa8e40c5-5964-3fae-98f3-df194dbb7eec.png">
<meta property="og:image" content="http://yoursite.com/img/aa8e40c5-5964-3fae-98f3-df194dbb7eed.png">
<meta property="og:image" content="http://yoursite.com/img/05aa899e-a4dd-37f2-9824-e5cb6ad8434d.png">
<meta property="og:image" content="http://yoursite.com/img/289baeed-3f91-3651-b81b-159632d1cf45.png">
<meta property="og:updated_time" content="2022-10-01T03:35:35.345Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ELF文件格式">
<meta name="twitter:description" content="来源：https://www.cnblogs.com/jiqingwu/p/elf_format_research_01.html ELF文件解析（一）：Segment和SectionELF 是Executable and Linking Format的缩写，即可执行和可链接的格式，是Unix/Linux系统ABI (Application Binary Interface)规范的一部分。 Uni">
<meta name="twitter:image" content="http://yoursite.com/img/417313-20181012154909093-954664315.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/04/23/elf文件格式/">





  <title>ELF文件格式 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/23/elf文件格式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ELF文件格式</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-23T21:41:39+08:00">
                2019-04-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>来源：<a href="https://www.cnblogs.com/jiqingwu/p/elf_format_research_01.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiqingwu/p/elf_format_research_01.html</a></p>
<h1 id="ELF文件解析（一）：Segment和Section"><a href="#ELF文件解析（一）：Segment和Section" class="headerlink" title="ELF文件解析（一）：Segment和Section"></a>ELF文件解析（一）：Segment和Section</h1><p>ELF 是Executable and Linking Format的缩写，即可执行和可链接的格式，是Unix/Linux系统ABI (Application Binary Interface)规范的一部分。</p>
<p>Unix/Linux下的可执行二进制文件、目标代码文件、共享库文件和core dump文件都属于ELF文件。下面的图来自于文档 Executable and Linkable Format (ELF)，描述了ELF文件的大致布局。<br><img src="/img/417313-20181012154909093-954664315.png" alt></p>
<p>左边是ELF的链接视图，可以理解为是目标代码文件的内容布局。右边是ELF的执行视图，可以理解为可执行文件的内容布局。<br>注意目标代码文件的内容是由section组成的，而可执行文件的内容是由segment组成的。</p>
<p>要注意区分段(segment)和节(section)的概念，这两个概念在后面会经常提到。<br>我们写汇编程序时，用.text，.bss，.data这些指示，都指的是section，比如.text，告诉汇编器后面的代码放入.text section中。<br>目标代码文件中的section和section header table中的条目是一一对应的。section的信息用于链接器对代码重定位。</p>
<p>而文件载入内存执行时，是以segment组织的，每个segment对应ELF文件中program header table中的一个条目，用来建立可执行文件的进程映像。<br>比如我们通常说的，代码段、数据段是segment，目标代码中的section会被链接器组织到可执行文件的各个segment中。<br>.text section的内容会组装到代码段中，.data, .bss等节的内容会包含在数据段中。</p>
<p>在目标文件中，program header不是必须的，我们用gcc生成的目标文件也不包含program header。<br>一个好用的解析ELF文件的工具是readelf。对我本机上的一个目标代码文件sleep.o执行<code>readelf -S sleep.o</code>，输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">There are 12 section headers, starting at offset 0x270:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000000000  00000040</span><br><span class="line">       0000000000000015  0000000000000000  AX       0     0     1</span><br><span class="line">  [ 2] .rela.text        RELA             0000000000000000  000001e0</span><br><span class="line">       0000000000000018  0000000000000018   I       9     1     8</span><br><span class="line">  [ 3] .data             PROGBITS         0000000000000000  00000055</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  [ 4] .bss              NOBITS           0000000000000000  00000055</span><br><span class="line">       0000000000000000  0000000000000000  WA       0     0     1</span><br><span class="line">  ... ... ... ...</span><br><span class="line">  [11] .shstrtab         STRTAB           0000000000000000  00000210</span><br><span class="line">       0000000000000059  0000000000000000           0     0     1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  l (large), p (processor specific)</span><br></pre></td></tr></table></figure></p>
<p><code>readelf -S</code>是显示文件中的Section信息，sleep.o中共有12个section, 我们省略了其中一些Section的信息。<br>可以看到，除了我们熟悉的.text, .data, .bss，还有其它Section，这等我们以后展开讲Section的时候还会专门讲到。<br>看每个Section的Flags我们也可以得到一些信息，比如.text section的Flags是AX，表示要分配内存，并且是可执行的，这一节是代码无疑了。<br>.data 和 .bss的Flags的Flags都是WA，表示可写，需分配内存，这都是数据段的特征。</p>
<p>使用<code>readelf -l</code>可以显示文件的program header信息。我们对sleep.o执行<code>readelf -l sleep.o</code>，会输出<code>There are no program headers in this file.</code>。<br>program header和文件中的segment一一对应，因为目标代码文件中没有segment，program header也就没有必要了。</p>
<p>可执行文件的内容组织成segment，因此program header table是必须的。<br>section header不是必须的，但没有strip过的二进制文件中都含有此信息。<br>对本地可执行文件sleep执行<code>readelf -l sleep</code>，输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Elf file type is DYN (Shared object file)</span><br><span class="line">Entry point 0x1040</span><br><span class="line">There are 11 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040</span><br><span class="line">                 0x0000000000000268 0x0000000000000268  R      0x8</span><br><span class="line">  INTERP         0x00000000000002a8 0x00000000000002a8 0x00000000000002a8</span><br><span class="line">                 0x000000000000001c 0x000000000000001c  R      0x1</span><br><span class="line">      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000560 0x0000000000000560  R      0x1000</span><br><span class="line">  LOAD           0x0000000000001000 0x0000000000001000 0x0000000000001000</span><br><span class="line">                 0x00000000000001d5 0x00000000000001d5  R E    0x1000</span><br><span class="line">  LOAD           0x0000000000002000 0x0000000000002000 0x0000000000002000</span><br><span class="line">                 0x0000000000000110 0x0000000000000110  R      0x1000</span><br><span class="line">  LOAD           0x0000000000002de8 0x0000000000003de8 0x0000000000003de8</span><br><span class="line">                 0x0000000000000248 0x0000000000000250  RW     0x1000</span><br><span class="line">  DYNAMIC        0x0000000000002df8 0x0000000000003df8 0x0000000000003df8</span><br><span class="line">                 0x00000000000001e0 0x00000000000001e0  RW     0x8</span><br><span class="line">  NOTE           0x00000000000002c4 0x00000000000002c4 0x00000000000002c4</span><br><span class="line">                 0x0000000000000044 0x0000000000000044  R      0x4</span><br><span class="line">  GNU_EH_FRAME   0x0000000000002004 0x0000000000002004 0x0000000000002004</span><br><span class="line">                 0x0000000000000034 0x0000000000000034  R      0x4</span><br><span class="line">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000000 0x0000000000000000  RW     0x10</span><br><span class="line">  GNU_RELRO      0x0000000000002de8 0x0000000000003de8 0x0000000000003de8</span><br><span class="line">                 0x0000000000000218 0x0000000000000218  R      0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00</span><br><span class="line">   01     .interp</span><br><span class="line">   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt</span><br><span class="line">   03     .init .plt .text .fini</span><br><span class="line">   04     .rodata .eh_frame_hdr .eh_frame</span><br><span class="line">   05     .init_array .fini_array .dynamic .got .got.plt .data .bss</span><br><span class="line">   06     .dynamic</span><br><span class="line">   07     .note.ABI-tag .note.gnu.build-id</span><br><span class="line">   08     .eh_frame_hdr</span><br><span class="line">   09</span><br><span class="line">   10     .init_array .fini_array .dynamic .got</span><br></pre></td></tr></table></figure></p>
<p>如输出所示，文件中共有11个segment。只有类型为LOAD的段是运行时真正需要的。<br>除了段信息，还输出了每个段包含了哪些section。比如第二个LOAD段标志为R（只读）E（可执行）的，它的编号是03，表示它包含哪些section的那一行内容为：<br><code>03 .init .plt .text .fini</code>。<br>可以发现.text包含在其中，这一段就是代码段。<br>再比如第三个LOAD段，索引是04，标志为R（只读），但没有可执行的属性，它包含的section有<code>.rodata .eh_frame_hdr .eh_frame</code>，其中rodata表示只读的数据，也就是程序中用到的字符串常量等。<br>最后一个LOAD段，索引05，标志RW（可读写），它包含的节是<code>.init_array .fini_array .dynamic .got .got.plt .data .bss</code>，可以看到.data和.bss都包含其中，这段是数据段无疑。</p>
<h1 id="ELF-header详解"><a href="#ELF-header详解" class="headerlink" title="ELF header详解"></a>ELF header详解</h1><p>ELF header的定义可以在<code>/usr/include/elf.h</code>中找到。Elf32_Ehdr是32位 ELF header的结构体。Elf64_Ehdr是64位ELF header的结构体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  unsigned char e_ident[EI_NIDENT]; /* Magic number和其它信息 */</span><br><span class="line">  Elf32_Half    e_type;         /* Object file type */</span><br><span class="line">  Elf32_Half    e_machine;      /* Architecture */</span><br><span class="line">  Elf32_Word    e_version;      /* Object file version */</span><br><span class="line">  Elf32_Addr    e_entry;        /* Entry point virtual address */</span><br><span class="line">  Elf32_Off e_phoff;        /* Program header table file offset */</span><br><span class="line">  Elf32_Off e_shoff;        /* Section header table file offset */</span><br><span class="line">  Elf32_Word    e_flags;        /* Processor-specific flags */</span><br><span class="line">  Elf32_Half    e_ehsize;       /* ELF header size in bytes */</span><br><span class="line">  Elf32_Half    e_phentsize;        /* Program header table entry size */</span><br><span class="line">  Elf32_Half    e_phnum;        /* Program header table entry count */</span><br><span class="line">  Elf32_Half    e_shentsize;        /* Section header table entry size */</span><br><span class="line">  Elf32_Half    e_shnum;        /* Section header table entry count */</span><br><span class="line">  Elf32_Half    e_shstrndx;     /* Section header string table index */</span><br><span class="line">&#125; Elf32_Ehdr;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */</span><br><span class="line">  Elf64_Half    e_type;         /* Object file type */</span><br><span class="line">  Elf64_Half    e_machine;      /* Architecture */</span><br><span class="line">  Elf64_Word    e_version;      /* Object file version */</span><br><span class="line">  Elf64_Addr    e_entry;        /* Entry point virtual address */</span><br><span class="line">  Elf64_Off e_phoff;        /* Program header table file offset */</span><br><span class="line">  Elf64_Off e_shoff;        /* Section header table file offset */</span><br><span class="line">  Elf64_Word    e_flags;        /* Processor-specific flags */</span><br><span class="line">  Elf64_Half    e_ehsize;       /* ELF header size in bytes */</span><br><span class="line">  Elf64_Half    e_phentsize;        /* Program header table entry size */</span><br><span class="line">  Elf64_Half    e_phnum;        /* Program header table entry count */</span><br><span class="line">  Elf64_Half    e_shentsize;        /* Section header table entry size */</span><br><span class="line">  Elf64_Half    e_shnum;        /* Section header table entry count */</span><br><span class="line">  Elf64_Half    e_shstrndx;     /* Section header string table index */</span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure>
<p>64位和32位只是个别字段长度不同，比如 Elf64_Addr 和 Elf64_Off 都是64位无符号整数。而Elf32_Addr 和 Elf32_Off是32位无符号整数。这导致ELF header的所占的字节数不同。32位的ELF header占52个字节，64位的ELF header占64个字节。</p>
<h2 id="ELF-header详解-1"><a href="#ELF-header详解-1" class="headerlink" title="ELF header详解"></a>ELF header详解</h2><p><img src="/img/417313-20181022201440705-1728299314.png" alt></p>
<ol>
<li><p><code>e_ident</code>占16个字节。前四个字节被称作ELF的Magic Number。后面的字节描述了ELF文件内容如何解码等信息。等一下详细讲。</p>
</li>
<li><p><code>e_type</code>，2字节，描述了ELF文件的类型。以下取值有意义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ET_NONE, 0, No file type</span><br><span class="line">ET_REL, 1, Relocatable file（可重定位文件，通常是文件名以.o结尾，目标文件）</span><br><span class="line">ET_EXEC, 2, Executable file （可执行文件）</span><br><span class="line">ET_DYN, 3, Shared object file （动态库文件，你用gcc编译出的二进制往往也属于这种类型，惊讶吗？）</span><br><span class="line">ET_CORE, 4, Core file （core文件，是core dump生成的吧？）</span><br><span class="line">ET_NUM, 5，表示已经定义了5种文件类型</span><br><span class="line">ET_LOPROC, 0xff00, Processor-specific</span><br><span class="line">ET_HIPROC, 0xffff, Processor-specific</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>从<code>ET_LOPROC</code>到<code>ET_HIPROC</code>的值，包含特定于处理器的语义。</p>
<ol>
<li><p><code>e_machine</code>，2字节。描述了文件面向的架构，可取值如下（因为文档较老，现在有更多取值，参见/usr/include/elf.h中的EM_开头的宏定义）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EM_NONE, 0, No machine</span><br><span class="line">EM_M32, 1, AT&amp;T WE 32100</span><br><span class="line">EM_SPARC, 2, SPARC</span><br><span class="line">EM_386, 3, Intel 80386</span><br><span class="line">EM_68K, 4, Motorola 68000</span><br><span class="line">EM_88K, 5, Motorola 88000</span><br><span class="line">EM_860, 7, Intel 80860</span><br><span class="line">EM_MIPS, 8, MIPS RS3000</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>e_version</code>，2字节，描述了ELF文件的版本号，合法取值如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EV_NONE, 0, Invalid version</span><br><span class="line">EV_CURRENT, 1, Current version，通常都是这个取值。</span><br><span class="line">EV_NUM, 2, 表示已经定义了2种版本号</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>e_entry</code>，（32位4字节，64位8字节），执行入口点，如果文件没有入口点，这个域保持0。</p>
</li>
<li><code>e_phoff</code>, （32位4字节，64位8字节），program header table的offset，如果文件没有PH，这个值是0。</li>
<li><code>e_shoff</code>, （32位4字节，64位8字节）， section header table 的offset，如果文件没有SH，这个值是0。</li>
<li><code>e_flags</code>, 4字节，特定于处理器的标志，32位和64位Intel架构都没有定义标志，因此eflags的值是0。</li>
<li><code>e_ehsize</code>, 2字节，ELF header的大小，32位ELF是52字节，64位是64字节。</li>
<li><code>e_phentsize</code>，2字节。program header table中每个入口的大小。</li>
<li><code>e_phnum</code>, 2字节。如果文件没有program header table, e_phnum的值为0。e_phentsize乘以e_phnum就得到了整个program header table的大小。</li>
<li><code>e_shentsize</code>, 2字节，section header table中entry的大小，即每个section header占多少字节。</li>
<li><code>e_shnum</code>, 2字节，section header table中header的数目。如果文件没有section header table, e_shnum的值为0。e_shentsize乘以e_shnum，就得到了整个section header table的大小。</li>
<li><code>e_shstrndx</code>, 2字节。section header string table index. 包含了section header table中section name string table。如果没有section name string table, e_shstrndx的值是SHN_UNDEF.</li>
</ol>
<p>e_ident<br>回过头来，我们仔细看看文件前16个字节，也是e_ident。<br><img src="/img/417313-20181022201527605-1024038352.png" alt></p>
<p>如图，前4个字节是ELF的Magic Number，固定为<code>7f 45 4c 46</code>。<br>第5个字节指明ELF文件是32位还是64位的。<br>第6个字节指明了数据的编码方式，即我们通常说的little endian或是big endian。little endian我喜欢称作小头在前，低位字节在前，或者直接说低位字节在低位地址，比如<code>0x7f454c46</code>，存储顺序就是<code>46 4c 45 7f</code>。big endian就是大头在前，高位字节在前，直接说就是高位字节在低位地址，比如<code>0x7f454c46</code>，在文件中的存储顺序是<code>7f 45 4c 46</code>。<br>第7个字节指明了ELF header的版本号，目前值都是1。<br>第8-16个字节，都填充为0。</p>
<p>readelf读取ELF header<br>我们使用readelf -h <elffile>可以读取文件的ELF header信息。<br>比如我本地有执行文件hello，我执行reaelf -h hello，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2&apos;s complement, little endian</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS/ABI:                            UNIX - System V</span><br><span class="line">  ABI Version:                       0</span><br><span class="line">  Type:                              DYN (Shared object file)</span><br><span class="line">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">  Version:                           0x1</span><br><span class="line">  Entry point address:               0x1050</span><br><span class="line">  Start of program headers:          64 (bytes into file)</span><br><span class="line">  Start of section headers:          14768 (bytes into file)</span><br><span class="line">  Flags:                             0x0</span><br><span class="line">  Size of this header:               64 (bytes)</span><br><span class="line">  Size of program headers:           56 (bytes)</span><br><span class="line">  Number of program headers:         11</span><br><span class="line">  Size of section headers:           64 (bytes)</span><br><span class="line">  Number of section headers:         29</span><br><span class="line">  Section header string table index: 28</span><br></pre></td></tr></table></figure></elffile></p>
<p>这是我用gcc生成的执行文件，但注意它的Type是DYN (Shared object file)，这大概是因为，这个文件不能直接执行，是依赖于解释器和c库才能运行。真正的可执行文件是解释器，而hello相对于解释器来说也是个共享库文件。这是我的推断，需要后面深入学习后验证。</p>
<h1 id="ELF格式探析之三：sections"><a href="#ELF格式探析之三：sections" class="headerlink" title="ELF格式探析之三：sections"></a>ELF格式探析之三：sections</h1><p>我们在讲ELF Header的时候，讲到了section header table。它是一个section header的集合，每个section header是一个描述section的结构体。在同一个ELF文件中，每个section header大小是相同的。（其实看了源码就知道，32位ELF文件中的section header都是一样的大小，64位ELF文件中的section header也是一样的大小）</p>
<p>每个section都有一个section header描述它，但是一个section header可能在文件中没有对应的section，因为有的section是不占用文件空间的。每个section在文件中是连续的字节序列。section之间不会有重叠。</p>
<p>一个目标文件中可能有未覆盖到的空间，比如各种header和section都没有覆盖到。这部分字节的内容是未指定的，也是没有意义的。</p>
<p>section header定义<br>section header结构体的定义可以在 <code>/usr/include/elf.h</code>中找到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/* Section header.  */</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Word    sh_name;        /* Section name (string tbl index) */</span><br><span class="line">  Elf32_Word    sh_type;        /* Section type */</span><br><span class="line">  Elf32_Word    sh_flags;       /* Section flags */</span><br><span class="line">  Elf32_Addr    sh_addr;        /* Section virtual addr at execution */</span><br><span class="line">  Elf32_Off sh_offset;      /* Section file offset */</span><br><span class="line">  Elf32_Word    sh_size;        /* Section size in bytes */</span><br><span class="line">  Elf32_Word    sh_link;        /* Link to another section */</span><br><span class="line">  Elf32_Word    sh_info;        /* Additional section information */</span><br><span class="line">  Elf32_Word    sh_addralign;       /* Section alignment */</span><br><span class="line">  Elf32_Word    sh_entsize;     /* Entry size if section holds table */</span><br><span class="line">&#125; Elf32_Shdr;</span><br><span class="line"></span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf64_Word    sh_name;        /* Section name (string tbl index) */</span><br><span class="line">  Elf64_Word    sh_type;        /* Section type */</span><br><span class="line">  Elf64_Xword   sh_flags;       /* Section flags */</span><br><span class="line">  Elf64_Addr    sh_addr;        /* Section virtual addr at execution */</span><br><span class="line">  Elf64_Off sh_offset;      /* Section file offset */</span><br><span class="line">  Elf64_Xword   sh_size;        /* Section size in bytes */</span><br><span class="line">  Elf64_Word    sh_link;        /* Link to another section */</span><br><span class="line">  Elf64_Word    sh_info;        /* Additional section information */</span><br><span class="line">  Elf64_Xword   sh_addralign;       /* Section alignment */</span><br><span class="line">  Elf64_Xword   sh_entsize;     /* Entry size if section holds table */</span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/417313-20181029104008898-1703340645.png" alt></p>
<p>下面我们依次讲解结构体各个字段：</p>
<ol>
<li><p><code>sh_name</code>，4字节，是一个索引值，在shstrtable（section header string table，包含section name的字符串表，也是一个section）中的索引。第二讲介绍ELF文件头时，里面专门有一个字段e_shstrndx，其含义就是shstrtable对应的section header在section header table中的索引。</p>
</li>
<li><p><code>sh_type</code>，4字节，描述了section的类型，常见的取值如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SHT_NULL 0，表明section header无效，没有关联的section。</span><br><span class="line">SHT_PROGBITS 1，section包含了程序需要的数据，格式和含义由程序解释。</span><br><span class="line">SHT_SYMTAB 2， 包含了一个符号表。当前，一个ELF文件中只有一个符号表。SHT_SYMTAB提供了用于(link editor)链接编辑的符号，当然这些符号也可能用于动态链接。这是一个完全的符号表，它包含许多符号。</span><br><span class="line">SHT_STRTAB 3，包含一个字符串表。一个对象文件包含多个字符串表，比如.strtab（包含符号的名字）和.shstrtab（包含section的名称）。</span><br><span class="line">SHT_RELA 4，重定位节，包含relocation入口，参见Elf32_Rela。一个文件可能有多个Relocation Section。比如.rela.text，.rela.dyn。</span><br><span class="line">SHT_HASH 5，这样的section包含一个符号hash表，参与动态连接的目标代码文件必须有一个hash表。目前一个ELF文件中只包含一个hash表。讲链接的时候再细讲。</span><br><span class="line">SHT_DYNAMIC 6，包含动态链接的信息。目前一个ELF文件只有一个DYNAMIC section。</span><br><span class="line">SHT_NOTE 7，note section, 以某种方式标记文件的信息，以后细讲。</span><br><span class="line">SHT_NOBITS 8，这种section不含字节，也不占用文件空间，section header中的sh_offset字段只是概念上的偏移。</span><br><span class="line">SHT_REL 9， 重定位节，包含重定位条目。和SHT_RELA基本相同，两者的区别在后面讲重定位的时候再细讲。</span><br><span class="line">SHT_SHLIB 10，保留，语义未指定，包含这种类型的section的elf文件不符合ABI。</span><br><span class="line">SHT_DYNSYM 11， 用于动态连接的符号表，推测是symbol table的子集。</span><br><span class="line">SHT_LOPROC 0x70000000 到 SHT_HIPROC 0x7fffffff，为特定于处理器的语义保留。</span><br><span class="line">SHT_LOUSER 0x80000000 and SHT_HIUSER 0xffffffff，指定了为应用程序保留的索引的下界和上界，这个范围内的索引可以被应用程序使用。</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sh_flags</code>, 32位占4字节， 64位占8字节。包含位标志，用 readelf -S <elf> 可以看到很多标志。常用的有：</elf></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SHF_WRITE 0x1，进程执行的时候，section内的数据可写。</span><br><span class="line">SHF_ALLOC 0x2，进程执行的时候，section需要占据内存。</span><br><span class="line">SHF_EXECINSTR 0x4，节内包含可以执行的机器指令。</span><br><span class="line">SHF_STRINGS 0x20，包含0结尾的字符串。</span><br><span class="line">SHF_MASKOS 0x0ff00000，这个mask为OS特定的语义保留8位。</span><br><span class="line">SHF_MASKPROC 0xf0000000，这个mask包含的所有位保留（也就是最高字节的高4位），为处理器相关的语义使用。</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sh_addr</code>, 对32位来说是4字节，64位是8字节。如果section会出现在进程的内存映像中，给出了section第一字节的虚拟地址。</p>
</li>
<li><p><code>sh_offset</code>，对于32位来说是4字节，64位是8字节。section相对于文件头的字节偏移。对于不占文件空间的section（比如SHT_NOBITS），它的sh_offset只是给出了section逻辑上的位置。</p>
</li>
<li><p><code>sh_size</code>，section占多少字节，对于SHT_NOBITS类型的section，sh_size没用，其值可能不为0，但它也不占文件空间。</p>
</li>
<li><p><code>sh_link</code>，含有一个section header的index，该值的解释依赖于section type。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果是SHT_DYNAMIC，sh_link是string table的section header index，也就是说指向字符串表。</span><br><span class="line">如果是SHT_HASH，sh_link指向symbol table的section header index，hash table应用于symbol table。</span><br><span class="line">如果是重定位节SHT_REL或SHT_RELA，sh_link指向相应符号表的section header index。</span><br><span class="line">如果是SHT_SYMTAB或SHT_DYNSYM，sh_link指向相关联的符号表，暂时不解。</span><br><span class="line">对于其它的section type，sh_link的值是SHN_UNDEF</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sh_info</code>，存放额外的信息，值的解释依赖于section type。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果是SHT_REL和SHT_RELA类型的重定位节，sh_info是应用relocation的节的节头索引。</span><br><span class="line">如果是SHT_SYMTAB和SHT_DYNSYM，sh_info是第一个non-local符号在符号表中的索引。推测local symbol在前面，non-local symbols紧跟在后面，所以文档中也说，sh_info是最后一个本地符号的在符号表中的索引加1。</span><br><span class="line">对于其它类型的section，sh_info是0。</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>sh_addralign</code>，地址对齐，如果一个section有一个doubleword字段，系统在载入section时的内存地址必须是doubleword对齐。也就是说sh_addr必须是sh_addralign的整数倍。只有2的正整数幂是有效的。0和1说明没有对齐约束。</p>
</li>
<li><code>sh_entsize</code>，有些section包含固定大小的记录，比如符号表。这个值给出了每个记录大小。对于不包含固定大小记录的section，这个值是0。</li>
</ol>
<p>系统预定义的section name</p>
<p>系统预定义了一些节名（以.开头），这些节有其特定的类型和含义。</p>
<ol>
<li><code>.bss</code>：包含程序运行时未初始化的数据（全局变量和静态变量）。当程序运行时，这些数据初始化为0。 其类型为SHT_NOBITS，表示不占文件空间。SHF_ALLOC + SHF_WRITE，运行时要占用内存的。</li>
<li><code>.comment</code>包含版本控制信息（是否包含程序的注释信息？不包含，注释在预处理时已经被删除了）。类型为SHT_PROGBITS。</li>
<li><code>.data</code>和<code>.data1</code>，包含初始化的全局变量和静态变量。 类型为SHT_PROGBITS，标志为SHF_ALLOC + SHF_WRITE（占用内存，可写）。</li>
<li><code>.debug</code>，包含了符号调试用的信息，我们要想用gdb等工具调试程序，需要该类型信息，类型为SHT_PROGBITS。</li>
<li><code>.dynamic</code>，类型SHT_DYNAMIC，包含了动态链接的信息。标志SHF_ALLOC，是否包含SHF_WRITE和处理器有关。</li>
<li><code>.dynstr</code>，SHT_STRTAB，包含了动态链接用的字符串，通常是和符号表中的符号关联的字符串。标志 SHF_ALLOC</li>
<li><code>.dynsym</code>，类型SHT_DYNSYM，包含动态链接符号表， 标志SHF_ALLOC。</li>
<li><code>.fini</code>，类型SHT_PROGBITS，程序正常结束时，要执行该section中的指令。标志SHF_ALLOC + SHF_EXECINSTR（占用内存可执行）。现在ELF还包含.fini_array section。</li>
<li><code>.got</code>，类型SHT_PROGBITS，全局偏移表(global offset table)，以后会重点讲。</li>
<li><code>.hash</code>，类型SHT_HASH，包含符号hash表，以后细讲。标志SHF_ALLOC。</li>
<li><code>.init</code>，SHT_PROGBITS，程序运行时，先执行该节中的代码。SHF_ALLOC + SHF_EXECINSTR，和.fini对应。现在ELF还包含.init_array section。</li>
<li><code>.interp</code>，SHT_PROGBITS，该节内容是一个字符串，指定了程序解释器的路径名。如果文件中有一个可加载的segment包含该节，属性就包含SHF_ALLOC，否则不包含。</li>
<li><code>.line</code>，SHT_PROGBITS，包含符号调试的行号信息，描述了源程序和机器代码的对应关系。gdb等调试器需要此信息。</li>
<li><code>.note</code> Note Section, 类型SHT_NOTE，以后单独讲。</li>
<li><code>.plt</code> 过程链接表（Procedure Linkage Table），类型SHT_PROGBITS,以后重点讲。</li>
<li><code>.relNAME</code>，类型SHT_REL, 包含重定位信息。如果文件有一个可加载的segment包含该section，section属性将包含SHF_ALLOC，否则不包含。NAME，是应用重定位的节的名字，比如.text的重定位信息存储在.rel.text中。</li>
<li><code>.relaname</code>类型SHT_RELA，和.rel相同。SHT_RELA和SHT_REL的区别，会在讲重定位的时候说明。</li>
<li><code>.rodata</code>和<code>.rodata1</code>。类型SHT_PROGBITS, 包含只读数据，组成不可写的段。标志SHF_ALLOC。</li>
<li><code>.shstrtab</code>，类型SHT_STRTAB，包含section的名字。有读者可能会问：section header中不是已经包含名字了吗，为什么把名字集中存放在这里？ sh_name 包含的是.shstrtab 中的索引，真正的字符串存储在.shstrtab中。那么section names为什么要集中存储？我想是这样：如果有相同的字符串，就可以共用一块存储空间。如果字符串存在包含关系，也可以共用一块存储空间。</li>
<li><code>.strtab</code> SHT_STRTAB，包含字符串，通常是符号表中符号对应的变量名字。如果文件有一个可加载的segment包含该section，属性将包含SHF_ALLOC。字符串以\0结束， section以\0开始，也以\0结束。一个.strtab可以是空的，它的sh_size将是0。针对空字符串表的非0索引是允许的。</li>
<li><code>symtab</code>，类型SHT_SYMTAB，Symbol Table，符号表。包含了定位、重定位符号定义和引用时需要的信息。符号表是一个数组，Index 0 第一个入口，它的含义是undefined symbol index， STN_UNDEF。如果文件有一个可加载的segment包含该section，属性将包含SHF_ALLOC。</li>
</ol>
<p>练习：读取section names<br>从这一讲开始，都会有练习，方便我们把前面的理论知识综合运用。</p>
<p>下面这个练习的目标是：从一个ELF文件中读取存储section name的字符串表。前面讲过，该字符串表也是一个section，section header table中有其对应的section header，并且ELF文件头中给出了节名字符串表对应的section header的索引，e_shstrndx。</p>
<p>我们的思路是这样：</p>
<ol>
<li>从ELF header中读取section header table的起始位置，每个section header的大小，以及节名字符串表对应section header的索引。</li>
<li>计算<code>section_header_table_offset + section_header_size * e_shstrndx</code>就是节名字符串表对应section header的偏移。</li>
<li>读取section header，可以从中得到节名字符串表在文件中的偏移和大小。</li>
<li>把节名字符串表读取到内存中，打印其内容。</li>
</ol>
<p>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 64位ELF文件读取section name string table */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 打开本地的ELF可执行文件hello */</span></span><br><span class="line">    FILE *fp = fopen(<span class="string">"./hello"</span>, <span class="string">"rb"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!fp) &#123;</span><br><span class="line">        perror(<span class="string">"open ELF file"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 通过读取ELF header得到section header table的偏移 */</span></span><br><span class="line">    <span class="comment">/* for 64 bit ELF,</span></span><br><span class="line"><span class="comment">       e_ident(16) + e_type(2) + e_machine(2) +</span></span><br><span class="line"><span class="comment">       e_version(4) + e_entry(8) + e_phoff(8) = 40 */</span></span><br><span class="line">    fseek(fp, <span class="number">40</span>, SEEK_SET);</span><br><span class="line">    <span class="keyword">uint64_t</span> sh_off;</span><br><span class="line">    <span class="keyword">int</span> r = fread(&amp;sh_off, <span class="number">1</span>, <span class="number">8</span>, fp);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">8</span>) &#123;</span><br><span class="line">        perror(<span class="string">"read section header offset"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 得到的这个偏移值，可以用`reaelf -h hello`来验证是否正确 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"section header offset in file: %ld (0x%lx)\n"</span>, sh_off, sh_off);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2. 读取每个section header的大小e_shentsize,</span></span><br><span class="line"><span class="comment">       section header的数量e_shnum,</span></span><br><span class="line"><span class="comment">       以及对应section name字符串表的section header的索引e_shstrndx</span></span><br><span class="line"><span class="comment">       得到这些值后，都可以用`readelf -h hello`来验证是否正确 */</span></span><br><span class="line">    <span class="comment">/* e_flags(4) + e_ehsize(2) + e_phentsize(2) + e_phnum(2) = 10 */</span></span><br><span class="line">    fseek(fp, <span class="number">10</span>, SEEK_CUR);</span><br><span class="line">    <span class="keyword">uint16_t</span> sh_ent_size;            <span class="comment">/* 每个section header的大小 */</span></span><br><span class="line">    r = fread(&amp;sh_ent_size, <span class="number">1</span>, <span class="number">2</span>, fp);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">2</span>) &#123;</span><br><span class="line">        perror(<span class="string">"read section header entry size"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"section header entry size: %d\n"</span>, sh_ent_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> sh_num;            <span class="comment">/* section header的数量 */</span></span><br><span class="line">    r = fread(&amp;sh_num, <span class="number">1</span>, <span class="number">2</span>, fp);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">2</span>) &#123;</span><br><span class="line">        perror(<span class="string">"read section header number"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"section header number: %d\n"</span>, sh_num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> sh_strtab_index;   <span class="comment">/* 节名字符串表对应的节头的索引 */</span></span><br><span class="line">    r = fread(&amp;sh_strtab_index, <span class="number">1</span>, <span class="number">2</span>, fp);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">2</span>) &#123;</span><br><span class="line">        perror(<span class="string">"read section header string table index"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"section header string table index: %d\n"</span>, sh_strtab_index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 3. read section name string table offset, size */</span></span><br><span class="line">    <span class="comment">/* 先找到节头字符串表对应的section header的偏移位置 */</span></span><br><span class="line">    fseek(fp, sh_off + sh_strtab_index * sh_ent_size, SEEK_SET);</span><br><span class="line">    <span class="comment">/* 再从section header中找到节头字符串表的偏移 */</span></span><br><span class="line">    <span class="comment">/* sh_name(4) + sh_type(4) + sh_flags(8) + sh_addr(8) = 24 */</span></span><br><span class="line">    fseek(fp, <span class="number">24</span>, SEEK_CUR);</span><br><span class="line">    <span class="keyword">uint64_t</span> str_table_off;</span><br><span class="line">    r = fread(&amp;str_table_off, <span class="number">1</span>, <span class="number">8</span>, fp);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">8</span>) &#123;</span><br><span class="line">        perror(<span class="string">"read section name string table offset"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"section name string table offset: %ld\n"</span>, str_table_off);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 从section header中找到节头字符串表的大小 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> str_table_size;</span><br><span class="line">    r = fread(&amp;str_table_size, <span class="number">1</span>, <span class="number">8</span>, fp);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">8</span>) &#123;</span><br><span class="line">        perror(<span class="string">"read section name string table size"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"section name string table size: %ld\n"</span>, str_table_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 动态分配内存，把节头字符串表读到内存中 */</span></span><br><span class="line">    <span class="keyword">char</span> *buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(str_table_size);</span><br><span class="line">    <span class="keyword">if</span>(!buf) &#123;</span><br><span class="line">        perror(<span class="string">"allocate memory for section name string table"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fseek(fp, str_table_off, SEEK_SET);</span><br><span class="line">    r = fread(buf, <span class="number">1</span>, str_table_size, fp);</span><br><span class="line">    <span class="keyword">if</span>(r != str_table_size) &#123;</span><br><span class="line">        perror(<span class="string">"read section name string table"</span>);</span><br><span class="line">        <span class="built_in">free</span>(buf);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint16_t</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; str_table_size; ++i) &#123;</span><br><span class="line">        <span class="comment">/* 如果节头字符串表中的字节是0，就打印`\0` */</span></span><br><span class="line">        <span class="keyword">if</span> (buf[i] == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\\0"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>把以上代码存为chap3_read_section_names.c，执行gcc -Wall -o secnames chap3_read_section_names.c进行编译，输出的执行文件名叫secnames。执行secnames，输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./secnames</span><br><span class="line">section header offset in file: 14768 (0x39b0)</span><br><span class="line">section header entry size: 64</span><br><span class="line">section header number: 29</span><br><span class="line">section header string table index: 28</span><br><span class="line">section name string table offset: 14502</span><br><span class="line">section name string table size: 259</span><br><span class="line">\0.symtab\0.strtab\0.shstrtab\0.interp\0.note.ABI-tag\0.note.gnu.build-id\0.gnu.hash\0.dynsym\0.dynstr\0.gnu.version\0.gnu.version_r\0.rela.dyn\0.rela.plt\0.init\0.text\0.fini\0.rodata\0.eh_frame_hdr\0.eh_frame\0.init_array\0.fini_array\0.dynamic\0.got\0.got.plt\0.data\0.bss\0.comment\0</span><br></pre></td></tr></table></figure></p>
<p>可以发现，节头字符串表以\0开始，以\0结束。如果一个section的name字段指向0，则他指向的字节值是0，则它没有名称，或名称是空。</p>
<p><strong>本文的目的</strong>：大家对于Hello World程序应该非常熟悉，随便使用哪一种语言，即使还不熟悉的语言，写出一个Hello World程序应该毫不费力，但是如果让大家详细的说明这个程序加载和链接的过程，以及后续的符号动态解析过程，可能还会有点困难。本文就是以一个最基本的C语言版本Hello World程序为基础，了解Linux下ELF文件的格式，分析并验证ELF文件和加载和动态链接的具有实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* hello.c */  </span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(“hello world!\n”);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">$ gcc –o hello hello.c</span><br></pre></td></tr></table></figure>
<p>本文的实验平台：<br> Ubuntu 7.04<br> Linux kernel 2.6.20<br> gcc 4.1.2<br> glibc 2.5<br> gdb 6.6<br> objdump/readelf 2.17.50</p>
<p>本文的组织：</p>
<p> 第一部分大致描述ELF文件的格式；<br> 第二部分分析ELF文件在内核空间的加载过程；<br> 第三部分分析ELF文件在运行过程中符号的动态解析过程；<br>（以上各部分都是以Hello World程序为例说明）<br> 第四部分简要总结；<br> 第五部分阐明需要深入了解的东西。</p>
<h1 id="ELF文件格式"><a href="#ELF文件格式" class="headerlink" title="ELF文件格式"></a>ELF文件格式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Executable and Linking Format(ELF)文件是x86 Linux系统下的一种常用目标文件(object file)格式，有三种主要类型:</p>
<ul>
<li>适于连接的可重定位文件(relocatable file)，可与其它目标文件一起创建可执行文件和共享目标文件。</li>
<li>适于执行的可执行文件(executable file)，用于提供程序的进程映像，加载的内存执行。</li>
<li>共享目标文件(shared object file)，连接器可将它与其它可重定位文件和共享目标文件连接成其它的目标文件，动态连接器又可将它与可执行文件和其它共享目标文件结合起来创建一个进程映像。</li>
</ul>
<p>ELF文件格式比较复杂，本文只是简要介绍它的结构，希望能给想了解ELF文件结构的读者以帮助。具体详尽的资料请参阅专门的ELF文档。</p>
<h2 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h2><p>为了方便和高效，ELF文件内容有两个平行的视角:一个是程序连接角度，另一个是程序运行角度，如图所示。<br><img src="/img/6cc27e57-5159-31ee-bc69-8392eeb4731a.png" alt></p>
<p>ELF header在文件开始处描述了整个文件的组织，Section提供了目标文件的各项信息（如指令、数据、符号表、重定位信息等），Program header table指出怎样创建进程映像，含有每个program header的入口，section header table包含每一个section的入口，给出名字、大小等信息。</p>
<h2 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h2><p> ELF数据编码顺序与机器相关，数据类型有六种，见下表：<br><img src="/img/609d893b-f125-31bf-93a7-4a57c06e36de.png" alt></p>
<h2 id="ELF文件头"><a href="#ELF文件头" class="headerlink" title="ELF文件头"></a>ELF文件头</h2><p> 像bmp、exe等文件一样，ELF的文件头包含整个文件的控制结构。它的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#define EI_NIDENT       16  </span><br><span class="line">typedef struct elf32_hdr&#123;  </span><br><span class="line">  unsigned char e_ident[EI_NIDENT];   </span><br><span class="line">  Elf32_Half    e_type;     /* file type */  </span><br><span class="line">  Elf32_Half    e_machine;  /* architecture */  </span><br><span class="line">  Elf32_Word e_version;  </span><br><span class="line">  Elf32_Addr    e_entry;    /* entry point */  </span><br><span class="line">  Elf32_Off e_phoff;        /* PH table offset */  </span><br><span class="line">  Elf32_Off e_shoff;        /* SH table offset */  </span><br><span class="line">  Elf32_Word    e_flags;  </span><br><span class="line">  Elf32_Half    e_ehsize;       /* ELF header size in bytes */  </span><br><span class="line">  Elf32_Half    e_phentsize;    /* PH size */  </span><br><span class="line">  Elf32_Half    e_phnum;        /* PH number */  </span><br><span class="line">  Elf32_Half    e_shentsize;    /* SH size */  </span><br><span class="line">  Elf32_Half    e_shnum;        /* SH number */  </span><br><span class="line">  Elf32_Half    e_shstrndx; /* SH name string table index */  </span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure></p>
<p>其中E_ident的16个字节标明是个ELF文件（7F+’E’+’L’+’F’）。e_type表示文件类型，2表示可执行文件。e_machine说明机器类别，3表示386机器，8表示MIPS机器。e_entry给出进程开始的虚地址，即系统将控制转移的位置。e_phoff指出program header table的文件偏移，e_phentsize表示一个program header表中的入口的长度（字节数表示），e_phnum给出program header表中的入口数目。类似的，e_shoff，e_shentsize，e_shnum 分别表示section header表的文件偏移，表中每个入口的的字节数和入口数目。e_flags给出与处理器相关的标志，e_ehsize给出ELF文件头的长度（字节数表示）。e_shstrndx表示section名表的位置，指出在section header表中的索引。</p>
<h2 id="Section-Header"><a href="#Section-Header" class="headerlink" title="Section Header"></a>Section Header</h2><p>目标文件的section header table可以定位所有的section，它是一个Elf32_Shdr结构的数组，Section头表的索引是这个数组的下标。有些索引号是保留的，目标文件不能使用这些特殊的索引。<br>Section包含目标文件除了ELF文件头、程序头表、section头表的所有信息，而且目标文件section满足几个条件：</p>
<p>目标文件中的每个section都只有一个section头项描述，可以存在不指示任何section的section头项。<br>每个section在文件中占据一块连续的空间。<br>Section之间不可重叠。<br>目标文件可以有非活动空间，各种headers和sections没有覆盖目标文件的每一个字节，这些非活动空间是没有定义的。<br>Section header结构定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;  </span><br><span class="line">  Elf32_Word    sh_name;    /* name of section, index */  </span><br><span class="line">  Elf32_Word    sh_type;      </span><br><span class="line">  Elf32_Word    sh_flags;  </span><br><span class="line">  Elf32_Addr     sh_addr;       /* memory address, if any */  </span><br><span class="line">  Elf32_Off      sh_offset;  </span><br><span class="line">  Elf32_Word    sh_size;        /* section size in file */  </span><br><span class="line">  Elf32_Word    sh_link;  </span><br><span class="line">  Elf32_Word    sh_info;  </span><br><span class="line">  Elf32_Word    sh_addralign;  </span><br><span class="line">  Elf32_Word    sh_entsize;     /* fixed entry size, if have */  </span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure></p>
<p>其中sh_name指出section的名字，它的值是后面将会讲到的section header string table中的索引，指出一个以null结尾的字符串。sh_type是类别，sh_flags指示该section在进程执行时的特性。sh_addr指出若此section在进程的内存映像中出现，则给出开始的虚地址。sh_offset给出此section在文件中的偏移。其它字段的意义不太常用，在此不细述。</p>
<p>文件的section含有程序和控制信息，系统使用一些特定的section，并有其固定的类型和属性（由sh_type和sh_info指出）。下面介绍几个常用到的section:“.bss”段含有占据程序内存映像的未初始化数据，当程序开始运行时系统对这段数据初始为零，但这个section并不占文件空间。“.data.”和“.data1”段包含占据内存映像的初始化数据。“.rodata”和“.rodata1”段含程序映像中的只读数据。“.shstrtab”段含有每个section的名字，由section入口结构中的sh_name索引。“.strtab”段含有表示符号表(symbol table)名字的字符串。“.symtab”段含有文件的符号表，在后文专门介绍。“.text”段包含程序的可执行指令。</p>
<p>当然一个实际的ELF文件中，会包含很多的section，如.got，.plt等等，我们这里就不一一细述了，需要时再详细的说明。</p>
<h2 id="Program-Header"><a href="#Program-Header" class="headerlink" title="Program Header"></a>Program Header</h2><p>目标文件或者共享文件的program header table描述了系统执行一个程序所需要的段或者其它信息。目标文件的一个段（segment）包含一个或者多个section。Program header只对可执行文件和共享目标文件有意义，对于程序的链接没有任何意义。结构定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct elf32_phdr&#123;  </span><br><span class="line">  Elf32_Word    p_type;   </span><br><span class="line">  Elf32_Off      p_offset;  </span><br><span class="line">  Elf32_Addr    p_vaddr;        /* virtual address */  </span><br><span class="line">  Elf32_Addr    p_paddr;        /* ignore */  </span><br><span class="line">  Elf32_Word    p_filesz;       /* segment size in file */  </span><br><span class="line">  Elf32_Word    p_memsz;        /* size in memory */  </span><br><span class="line">  Elf32_Word    p_flags;  </span><br><span class="line">  Elf32_Word    p_align;       </span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure></p>
<p>其中p_type描述段的类型；p_offset给出该段相对于文件开关的偏移量；p_vaddr给出该段所在的虚拟地址；p_paddr给出该段的物理地址，在Linux x86内核中，这项并没有被使用；p_filesz给出该段的大小，在字节为单元，可能为0；p_memsz给出该段在内存中所占的大小，可能为0；p_filesze与p_memsz的值可能会不相等。</p>
<h2 id="Symbol-Table"><a href="#Symbol-Table" class="headerlink" title="Symbol Table"></a>Symbol Table</h2><p>目标文件的符号表包含定位或重定位程序符号定义和引用时所需要的信息。符号表入口结构定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct elf32_sym&#123;  </span><br><span class="line">  Elf32_Word    st_name;  </span><br><span class="line">  Elf32_Addr    st_value;  </span><br><span class="line">  Elf32_Word    st_size;  </span><br><span class="line">  unsigned char     st_info;  </span><br><span class="line">  unsigned char st_other;  </span><br><span class="line">  Elf32_Half     st_shndx;  </span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure></p>
<p>其中st_name包含指向符号表字符串表(strtab)中的索引，从而可以获得符号名。st_value指出符号的值，可能是一个绝对值、地址等。st_size指出符号相关的内存大小，比如一个数据结构包含的字节数等。st_info规定了符号的类型和绑定属性，指出这个符号是一个数据名、函数名、section名还是源文件名；并且指出该符号的绑定属性是local、global还是weak。</p>
<h2 id="Section和Segment的区别和联系"><a href="#Section和Segment的区别和联系" class="headerlink" title="Section和Segment的区别和联系"></a>Section和Segment的区别和联系</h2><p>可执行文件中，一个program header描述的内容称为一个段（segment）。Segment包含一个或者多个section，我们以Hello World程序为例，看一下section与segment的映射关系：<br><img src="/img/e4c15bdc-2db0-3e42-8176-081f454e25fc.png" alt></p>
<p><img src="/img/aa8e40c5-5964-3fae-98f3-df194dbb7eec.png" alt></p>
<p>如上图红色区域所示，就是我们经常提到的文本段和数据段，由图中绿色部分的映射关系可知，文本段并不仅仅包含.text节，数据段也不仅仅包含.data节，而是都包含了多个section。</p>
<h1 id="ELF文件的加载过程"><a href="#ELF文件的加载过程" class="headerlink" title="ELF文件的加载过程"></a>ELF文件的加载过程</h1><h2 id="加载和动态链接的简要介绍"><a href="#加载和动态链接的简要介绍" class="headerlink" title="加载和动态链接的简要介绍"></a>加载和动态链接的简要介绍</h2><p>从编译/链接和运行的角度看，应用程序和库程序的连接有两种方式。一种是固定的、静态的连接，就是把需要用到的库函数的目标代码（二进制）代码从程序库中抽取出来，链接进应用软件的目标映像中；另一种是动态链接，是指库函数的代码并不进入应用软件的目标映像，应用软件在编译/链接阶段并不完成跟库函数的链接，而是把函数库的映像也交给用户，到启动应用软件目标映像运行时才把程序库的映像也装入用户空间（并加以定位），再完成应用软件与库函数的连接。</p>
<p>这样，就有了两种不同的ELF格式映像。一种是静态链接的，在装入/启动其运行时无需装入函数库映像、也无需进行动态连接。另一种是动态连接，需要在装入/启动其运行时同时装入函数库映像并进行动态链接。Linux内核既支持静态链接的ELF映像，也支持动态链接的ELF映像，而且装入/启动ELF映像必需由内核完成，而动态连接的实现则既可以在内核中完成，也可在用户空间完成。因此，GNU把对于动态链接ELF映像的支持作了分工：把ELF映像的装入/启动入在Linux内核中；而把动态链接的实现放在用户空间（glibc），并为此提供一个称为“解释器”（ld-linux.so.2）的工具软件，而解释器的装入/启动也由内核负责，这在后面我们分析ELF文件的加载时就可以看到。</p>
<p>这部分主要说明ELF文件在内核空间的加载过程，下一部分对用户空间符号的动态解析过程进行说明。</p>
<h2 id="Linux可执行文件类型的注册机制"><a href="#Linux可执行文件类型的注册机制" class="headerlink" title="Linux可执行文件类型的注册机制"></a>Linux可执行文件类型的注册机制</h2><p>在说明ELF文件的加载过程以前，我们先回答一个问题，就是：为什么Linux可以运行ELF文件？</p>
<p>回答：内核对所支持的每种可执行的程序类型都有个struct linux_binfmt的数据结构，定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * This structure defines the functions that are used to load the binary formats that </span><br><span class="line"> * linux accepts. </span><br><span class="line"> */  </span><br><span class="line">struct linux_binfmt &#123;  </span><br><span class="line">        struct linux_binfmt * next;  </span><br><span class="line">        struct module *module;  </span><br><span class="line">        int (*load_binary)(struct linux_binprm *, struct  pt_regs * regs);  </span><br><span class="line">        int (*load_shlib)(struct file *)  </span><br><span class="line">        int (*core_dump)(long signr, struct pt_regs * regs, struct file * file);  </span><br><span class="line">        unsigned long min_coredump;     /* minimal dump size */  </span><br><span class="line">        int hasvdso;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其中的load_binary函数指针指向的就是一个可执行程序的处理函数。而我们研究的ELF文件格式的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static struct linux_binfmt elf_format = &#123;  </span><br><span class="line">                .module      = THIS_MODULE,  </span><br><span class="line">                .load_binary = load_elf_binary,  </span><br><span class="line">                .load_shlib      = load_elf_library,  </span><br><span class="line">                .core_dump       = elf_core_dump,  </span><br><span class="line">                .min_coredump    = ELF_EXEC_PAGESIZE,  </span><br><span class="line">                .hasvdso     = 1  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p> 要支持ELF文件的运行，则必须向内核登记这个数据结构，加入到内核支持的可执行程序的队列中。内核提供两个函数来完成这个功能，一个注册，一个注销，即：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int register_binfmt(struct linux_binfmt * fmt)  </span><br><span class="line">int unregister_binfmt(struct linux_binfmt * fmt)</span><br></pre></td></tr></table></figure></p>
<p>当需要运行一个程序时，则扫描这个队列，让各个数据结构所提供的处理程序，ELF中即为load_elf_binary，逐一前来认领，如果某个格式的处理程序发现相符后，便执行该格式映像的装入和启动。</p>
<h2 id="内核空间的加载过程"><a href="#内核空间的加载过程" class="headerlink" title="内核空间的加载过程"></a>内核空间的加载过程</h2><p>内核中实际执行execv()或execve()系统调用的程序是do_execve()，这个函数先打开目标映像文件，并从目标文件的头部（第一个字节开始）读入若干（当前Linux内核中是128）字节（实际上就是填充ELF文件头，下面的分析可以看到），然后调用另一个函数search_binary_handler()，在此函数里面，它会搜索我们上面提到的Linux支持的可执行文件类型队列，让各种可执行程序的处理程序前来认领和处理。如果类型匹配，则调用load_binary函数指针所指向的处理函数来处理目标映像文件。在ELF文件格式中，处理函数是load_elf_binary函数，下面主要就是分析load_elf_binary函数的执行过程（说明：因为内核中实际的加载需要涉及到很多东西，这里只关注跟ELF文件的处理相关的代码）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">elf_ex</span>;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> <span class="title">interp_elf_ex</span>;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">exec</span> <span class="title">interp_ex</span>;</span>  </span><br><span class="line">&#125; *loc;  </span><br><span class="line">loc = kmalloc(<span class="keyword">sizeof</span>(*loc), GFP_KERNEL);  </span><br><span class="line"><span class="comment">/* Get the exec-header */</span>  </span><br><span class="line">loc-&gt;elf_ex = *((struct elfhdr *)bprm-&gt;buf);  </span><br><span class="line">   ……  </span><br><span class="line"><span class="comment">/* First of all, some simple consistency checks */</span>  </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">memcmp</span>(loc-&gt;elf_ex.e_ident, ELFMAG, SELFMAG) != <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">goto</span> out;  </span><br><span class="line"><span class="keyword">if</span> (loc-&gt;elf_ex.e_type != ET_EXEC &amp;&amp; loc-&gt;elf_ex.e_type != ET_DYN)  </span><br><span class="line">        <span class="keyword">goto</span> out;</span><br></pre></td></tr></table></figure>
<p>在load_elf_binary之前，内核已经使用映像文件的前128个字节对bprm-&gt;buf进行了填充，563行就是使用这此信息填充映像的文件头（具体数据结构定义见第一部分，ELF文件头节），然后567行就是比较文件头的前四个字节，查看是否是ELF文件类型定义的“\177ELF”。除这4个字符以外，还要看映像的类型是否ET_EXEC和ET_DYN之一；前者表示可执行映像，后者表示共享库。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Now read in all of the header information */</span>  </span><br><span class="line"><span class="keyword">if</span> (loc-&gt;elf_ex.e_phnum &lt; <span class="number">1</span> || loc-&gt;elf_ex.e_phnum &gt; <span class="number">65536U</span> / <span class="keyword">sizeof</span>(struct elf_phdr))  </span><br><span class="line">        <span class="keyword">goto</span> out;  </span><br><span class="line">size = loc-&gt;elf_ex.e_phnum * <span class="keyword">sizeof</span>(struct elf_phdr);  </span><br><span class="line">   ……  </span><br><span class="line">elf_phdata = kmalloc(size, GFP_KERNEL);  </span><br><span class="line">   ……  </span><br><span class="line">retval = kernel_read(bprm-&gt;file, loc-&gt;elf_ex.e_phoff,  </span><br><span class="line">                     (<span class="keyword">char</span> *)elf_phdata, size);</span><br></pre></td></tr></table></figure></p>
<p>这块就是通过kernel_read读入整个program header table。从代码中可以看到，一个可执行程序必须至少有一个段（segment），而所有段的大小之和不能超过64K。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">elf_ppnt = elf_phdata;  </span><br><span class="line">            ……  </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loc-&gt;elf_ex.e_phnum; i++) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (elf_ppnt-&gt;p_type == PT_INTERP) &#123;  </span><br><span class="line">        ……  </span><br><span class="line">        elf_interpreter = kmalloc(elf_ppnt-&gt;p_filesz, GFP_KERNEL);  </span><br><span class="line">        ……  </span><br><span class="line">        retval = kernel_read(bprm-&gt;file, elf_ppnt-&gt;p_offset,  </span><br><span class="line">                         elf_interpreter,  </span><br><span class="line">                         elf_ppnt-&gt;p_filesz);  </span><br><span class="line">        ……  </span><br><span class="line">        interpreter = open_exec(elf_interpreter);  </span><br><span class="line">        ……  </span><br><span class="line">        retval = kernel_read(interpreter, <span class="number">0</span>, bprm-&gt;buf,  </span><br><span class="line">                         BINPRM_BUF_SIZE);  </span><br><span class="line">        ……  </span><br><span class="line">        <span class="comment">/* Get the exec headers */</span>  </span><br><span class="line">        ……  </span><br><span class="line">        loc-&gt;interp_elf_ex = *((struct elfhdr *)bprm-&gt;buf);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    elf_ppnt++;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个for循环的目的在于寻找和处理目标映像的“解释器”段。“解释器”段的类型为PT_INTERP，找到后就根据其位置的p_offset和大小p_filesz把整个“解释器”段的内容读入缓冲区（640~640）。事个“解释器”段实际上只是一个字符串，即解释器的文件名，如“/lib/ld-linux.so.2”。有了解释器的文件名以后，就通过open_exec()打开这个文件，再通过kernel_read()读入其开关128个字节（695~696），即解释器映像的头部。我们以Hello World程序为例，看一下这段中具体的内容：<br><img src="/img/aa8e40c5-5964-3fae-98f3-df194dbb7eed.png" alt></p>
<p>其实从readelf程序的输出中，我们就可以看到需要解释器/lib/ld-linux.so.2，为了进一步的验证，我们用hd命令以16进制格式查看下类型为INTERP的段所在位置的内容，在上面的各个域可以看到，它位于偏移量为0x000114的位置，文件内占19个字节：<br><img src="/img/05aa899e-a4dd-37f2-9824-e5cb6ad8434d.png" alt></p>
<p>从上面红色部分可以看到，这个段中实际保存的就是“/lib/ld-linux.so.2”这个字符串。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>, elf_ppnt = elf_phdata; i &lt; loc-&gt;elf_ex.e_phnum; i++, elf_ppnt++) &#123;  </span><br><span class="line">           ……   </span><br><span class="line">        <span class="keyword">if</span> (elf_ppnt-&gt;p_type != PT_LOAD)  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">           ……   </span><br><span class="line">        error = elf_map(bprm-&gt;file, load_bias + vaddr, elf_ppnt,  </span><br><span class="line">                        elf_prot, elf_flags);  </span><br><span class="line">           ……  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码从目标映像的程序头中搜索类型为PT_LOAD的段（Segment）。在二进制映像中，只有类型为PT_LOAD的段才是需要装入的。当然在装入之前，需要确定装入的地址，只要考虑的就是页面对齐，还有该段的p_vaddr域的值（上面省略这部分内容）。确定了装入地址后，就通过elf_map()建立用户空间虚拟地址空间与目标映像文件中某个连续区间之间的映射，其返回值就是实际映射的起始地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (elf_interpreter) &#123;  </span><br><span class="line">        ……  </span><br><span class="line">    elf_entry = load_elf_interp(&amp;loc-&gt;interp_elf_ex,  </span><br><span class="line">                            interpreter,  </span><br><span class="line">                                &amp;interp_load_addr);  </span><br><span class="line">                        ……  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    elf_entry = loc-&gt;elf_ex.e_entry;  </span><br><span class="line">        ……  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段程序的逻辑非常简单：如果需要装入解释器，就通过load_elf_interp装入其映像（951~953），并把将来进入用户空间的入口地址设置成load_elf_interp()的返回值，即解释器映像的入口地址。而若不装入解释器，那么这个入口地址就是目标映像本身的入口地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create_elf_tables(bprm, &amp;loc-&gt;elf_ex,  </span><br><span class="line">                   (interpreter_type == INTERPRETER_AOUT),  </span><br><span class="line">                   load_addr, interp_load_addr);  </span><br><span class="line">    ……  </span><br><span class="line">start_thread(regs, elf_entry, bprm-&gt;p);</span><br></pre></td></tr></table></figure>
<p>在完成装入，启动用户空间的映像运行之前，还需要为目标映像和解释器准备好一些有关的信息，这些信息包括常规的argc、envc等等，还有一些“辅助向量（Auxiliary Vector）”。这些信息需要复制到用户空间，使它们在CPU进入解释器或目标映像的程序入口时出现在用户空间堆栈上。这里的create_elf_tables()就起着这个作用。</p>
<p>最后，start_thread()这个宏操作会将eip和esp改成新的地址，就使得CPU在返回用户空间时就进入新的程序入口。如果存在解释器映像，那么这就是解释器映像的程序入口，否则就是目标映像的程序入口。那么什么情况下有解释器映像存在，什么情况下没有呢？如果目标映像与各种库的链接是静态链接，因而无需依靠共享库、即动态链接库，那就不需要解释器映像；否则就一定要有解释器映像存在。</p>
<p>以我们的Hello World为例，gcc在编译时，除非显示的使用static标签，否则所有程序的链接都是动态链接的，也就是说需要解释器。由此可见，我们的Hello World程序在被内核加载到内存，内核跳到用户空间后并不是执行Hello World的，而是先把控制权交到用户空间的解释器，由解释器加载运行用户程序所需要的动态库（Hello World需要libc），然后控制权才会转移到用户程序。</p>
<h1 id="ELF文件中符号的动态解析过程"><a href="#ELF文件中符号的动态解析过程" class="headerlink" title="ELF文件中符号的动态解析过程"></a>ELF文件中符号的动态解析过程</h1><p>上面一节提到，控制权是先交到解释器，由解释器加载动态库，然后控制权才会到用户程序。因为时间原因，动态库的具体加载过程，并没有进行深入分析。大致的过程就是将每一个依赖的动态库都加载到内存，并形成一个链表，后面的符号解析过程主要就是在这个链表中搜索符号的定义。</p>
<p>我们后面主要就是以Hello World为例，分析程序是如何调用printf的：</p>
<p>查看一下gcc编译生成的Hello World程序的汇编代码（main函数部分）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">08048374 &lt;main&gt;:  </span><br><span class="line">8048374:       8d 4c 24 04         lea     0x4(%esp),%ecx  </span><br><span class="line">                ……  </span><br><span class="line">8048385:       c7 04 24 6c 84 04 08    movl    $0x804846c,(%esp)  </span><br><span class="line">804838c:       e8 2b ff ff ff          call        80482bc &lt;puts@plt&gt;  </span><br><span class="line">8048391:       b8 00 00 00 00          mov     $0x0,%eax</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码可以看出，经过编译后，printf函数的调用已经换成了puts函数（原因读者可以想一下）。其中的call指令就是调用puts函数。但从上面的代码可以看出，它调用的是puts@plt这个标号，它代表什么意思呢？在进一步说明符号的动态解析过程以前，需要先了解两个概念，一个是global offset table，一个是procedure linkage table。</p>
<h2 id="Global-Offset-Table（GOT）"><a href="#Global-Offset-Table（GOT）" class="headerlink" title="Global Offset Table（GOT）"></a>Global Offset Table（GOT）</h2><p>在位置无关代码中，一般不能包含绝对虚拟地址（如共享库）。当在程序中引用某个共享库中的符号时，编译链接阶段并不知道这个符号的具体位置，只有等到动态链接器将所需要的共享库加载时进内存后，也就是在运行阶段，符号的地址才会最终确定。因此，需要有一个数据结构来保存符号的绝对地址，这就是GOT表的作用，GOT表中每项保存程序中引用其它符号的绝对地址。这样，程序就可以通过引用GOT表来获得某个符号的地址。</p>
<p>在x86结构中，GOT表的前三项保留，用于保存特殊的数据结构地址，其它的各项保存符号的绝对地址。对于符号的动态解析过程，我们只需要了解的就是第二项和第三项，即GOT[1]和GOT[2]：GOT[1]保存的是一个地址，指向已经加载的共享库的链表地址（前面提到加载的共享库会形成一个链表）；GOT[2]保存的是一个函数的地址，定义如下：GOT[2] = &amp;_dl_runtime_resolve，这个函数的主要作用就是找到某个符号的地址，并把它写到与此符号相关的GOT项中，然后将控制转移到目标函数，后面我们会详细分析。</p>
<h2 id="Procedure-Linkage-Table（PLT）"><a href="#Procedure-Linkage-Table（PLT）" class="headerlink" title="Procedure Linkage Table（PLT）"></a>Procedure Linkage Table（PLT）</h2><p>过程链接表（PLT）的作用就是将位置无关的函数调用转移到绝对地址。在编译链接时，链接器并不能控制执行从一个可执行文件或者共享文件中转移到另一个中（如前所说，这时候函数的地址还不能确定），因此，链接器将控制转移到PLT中的某一项。而PLT通过引用GOT表中的函数的绝对地址，来把控制转移到实际的函数。</p>
<p>在实际的可执行程序或者共享目标文件中，GOT表在名称为.got.plt的section中，PLT表在名称为.plt的section中。</p>
<p>大致的了解了GOT和PLT的内容后，我们查看一下puts@plt中到底是什么内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .plt:  </span><br><span class="line">  </span><br><span class="line">0804828c &lt;__gmon_start__@plt-0x10&gt;:  </span><br><span class="line"> 804828c:       ff 35 68 95 04 08       pushl   0x8049568  </span><br><span class="line"> 8048292:       ff 25 6c 95 04 08       jmp     *0x804956c  </span><br><span class="line"> 8048298:       00 00  </span><br><span class="line">        ......  </span><br><span class="line">0804829c &lt;__gmon_start__@plt&gt;:  </span><br><span class="line"> 804829c:       ff 25 70 95 04 08       jmp     *0x8049570  </span><br><span class="line"> 80482a2:       68 00 00 00 00          push        $0x0  </span><br><span class="line"> 80482a7:       e9 e0 ff ff ff          jmp     804828c &lt;_init+0x18&gt;  </span><br><span class="line">  </span><br><span class="line">080482ac &lt;__libc_start_main@plt&gt;:  </span><br><span class="line"> 80482ac:       ff 25 74 95 04 08       jmp     *0x8049574  </span><br><span class="line"> 80482b2:       68 08 00 00 00          push        $0x8  </span><br><span class="line"> 80482b7:       e9 d0 ff ff ff          jmp     804828c &lt;_init+0x18&gt;  </span><br><span class="line">080482bc &lt;puts@plt&gt;:  </span><br><span class="line"> 80482bc:       ff 25 78 95 04 08       jmp     *0x8049578  </span><br><span class="line"> 80482c2:       68 10 00 00 00          push    $0x10  </span><br><span class="line"> 80482c7:       e9 c0 ff ff ff          jmp     804828c &lt;_init+0x18&gt;</span><br></pre></td></tr></table></figure></p>
<p>可以看到puts@plt包含三条指令，程序中所有对有puts函数的调用都要先来到这里（Hello World里只有一次）。可以看出，除PLT0以外（就是<strong>gmon_start</strong>@plt-0x10所标记的内容），其它的所有PLT项的形式都是一样的，而且最后的jmp指令都是0x804828c，即PLT0为目标的。所不同的只是第一条jmp指令的目标和push指令中的数据。PLT0则与之不同，但是包括PLT0在内的每个表项都占16个字节，所以整个PLT就像个数组（实际是代码段）。另外，每个PLT表项中的第一条jmp指令是间接寻址的。比如我们的puts函数是以地址0x8049578处的内容为目标地址进行中跳转的。</p>
<p>顺着这个地址，我们进一步查看此处的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/w  0x8049578  </span><br><span class="line">0x8049578 &lt;_GLOBAL_OFFSET_TABLE_+20&gt;:   0x080482c2</span><br></pre></td></tr></table></figure></p>
<p>从上面可以看出，这个地址就是GOT表中的一项。它里面的内容是0x80482c2，即puts@plt中的第二条指令。前面我们不是提到过，GOT中这里本应该是puts函数的地址才对，那为什么会这样呢？原来链接器在把所需要的共享库加载进内存后，并没有把共享库中的函数的地址写到GOT表项中，而是延迟到函数的第一次调用时，才会对函数的地址进行定位。</p>
<p>puts@plt的第二条指令是pushl $0x10，那这个0x10代表什么呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Relocation section &apos;.rel.plt&apos; at offset 0x25c contains 3 entries:  </span><br><span class="line"> Offset       Info       Type            Sym.Value  Sym. Name  </span><br><span class="line">08049570  00000107 R_386_JUMP_SLOT      00000000   __gmon_start__  </span><br><span class="line">08049574  00000207 R_386_JUMP_SLOT      00000000   __libc_start_main  </span><br><span class="line">08049578  00000307 R_386_JUMP_SLOT  00000000   puts</span><br></pre></td></tr></table></figure></p>
<p>其中的第三项就是puts函数的重定向信息，0x10即代表相对于.rel.plt这个section的偏移位置（每一项占8个字节）。其中的Offset这个域就代表的是puts函数地址在GOT表项中的位置，从上面puts@plt的第一条指令也可以验证这一点。向堆栈中压入这个偏移量的主要作用就是为了找到puts函数的符号名（即上面的Sym.Name域的“puts”这个字符串）以及puts函数地址在GOT表项中所占的位置，以便在函数定位完成后将函数的实际地址写到这个位置。</p>
<p>puts@plt的第三条指令就跳到了PLT0的位置。这条指令只是将0x8049568这个数值压入堆栈，它实际上是GOT表项的第二个元素，即GOT[1]（共享库链表的地址）。</p>
<p>随即PLT0的第二条指令即跳到了GOT[2]中所保存的地址（间接寻址），即_dl_runtime_resolve这个函数的入口。</p>
<p>_dl_runtime_resolve的定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_dl_runtime_resolve:  </span><br><span class="line">    pushl %eax      # Preserve registers otherwise clobbered.  </span><br><span class="line">    pushl %ecx  </span><br><span class="line">    pushl %edx  </span><br><span class="line">    movl 16(%esp), %edx # Copy args pushed by PLT in register.  Note  </span><br><span class="line">    movl 12(%esp), %eax # that `fixup&apos; takes its parameters in regs.  </span><br><span class="line">    call _dl_fixup      # Call resolver.  </span><br><span class="line">    popl %edx       # Get register content back.  </span><br><span class="line">    popl %ecx  </span><br><span class="line">    xchgl %eax, (%esp)  # Get %eax contents end store function address.  </span><br><span class="line">    ret $8          # Jump to function address.</span><br></pre></td></tr></table></figure></p>
<p>从调用puts函数到现在，总共有两次压栈操作，一次是压入puts函数的重定向信息的偏移量，一次是GOT[1]（共享库链表的地址）。上面的两次movl操作就是将这两个数据分别取到edx和eax，然后调用_dl_fixup（从寄存器取参数），此函数完成的功能就是找到puts函数的实际加载地址，并将它写到GOT中，然后通过eax将此值返回给_dl_runtime_resolve。xchagl这条指令，不仅将eax的值恢复，而且将puts函数的值压到栈顶，这样当执行ret指令后，控制就转移到puts函数内部。ret指令同时也完成了清栈动作，使栈顶为puts函数的返回地址（main函数中call指令的下一条指令），这样，当puts函数返回时，就返回到正确的位置。</p>
<p>当然，如果是第二次调用puts函数，那么就不需要这么复杂的过程，而只要通过GOT表中已经确定的函数地址直接进行跳转即可。下图是前面过程的一个示意图，红色为第一次函数调用的顺序，蓝色为后续函数调用的顺序（第1步都要执行）。<br><img src="/img/289baeed-3f91-3651-b81b-159632d1cf45.png" alt></p>
<h1 id="ELF文件加载和链接的简要总结"><a href="#ELF文件加载和链接的简要总结" class="headerlink" title="ELF文件加载和链接的简要总结"></a>ELF文件加载和链接的简要总结</h1><p>用户通过shell执行程序，shell通过exceve进入系统调用。（User-Mode）</p>
<p>sys_execve经过一系列过程，并最终通过ELF文件的处理函数load_elf_binary将用户程序和ELF解释器加载进内存，并将控制权交给解释器。（Kernel-Mode）</p>
<p>ELF解释器进行相关库的加载，并最终把控制权交给用户程序。由解释器处理用户程序运行过程中符号的动态解析。（User-Mode）</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/21/git技巧/" rel="next" title="git 常用技巧">
                <i class="fa fa-chevron-left"></i> git 常用技巧
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/24/理解glibc_malloc_主流用户态内存分配器实现原理/" rel="prev" title="理解 glibc malloc：主流用户态内存分配器实现原理">
                理解 glibc malloc：主流用户态内存分配器实现原理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">171</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ELF文件解析（一）：Segment和Section"><span class="nav-number">1.</span> <span class="nav-text">ELF文件解析（一）：Segment和Section</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ELF-header详解"><span class="nav-number">2.</span> <span class="nav-text">ELF header详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ELF-header详解-1"><span class="nav-number">2.1.</span> <span class="nav-text">ELF header详解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ELF格式探析之三：sections"><span class="nav-number">3.</span> <span class="nav-text">ELF格式探析之三：sections</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ELF文件格式"><span class="nav-number">4.</span> <span class="nav-text">ELF文件格式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件格式"><span class="nav-number">4.2.</span> <span class="nav-text">文件格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据表示"><span class="nav-number">4.3.</span> <span class="nav-text">数据表示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ELF文件头"><span class="nav-number">4.4.</span> <span class="nav-text">ELF文件头</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Section-Header"><span class="nav-number">4.5.</span> <span class="nav-text">Section Header</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Program-Header"><span class="nav-number">4.6.</span> <span class="nav-text">Program Header</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Symbol-Table"><span class="nav-number">4.7.</span> <span class="nav-text">Symbol Table</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Section和Segment的区别和联系"><span class="nav-number">4.8.</span> <span class="nav-text">Section和Segment的区别和联系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ELF文件的加载过程"><span class="nav-number">5.</span> <span class="nav-text">ELF文件的加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#加载和动态链接的简要介绍"><span class="nav-number">5.1.</span> <span class="nav-text">加载和动态链接的简要介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux可执行文件类型的注册机制"><span class="nav-number">5.2.</span> <span class="nav-text">Linux可执行文件类型的注册机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内核空间的加载过程"><span class="nav-number">5.3.</span> <span class="nav-text">内核空间的加载过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ELF文件中符号的动态解析过程"><span class="nav-number">6.</span> <span class="nav-text">ELF文件中符号的动态解析过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Global-Offset-Table（GOT）"><span class="nav-number">6.1.</span> <span class="nav-text">Global Offset Table（GOT）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Procedure-Linkage-Table（PLT）"><span class="nav-number">6.2.</span> <span class="nav-text">Procedure Linkage Table（PLT）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ELF文件加载和链接的简要总结"><span class="nav-number">7.</span> <span class="nav-text">ELF文件加载和链接的简要总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
