<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="操作系统,">










<meta name="description" content="操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)用make “V=”看到了所有的编译命令第178行 create ucore.img，可以看到call函数，totarget = $(addprefix $(BINDIR)$(SLASH),$(1))这样就调用了addprefix，把$(BINDIR">
<meta name="keywords" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="清华大学操作系统课程实验一">
<meta property="og:url" content="http://yoursite.com/2019/06/29/清华大学操作系统课程实验一/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)用make “V=”看到了所有的编译命令第178行 create ucore.img，可以看到call函数，totarget = $(addprefix $(BINDIR)$(SLASH),$(1))这样就调用了addprefix，把$(BINDIR">
<meta property="og:locale" content="zn-ch">
<meta property="og:updated_time" content="2019-06-29T16:00:09.984Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="清华大学操作系统课程实验一">
<meta name="twitter:description" content="操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)用make “V=”看到了所有的编译命令第178行 create ucore.img，可以看到call函数，totarget = $(addprefix $(BINDIR)$(SLASH),$(1))这样就调用了addprefix，把$(BINDIR">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/06/29/清华大学操作系统课程实验一/">





  <title>清华大学操作系统课程实验一 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/29/清华大学操作系统课程实验一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">清华大学操作系统课程实验一</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-29T23:56:00+08:00">
                2019-06-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="操作系统镜像文件ucore-img是如何一步一步生成的？-需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果"><a href="#操作系统镜像文件ucore-img是如何一步一步生成的？-需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果" class="headerlink" title="操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)"></a>操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)</h1><p>用<em>make “V=”</em>看到了所有的编译命令<br>第178行 create ucore.img，可以看到call函数，<br>totarget = $(addprefix $(BINDIR)$(SLASH),$(1))<br>这样就调用了addprefix，把$(BINDIR)$(SLASH)变成$(1)的前缀，在makefile里再把$(1)调用call变成要生成的文件，这里需要bootblock和kernel。<br>bootblock需要一些.o文件，makefile里的foreach有如下格式：$(foreach &lt; var &gt;,&lt; list &gt;,&lt; text &gt;)<br>这个函数的意思是，把参数&lt; list &gt;;中的单词逐一取出放到参数&lt; var &gt;所指定的变量中，然后再执行&lt; text&gt;;所包含的表达式。每一次&lt; text &gt;会返回一个字符串，循环过程中，&lt; text &gt;的所返回的每个字符串会以空格分隔，最后当整个循环结束时，&lt; text &gt;所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。</p>
<ul>
<li>通过看makefile生成的编译命令，生成bootasm.o需要bootasm.S<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>参考：-ggdb  生成可供gdb使用的调试信息。这样才能用qemu+gdb来调试bootloader or ucore。<br>-m32  生成适用于32位环境的代码。我们用的模拟硬件是32bit的80386，所以ucore也要是32位。<br>-gstabs  生成stabs格式的调试信息。这样要ucore的monitor可以显示出便于开发者阅读的函数调用<br>-nostdinc  不使用标准库。标准库是给应用程序用的，我们是编译ucore内核，OS内核是提供服务的<br>，所以所有的服务要自给自足。<br>-fno-stack-protector  不生成用于检测缓冲区溢出的代码。这是for 应用程序的，我们是编译内核<br>，ucore内核好像还用不到此功能。<br>-Os  为减小代码大小而进行优化。根据硬件spec，主引导扇区只有512字节，我们写的简单bootload<br>er的最终大小不能大于510字节。<br>-I&lt; dir &gt;  添加搜索头文件的路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o</span><br></pre></td></tr></table></figure></p>
<p>参考：-m <emulation>  模拟为i386上的连接器<br>-nostdlib  不使用标准库<br>-N  设置代码段和数据段均可读写<br>-e <entry>  指定入口<br>-Ttext  制定代码段开始位置  </entry></emulation></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kernel = $(call totarget,kernel)</span><br><span class="line"></span><br><span class="line">$(kernel): tools/kernel.ld</span><br><span class="line"></span><br><span class="line">$(kernel): $(KOBJS)</span><br><span class="line">	@echo + ld $@</span><br><span class="line">	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)</span><br><span class="line">	@$(OBJDUMP) -S $@ &gt; $(call asmfile,kernel)</span><br><span class="line">	@$(OBJDUMP) -t $@ | $(SED) &apos;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&apos; &gt; $(call symfile,kernel)</span><br><span class="line"></span><br><span class="line">$(call create_target,kernel)</span><br></pre></td></tr></table></figure>
<p>编译命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Ikern/trap/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trapentry.S -o obj/kern/（o文件）</span><br></pre></td></tr></table></figure></p>
<p>链接器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/stdio.o obj/kern/libs/readline.o obj/kern/debug/panic.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/picirq.o obj/kern/driver/intr.o obj/kern/trap/trap.o obj/kern/trap/vectors.o obj/kern/trap/trapentry.o obj/kern/mm/pmm.o  obj/libs/string.o obj/libs/printfmt.o</span><br></pre></td></tr></table></figure></p>
<p>dd：</p>
<blockquote>
<p>dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。</p>
</blockquote>
<blockquote>
<p>注意：指定数字的地方若以下列字符结尾，则乘以相应的数字：b=512；c=1；k=1024；w=2</p>
</blockquote>
<blockquote>
<p>参数注释：</p>
</blockquote>
<blockquote>
<ol>
<li>if=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if=input file &gt;</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>of=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of=output file &gt;</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>ibs=bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。</li>
</ol>
</blockquote>
<blockquote>
<p>   obs=bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。</p>
</blockquote>
<blockquote>
<p>   bs=bytes：同时设置读入/输出的块大小为bytes个字节。</p>
</blockquote>
<blockquote>
<ol start="4">
<li>cbs=bytes：一次转换bytes个字节，即指定转换缓冲区大小。</li>
</ol>
</blockquote>
<blockquote>
<ol start="5">
<li>skip=blocks：从输入文件开头跳过blocks个块后再开始复制。</li>
</ol>
</blockquote>
<blockquote>
<ol start="6">
<li>seek=blocks：从输出文件开头跳过blocks个块后再开始复制。</li>
</ol>
</blockquote>
<blockquote>
<p>注意：通常只用当输出文件是磁盘或磁带时才有效，即备份到磁盘或磁带时才有效。</p>
</blockquote>
<blockquote>
<ol start="7">
<li>count=blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。</li>
</ol>
</blockquote>
<blockquote>
<ol start="8">
<li>conv=conversion：用指定的参数转换文件。</li>
</ol>
</blockquote>
<blockquote>
<p>   ascii：转换ebcdic为ascii</p>
</blockquote>
<blockquote>
<p>   ebcdic：转换ascii为ebcdic</p>
</blockquote>
<blockquote>
<p>   ibm：转换ascii为alternate ebcdic</p>
</blockquote>
<blockquote>
<p>   block：把每一行转换为长度为cbs，不足部分用空格填充</p>
</blockquote>
<blockquote>
<p>   unblock：使每一行的长度都为cbs，不足部分用空格填充</p>
</blockquote>
<blockquote>
<p>   lcase：把大写字符转换为小写字符</p>
</blockquote>
<blockquote>
<p>   ucase：把小写字符转换为大写字符</p>
</blockquote>
<blockquote>
<p>   swab：交换输入的每对字节</p>
</blockquote>
<blockquote>
<p>   noerror：出错时不停止</p>
</blockquote>
<blockquote>
<p>   notrunc：不截短输出文件</p>
</blockquote>
<blockquote>
<p>   sync：将每个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">生成一个有10000个块的文件，用0填充（答案中说，每个块默认512字节，但是可能要有bs参数指定或者bs默认就是512？）</span><br><span class="line">dd if=/dev/zero of=bin/ucore.img count=10000</span><br><span class="line"></span><br><span class="line">把bootblock中的内容写到第一个块</span><br><span class="line">dd if=bin/bootblock of=bin/ucore.img conv=notrunc</span><br><span class="line"></span><br><span class="line">从第二个块开始写kernel中的内容</span><br><span class="line">dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"><a href="#一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？" class="headerlink" title="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"></a>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</h1><p>上课讲过，合法的主引导扇区最后两个字节有特定值<br>0x55、0xAA<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buf一共512个字节</span><br><span class="line">buf[510] = 0x55;</span><br><span class="line">buf[511] = 0xAA;</span><br></pre></td></tr></table></figure></p>
<h1 id="练习2："><a href="#练习2：" class="headerlink" title="练习2："></a>练习2：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file bin/kernel</span><br><span class="line">set architecture i8086</span><br><span class="line">target remote :1234</span><br><span class="line">b *0x7c00</span><br><span class="line">continue</span><br></pre></td></tr></table></figure>
<p>在gdb中输入命令，输出2条instruction<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x /2i $pc</span><br></pre></td></tr></table></figure></p>
<p>跟bootasm.S里的汇编代码一致！amazing<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x /2i $pc</span><br><span class="line">=&gt; 0x7c00:	cli    </span><br><span class="line">   0x7c01:	cld    </span><br><span class="line">(gdb) x /10i $pc</span><br><span class="line">=&gt; 0x7c00:	cli    </span><br><span class="line">   0x7c01:	cld    </span><br><span class="line">   0x7c02:	xor    %ax,%ax</span><br><span class="line">   0x7c04:	mov    %ax,%ds</span><br><span class="line">   0x7c06:	mov    %ax,%es</span><br><span class="line">   0x7c08:	mov    %ax,%ss</span><br><span class="line">   0x7c0a:	in     $0x64,%al</span><br><span class="line">   0x7c0c:	test   $0x2,%al</span><br><span class="line">   0x7c0e:	jne    0x7c0a</span><br><span class="line">   0x7c10:	mov    $0xd1,%al</span><br></pre></td></tr></table></figure></p>
<p>在Makefile的debug选项中加入<em>-d in_asm -D q.log</em>，可以生成一个q.log里边是执行的汇编命令（部分）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0xfffffff0:  ljmp   $0xf000,$0xe05b</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x000fe05b:  cmpl   $0x0,%cs:0x6c48</span><br><span class="line">0x000fe062:  jne    0xfd2e1</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x000fe066:  xor    %dx,%dx</span><br><span class="line">0x000fe068:  mov    %dx,%ss</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x000fe06a:  mov    $0x7000,%esp</span><br><span class="line"></span><br><span class="line">----------------</span><br><span class="line">IN:</span><br><span class="line">0x000fe070:  mov    $0xf3691,%edx</span><br><span class="line">0x000fe076:  jmp    0xfd165</span><br></pre></td></tr></table></figure></p>
<h1 id="练习3"><a href="#练习3" class="headerlink" title="练习3"></a>练习3</h1><p>分析bootloader进入保护模式的过程。（要求在报告中写出分析）<br>BIOS将通过读取硬盘主引导扇区到内存，并转跳到对应内存中的位置执行bootloader。请分析bootloader是如何完成从实模式进入保护模式的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lab1/boot/bootasm.S</span><br></pre></td></tr></table></figure></p>
<p>类似之前，从0x7c00进入，首先<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">        .code16</span><br><span class="line">            cli				;禁止中断发生</span><br><span class="line">            cld				;CLD与STD是用来操作方向标志位DF。CLD使DF复位，即D</span><br><span class="line">            				  ;F=0，STD使DF置位，即DF=1.用于串操作指令中。</span><br><span class="line">            xorw %ax, %ax   ;ax置0</span><br><span class="line">            movw %ax, %ds   ;其他寄存器也清空</span><br><span class="line">            movw %ax, %es</span><br><span class="line">            movw %ax, %ss</span><br></pre></td></tr></table></figure></p>
<p>.globl指示告诉汇编器，_start这个符号要被链接器用到，所以要在目标文件的符号表中标记它是一个全局符号（在第 5.1 节 “目标文件”详细解释）。_start就像C程序的main函数一样特殊，是整个程序的入口，链接器在链接时会查找目标文件中的_start符号代表的地址，把它设置为整个程序的入口地址，所以每个汇编程序都要提供一个_start符号并且用.globl声明。如果一个符号没有用.globl声明，就表示这个符号不会被链接器用到。<br><br><br>开启A20：到了80286，系统的地址总线有原来的20根发展为24根，这样能够访问的内存可以达到2^24=16M。Intel在设计80286时提出的目标是向下兼容。所以，在实模式下，系统所表现的行为应该和8086/8088所表现的完全一样，也就是说，在实模式下，80286以及后续系列，应该和8086/8088完全兼容。但最终，80286芯片却存在一个BUG：因为有了80286有A20线，如果程序员访问100000H-10FFEFH之间的内存，系统将实际访问这块内存，而不是象8086/8088一样从0开始。为了解决上述兼容性问题，IBM使用键盘控制器上剩余的一些输出线来管理第21根地址线（从0开始数是第20根） 的有效性，被称为A20 Gate:</p>
<blockquote>
<p>如果A20 Gate被打开，则当程序员给出100000H-10FFEFH之间的地址的时候，系统将真正访问这块内存区域； </p>
</blockquote>
<blockquote>
<p>如果A20 Gate被禁止，则当程序员给出100000H-10FFEFH之间的地址的时候，系统仍然使用8086/8088的方式即取模方式（8086仿真）。绝大多数IBM PC兼容机默认的A20 Gate是被禁止的。现在许多新型PC上存在直接通过BIOS功能调用来控制A20 Gate的功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">seta20.1:               </span><br><span class="line">    inb $0x64, %al      ;0x64里的数据放到al中，即从I/O端口读取一个字节(BYTE,;HALF-WORD)</span><br><span class="line">    testb $0x2, %al     ;检测</span><br><span class="line">    jnz seta20.1        ;等到这个端口不忙，没有东西传进来</span><br><span class="line"></span><br><span class="line">    movb $0xd1, %al     ; 0xd1 写到 0x64</span><br><span class="line">    outb %al, $0x64     ;写8042输出端口</span><br><span class="line"></span><br><span class="line">seta20.2:                </span><br><span class="line">    inb $0x64, %al      </span><br><span class="line">    testb $0x2, %al     </span><br><span class="line">    jnz seta20.2		;等不忙</span><br><span class="line"></span><br><span class="line">    movb $0xdf, %al     ;打开A20 0xdf -&gt; port 0x60</span><br><span class="line">    outb %al, $0x60     ;0xdf = 11011111</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>初始化GDT表并打开保护模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lgdt gdtdesc		   ;让CPU读取gdtr_addr所指向内存内容保存到GDT内存当中</span><br><span class="line">movl %cr0, %eax		   ;cr0寄存器PE位or置1</span><br><span class="line">orl $CR0_PE_ON, %eax   </span><br><span class="line">movl %eax, %cr0</span><br><span class="line">ljmp $PROT_MODE_CSEG, $protcseg ;长跳改cs，基于段机制的寻址</span><br></pre></td></tr></table></figure></p>
<p>最后初始化堆栈、寄存器，调用bootmain<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protcseg:</span><br><span class="line">    # 初始化寄存器</span><br><span class="line">    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector</span><br><span class="line">    movw %ax, %ds                                   # -&gt; DS: Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; ES: Extra Segment</span><br><span class="line">    movw %ax, %fs                                   # -&gt; FS</span><br><span class="line">    movw %ax, %gs                                   # -&gt; GS</span><br><span class="line">    movw %ax, %ss                                   # -&gt; SS: Stack Segment</span><br><span class="line"></span><br><span class="line">    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)</span><br><span class="line">    movl $0x0, %ebp</span><br><span class="line">    movl $start, %esp</span><br><span class="line">    call bootmain</span><br></pre></td></tr></table></figure></p>
<h1 id="练习四"><a href="#练习四" class="headerlink" title="练习四"></a>练习四</h1><p>对于bootmain.c，它唯一的工作就是从硬盘的第一个扇区启动格式为ELF的内核镜像；控制从boot.S文件开始–这个文件设置了保护模式和一个栈，这样C代码就可以运行了，然后再调用bootmain()。  </p>
<blockquote>
<p>对x86.h头文件有：<a href="http://www.codeforge.cn/read/234474/x86.h__html" target="_blank" rel="noopener">http://www.codeforge.cn/read/234474/x86.h__html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static inline uchar</span><br><span class="line">inb(ushort port)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">  uchar data;</span><br><span class="line"> </span><br><span class="line">  asm volatile(&quot;in %1,%0&quot; : &quot;=a&quot; (data) : &quot;d&quot; (port));</span><br><span class="line">  //对应 in port,data</span><br><span class="line">  return data;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>0x1F7：读 用来存放读操作后的状态<br>readsect(void *dst, uint32_t secno)从secno扇区读取数据到dst  </p>
<blockquote>
<p>用汇编的方式实现读取1000号逻辑扇区开始的8个扇区<br>IDE通道的通讯地址是0x1F0 - 0x1F7<br>其中0x1F3 - 0x1F6 4个字节的端口是用来写入LBA地址的<br>LBA就是 logical Block Address<br>1000的16进制就是0x3E8<br>向0x1F3 - 0x1F6写入 0x3E8<br>向0x1F2这个地址写入扇区数量，也就是8<br>向0X1F7写入要执行的操作命令码，对读操作的命令码是 0x20<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">out 0x1F3 0x00</span><br><span class="line">out 0x1F4 0x00</span><br><span class="line">out 0x1F5 0x03</span><br><span class="line">out 0x1F6 0xE8</span><br><span class="line">out 0x1F2 0x08</span><br><span class="line">out 0x1F7 0x20</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>outb的定义在x86.h中，封装out命令，将data输出到port端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static inline void</span><br><span class="line">outb(ushort port, uchar data)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">  asm volatile(&quot;out %0,%1&quot; : : &quot;a&quot; (data), &quot;d&quot; (port));</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>业界共同推出了 LBA48，采用 48 个比特来表示逻辑扇区号。如此一来，就可以管理131072 TB 的硬盘容量了。在这里我们采用将采用 LBA28 来访问硬盘。<br>第1步：设置要读取的扇区数量。这个数值要写入0x1f2端口。这是个8位端口，因此每次只能读写255个扇区：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dx,0x1f2</span><br><span class="line">mov al,0x01    ;1 个扇区</span><br><span class="line">out dx,al</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：如果写入的值为 0，则表示要读取 256 个扇区。每读一个扇区，这个数值就减一。因此，如果在读写过程中发生错误，该端口包含着尚未读取的扇区数。   </p>
</blockquote>
<p>第2步：设置起始LBA扇区号。扇区的读写是连续的，因此只需要给出第一个扇区的编号就可以了。28 位的扇区号太长，需要将其分成 4 段，分别写入端口 0x1f3、0x1f4、0x1f5 和 0x1f6 号端口。其中，0x1f3 号端口存放的是 0～7 位；0x1f4 号端口存放的是 8～15 位；0x1f5 号端口存放的是 16～23 位，最后 4 位在 0x1f6 号端口。  </p>
<p>第3步:<br>向端口 0x1f7 写入 0x20，请求硬盘读。  </p>
<p>第4步:等待读写操作完成。端口0x1f7既是命令端口，又是状态端口。在通过这个端口发送读写命令之后，硬盘就忙乎开了。在它内部操作期间，它将 0x1f7 端口的第7位置“1”，表明自己很忙。一旦硬盘系统准备就绪，它再将此位清零，说明自己已经忙完了，同时将第3位置“1”，意思是准备好了，请求主机发送或者接收数据。  </p>
<p>第5步:连续取出数据。0x1f0 是硬盘接口的数据端口，而且还是一个16位端口。一旦硬盘控制器空闲，且准备就绪，就可以连续从这个端口写入或者读取数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">outb(0x1F2, 1);                         // 读取第一个数据块</span><br><span class="line">outb(0x1F3, secno &amp; 0xFF);</span><br><span class="line">outb(0x1F4, (secno &gt;&gt; 8) &amp; 0xFF);</span><br><span class="line">outb(0x1F5, (secno &gt;&gt; 16) &amp; 0xFF);</span><br><span class="line">outb(0x1F6, ((secno &gt;&gt; 24) &amp; 0xF) | 0xE0);</span><br><span class="line">outb(0x1F7, 0x20);                      // cmd 0x20 - read sectors</span><br><span class="line"></span><br><span class="line">insl(0x1F0, dst, SECTSIZE / 4)          // 第五步</span><br></pre></td></tr></table></figure>
<p>readseg函数简单包装了readsect，可以从设备读取任意长度的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static void readseg(uintptr_t va, uint32_t count, uint32_t offset) &#123;</span><br><span class="line">  uintptr_t end_va = va + count;</span><br><span class="line">  va -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">  uint32_t secno = (offset / SECTSIZE) + 1;</span><br><span class="line">  // 看是第几块，加1因为0扇区被引导占用,ELF文件从1扇区开始</span><br><span class="line"></span><br><span class="line">  for (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;</span><br><span class="line">    readsect((void *)va, secno);//调用之前的封装函数对每一块进行处理</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对不同的文件，执行file命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">file link.o </span><br><span class="line">link.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</span><br><span class="line"> </span><br><span class="line">file libfoo.so </span><br><span class="line">libfoo.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=871ecaf438d2ccdcd2e54cd8158b9d09a9f971a7, not stripped</span><br><span class="line"> </span><br><span class="line">file p1</span><br><span class="line">p1: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.32, BuildID[sha1]=37f75ef01273a9c77f4b4739bcb7b63a4545d729, not stripped</span><br><span class="line"> </span><br><span class="line">file libfoo.so </span><br><span class="line">libfoo.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=871ecaf438d2ccdcd2e54cd8158b9d09a9f971a7, stripped</span><br></pre></td></tr></table></figure></p>
<p>以下是主函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">bootmain(void) &#123;</span><br><span class="line">    // read the 1st page off disk</span><br><span class="line">    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);</span><br><span class="line"></span><br><span class="line">    // 看是不是标准的elf</span><br><span class="line">    if (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        goto bad;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct proghdr *ph, *eph;</span><br><span class="line"></span><br><span class="line">    // elf头中有elf文件应该加载到什么位置，将表头地址存在ph中</span><br><span class="line">    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">    eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">    for (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">        readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 找到内核的入口，这个函数不返回</span><br><span class="line">    ((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();</span><br><span class="line"></span><br><span class="line">bad:</span><br><span class="line">    outw(0x8A00, 0x8A00);</span><br><span class="line">    outw(0x8A00, 0x8E00);</span><br><span class="line"></span><br><span class="line">    /* do nothing */</span><br><span class="line">    while (1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>一般的 ELF 文件包括三个索引表：ELF header，Program header table，Section header table。<br>ELF header：在文件的开始，保存了路线图，描述了该文件的组织情况。<br>Program header table：告诉系统如何创建进程映像。用来构造进程映像的目标文件必须具有程序头部表，可重定位文件不需要这个表。<br>Section header table：包含了描述文件节区的信息，每个节区在表中都有一项，每一项给出诸如节区名称、节区大小这类信息。用于链接的目标文件必须包含节区头部表，其他目标文件可以有，也可以没有这个表。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */</span><br><span class="line">  Elf64_Half    e_type;         /* Object file type */</span><br><span class="line">  Elf64_Half    e_machine;      /* Architecture */</span><br><span class="line">  Elf64_Word    e_version;      /* Object file version */</span><br><span class="line">  Elf64_Addr    e_entry;        /* Entry point virtual address */</span><br><span class="line">  Elf64_Off e_phoff;        /* Program header table file offset */</span><br><span class="line">  Elf64_Off e_shoff;        /* Section header table file offset */</span><br><span class="line">  Elf64_Word    e_flags;        /* Processor-specific flags */</span><br><span class="line">  Elf64_Half    e_ehsize;       /* ELF header size in bytes */</span><br><span class="line">  Elf64_Half    e_phentsize;        /* Program header table entry size */</span><br><span class="line">  Elf64_Half    e_phnum;        /* Program header table entry count */</span><br><span class="line">  Elf64_Half    e_shentsize;        /* Section header table entry size */</span><br><span class="line">  Elf64_Half    e_shnum;        /* Section header table entry count */</span><br><span class="line">  Elf64_Half    e_shstrndx;     /* Section header string table index */</span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>ELF文件中有很多段，段表（Section Header Table）就是保存这些段的基本信息的结构，包括了段名、段长度、段在文件中的偏移位置、读写权限和其他段属性。<br>objdump工具可以查看ELF文件基本的段结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf64_Word    sh_name;        /* Section name (string tbl index) */</span><br><span class="line">  Elf64_Word    sh_type;        /* Section type */</span><br><span class="line">  Elf64_Xword   sh_flags;       /* Section flags */</span><br><span class="line">  Elf64_Addr    sh_addr;        /* Section virtual addr at execution */</span><br><span class="line">  Elf64_Off sh_offset;      /* Section file offset */</span><br><span class="line">  Elf64_Xword   sh_size;        /* Section size in bytes */</span><br><span class="line">  Elf64_Word    sh_link;        /* Link to another section */</span><br><span class="line">  Elf64_Word    sh_info;        /* Additional section information */</span><br><span class="line">  Elf64_Xword   sh_addralign;       /* Section alignment */</span><br><span class="line">  Elf64_Xword   sh_entsize;     /* Entry size if section holds table */</span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure></p>
<h1 id="练习五"><a href="#练习五" class="headerlink" title="练习五"></a>练习五</h1><p>一个比较简单但很绕的逻辑，找到每个函数调用压栈时的指针，找到这个指针也就找到了上一个函数的部分，再找它之前的函数调用压栈的内容。<br>主要问题是忘记了ebp!=0这个条件，忽视了要用16进制。<br>eip是寄存器存放下一个CPU指令存放的内存地址，当CPU执行完当前的指令后，从eip寄存器中读取下一条指令的内存地址，然后继续执行；<br>esp是寄存器存放当前线程的栈顶指针；<br>ebp存放一个指针，该指针指向系统栈最上面一个栈帧的底部。即EBP寄存器存储的是栈底地址，而这个地址是由ESP在函数调用前传递给EBP的。等到调用结束，EBP会把其地址再次传回给ESP。所以ESP又一次指向了函数调用结束后，栈顶的地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void print_stackframe(void) &#123;</span><br><span class="line">     /* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);</span><br><span class="line">      * (2) call read_eip() to get the value of eip. the type is (uint32_t);</span><br><span class="line">      * (3) from 0 .. STACKFRAME_DEPTH</span><br><span class="line">      *    (3.1) printf value of ebp, eip</span><br><span class="line">      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t)ebp +2 [0..4]</span><br><span class="line">      *    (3.3) cprintf(&quot;\n&quot;);</span><br><span class="line">      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.</span><br><span class="line">      *    (3.5) popup a calling stackframe</span><br><span class="line">      *           NOTICE: the calling funciton&apos;s return addr eip  = ss:[ebp+4]</span><br><span class="line">      *                   the calling funciton&apos;s ebp = ss:[ebp]</span><br><span class="line">      */</span><br><span class="line">        uint32_t my_ebp = read_ebp();</span><br><span class="line">        uint32_t my_eip = read_eip();//读取当前的ebp和eip</span><br><span class="line">        int i,j;</span><br><span class="line">        for(i = 0; my_ebp!=0 &amp;&amp; i&lt; STACKFRAME_DEPTH; i++)&#123;</span><br><span class="line">                cprintf(&quot;%0x %0x\n&quot;,my_ebp,my_eip);</span><br><span class="line">                for(j=0;j&lt;4;j++)&#123;</span><br><span class="line">                        cprintf(&quot;%0x\t&quot;,((uint32_t*)my_ebp+2)[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                cprintf(&quot;\n&quot;);</span><br><span class="line">                print_debuginfo(my_eip-1);</span><br><span class="line">                my_ebp = ((uint32_t*)my_ebp)[0];</span><br><span class="line">                my_eip = ((uint32_t*)my_ebp)[1];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ebp（基指针）寄存器主要通过软件约定与堆栈相关联。 在进入C函数时，函数的初始代码通常将先前函数的基本指针推入堆栈来保存，然后在函数持续时间内将当前esp值复制到ebp中。 如果程序中的所有函数都遵循这个约定，那么在程序执行期间的任何给定点，都可以通过跟踪保存的ebp指针链并确切地确定嵌套的函数调用序列引起这个特定的情况来追溯堆栈。 指向要达到的函数。 例如，当某个特定函数导致断言失败时，因为错误的参数传递给它，但您不确定是谁传递了错误的参数。 堆栈回溯可找到有问题的函数。<br>最后一行对应的是第一个使用堆栈的函数，所以在栈的最深一层，就是bootmain.c中的bootmain。 bootloader起始的堆栈从0x7c00开始，使用”call bootmain”转入bootmain函数。 call指令压栈，所以bootmain中ebp为0x7bf8。</p>
<h1 id="练习六"><a href="#练习六" class="headerlink" title="练习六"></a>练习六</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">一个表项的结构如下:</span><br><span class="line"></span><br><span class="line">/*lab1/kern/mm/mmu.h*/</span><br><span class="line">/* Gate descriptors for interrupts and traps */</span><br><span class="line">struct gatedesc &#123;</span><br><span class="line">    unsigned gd_off_15_0 : 16;        // low 16 bits of offset in segment</span><br><span class="line">    unsigned gd_ss : 16;            // segment selector</span><br><span class="line">    unsigned gd_args : 5;            // # args, 0 for interrupt/trap gates</span><br><span class="line">    unsigned gd_rsv1 : 3;            // reserved(should be zero I guess)</span><br><span class="line">    unsigned gd_type : 4;            // type(STS_&#123;TG,IG32,TG32&#125;)</span><br><span class="line">    unsigned gd_s : 1;                // must be 0 (system)</span><br><span class="line">    unsigned gd_dpl : 2;            // descriptor(meaning new) privilege level</span><br><span class="line">    unsigned gd_p : 1;                // Present</span><br><span class="line">    unsigned gd_off_31_16 : 16;        // high bits of offset in segment</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个表项占用8字节，其中2-3字节是段选择子，0-1字节和6-7字节拼成位移， 两者联合便是中断处理程序的入口地址。(copy from answer)<br>pic_init：中断控制器的初始化；idt_init：建立中断描述符表，并使能中断，intr_enable()<br>中断向量表可以认为是一个大数组，产生中断时生成一个中断号，来查这个idt表，找到中断服务例程的地址（段选择子加offset）。<br>主要是调用SETGATE这个宏对interrupt descriptor table进行初始化，是之前看到的对每个字节进行操作。然后调用lidt进行load idt（sti：使能中断）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">建立一个中断描述符</span><br><span class="line">  - istrap: 1 是一个trap, 0 代表中断</span><br><span class="line">  - sel: 中断处理代码段</span><br><span class="line">  - off: 中断处理代码段偏移</span><br><span class="line">  - dpl: 描述符的优先级</span><br><span class="line">*/</span><br><span class="line">#define SETGATE(gate, istrap, sel, off, dpl)</span><br></pre></td></tr></table></figure></p>
<p>除了系统调用中断(T_SYSCALL)使用陷阱门描述符且权限为用户态权限以外，其它中断均使用特权级(DPL)为０的中断门描述符，权限为内核态权限；</p>
<ol>
<li><p>中断描述符表（Interrupt Descriptor Table）中断描述符表把每个中断或异常编号和一个指向中断服务例程的描述符联系起来。同GDT一样，IDT是一个8字节的描述符数组，但IDT的第一项可以包含一个描述符。CPU把中断（异常）号<em>乘以8</em>做为IDT的索引。IDT可以位于内存的任意位置，CPU通过IDT寄存器（IDTR）的内容来寻址IDT的起始地址。指令LIDT和SIDT用来操作IDTR。两条指令都有一个显示的操作数：一个6字节表示的内存地址。在保护模式下，最多会存在256个Interrupt/Exception Vectors。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        extern uintptr_t __vectors[];</span><br><span class="line">        int i;</span><br><span class="line">        //for(i=0;i&lt;256;i++)</span><br><span class="line">        for(i=0;i&lt; sizeof(idt) / sizeof(struct gatedesc); i++)&#123;</span><br><span class="line">                SETGATE(idt[i],0,GD_KTEXT,__vectors[i],DPL_KERNEL);</span><br><span class="line">        &#125;</span><br><span class="line">//      SETGATE(idt[T_SWITCH_TOK], 0, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);</span><br><span class="line">        SETGATE(idt[T_SWITCH_TOK], 1, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);</span><br><span class="line">        lidt(&amp;idt_pd);</span><br></pre></td></tr></table></figure>
<p>对idt中的每一项，调用SETGATE进行设置，第二个是0表明是一个中断，如果是1表明是一个陷阱；GD_KTEXT是SEG_KTEXT（1，全局段编号）乘8，是处理中断的代码段编号，__vectors[i]是作为在代码段中的偏移量，vectors[i]在kern/trap/vectors.S中定义，定义了255个中断服务例程的地址，这里才是入口，且都跳转到__alltraps。在trap中调用了trap_dispatch，这样就根据传进来的进行switch处理。<br>用户态设置在特权级3，内核态设置在特权级0。</p>
<h1 id="练习七"><a href="#练习七" class="headerlink" title="练习七"></a>练习七</h1><p>这个实验实现用户态和内核态的转换，通过看代码基本明白。在init.c中的lab1_switch_to_user函数时一段汇编代码， 触发中断的话，有‘int %0’，就把第二个冒号（输入的数，T_SWITCH_TOK）替换%0， 这样中断号就是T_SWITCH_TOK。<br>SETGATE设置中断向量表将每个中断处理例程的入口设成<strong>vector[i]的值，然后在有中断时，找到中断向量表中这个中断的处理例程，都是跳到</strong>alltraps，__alltraps把寄存器（ds es fs gs）压栈，把esp压栈，这样假装构造一个trapframe然后调用trap，trap调用了trap_dispatch<br>在trap_dispatch中，对从堆栈弹出的段寄存器进行修改，转成User时和转成Kernel时不一样，分别赋值，同时需要修改之前的trapframe，实现中断的恢复。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> //LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.</span><br><span class="line">case T_SWITCH_TOU:</span><br><span class="line">    if(tf-&gt;tf_cs != USER_CS)&#123;</span><br><span class="line">            tf-&gt;tf_cs = USER_CS;</span><br><span class="line">            tf-&gt;tf_ds = USER_DS;</span><br><span class="line">            tf-&gt;tf_es = USER_DS;</span><br><span class="line">            tf-&gt;tf_ss = USER_DS;</span><br><span class="line">            tf-&gt;tf_eflags |= FL_IOPL_MASK;</span><br><span class="line">            *((uint32_t*)tf - 1) = (uint32_t)tf;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">case T_SWITCH_TOK:</span><br><span class="line">    if(tf-&gt;tf_cs != KERNEL_CS) &#123;</span><br><span class="line">    tf-&gt;tf_cs = KERNEL_CS;</span><br><span class="line">    tf-&gt;tf_ds = KERNEL_DS;</span><br><span class="line">    tf-&gt;tf_es = KERNEL_DS;</span><br><span class="line">    tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;</span><br><span class="line">    struct trapframe *switchu2k = (struct trapframe *)(tf-&gt;tf_esp - (sizeof(struct trapframe) - 8));</span><br><span class="line">    memmove(switchu2k,tf,sizeof(struct trapframe)-8);</span><br><span class="line">    *((uint32_t *)tf-1)=(uint32_t)switchu2k;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/操作系统/" rel="tag"># 操作系统</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/29/清华大学操作系统课程笔记五/" rel="next" title="清华大学操作系统课程笔记五">
                <i class="fa fa-chevron-left"></i> 清华大学操作系统课程笔记五
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/29/清华大学操作系统课程实验七/" rel="prev" title="清华大学操作系统课程实验七">
                清华大学操作系统课程实验七 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">334</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#操作系统镜像文件ucore-img是如何一步一步生成的？-需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果"><span class="nav-number">1.</span> <span class="nav-text">操作系统镜像文件ucore.img是如何一步一步生成的？(需要比较详细地解释Makefile中每一条相关命令和命令参数的含义，以及说明命令导致的结果)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"><span class="nav-number">2.</span> <span class="nav-text">一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#练习2："><span class="nav-number">3.</span> <span class="nav-text">练习2：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#练习3"><span class="nav-number">4.</span> <span class="nav-text">练习3</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#练习四"><span class="nav-number">5.</span> <span class="nav-text">练习四</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#练习五"><span class="nav-number">6.</span> <span class="nav-text">练习五</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#练习六"><span class="nav-number">7.</span> <span class="nav-text">练习六</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#练习七"><span class="nav-number">8.</span> <span class="nav-text">练习七</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
