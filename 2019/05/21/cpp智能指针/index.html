<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,">










<meta name="description" content="智能指针的作用；1)  C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。 2)  智能指针在C++11版本之后提供，包含在头文件中，shared_ptr、unique_ptr、weak_pptr。shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++智能指针">
<meta property="og:url" content="http://yoursite.com/2019/05/21/cpp智能指针/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="智能指针的作用；1)  C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。 2)  智能指针在C++11版本之后提供，包含在头文件中，shared_ptr、unique_ptr、weak_pptr。shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/2018081010344581.png">
<meta property="og:image" content="http://yoursite.com/img/20180810103513927.png">
<meta property="og:image" content="http://yoursite.com/img/20180810103527411.png">
<meta property="og:updated_time" content="2022-03-12T15:34:14.969Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++智能指针">
<meta name="twitter:description" content="智能指针的作用；1)  C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。 2)  智能指针在C++11版本之后提供，包含在头文件中，shared_ptr、unique_ptr、weak_pptr。shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一">
<meta name="twitter:image" content="http://yoursite.com/img/2018081010344581.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/21/cpp智能指针/">





  <title>C++智能指针 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/21/cpp智能指针/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++智能指针</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-21T17:21:39+08:00">
                2019-05-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="智能指针的作用；"><a href="#智能指针的作用；" class="headerlink" title="智能指针的作用；"></a>智能指针的作用；</h1><p>1)  C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。</p>
<p>2)  智能指针在C++11版本之后提供，包含在头文件中，shared_ptr、unique_ptr、weak_pptr。shared_ptr多个指针指向相同的对象。shared_ptr使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。</p>
<p>3)  初始化。智能指针是个模板类，可以指定类型，传入指针通过构造函数初始化。也可以使用make_shared函数初始化。不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如std::shared_ptrp4 = new int(1);的写法是错误的</p>
<p>4)  unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。相比与原始指针unique_ptr用于其RAII的特性，使得在出现异常的情况下，动态资源能得到释放。unique_ptr指针本身的生命周期：从unique_ptr指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。unique_ptr指针与其所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。</p>
<p>5)  智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。</p>
<p>6)  weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr。 weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少.</p>
<h1 id="说说你了解的auto-ptr作用"><a href="#说说你了解的auto-ptr作用" class="headerlink" title="说说你了解的auto_ptr作用"></a>说说你了解的auto_ptr作用</h1><ul>
<li>auto_ptr的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；抛出异常，将导致指针p所指向的空间得不到释放而导致内存泄漏；</li>
<li>auto_ptr构造时取得某个对象的控制权，在析构时释放该对象。我们实际上是创建一个auto_ptr类型的局部对象，该局部对象析构时，会将自身所拥有的指针空间释放，所以不会有内存泄漏；</li>
<li>auto_ptr的构造函数是explicit，阻止了一般指针隐式转换为 auto_ptr的构造，所以不能直接将一般类型的指针赋值给auto_ptr类型的对象，必须用auto_ptr的构造函数创建对象；</li>
<li>由于auto_ptr对象析构时会删除它所拥有的指针，所以使用时避免多个auto_ptr对象管理同一个指针；</li>
<li>auto_ptr内部实现，析构函数中删除对象用的是delete而不是delete[]，所以auto_ptr不能管理数组；</li>
<li>auto_ptr支持所拥有的指针类型之间的隐式类型转换。</li>
<li>可以通过*和-&gt;运算符对auto_ptr所有用的指针进行提领操作；</li>
<li>T<em> get(),获得auto_ptr所拥有的指针；T</em> release()，释放auto_ptr的所有权，并将所<br>有用的指针返回。</li>
</ul>
<h1 id="智能指针的循环引用"><a href="#智能指针的循环引用" class="headerlink" title="智能指针的循环引用"></a>智能指针的循环引用</h1><p>循环引用是指使用多个智能指针share_ptr时，出现了指针之间相互指向，从而形成环的情况，有点类似于死锁的情况，这种情况下，智能指针往往不能正常调用对象的析构函数，从而造成内存泄漏。举个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node(<span class="keyword">const</span> T&amp; value)</span><br><span class="line">        :_pPre(<span class="literal">NULL</span>)</span><br><span class="line">        , _pNext(<span class="literal">NULL</span>)</span><br><span class="line">        , _value(value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Node()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Node()</span><br><span class="line">    ~Node()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"~Node()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"this:"</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Node&lt;T&gt;&gt; _pPre;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Node&lt;T&gt;&gt; _pNext;</span><br><span class="line">    T _value;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Funtest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Node&lt;<span class="keyword">int</span>&gt;&gt; sp1(<span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Node&lt;<span class="keyword">int</span>&gt;&gt; sp2(<span class="keyword">new</span> Node&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sp1.use_count:"</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sp2.use_count:"</span> &lt;&lt; sp2.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    sp1-&gt;_pNext = sp2; <span class="comment">//sp1的引用+1</span></span><br><span class="line">    sp2-&gt;_pPre = sp1; <span class="comment">//sp2的引用+1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sp1.use_count:"</span> &lt;&lt; sp1.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"sp2.use_count:"</span> &lt;&lt; sp2.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Funtest();</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//Node()</span></span><br><span class="line"><span class="comment">//Node()</span></span><br><span class="line"><span class="comment">//sp1.use_count:1</span></span><br><span class="line"><span class="comment">//sp2.use_count:1</span></span><br><span class="line"><span class="comment">//sp1.use_count:2</span></span><br><span class="line"><span class="comment">//sp2.use_count:2</span></span><br></pre></td></tr></table></figure></p>
<p>从上面shared_ptr的实现中我们知道了只有当引用计数减减之后等于0，析构时才会释放对象，而上述情况造成了一个僵局，那就是析构对象时先析构sp2,可是由于sp2的空间sp1还在使用中，所以sp2.use_count减减之后为1，不释放，sp1也是相同的道理，由于sp1的空间sp2还在使用中，所以sp1.use_count减减之后为1，也不释放。sp1等着sp2先释放，sp2等着sp1先释放,二者互不相让，导致最终都没能释放，内存泄漏。</p>
<p>在实际编程过程中，应该尽量避免出现智能指针之间相互指向的情况，如果不可避免，可以使用弱指针—weak_ptr，它不增加引用计数，只要出了作用域就会自动析构。</p>
<h1 id="使用智能指针管理内存资源，RAII是怎么回事？"><a href="#使用智能指针管理内存资源，RAII是怎么回事？" class="headerlink" title="使用智能指针管理内存资源，RAII是怎么回事？"></a>使用智能指针管理内存资源，RAII是怎么回事？</h1><p>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。</p>
<p>因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。</p>
<p>智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。</p>
<p>毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。</p>
<h1 id="智能指针背后的设计思想"><a href="#智能指针背后的设计思想" class="headerlink" title="智能指针背后的设计思想"></a>智能指针背后的设计思想</h1><h2 id="无智能指针造成内存泄漏的例子"><a href="#无智能指针造成内存泄漏的例子" class="headerlink" title="无智能指针造成内存泄漏的例子"></a>无智能指针造成内存泄漏的例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remodel</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> * ps = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(str);<span class="comment">//堆内存</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (weird_thing())</span><br><span class="line">        <span class="keyword">throw</span> exception();</span><br><span class="line">    str = *ps; </span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当出现异常时（weird_thing()返回true），delete将不被执行，因此将导致内存泄露 。</p>
<p>常规解决方案：</p>
<ul>
<li>在throw exception()之前添加delete ps;</li>
<li>不要忘了最后一个delete ps;</li>
</ul>
<h2 id="智能指针的设计思想"><a href="#智能指针的设计思想" class="headerlink" title="智能指针的设计思想"></a>智能指针的设计思想</h2><p>仿照本地变量能够自动从栈内存中删除的思想，对指针设计一个析构函数，该析构函数将在指针过期时自动释放它指向的内存，总结来说就是：将基本类型指针封装为类对象指针（这个类肯定是个模板，以适应不同基本类型的需求），并在析构函数中编写delete语句以用来删除指针指向的内存空间。</p>
<p>转换remodel()函数的步骤：</p>
<ul>
<li>包含头文件memory（智能指针所在的头文件）；</li>
<li>将指向string的指针替换为指向string的智能指针对象；</li>
<li>删除delete语句。</li>
</ul>
<p>使用auto_ptr修改该函数的结果：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remodel</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; ps (<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(str))；</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (weird_thing ())</span><br><span class="line">        <span class="keyword">throw</span> exception()； </span><br><span class="line">    str = *ps； </span><br><span class="line">    <span class="comment">// delete ps； NO LONGER NEEDED</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="C-智能指针简单介绍"><a href="#C-智能指针简单介绍" class="headerlink" title="C++智能指针简单介绍"></a>C++智能指针简单介绍</h1><p>STL一共给我们提供了四种智能指针：auto_ptr、unique_ptr、shared_ptr和weak_ptr。</p>
<p>其中：auto_ptr在C++11中已将其摒弃。</p>
<p>使用注意点：</p>
<p>所有的智能指针类都有一个explicit构造函数，以指针作为参数。比如auto_ptr的类模板原型为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">templet&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">auto_ptr</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(X* p = <span class="number">0</span>)</span> </span>; </span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>因此不能自动将指针转换为智能指针对象，必须显示调用：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt; pd;</span><br><span class="line"><span class="keyword">double</span> *p_reg = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line">pd = p_reg;<span class="comment">//NOT ALLOWED(implicit conversion)</span></span><br><span class="line">pd = <span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt;(p_reg);<span class="comment">// ALLOWED (explicit conversion)</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt; pshared = p_reg;<span class="comment">//NOT ALLOWED (implicit conversion)</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">double</span>&gt; pshared(p_reg);<span class="comment">//ALLOWED (explicit conversion)</span></span><br></pre></td></tr></table></figure></p>
<p>对全部三种智能指针都应避免的一点：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">vacation</span><span class="params">(<span class="string">"I wandered lonely as a child."</span>)</span></span>; <span class="comment">//heap param</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; pvac(&amp;vacation);<span class="comment">//NO!!</span></span><br></pre></td></tr></table></figure></p>
<p>pvac过期时，程序将把delete运算符用于非堆(栈)内存，这是错误的！</p>
<p>使用实例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">report</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    report(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> s) : str(s)&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Object created.\n"</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">    ~report()&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Object deleted.\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">comment</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;report&gt; ps(<span class="keyword">new</span> report(<span class="string">"using auto ptr"</span>));</span><br><span class="line">        ps-&gt;comment();</span><br><span class="line">    &#125;<span class="comment">//auto_ptr 作用域结束</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;report&gt; ps(<span class="keyword">new</span> report(<span class="string">"using shared_ptr"</span>));</span><br><span class="line">        ps-&gt;comment();</span><br><span class="line">	&#125;<span class="comment">//shared_ptr 作用域结束</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;report&gt; ps(<span class="keyword">new</span> report(<span class="string">"using unique ptr"</span>));</span><br><span class="line">        ps-&gt;comment();</span><br><span class="line">    &#125;<span class="comment">//unique_ptr 作用域结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="为什么摒弃auto-ptr"><a href="#为什么摒弃auto-ptr" class="headerlink" title="为什么摒弃auto_ptr?"></a>为什么摒弃auto_ptr?</h1><p>问题来源：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; ps (<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"I reigned lonely as a cloud."</span>));</span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; vocation;</span><br><span class="line">vocation = ps;</span><br></pre></td></tr></table></figure></p>
<p>如果ps和vocation是常规指针，则两个指针指向同一个string对象，当指针过期时，则程序会试图删除同一个对象，要避免这种问题，解决办法：</p>
<p>定义赋值运算符，使之执行深复制。这样两个指针将指向不同的对象，其中的一个对象是另一个对象的副本，缺点是浪费空间，所以智能指针都未采取此方案。</p>
<p>建立所有权(ownership)概念。对于特定的对象，智能有一个智能对象可拥有，这样只能拥有对象的智能指针的析构函数会删除该对象。然后让赋值操作转让所有权。这就是用于auto_ptr和unique_ptr的策略，但unique_ptr的策略更严格。</p>
<p>创建智能更高的指针，跟踪引用特定对象的智能指针数。这称为引用计数。例如，赋值时，计数将加1，而指针过期时，计数将减1，当减为0时才调用delete。这是shared_ptr采用的策略。同样的策略也适用于复制构造函数。</p>
<p>摒弃auto_ptr的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; films[<span class="number">5</span>] = &#123;</span><br><span class="line">        <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; (<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Fowl Balls"</span>)),</span><br><span class="line">        <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; (<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Duck Walks"</span>)),</span><br><span class="line">        <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; (<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Chicken Runs"</span>)),</span><br><span class="line">        <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; (<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Turkey Errors"</span>)),</span><br><span class="line">        <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; (<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Goose Eggs"</span>))</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; pwin;</span><br><span class="line">    pwin = films[<span class="number">2</span>];<span class="comment">//films[2] loses owership,将所有权从films[2]转让给pwin,此时films[2]不再引用该字符串从而变成空指针</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"The nominees for best avian baseball film are\n"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; *films[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"The winner is "</span>&lt;&lt;*pwin&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>.get();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行下发现程序崩溃了，原因是films[2]已经是空指针了，输出空指针就会崩溃。如果把auto_ptr换成shared_ptr或unique_ptr后，程序就不会崩溃，原因如下：</p>
<p>适用shared_ptr时运行正常，因为shared_ptr采用引用计数，pwin和films[2]都指向同一块内存，在释放空间时因为事先要判断引用计数值的大小，因此不会出现多次删除一个对象的错误。</p>
<p>适用unique_ptr时编译出错，与auto_ptr一样，unique_ptr也采用所有权模型，但在适用unique_ptr时，程序不会等到运行阶段崩溃，在编译阶段下属代码就会出现错误：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pwin;</span><br><span class="line">pwin = films[<span class="number">2</span>];<span class="comment">//films[2] loses ownership</span></span><br></pre></td></tr></table></figure></p>
<p>这就是为何摒弃auto_ptr的原因：避免潜在的内存泄漏问题。</p>
<h1 id="unique-ptr为何优于auto-ptr？"><a href="#unique-ptr为何优于auto-ptr？" class="headerlink" title="unique_ptr为何优于auto_ptr？"></a>unique_ptr为何优于auto_ptr？</h1><h2 id="使用规则更严格"><a href="#使用规则更严格" class="headerlink" title="使用规则更严格"></a>使用规则更严格</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; p1(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"auto"</span>));  <span class="comment">//#1</span></span><br><span class="line">  <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; p2;					  <span class="comment">//#2</span></span><br><span class="line">  p2 = p1;							     <span class="comment">//#3</span></span><br></pre></td></tr></table></figure>
<p>在语句#3中，p2接管string对象的所有权后，p1的所有权将被剥夺。–&gt;可防止p1和p2的析构函数试图删除同一个对象。但如果随后试图使用p1，则会出现错误。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p3(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"auto"</span>));<span class="comment">//#4</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; p4;<span class="comment">//#5</span></span><br><span class="line">p4=p3;<span class="comment">//#6</span></span><br></pre></td></tr></table></figure></p>
<p>编译器会认为#6语句为非法，可以避免上述问题。</p>
<h2 id="对悬挂指针的操作更智能"><a href="#对悬挂指针的操作更智能" class="headerlink" title="对悬挂指针的操作更智能"></a>对悬挂指针的操作更智能</h2><p>总体来说：允许临时悬挂指针的赋值，禁止其他情况的出现。</p>
<p>示例：函数定义如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; demo(<span class="keyword">const</span> <span class="keyword">char</span> *s)&#123;</span><br><span class="line">      <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; temp (<span class="keyword">new</span> <span class="built_in">string</span>(a));</span><br><span class="line">      <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在程序中调用函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ps;</span><br><span class="line">ps = demo(<span class="string">"unique special"</span>);</span><br></pre></td></tr></table></figure></p>
<p>编译器允许此种赋值方式。总之：当程序试图将一个unique_ptr赋值给另一个时，如果源unique_ptr是个临时右值，编译器允许这么做；如果源unique_ptr将存在一段时间，编译器将禁止这么做。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu1(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"hello world"</span>));</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu2;</span><br><span class="line">pu2 = pu1;<span class="comment">//#1 not allowed</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; pu3;</span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"you"</span>));<span class="comment">//#2 allowed</span></span><br></pre></td></tr></table></figure></p>
<p>如果确实想执行类似#1的操作，仅当以非智能的方式使用摒弃的智能指针时（如解除引用时），这种赋值才不安全。要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，可以将原来的指针转让所有权变成空指针，可以对其重新赋值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unque_ptr&lt;<span class="built_in">string</span>&gt; ps1,ps2;</span><br><span class="line">ps1 = demo(<span class="string">"hello"</span>);</span><br><span class="line">ps2 = move(ps1);</span><br><span class="line">ps1 = demo(<span class="string">"alexia"</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*ps2&lt;&lt;*ps1&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="如何选择智能指针"><a href="#如何选择智能指针" class="headerlink" title="如何选择智能指针"></a>如何选择智能指针</h1><h2 id="使用指南："><a href="#使用指南：" class="headerlink" title="使用指南："></a>使用指南：</h2><ol>
<li><p>如果程序要使用多个指向同一个对象的指针，应选用shared_ptr。这样的情况包括：</p>
<ul>
<li>有一个指针数组，并使用一些辅助指针来标示特定的元素，如最大的元素和最小的元素；</li>
<li>连个对象包含指向第三个对象的指针；</li>
<li>STL容器包含指针。很多STL算法都支持复制和赋值操作，这些操作可用于shared_ptr，但不能用于unique_ptr（编译器发出warning）和auto_ptr（行为不确定）。如果你的编译器没有提供shared_ptr，可使用Boost库提供的shared_ptr。</li>
</ul>
</li>
<li><p>如果程序不需要多个指向同一个对象的指针，则可使用unique_ptr。如果函数使用new分配内存，并返还指向该内存的指针，将其返回类型声明为unique_ptr是不错的选择。这样，所有权转让给接受返回值的unique_ptr，而该智能指针将负责调用delete。可将unique_ptr储存到STL容器中，只要不调用将unique_ptr复制或赋值给另一个算法（如sort())。例如，可在程序中使用类似于下面的代码段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; make_int(<span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>(n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; &amp;p1)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*a&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;&gt; vp(size);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;vp.size();i++)&#123;</span><br><span class="line">        vp[i] = make_int(rand() %<span class="number">1000</span>);<span class="comment">//copy temporary unique_ptr</span></span><br><span class="line">    &#125;</span><br><span class="line">    vp.push_back(make_int(rand()%<span class="number">1000</span>));<span class="comment">// ok because arg is temporary</span></span><br><span class="line">    for_each(vp.begin(),vp.end(),show); <span class="comment">//use for_each();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其中push_back调用没有问题，因为它返回一个临时unique_ptr，该unique_ptr被赋值给vp中的一个unique_ptr。另外，如果按值而不是按引用给show()传递对象，for_each()将非法，因为这将导致使用一个来自vp的非临时unique_ptr初始化p1，而这是不允许的。前面说过，编译器将发现错误使用unique_ptr的企图。</p>
<p>在unique_ptr为右值时，可将其赋给shared_ptr，这与将一个unique_ptr赋给一个需要满足的条件相同。与前面一样，在下面的代码中,make_int()的返回类型为unique_ptr<int>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pup(make_int(rand() % <span class="number">1000</span>));   <span class="comment">// ok</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; spp(pup);                       <span class="comment">// not allowed, pup as lvalue</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; spr(make_int(rand() % <span class="number">1000</span>));   <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></int></p>
<p>模板shared_ptr包含一个显式构造函数，可用于将右值unique_ptr转换为shared_ptr。shared_ptr将接管原来归unique_ptr所有的对象。</p>
<p>在满足unique_ptr要求的条件时，也可使用auto_ptr，但unique_ptr是更好的选择。如果你的编译器没有unique_ptr，可考虑使用Boost库提供的scoped_ptr，它与unique_ptr类似。</p>
<h1 id="弱引用智能指针-weak-ptr"><a href="#弱引用智能指针-weak-ptr" class="headerlink" title="弱引用智能指针 weak_ptr"></a>弱引用智能指针 weak_ptr</h1><p>设计weak_ptr的原因：解决使用shared_ptr因循环引用而不能释放资源的问题。</p>
<h2 id="空悬指针问题"><a href="#空悬指针问题" class="headerlink" title="空悬指针问题"></a>空悬指针问题</h2><p><img src="/img/2018081010344581.png" alt></p>
<p>有两个指针p1和p2，指向堆上的同一个对象Object，p1和p2位于不同的线程中。假设线程A通过p1指针将对象销毁了（尽管把p1置为NULL），那p2就成了空悬指针。这是一种典型的C/C++内存错误。</p>
<p>使用weak_ptr能够帮助我们轻松解决上述的空悬指针问题（直接使用shared_ptr也是可以的）。</p>
<p>weak_ptr不控制对象的生命期，但是它知道对象是否还活着，如果对象还活着，那么它可以提升为有效的shared_ptr（提升操作通过lock()函数获取所管理对象的强引用指针）；如果对象已经死了，提升会失败，返回一个空的shared_ptr。</p>
<p>举个栗子 ：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// OLD, problem with dangling pointer</span></span><br><span class="line">    <span class="comment">// PROBLEM: ref will point to undefined data!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* ptr = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span>* ref = ptr;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NEW</span></span><br><span class="line">    <span class="comment">// SOLUTION: check expired() or lock() to determine if pointer is valid</span></span><br><span class="line">    <span class="comment">// empty definition</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sptr;</span><br><span class="line">    <span class="comment">// takes ownership of pointer</span></span><br><span class="line">    sptr.reset(<span class="keyword">new</span> <span class="keyword">int</span>);</span><br><span class="line">    *sptr = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// get pointer to data without taking ownership</span></span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; weak1 = sptr;</span><br><span class="line">    <span class="comment">// deletes managed object, acquires new pointer</span></span><br><span class="line">    sptr.reset(<span class="keyword">new</span> <span class="keyword">int</span>);</span><br><span class="line">    *sptr = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// get pointer to new data without taking ownership</span></span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">int</span>&gt; weak2 = sptr;</span><br><span class="line">    <span class="comment">// weak1 is expired!</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">auto</span> tmp = weak1.lock())</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *tmp &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"weak1 is expired\n"</span>;</span><br><span class="line">    <span class="comment">// weak2 points to new data (5)</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">auto</span> tmp = weak2.lock())</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *tmp &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"weak2 is expired\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>循环引用问题<br>栗子 大法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/smart_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AA() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"AA::AA() called"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~AA() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"AA::~AA() called"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;BB&gt; m_bb_ptr;  <span class="comment">//!</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BB() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"BB::BB() called"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~BB() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"BB::~BB() called"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;AA&gt; m_aa_ptr; <span class="comment">//!</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;AA&gt; ptr_a (<span class="keyword">new</span> AA);</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;BB&gt; ptr_b ( <span class="keyword">new</span> BB);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr_a use_count: "</span> &lt;&lt; ptr_a.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr_b use_count: "</span> &lt;&lt; ptr_b.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//下面两句导致了AA与BB的循环引用，结果就是AA和BB对象都不会析构</span></span><br><span class="line">    ptr_a-&gt;m_bb_ptr = ptr_b;</span><br><span class="line">    ptr_b-&gt;m_aa_ptr = ptr_a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr_a use_count: "</span> &lt;&lt; ptr_a.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr_b use_count: "</span> &lt;&lt; ptr_b.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="/img/20180810103513927.png" alt></p>
<p>可以看到由于AA和BB内部的shared_ptr各自保存了对方的一次引用，所以导致了ptr_a和ptr_b销毁的时候都认为内部保存的指针计数没有变成0，所以AA和BB的析构函数不会被调用。解决方法就是把一个shared_ptr替换成weak_ptr。</p>
<p>可以看到由于AA和BB内部的shared_ptr各自保存了对方的一次引用，所以导致了ptr_a和ptr_b销毁的时候都认为内部保存的指针计数没有变成0，所以AA和BB的析构函数不会被调用。解决方法就是把一个shared_ptr替换成weak_ptr。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/smart_ptr.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AA() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"AA::AA() called"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~AA() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"AA::~AA() called"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    weak_ptr&lt;BB&gt; m_bb_ptr;  <span class="comment">//!</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BB() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"BB::BB() called"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    ~BB() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"BB::~BB() called"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;AA&gt; m_aa_ptr; <span class="comment">//!</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;AA&gt; ptr_a (<span class="keyword">new</span> AA);</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;BB&gt; ptr_b ( <span class="keyword">new</span> BB);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr_a use_count: "</span> &lt;&lt; ptr_a.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr_b use_count: "</span> &lt;&lt; ptr_b.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//下面两句导致了AA与BB的循环引用，结果就是AA和BB对象都不会析构</span></span><br><span class="line">    ptr_a-&gt;m_bb_ptr = ptr_b;</span><br><span class="line">    ptr_b-&gt;m_aa_ptr = ptr_a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr_a use_count: "</span> &lt;&lt; ptr_a.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr_b use_count: "</span> &lt;&lt; ptr_b.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="/img/20180810103527411.png" alt></p>
<p>最后值得一提的是，虽然通过弱引用指针可以有效的解除循环引用，但这种方式必须在能预见会出现循环引用的情况下才能使用，即这个仅仅是一种编译期的解决方案，如果程序在运行过程中出现了循环引用，还是会造成内存泄漏的。因此，不要认为只要使用了智能指针便能杜绝内存泄漏。</p>
<h1 id="智能指针源码解析"><a href="#智能指针源码解析" class="headerlink" title="智能指针源码解析"></a>智能指针源码解析</h1><p>在介绍智能指针源码前，需要明确的是，智能指针本身是一个栈上分配的对象。根据栈上分配的特性，在离开作用域后，会自动调用其析构方法。智能指针根据这个特性实现了对象内存的管理和自动释放。</p>
<p>本文所分析的智能指针源码基于 Android ndk-16b 中 llvm-libc++的 memory 文件。</p>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>先看下 unique_ptr的声明。unique_ptr有两个模板参数，分别为_Tp和_Dp。</p>
<ul>
<li>_Tp表示原生指针的类型。</li>
<li>_Dp则表示析构器，开发者可以自定义指针销毁的代码。其拥有一个默认值default_delete<_tp>，其实就是标准的delete函数。</_tp></li>
</ul>
<p>函数声明中<code>typename __pointer_type&lt;_Tp, deleter_type&gt;::type</code>可以简单理解为_Tp*，即原生指针类型。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Dp</span> = <span class="title">default_delete</span>&lt;_Tp&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">LIBCPP_TEMPLATE_VIS</span> <span class="title">unique_ptr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _Tp element_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Dp deleter_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __pointer_type&lt;_Tp, deleter_type&gt;::type pointer;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>unique_ptr中唯一的数据成员就是原生指针和析构器的 pair。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  __compressed_pair&lt;pointer, deleter_type&gt; __ptr_;</span><br></pre></td></tr></table></figure></p>
<p>下面看下unique_ptr的构造函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Dp</span> = <span class="title">default_delete</span>&lt;_Tp&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">LIBCPP_TEMPLATE_VIS</span> <span class="title">unique_ptr</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 默认构造函数，用pointer的默认构造函数初始化__ptr_</span></span><br><span class="line">  constexpr unique_ptr() noexcept : __ptr_(pointer()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 空指针的构造函数，同上</span></span><br><span class="line">  constexpr unique_ptr(nullptr_t) noexcept : __ptr_(pointer()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 原生指针的构造函数，用原生指针初始化__ptr_</span></span><br><span class="line">  explicit unique_ptr(pointer __p) noexcept : __ptr_(__p) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 原生指针和析构器的构造函数，用这两个参数初始化__ptr_,当前析构器为左值引用</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>(pointer __p, _LValRefType&lt;_Dummy&gt; __d) <span class="keyword">noexcept</span></span><br><span class="line">      : __ptr_(__p, __d) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 原生指针和析构器的构造函数，析构器使用转移语义进行转移</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>(pointer __p, _GoodRValRefType&lt;_Dummy&gt; __d) <span class="keyword">noexcept</span></span><br><span class="line">      : __ptr_(__p, _VSTD::move(__d)) &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(!is_reference&lt;deleter_type&gt;::value,</span><br><span class="line">                  <span class="string">"rvalue deleter bound to reference"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移动构造函数，取出原有unique_ptr的指针和析构器进行构造</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>(<span class="built_in">unique_ptr</span>&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line">      : __ptr_(__u.release(), _VSTD::forward&lt;deleter_type&gt;(__u.get_deleter())) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移动赋值函数，取出原有unique_ptr的指针和析构器进行构造</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>&amp; <span class="keyword">operator</span>=(<span class="built_in">unique_ptr</span>&amp;&amp; __u) _NOEXCEPT &#123;</span><br><span class="line">    reset(__u.release());</span><br><span class="line">    __ptr_.second() = _VSTD::forward&lt;deleter_type&gt;(__u.get_deleter());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再看下unique_ptr几个常用函数的实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Dp</span> = <span class="title">default_delete</span>&lt;_Tp&gt; &gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">LIBCPP_TEMPLATE_VIS</span> <span class="title">unique_ptr</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回原生指针</span></span><br><span class="line">    <span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __ptr_.first();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断原生指针是否为空</span></span><br><span class="line">    _<span class="function">LIBCPP_EXPLICIT <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __ptr_.first() != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将__ptr置空，并返回原有的指针</span></span><br><span class="line">    <span class="function">pointer <span class="title">release</span><span class="params">()</span> _NOEXCEPT </span>&#123;</span><br><span class="line">    pointer <span class="keyword">__t</span> = __ptr_.first();</span><br><span class="line">    __ptr_.first() = pointer();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">__t</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置原有的指针为新的指针，如果原有指针不为空，对原有指针所指对象进行销毁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(pointer __p = pointer())</span> _NOEXCEPT </span>&#123;</span><br><span class="line">    pointer __tmp = __ptr_.first();</span><br><span class="line">    __ptr_.first() = __p;</span><br><span class="line">    <span class="keyword">if</span> (__tmp)</span><br><span class="line">        __ptr_.second()(__tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再看下unique_ptr指针特性的两个方法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回原生指针的引用</span></span><br><span class="line"><span class="keyword">typename</span> add_lvalue_reference&lt;_Tp&gt;::type</span><br><span class="line"><span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> *__ptr_.first();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回原生指针</span></span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> _NOEXCEPT &#123;</span><br><span class="line">  <span class="keyword">return</span> __ptr_.first();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后再看下unique_ptr的析构函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过reset()方法进行对象的销毁</span></span><br><span class="line">~<span class="built_in">unique_ptr</span>() &#123; reset(); &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><p>shared_ptr 与unique_ptr最核心的区别就是比unique_ptr多了一个引用计数，并由于引用计数的加入，可以支持拷贝。</p>
<p>先看下shared_ptr的声明。shared_ptr主要有两个成员变量，一个是原生指针，一个是控制块的指针，用来存储这个原生指针的shared_ptr和weak_ptr的数量。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">shared_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp element_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    element_type*      __ptr_;</span><br><span class="line">    __shared_weak_count* __cntrl_;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们重点看下<code>__shared_weak_count</code>的定义。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享计数类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">shared_count</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __shared_count(<span class="keyword">const</span> __shared_count&amp;);</span><br><span class="line">    __shared_count&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> __shared_count&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 共享计数</span></span><br><span class="line">    <span class="keyword">long</span> __shared_owners_;</span><br><span class="line">    <span class="keyword">virtual</span> ~__shared_count();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 引用计数变为0的回调，一般是进行内存释放</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> __on_zero_shared() _NOEXCEPT = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，需要注意内部存储的引用计数是从0开始，外部看到的引用计数其实为1</span></span><br><span class="line">    <span class="keyword">explicit</span> __shared_count(<span class="keyword">long</span> __refs = <span class="number">0</span>) _NOEXCEPT</span><br><span class="line">        : __shared_owners_(__refs) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加共享计数</span></span><br><span class="line">    <span class="keyword">void</span> __add_shared() _NOEXCEPT &#123;</span><br><span class="line">      __libcpp_atomic_refcount_increment(__shared_owners_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放共享计数，如果共享计数为0（内部为-1），则调用__on_zero_shared进行内存释放</span></span><br><span class="line">    <span class="keyword">bool</span> __release_shared() _NOEXCEPT &#123;</span><br><span class="line">      <span class="keyword">if</span> (__libcpp_atomic_refcount_decrement(__shared_owners_) == <span class="number">-1</span>) &#123;</span><br><span class="line">        __on_zero_shared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回引用计数，需要对内部存储的引用计数+1处理</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="keyword">const</span> _NOEXCEPT </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> __libcpp_relaxed_load(&amp;amp;__shared_owners_) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">shared_weak_count</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">private</span> __shared_count</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// weak ptr计数</span></span><br><span class="line">    <span class="keyword">long</span> __shared_weak_owners_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 内部共享计数和weak计数都为0</span></span><br><span class="line">    <span class="keyword">explicit</span> __shared_weak_count(<span class="keyword">long</span> __refs = <span class="number">0</span>) _NOEXCEPT</span><br><span class="line">        : __shared_count(__refs),</span><br><span class="line">          __shared_weak_owners_(__refs) &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~__shared_weak_count();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 调用通过父类的__add_shared，增加共享引用计数</span></span><br><span class="line">    <span class="keyword">void</span> __add_shared() _NOEXCEPT &#123;</span><br><span class="line">      __shared_count::__add_shared();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加weak引用计数</span></span><br><span class="line">    <span class="keyword">void</span> __add_weak() _NOEXCEPT &#123;</span><br><span class="line">      __libcpp_atomic_refcount_increment(__shared_weak_owners_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用父类的__release_shared，如果释放了原生指针的内存，还需要调用__release_weak，因为内部weak计数默认为0</span></span><br><span class="line">    <span class="keyword">void</span> __release_shared() _NOEXCEPT &#123;</span><br><span class="line">      <span class="keyword">if</span> (__shared_count::__release_shared())</span><br><span class="line">        __release_weak();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// weak引用计数减1</span></span><br><span class="line">    <span class="keyword">void</span> __release_weak() _NOEXCEPT;</span><br><span class="line">    <span class="comment">// 获取共享计数</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">use_count</span><span class="params">()</span> <span class="keyword">const</span> _NOEXCEPT </span>&#123;<span class="keyword">return</span> __shared_count::use_count();&#125;</span><br><span class="line">    __<span class="function">shared_weak_count* <span class="title">lock</span><span class="params">()</span> _NOEXCEPT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// weak计数为0的处理</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> __on_zero_shared_weak() _NOEXCEPT = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其实<code>__shared_weak_count</code>也是虚类，具体使用的是<code>__shared_ptr_pointer</code>。<code>__shared_ptr_pointer</code>中有一个成员变量<code>__data_</code>，用于存储原生指针、析构器、分配器。<code>__shared_ptr_pointer</code>继承了<code>__shared_weak_count</code>，因此它就主要负责内存的分配、销毁，引用计数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">shared_ptr_pointer</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> __shared_weak_count</span><br><span class="line">&#123;</span><br><span class="line">    __compressed_pair&lt;__compressed_pair&lt;_Tp, _Dp&gt;, _Alloc&gt; __data_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    _LIBCPP_INLINE_VISIBILITY</span><br><span class="line">    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)</span><br><span class="line">        :  __data_(__compressed_pair&lt;_Tp, _Dp&gt;(__p, _VSTD::move(__d)), _VSTD::move(__a)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBCPP_NO_RTTI</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">void</span>* __get_deleter(<span class="keyword">const</span> type_info&amp;) <span class="keyword">const</span> _NOEXCEPT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> __on_zero_shared() _NOEXCEPT;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> __on_zero_shared_weak() _NOEXCEPT;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>了解了引用计数的基本原理后，再看下shared_ptr的实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用原生指针构造shared_ptr时，会构建__shared_ptr_pointer的控制块</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;_Tp&gt;::<span class="built_in">shared_ptr</span>(_Yp* __p,</span><br><span class="line">                            <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type)</span><br><span class="line">    : __ptr_(__p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;_Yp&gt; __hold(__p);</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;</span><br><span class="line">    <span class="keyword">typedef</span> __shared_ptr_pointer&lt;_Yp*, default_delete&lt;_Yp&gt;, _AllocT &gt; _CntrlBlk;</span><br><span class="line">    __cntrl_ = <span class="keyword">new</span> _CntrlBlk(__p, default_delete&lt;_Yp&gt;(), _AllocT());</span><br><span class="line">    __hold.release();</span><br><span class="line">    __enable_weak_this(__p, __p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果进行shared_ptr的拷贝，会增加引用计数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span></span></span><br><span class="line"><span class="class"><span class="title">shared_ptr</span>&lt;_Tp&gt;:</span>:<span class="built_in">shared_ptr</span>(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&amp; __r) _NOEXCEPT</span><br><span class="line">    : __ptr_(__r.__ptr_),</span><br><span class="line">      __cntrl_(__r.__cntrl_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__cntrl_)</span><br><span class="line">        __cntrl_-&gt;__add_shared();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁shared_ptr时，会使共享引用计数减1，如果减到0会销毁内存</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">shared_ptr</span>&lt;_Tp&gt;:</span>:~<span class="built_in">shared_ptr</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__cntrl_)</span><br><span class="line">        __cntrl_-&gt;__release_shared();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>了解完shared_ptr，weak_ptr也就比较简单了。weak_ptr也包括两个对象，一个是原生指针，一个是控制块。虽然weak_ptr内存储了原生指针，不过由于未实现operator-&gt;因此不能直接使用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">LIBCPP_TEMPLATE_VIS</span> <span class="title">weak_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp element_type;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    element_type*        __ptr_;</span><br><span class="line">    __shared_weak_count* __cntrl_;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过shared_ptr构造weak_ptr。会将shared_ptr的成员变量地址进行复制。增加weak引用计数</span></span><br><span class="line">weak_ptr&lt;_Tp&gt;::weak_ptr(<span class="built_in">shared_ptr</span>&lt;_Yp&gt; <span class="keyword">const</span>&amp;amp; __r,</span><br><span class="line">                        <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_Yp*, _Tp*&gt;::value, __nat*&gt;::type)</span><br><span class="line">                         _NOEXCEPT</span><br><span class="line">    : __ptr_(__r.__ptr_),</span><br><span class="line">      __cntrl_(__r.__cntrl_)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__cntrl_)</span><br><span class="line">        __cntrl_-&gt;__add_weak();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// weak_ptr析构器</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">weak_ptr</span>&lt;_Tp&gt;:</span>:~weak_ptr()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__cntrl_)</span><br><span class="line">        __cntrl_-&gt;__release_weak();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/21/Linux伙伴算法简介/" rel="next" title="Linux 伙伴算法简介">
                <i class="fa fa-chevron-left"></i> Linux 伙伴算法简介
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/21/数据库设计三大范式与BCNF/" rel="prev" title="数据库设计三大范式与BCNF">
                数据库设计三大范式与BCNF <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">287</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#智能指针的作用；"><span class="nav-number">1.</span> <span class="nav-text">智能指针的作用；</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#说说你了解的auto-ptr作用"><span class="nav-number">2.</span> <span class="nav-text">说说你了解的auto_ptr作用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#智能指针的循环引用"><span class="nav-number">3.</span> <span class="nav-text">智能指针的循环引用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用智能指针管理内存资源，RAII是怎么回事？"><span class="nav-number">4.</span> <span class="nav-text">使用智能指针管理内存资源，RAII是怎么回事？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#智能指针背后的设计思想"><span class="nav-number">5.</span> <span class="nav-text">智能指针背后的设计思想</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#无智能指针造成内存泄漏的例子"><span class="nav-number">5.1.</span> <span class="nav-text">无智能指针造成内存泄漏的例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#智能指针的设计思想"><span class="nav-number">5.2.</span> <span class="nav-text">智能指针的设计思想</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-智能指针简单介绍"><span class="nav-number">6.</span> <span class="nav-text">C++智能指针简单介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么摒弃auto-ptr"><span class="nav-number">7.</span> <span class="nav-text">为什么摒弃auto_ptr?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#unique-ptr为何优于auto-ptr？"><span class="nav-number">8.</span> <span class="nav-text">unique_ptr为何优于auto_ptr？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用规则更严格"><span class="nav-number">8.1.</span> <span class="nav-text">使用规则更严格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对悬挂指针的操作更智能"><span class="nav-number">8.2.</span> <span class="nav-text">对悬挂指针的操作更智能</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何选择智能指针"><span class="nav-number">9.</span> <span class="nav-text">如何选择智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用指南："><span class="nav-number">9.1.</span> <span class="nav-text">使用指南：</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#弱引用智能指针-weak-ptr"><span class="nav-number">10.</span> <span class="nav-text">弱引用智能指针 weak_ptr</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#空悬指针问题"><span class="nav-number">10.1.</span> <span class="nav-text">空悬指针问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#智能指针源码解析"><span class="nav-number">11.</span> <span class="nav-text">智能指针源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#unique-ptr"><span class="nav-number">11.1.</span> <span class="nav-text">unique_ptr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shared-ptr"><span class="nav-number">11.2.</span> <span class="nav-text">shared_ptr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#weak-ptr"><span class="nav-number">11.3.</span> <span class="nav-text">weak_ptr</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
