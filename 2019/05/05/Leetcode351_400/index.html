<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Leetcode,">










<meta name="description" content="Leetcode354. Russian Doll EnvelopesYou have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height">
<meta name="keywords" content="Leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode351 - 400">
<meta property="og:url" content="http://yoursite.com/2019/05/05/Leetcode351_400/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Leetcode354. Russian Doll EnvelopesYou have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/dc70120f-e4d3-3ab2-b1c5-54a2025cb708.png">
<meta property="og:image" content="http://yoursite.com/img/34e89c30-5001-31cd-ac3d-4c3972e00701.gif">
<meta property="og:image" content="http://yoursite.com/img/shuffle_v1.png">
<meta property="og:image" content="http://yoursite.com/img/shuffle_v2.png">
<meta property="og:updated_time" content="2022-08-11T03:14:01.213Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode351 - 400">
<meta name="twitter:description" content="Leetcode354. Russian Doll EnvelopesYou have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height">
<meta name="twitter:image" content="http://yoursite.com/img/dc70120f-e4d3-3ab2-b1c5-54a2025cb708.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/05/Leetcode351_400/">





  <title>Leetcode351 - 400 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/05/Leetcode351_400/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode351 - 400</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-05T14:41:39+08:00">
                2019-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Leetcode354-Russian-Doll-Envelopes"><a href="#Leetcode354-Russian-Doll-Envelopes" class="headerlink" title="Leetcode354. Russian Doll Envelopes"></a>Leetcode354. Russian Doll Envelopes</h1><p>You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.</p>
<p>What is the maximum number of envelopes can you Russian doll? (put one inside other)</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given envelopes = [[5,4],[6,4],[6,7],[2,3]], the maximum number of envelopes you can Russian doll is 3 ([2,3] =&gt; [5,4] =&gt; [6,7]).</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一堆大小不一的信封，让我们像套俄罗斯娃娃那样把这些信封都给套起来，这道题实际上是之前那道Longest Increasing Subsequence的具体应用，而且难度增加了，从一维变成了两维，但是万变不离其宗，解法还是一样的，首先来看DP的解法，这是一种brute force的解法，首先要给所有的信封按从小到大排序，首先根据宽度从小到大排，如果宽度相同，那么高度小的再前面，这是STL里面sort的默认排法，所以我们不用写其他的comparator，直接排就可以了，然后我们开始遍历，对于每一个信封，我们都遍历其前面所有的信封，如果当前信封的长和宽都比前面那个信封的大，那么我们更新dp数组，通过dp[i] = max(dp[i], dp[j] + 1)。然后我们每遍历完一个信封，都更新一下结果res，参见代码如下；</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&amp; envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = envelopes.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">1</span>);</span><br><span class="line">        sort(envelopes.begin(), envelopes.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (envelopes[i].first &gt; envelopes[j].first &amp;&amp; envelopes[i].second &gt; envelopes[j].second) &#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode355-Design-Twitter"><a href="#Leetcode355-Design-Twitter" class="headerlink" title="Leetcode355. Design Twitter"></a>Leetcode355. Design Twitter</h1><p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user’s news feed. Your design should support the following methods:</p>
<ul>
<li>postTweet(userId, tweetId) : Compose a new tweet.</li>
<li>getNewsFeed(userId) : Retrieve the 10 most recent tweet ids in the user’s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.</li>
<li>follow(followerId, followeeId) : Follower follows a followee.</li>
<li>unfollow(followerId, followeeId) : Follower unfollows a followee.</li>
</ul>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Twitter twitter = new Twitter();</span><br><span class="line"></span><br><span class="line">// User 1 posts a new tweet (id = 5).</span><br><span class="line">twitter.postTweet(1, 5);</span><br><span class="line"></span><br><span class="line">// User 1&apos;s news feed should return a list with 1 tweet id -&gt; [5].</span><br><span class="line">twitter.getNewsFeed(1);</span><br><span class="line"></span><br><span class="line">// User 1 follows user 2.</span><br><span class="line">twitter.follow(1, 2);</span><br><span class="line"></span><br><span class="line">// User 2 posts a new tweet (id = 6).</span><br><span class="line">twitter.postTweet(2, 6);</span><br><span class="line"></span><br><span class="line">// User 1&apos;s news feed should return a list with 2 tweet ids -&gt; [6, 5].</span><br><span class="line">// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.</span><br><span class="line">twitter.getNewsFeed(1);</span><br><span class="line"></span><br><span class="line">// User 1 unfollows user 2.</span><br><span class="line">twitter.unfollow(1, 2);</span><br><span class="line"></span><br><span class="line">// User 1&apos;s news feed should return a list with 1 tweet id -&gt; [5],</span><br><span class="line">// since user 1 is no longer following user 2.</span><br><span class="line">twitter.getNewsFeed(1);</span><br></pre></td></tr></table></figure></p>
<p>这道题让我们设计个简单的推特，具有发布消息，获得新鲜事，添加关注和取消关注等功能。我们需要用两个哈希表来做，第一个是建立用户和其所有好友之间的映射，另一个是建立用户和其所有消息之间的映射。由于获得新鲜事是需要按时间顺序排列的，那么我们可以用一个整型变量cnt来模拟时间点，每发一个消息，cnt自增1，那么我们就知道cnt大的是最近发的。那么我们在建立用户和其所有消息之间的映射时，还需要建立每个消息和其时间点cnt之间的映射。这道题的主要难点在于实现getNewsFeed()函数，这个函数获取自己和好友的最近10条消息，我们的做法是用户也添加到自己的好友列表中，然后遍历该用户的所有好友，遍历每个好友的所有消息，维护一个大小为10的哈希表，如果新遍历到的消息比哈希表中最早的消息要晚，那么将这个消息加入，然后删除掉最早的那个消息，这样我们就可以找出最近10条消息了，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Twitter() &#123;</span><br><span class="line">        time = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">        follow(userId, userId);</span><br><span class="line">        tweets[userId].insert(&#123;time++, tweetId&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getNewsFeed(<span class="keyword">int</span> userId) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; top10;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> id : friends[userId]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> a : tweets[id]) &#123;</span><br><span class="line">                top10.insert(&#123;a.first, a.second&#125;);</span><br><span class="line">                <span class="keyword">if</span> (top10.size() &gt; <span class="number">10</span>) top10.erase(top10.begin());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : top10) &#123;</span><br><span class="line">            res.insert(res.begin(), a.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        friends[followerId].insert(followeeId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (followerId != followeeId) &#123;</span><br><span class="line">            friends[followerId].erase(followeeId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; friends;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; tweets;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode357-Count-Numbers-with-Unique-Digits"><a href="#Leetcode357-Count-Numbers-with-Unique-Digits" class="headerlink" title="Leetcode357. Count Numbers with Unique Digits"></a>Leetcode357. Count Numbers with Unique Digits</h1><p>Given an integer n, return the count of all numbers with unique digits, x, where 0 &lt;= x &lt; 10n.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: 91</span><br><span class="line">Explanation: The answer should be the total numbers in the range of 0 ≤ x &lt; 100, excluding 11,22,33,44,55,66,77,88,99</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 0</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>题目要求： 找出0到10的n次方中所有unique的数(既该数的所有位数无重复数组)，如123为为unique，122不为unique，因为后两位2重复出现。</p>
<p>其实这个题的思路还是蛮简单的，回想下最简单的排列组合的知识。如找出所有十位unique digits number， 那么我们在十位可取1-9这九个数字，在个位能取除十位的数字外剩下的数字，由于个位可取0，所以个位还是可以取9个数字，则十位数的unique number为<code>9*9 = 81</code>。同理, 所有百位数unique digits number为<code>9*9*8=648</code>，以此类推。</p>
<p>由于此题目要求返回0到10的n次方中所有的unique number个数，因此我们可以分别求出个，十，百…每个位数上分别对应的unique number个数，然后加起来就好。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">int</span> mul = <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">int</span> count = i;</span><br><span class="line">            <span class="keyword">while</span>(count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                mul *= idx;</span><br><span class="line">                idx --;</span><br><span class="line">                count --;</span><br><span class="line">            &#125;</span><br><span class="line">            res += mul;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode359-Logger-Rate-Limiter"><a href="#Leetcode359-Logger-Rate-Limiter" class="headerlink" title="Leetcode359. Logger Rate Limiter"></a>Leetcode359. Logger Rate Limiter</h1><p>Design a logger system that receive stream of messages along with its timestamps, each message should be printed if and only if it is not printed in the last 10 seconds.</p>
<p>Given a message and a timestamp (in seconds granularity), return true if the message should be printed in the given timestamp, otherwise returns false.</p>
<p>It is possible that several messages arrive roughly at the same time.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Logger logger = new Logger();</span><br><span class="line"></span><br><span class="line">// logging string &quot;foo&quot; at timestamp 1</span><br><span class="line">logger.shouldPrintMessage(1, &quot;foo&quot;); returns true; </span><br><span class="line"></span><br><span class="line">// logging string &quot;bar&quot; at timestamp 2</span><br><span class="line">logger.shouldPrintMessage(2,&quot;bar&quot;); returns true;</span><br><span class="line"></span><br><span class="line">// logging string &quot;foo&quot; at timestamp 3</span><br><span class="line">logger.shouldPrintMessage(3,&quot;foo&quot;); returns false;</span><br><span class="line"></span><br><span class="line">// logging string &quot;bar&quot; at timestamp 8</span><br><span class="line">logger.shouldPrintMessage(8,&quot;bar&quot;); returns false;</span><br><span class="line"></span><br><span class="line">// logging string &quot;foo&quot; at timestamp 10</span><br><span class="line">logger.shouldPrintMessage(10,&quot;foo&quot;); returns false;</span><br><span class="line"></span><br><span class="line">// logging string &quot;foo&quot; at timestamp 11</span><br><span class="line">logger.shouldPrintMessage(11,&quot;foo&quot;); returns true;</span><br></pre></td></tr></table></figure></p>
<p>这道题让我们设计一个记录系统每次接受信息并保存时间戳，然后让我们打印出该消息，前提是最近10秒内没有打印出这个消息。这不是一道难题，我们可以用哈希表来做，建立消息和时间戳之间的映射，如果某个消息不再哈希表表，我们建立其和时间戳的映射，并返回true。如果应经在哈希表里了，我们看当前时间戳是否比哈希表中保存的时间戳大10，如果是，更新哈希表，并返回true，反之返回false，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Logger() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">shouldPrintMessage</span><span class="params">(<span class="keyword">int</span> timestamp, <span class="built_in">string</span> message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m.count(message)) &#123;</span><br><span class="line">            m[message] = timestamp;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (timestamp - m[message] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            m[message] = timestamp;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode367-Valid-Perfect-Square"><a href="#Leetcode367-Valid-Perfect-Square" class="headerlink" title="Leetcode367. Valid Perfect Square"></a>Leetcode367. Valid Perfect Square</h1><p>Given a positive integer num, write a function which returns True if num is a perfect square else False.</p>
<p>Follow up: Do not use any built-in library function such as sqrt.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: num = 16</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: num = 14</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>给了我们一个数，让我们判断其是否为完全平方数，那么显而易见的是，肯定不能使用 brute force，这样太不高效了，那么最小是能以指数的速度来缩小范围。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num/i; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i * i == num)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode368-Largest-Divisible-Subset"><a href="#Leetcode368-Largest-Divisible-Subset" class="headerlink" title="Leetcode368. Largest Divisible Subset"></a>Leetcode368. Largest Divisible Subset</h1><p>Given a set of distinct positive integers, find the largest subset such that every pair (S i, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0.</p>
<p>If there are multiple solutions, return any subset is fine.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums: [1,2,3]</span><br><span class="line"></span><br><span class="line">Result: [1,2] (of course, [1,3] will also be ok)</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums: [1,2,4,8]</span><br><span class="line"></span><br><span class="line">Result: [1,2,4,8]</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一个数组，让我们求这样一个子集合，集合中的任意两个数相互取余均为0，而且提示中说明了要使用DP来解。那么我们考虑，较小数对较大数取余一定不为0，那么问题就变成了看较大数能不能整除这个较小数。那么如果数组是无序的，处理起来就比较麻烦，所以我们首先可以先给数组排序，这样我们每次就只要看后面的数字能否整除前面的数字。定义一个动态数组dp，其中dp[i]表示到数字nums[i]位置最大可整除的子集合的长度，还需要一个一维数组parent，来保存上一个能整除的数字的位置，两个整型变量mx和mx_idx分别表示最大子集合的长度和起始数字的位置，我们可以从后往前遍历数组，对于某个数字再遍历到末尾，在这个过程中，如果nums[j]能整除nums[i], 且dp[i] &lt; dp[j] + 1的话，更新dp[i]和parent[i]，如果dp[i]大于mx了，还要更新mx和mx_idx，最后循环结束后，我们来填res数字，根据parent数组来找到每一个数字，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; largestDivisibleSubset(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(nums.size(), <span class="number">0</span>), parent(nums.size(), <span class="number">0</span>), res;</span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>, mx_idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] % nums[i] == <span class="number">0</span> &amp;&amp; dp[i] &lt; dp[j] + <span class="number">1</span>) &#123;</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                    parent[i] = j;</span><br><span class="line">                    <span class="keyword">if</span> (mx &lt; dp[i]) &#123;</span><br><span class="line">                        mx = dp[i];</span><br><span class="line">                        mx_idx = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mx; ++i) &#123;</span><br><span class="line">            res.push_back(nums[mx_idx]);</span><br><span class="line">            mx_idx = parent[mx_idx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode371-Sum-of-Two-Integers"><a href="#Leetcode371-Sum-of-Two-Integers" class="headerlink" title="Leetcode371. Sum of Two Integers"></a>Leetcode371. Sum of Two Integers</h1><p>Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a = 1, b = 2</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: a = -2, b = 3</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>首先，先对数据a，b进行&amp;（与）运算，原因是下面用^（异或）的方法来进行加法会漏掉进位，所以，先对数据进行&amp;运算得到carry，carry中为1的位是会进行进位的位，接下来对数据进行^运算，结果记为add1，实现伪加法，之所以是伪加法，是因为它漏掉了进位。那漏掉的进位怎么办呢？对carry进行左移得到C，C+add1就是两个数据的真正的和。那怎么实现C+add1呢？将add1赋予a，C赋予b,重复以上的操作，直到b等于0。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c; </span><br><span class="line">        <span class="keyword">while</span>(b !=<span class="number">0</span> ) &#123; </span><br><span class="line">            c = (<span class="keyword">unsigned</span>)(a&amp;b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = a ^ b; </span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode372-Super-Pow"><a href="#Leetcode372-Super-Pow" class="headerlink" title="Leetcode372. Super Pow"></a>Leetcode372. Super Pow</h1><p>Your task is to calculate a b mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.</p>
<p>Example1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 2</span><br><span class="line">b = [3]</span><br><span class="line"></span><br><span class="line">Result: 8</span><br></pre></td></tr></table></figure></p>
<p>Example2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 2</span><br><span class="line">b = [1,0]</span><br><span class="line"></span><br><span class="line">Result: 1024</span><br></pre></td></tr></table></figure></p>
<p>这道题让我们求一个数的很大的次方对1337取余的值，开始一直在想这个1337有什么玄机，为啥突然给这么一个数，感觉很突兀，后来想来想去也没想出来为啥，估计就是怕结果太大无法表示，随便找个数取余吧。那么这道题和之前那道Pow(x, n)的解法很类似，我们都得对半缩小，不同的是后面都要加上对1337取余。由于给定的指数b是一个一维数组的表示方法，我们要是折半缩小处理起来肯定十分不方便，所以我们采用按位来处理，比如223 = (22)10 * 23, 所以我们可以从b的最高位开始，算出个结果存入res，然后到下一位是，res的十次方再乘以a的该位次方再对1337取余，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.size(); ++i) &#123;</span><br><span class="line">            res = <span class="built_in">pow</span>(res, <span class="number">10</span>) * <span class="built_in">pow</span>(a, b[i]) % <span class="number">1337</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> x % <span class="number">1337</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x % <span class="number">1337</span>, n / <span class="number">2</span>) * <span class="built_in">pow</span>(x % <span class="number">1337</span>, n - n / <span class="number">2</span>) % <span class="number">1337</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode373-Find-K-Pairs-with-Smallest-Sums"><a href="#Leetcode373-Find-K-Pairs-with-Smallest-Sums" class="headerlink" title="Leetcode373. Find K Pairs with Smallest Sums"></a>Leetcode373. Find K Pairs with Smallest Sums</h1><p>You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.</p>
<p>Define a pair (u, v) which consists of one element from the first array and one element from the second array.</p>
<p>Return  the  k  pairs  (u1, v1), (u2, v2), …, (uk, vk)  with the smallest sums.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3</span><br><span class="line">Output: [[1,2],[1,4],[1,6]]</span><br><span class="line">Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2</span><br><span class="line">Output: [[1,1],[1,1]]</span><br><span class="line">Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums1 = [1,2], nums2 = [3], k = 3</span><br><span class="line">Output: [[1,3],[2,3]]</span><br><span class="line">Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= nums1.length, nums2.length &lt;= 104</li>
<li>-109 &lt;= nums1[i], nums2[i] &lt;= 109</li>
<li>nums1 and nums2 both are sorted in ascending order.</li>
<li>1 &lt;= k &lt;= 1000 </li>
</ul>
<p>这道题给了我们两个数组，让从每个数组中任意取出一个数字来组成不同的数字对，返回前K个和最小的数字对。那么这道题有多种解法，首先来看 brute force 的解法，这种方法从0循环到数组的个数和k之间的较小值，这样做的好处是如果k远小于数组个数时，不需要计算所有的数字对，而是最多计算 k*k 个数字对，然后将其都保存在 res 里，这时候给 res 排序，用自定义的比较器，就是和的比较，然后把比k多出的数字对删掉即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; kSmallestPairs(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min((<span class="keyword">int</span>)nums1.size(), k); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; min((<span class="keyword">int</span>)nums2.size(), k); ++j) &#123;</span><br><span class="line">                res.push_back(&#123;nums1[i], nums2[j]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(res.begin(), res.end(), [](pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;b)&#123;<span class="keyword">return</span> a.first + a.second &lt; b.first + b.second;&#125;);</span><br><span class="line">        <span class="keyword">if</span> (res.size() &gt; k) res.erase(res.begin() + k, res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode374-Guess-Number-Higher-or-Lower"><a href="#Leetcode374-Guess-Number-Higher-or-Lower" class="headerlink" title="Leetcode374. Guess Number Higher or Lower"></a>Leetcode374. Guess Number Higher or Lower</h1><p>We are playing the Guess Game. The game is as follows:</p>
<ul>
<li>I pick a number from 1 to n. You have to guess which number I picked.</li>
<li>Every time you guess wrong, I’ll tell you whether the number is higher or lower.</li>
<li>You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):<ul>
<li>-1 : My number is lower</li>
<li>1 : My number is higher</li>
<li>0 : Congrats! You got it!</li>
</ul>
</li>
</ul>
<p>Example :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 10, pick = 6</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure></p>
<p>二分<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n, mid;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(guess(mid) &lt; <span class="number">0</span>)</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(guess(mid) &gt; <span class="number">0</span>)</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == guess(mid))</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode375-Guess-Number-Higher-or-Lower-II"><a href="#Leetcode375-Guess-Number-Higher-or-Lower-II" class="headerlink" title="Leetcode375. Guess Number Higher or Lower II"></a>Leetcode375. Guess Number Higher or Lower II</h1><p>We are playing the Guessing Game. The game will work as follows:</p>
<ol>
<li>I pick a number between 1 and n.</li>
<li>You guess a number.</li>
<li>If you guess the right number, you win the game.</li>
<li>If you guess the wrong number, then I will tell you whether the number I picked is higher or lower, and you will continue guessing.</li>
<li>Every time you guess a wrong number x, you will pay x dollars. If you run out of money, you lose the game.<br>Given a particular n, return the minimum amount of money you need to guarantee a win regardless of what number I pick.</li>
</ol>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 10</span><br><span class="line">Output: 16</span><br></pre></td></tr></table></figure></p>
<p>Explanation: The winning strategy is as follows:</p>
<ul>
<li>The range is [1,10]. Guess 7.<ul>
<li>If this is my number, your total is $0. Otherwise, you pay $7.</li>
<li>If my number is higher, the range is [8,10]. Guess 9.<ul>
<li>If this is my number, your total is $7. Otherwise, you pay $9.</li>
<li>If my number is higher, it must be 10. Guess 10. Your total is $7 + $9 = $16.</li>
<li>If my number is lower, it must be 8. Guess 8. Your total is $7 + $9 = $16.</li>
</ul>
</li>
<li>If my number is lower, the range is [1,6]. Guess 3.<ul>
<li>If this is my number, your total is $7. Otherwise, you pay $3.</li>
<li>If my number is higher, the range is [4,6]. Guess 5.<ul>
<li>If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $5.</li>
<li>If my number is higher, it must be 6. Guess 6. Your total is $7 + $3 + $5 = $15.</li>
<li>If my number is lower, it must be 4. Guess 4. Your total is $7 + $3 + $5 = $15.</li>
</ul>
</li>
<li>If my number is lower, the range is [1,2]. Guess 1.<ul>
<li>If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $1.</li>
<li>If my number is higher, it must be 2. Guess 2. Your total is $7 + $3 + $1 = $11.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>The worst case in all these scenarios is that you pay $16. Hence, you only need $16 to guarantee a win.</p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 1</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure></p>
<p>Explanation: There is only one possible number, so you can guess 1 and not have to pay anything.</p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Explanation: There are two possible numbers, 1 and 2.</p>
<ul>
<li>Guess 1.<ul>
<li>If this is my number, your total is $0. Otherwise, you pay $1.</li>
<li>If my number is higher, it must be 2. Guess 2. Your total is $1.<br>The worst case is that you pay $1.</li>
</ul>
</li>
</ul>
<p>这道题需要用到 Minimax 极小化极大算法，并且题目中还说明了要用 DP 来做，需要建立一个二维的 dp 数组，其中 dp[i][j] 表示从数字i到j之间猜中任意一个数字最少需要花费的钱数，那么需要遍历每一段区间 [j, i]，维护一个全局最小值 global_min 变量，然后遍历该区间中的每一个数字，计算局部最大值<code>local_max = k + max(dp[j][k - 1], dp[k + 1][i])</code>，这个正好是将该区间在每一个位置都分为两段，然后取当前位置的花费加上左右两段中较大的花费之和为局部最大值，相当于是猜k这个值时的代价。为啥要取两者之间的较大值呢，因为要 cover 所有的情况，就得取最坏的情况。然后更新全局最小值，最后在更新 dp[j][i] 的时候看j和i是否是相邻的，相邻的话赋为j，否则赋为 global_min。这里为啥又要取较小值呢，因为 dp 数组是求的 [j, i] 范围中的最低 cost，比如只有两个数字1和2，那么肯定是猜1的 cost 低。</p>
<p>如果只有一个数字，那么不用猜，cost 为0。如果有两个数字，比如1和2，猜1，即使不对，cost 也比猜2要低。如果有三个数字 1，2，3，那么就先猜2，根据对方的反馈，就可以确定正确的数字，所以 cost 最低为2。如果有四个数字 1，2，3，4，那么情况就有点复杂了，策略是用k来遍历所有的数字，然后再根据k分成的左右两个区间，取其中的较大 cost 加上k。</p>
<ul>
<li>当k为1时，左区间为空，所以 cost 为0，而右区间 2，3，4，根据之前的分析应该取3，所以整个 cost 就是 1+3=4。</li>
<li>当k为2时，左区间为1，cost 为0，右区间为 3，4，cost 为3，整个 cost 就是 2+3=5。</li>
<li>当k为3时，左区间为 1，2，cost 为1，右区间为4，cost 为0，整个 cost 就是 3+1=4。</li>
<li>当k为4时，左区间 1，2，3，cost 为2，右区间为空，cost 为0，整个 cost 就是 4+2=6。</li>
</ul>
<p>综上k的所有情况，此时应该取整体 cost 最小的，即4，为最后的答案，这就是极小化极大算法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMoneyAmount</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++)</span><br><span class="line">                <span class="keyword">if</span> (i != j)</span><br><span class="line">                    dp[i][j] = INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++)</span><br><span class="line">            dp[i][i+<span class="number">1</span>] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">1</span>; j --) &#123;</span><br><span class="line">                <span class="keyword">int</span> local, minn = INT_MAX;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j+<span class="number">1</span>; k &lt; i; k ++) &#123;</span><br><span class="line">                    local = max(dp[j][k<span class="number">-1</span>], dp[k+<span class="number">1</span>][i]) + k;</span><br><span class="line">                    minn = min(minn, local);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[j][i] = min(minn, dp[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="极小极大的定义"><a href="#极小极大的定义" class="headerlink" title="极小极大的定义"></a>极小极大的定义</h2><p>Minimax算法 又名极小化极大算法，是一种找出失败的最大可能性中的最小值的算法（即最小化对手的最大得益）。通常以递归形式来实现。</p>
<p>Minimax算法常用于棋类等由两方较量的游戏和程序。该算法是一个零总和算法，即一方要在可选的选项中选择将其优势最大化的选择，另一方则选择令对手 优势最小化的一个，其输赢的总和为0（有点像能量守恒，就像本身两个玩家都有1点，最后输家要将他的1点给赢家，但整体上还是总共有2点）。很多棋类游戏 可以采取此算法，例如tic-tac-toe。</p>
<h2 id="以TIC-TAC-TOE为例"><a href="#以TIC-TAC-TOE为例" class="headerlink" title="以TIC-TAC-TOE为例"></a>以TIC-TAC-TOE为例</h2><p>tic-tac-toe就是井字棋。</p>
<p>一般X的玩家先下。设定X玩家的最大利益为正无穷（+∞），O玩家的最大利益为负无穷（-∞），这样我们称X玩家为MAX（因为他总是追求更大的值），成O玩家为MIN（她总是追求更小的值），各自都为争取自己的最大获益而努力。</p>
<p>现在，让我们站在MAX的立场来分析局势（这是必须的，应为你总不能两边倒吧，你喜欢的话也可以选择MIN）。由于MAX是先下的（习惯上X的玩家先下），于是构建出来的博弈树如下(前面两层)：<br><img src="/img/dc70120f-e4d3-3ab2-b1c5-54a2025cb708.png" alt></p>
<p>MAX总是会选择MIN最大获利中的最小值（对MAX最有利），同样MIN也会一样，选择对自己最有利的（即MAX有可能获得的最大值）。有点难理解，其实就是自己得不到也不给你得到这样的意思啦，抢先把对对手有利的位置抢占了。你会看出，这是不断往下深钻的，直到最底层（即叶节点）你才能网上回溯，确定那个是对你最有利的。</p>
<p>具体过程会像是这么一个样子的：<br><img src="/img/34e89c30-5001-31cd-ac3d-4c3972e00701.gif" alt></p>
<p>但实际情况下，完全遍历一颗博弈树是不现实的，因为层级的节点数是指数级递增的，完全遍历会很耗时…一般情况下需要限制深钻的层数，在达到限定的层数时就返回一个估算值（通过一个启发式的函数对当前博弈位置进行估值），这样获得的值就不是精确的了（遍历的层数越深越精确，当然和估算函数也有一定关系），但该值依然是足够帮助我们做出决策的。于是，对耗时和精确度需要做一个权衡。一般我们限定其遍历的深度为6（目前多数的象棋游戏也是这么设定的）。</p>
<p>于是，我们站在MAX的角度，评估函数会是这样子的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>   <span class="keyword">final</span>   <span class="keyword">int</span>   INFINITY = <span class="number">100</span> ;   <span class="comment">// 表示无穷的值  </span></span><br><span class="line"><span class="keyword">static</span>   <span class="keyword">final</span>   <span class="keyword">int</span>   WIN = +INFINITY ;   <span class="comment">// MAX的最大利益为正无穷  </span></span><br><span class="line"><span class="keyword">static</span>   <span class="keyword">final</span>   <span class="keyword">int</span>   LOSE = -INFINITY ;   <span class="comment">// MAX的最小得益（即MIN的最大得益）为负无穷  </span></span><br><span class="line"><span class="keyword">static</span>   <span class="keyword">final</span>   <span class="keyword">int</span>   DOUBLE_LINK = INFINITY / <span class="number">2</span> ;   <span class="comment">// 如果同一行、列或对角上连续有两个，赛点  </span></span><br><span class="line"><span class="keyword">static</span>   <span class="keyword">final</span>   <span class="keyword">int</span>   INPROGRESS = <span class="number">1</span> ;   <span class="comment">// 仍可继续下（没有胜出或和局）  </span></span><br><span class="line"><span class="keyword">static</span>   <span class="keyword">final</span>   <span class="keyword">int</span>   DRAW = <span class="number">0</span> ;   <span class="comment">// 和局  </span></span><br><span class="line"><span class="keyword">static</span>   <span class="keyword">final</span>   <span class="keyword">int</span> [][] WIN_STATUS =   &#123;  </span><br><span class="line">      &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> &#125;,  </span><br><span class="line">      &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;,  </span><br><span class="line">      &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,  </span><br><span class="line">      &#123; <span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span> &#125;,  </span><br><span class="line">      &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span> &#125;,  </span><br><span class="line">      &#123; <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span> &#125;,  </span><br><span class="line">      &#123; <span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span> &#125;,  </span><br><span class="line">      &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>   &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 估值函数，提供一个启发式的值，决定了游戏AI的高低 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span>   <span class="keyword">int</span>   <span class="title">gameState</span><span class="params">( <span class="keyword">char</span> []   board )</span>   </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>   result = INPROGRESS;  </span><br><span class="line">    <span class="keyword">boolean</span>   isFull =   <span class="keyword">true</span> ;  </span><br><span class="line">     </span><br><span class="line">    <span class="comment">// is game over?  </span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span>   pos = <span class="number">0</span>; pos &lt; <span class="number">9</span>; pos++) &#123;  </span><br><span class="line">        <span class="keyword">char</span> chess = board[pos];  </span><br><span class="line">        <span class="keyword">if</span> ( empty   == chess) &#123;  </span><br><span class="line">            isFull =   <span class="keyword">false</span> ;  </span><br><span class="line">            <span class="keyword">break</span> ;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// is Max win/lose?  </span></span><br><span class="line">    <span class="keyword">for</span>   ( <span class="keyword">int</span> [] status : WIN_STATUS) &#123;  </span><br><span class="line">        <span class="keyword">char</span>   chess = board[status[<span class="number">0</span>]];  </span><br><span class="line">        <span class="keyword">if</span> (chess ==   empty ) &#123;  </span><br><span class="line">            <span class="keyword">break</span> ;  </span><br><span class="line">        &#125;  </span><br><span class="line">         <span class="keyword">int</span> i = <span class="number">1</span>;  </span><br><span class="line">         <span class="keyword">for</span> (; i &lt; status.length; i++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (board[status[i]] != chess) &#123;  </span><br><span class="line">                <span class="keyword">break</span> ;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (i == status.length) &#123;  </span><br><span class="line">            result = chess ==   x   ? WIN : LOSE;  </span><br><span class="line">             <span class="keyword">break</span> ;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (result != WIN &amp; result != LOSE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull) &#123;  </span><br><span class="line">            <span class="comment">// is draw  </span></span><br><span class="line">            result = DRAW;  </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// check double link  </span></span><br><span class="line">            <span class="comment">// finds[0]-&gt;'x', finds[1]-&gt;'o'  </span></span><br><span class="line">            <span class="keyword">int</span> [] finds =   <span class="keyword">new</span>   <span class="keyword">int</span> [<span class="number">2</span>];  </span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> [] status : WIN_STATUS) &#123;  </span><br><span class="line">                <span class="keyword">char</span> chess =   empty ;  </span><br><span class="line">                <span class="keyword">boolean</span> hasEmpty =   <span class="keyword">false</span> ;  </span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;  </span><br><span class="line">                <span class="keyword">for</span> ( <span class="keyword">int</span>   i = <span class="number">0</span>; i &lt; status.length; i++) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (board[status[i]] ==   empty ) &#123;  </span><br><span class="line">                        hasEmpty =   <span class="keyword">true</span> ;  </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (chess ==   empty ) &#123;  </span><br><span class="line">                            chess = board[status[i]];  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        <span class="keyword">if</span> (board[status[i]] == chess) &#123;  </span><br><span class="line">                            count++;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (hasEmpty &amp;&amp; count &gt; <span class="number">1</span>) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (chess ==   x ) &#123;  </span><br><span class="line">                        finds[<span class="number">0</span>]++;  </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                        finds[<span class="number">1</span>]++;  </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// check if two in one line  </span></span><br><span class="line">            <span class="keyword">if</span>   (finds[<span class="number">1</span>] &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                result = -DOUBLE_LINK;  </span><br><span class="line">            &#125; <span class="keyword">else</span>   <span class="keyword">if</span>   (finds[<span class="number">0</span>] &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                result = DOUBLE_LINK;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于这些，一个限定层数的实现是这样的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 以'x'的角度来考虑的极小极大算法 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimax</span><span class="params">( <span class="keyword">char</span> [] board,   <span class="keyword">int</span>   depth)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> [] bestMoves =   <span class="keyword">new</span>   <span class="keyword">int</span> [<span class="number">9</span>];  </span><br><span class="line">        <span class="keyword">int</span>   index = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">int</span>   bestValue = - INFINITY ;  </span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span>   pos=<span class="number">0</span>; pos&lt;<span class="number">9</span>; pos++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (board[pos]== empty )&#123;  </span><br><span class="line">                board[pos] =   x ;  </span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">int</span>   value = min(board, depth);  </span><br><span class="line">                <span class="keyword">if</span> (value&gt;bestValue)&#123;  </span><br><span class="line">                    bestValue = value;  </span><br><span class="line">                    index = <span class="number">0</span>;  </span><br><span class="line">                    bestMoves[index] = pos;  </span><br><span class="line">                &#125; <span class="keyword">else</span>  </span><br><span class="line">                    <span class="keyword">if</span> (value==bestValue)&#123;  </span><br><span class="line">                        index++;  </span><br><span class="line">                        bestMoves[index] = pos;  </span><br><span class="line">                &#125;  </span><br><span class="line">                    </span><br><span class="line">                board[pos] =   empty ;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (index&gt;<span class="number">1</span>)&#123;  </span><br><span class="line">            index = ( <span class="keyword">new</span>   Random (System. currentTimeMillis ()).nextInt()&gt;&gt;&gt;<span class="number">1</span>)%index;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span>   bestMoves[index];  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 对于'x'，估值越大对其越有利 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span>   <span class="keyword">int</span>   <span class="title">max</span><span class="params">( <span class="keyword">char</span> [] board,   <span class="keyword">int</span>   depth)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>   evalValue =   gameState (board);  </span><br><span class="line">    <span class="keyword">boolean</span> isGameOver = (evalValue== WIN || evalValue== LOSE || evalValue== DRAW );  </span><br><span class="line">    <span class="keyword">if</span> (depth==<span class="number">0</span> || isGameOver)&#123;  </span><br><span class="line">        <span class="keyword">return</span>   evalValue;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>   bestValue = - INFINITY ;  </span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span>   pos=<span class="number">0</span>; pos&lt;<span class="number">9</span>; pos++)&#123;  </span><br><span class="line">        <span class="keyword">if</span> (board[pos]== empty )&#123;  </span><br><span class="line">            <span class="comment">// try  </span></span><br><span class="line">            board[pos] =   x ;  </span><br><span class="line">                </span><br><span class="line">            <span class="comment">//   maximixing  </span></span><br><span class="line">            bestValue = Math. max (bestValue, min(board, depth-<span class="number">1</span>));  </span><br><span class="line">            <span class="comment">// reset  </span></span><br><span class="line">            board[pos] =   empty ;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span>   evalValue;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 对于'o'，估值越小对其越有利 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span>   <span class="keyword">int</span>   <span class="title">min</span><span class="params">( <span class="keyword">char</span> [] board,   <span class="keyword">int</span>   depth)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>   evalValue =   gameState (board);  </span><br><span class="line">    <span class="keyword">boolean</span>   isGameOver = (evalValue== WIN   || evalValue== LOSE   || evalValue== DRAW );  </span><br><span class="line">    <span class="keyword">if</span> (depth==<span class="number">0</span> || isGameOver)&#123;  </span><br><span class="line">        <span class="keyword">return</span>   evalValue;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">int</span>   bestValue = + INFINITY ;  </span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span>   pos=<span class="number">0</span>; pos&lt;<span class="number">9</span>; pos++)&#123;  </span><br><span class="line">        <span class="keyword">if</span> (board[pos]== empty )&#123;  </span><br><span class="line">            <span class="comment">// try  </span></span><br><span class="line">            board[pos] =   o ;  </span><br><span class="line">            <span class="comment">//   minimixing  </span></span><br><span class="line">            bestValue = Math.min(bestValue, max(board, depth-<span class="number">1</span>));  </span><br><span class="line">            <span class="comment">// reset  </span></span><br><span class="line">            board[pos] =   empty ;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>   evalValue;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Alpha-beta剪枝"><a href="#Alpha-beta剪枝" class="headerlink" title="Alpha-beta剪枝"></a>Alpha-beta剪枝</h2><p>另外，通过结合Alpha-beta剪枝能进一步优化效率。Alpha-beta剪枝顾名思义就是裁剪掉一些不必要的分支，以减少遍历的节点数。实际上是通过传递两个参数alpha和beta到递归的极小极大函数中，alpha表示了MAX的最坏情况，beta表示了MIN的最坏情况，因此他们的初始值为负无穷和正无穷。在递归的过程中，在轮到MAX的回合，如果极小极大的值比alpha大，则更新alpha；在MIN的回合中，如果极小极大值比beta小，则更新beta。当alpha和beta相交时（即alpha&gt;=beta），这时该节点的所有子节点对于MAX和MIN双方都不会带来好的获益，所以可以忽略掉（裁剪掉）以该节点为父节点的整棵子树。</p>
<p>根据这一定义，可以很轻易地在上面程序的基础上进行改进：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 以'x'的角度来考虑的极小极大算法 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span>   <span class="keyword">int</span>   <span class="title">minimax</span><span class="params">( <span class="keyword">char</span> [] board,   <span class="keyword">int</span>   depth)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> [] bestMoves =   <span class="keyword">new</span>   <span class="keyword">int</span> [<span class="number">9</span>];  </span><br><span class="line">    <span class="keyword">int</span>   index = <span class="number">0</span>;  </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">int</span>   bestValue = - INFINITY ;  </span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span>   pos=<span class="number">0</span>; pos&lt;<span class="number">9</span>; pos++)&#123;  </span><br><span class="line">        <span class="keyword">if</span> (board[pos]== empty )&#123;  </span><br><span class="line">            board[pos] =   x ;  </span><br><span class="line">              </span><br><span class="line">            <span class="keyword">int</span>   value = min(board, depth, - INFINITY , + INFINITY );  </span><br><span class="line">            <span class="keyword">if</span> (value&gt;bestValue)&#123;  </span><br><span class="line">                bestValue = value;  </span><br><span class="line">                index = <span class="number">0</span>;  </span><br><span class="line">                bestMoves[index] = pos;  </span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (value==bestValue)&#123;  </span><br><span class="line">                index++;  </span><br><span class="line">                bestMoves[index] = pos;  </span><br><span class="line">            &#125; </span><br><span class="line">            board[pos] =   empty ;  </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">    <span class="keyword">if</span> (index&gt;<span class="number">1</span>)&#123;  </span><br><span class="line">        index = ( <span class="keyword">new</span>   Random (System. currentTimeMillis ()).nextInt()&gt;&gt;&gt;<span class="number">1</span>)%index;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span>   bestMoves[index];  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 对于'x'，估值越大对其越有利 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span>   <span class="keyword">int</span>   <span class="title">max</span><span class="params">( <span class="keyword">char</span> [] board,   <span class="keyword">int</span>   depth,   <span class="keyword">int</span>   alpha,   <span class="keyword">int</span>   beta)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>   evalValue =   gameState (board);  </span><br><span class="line">    <span class="keyword">boolean</span>   isGameOver = (evalValue== WIN   || evalValue== LOSE   || evalValue== DRAW );  </span><br><span class="line">    <span class="keyword">if</span> (beta&lt;=alpha)&#123;  </span><br><span class="line">        <span class="keyword">return</span>   evalValue;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (depth==<span class="number">0</span> || isGameOver)&#123;  </span><br><span class="line">        <span class="keyword">return</span>   evalValue;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>   bestValue = - INFINITY ;  </span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span>   pos=<span class="number">0</span>; pos&lt;<span class="number">9</span>; pos++)&#123;  </span><br><span class="line">        <span class="keyword">if</span> (board[pos]== empty )&#123;</span><br><span class="line">            <span class="comment">// try  </span></span><br><span class="line">            board[pos] =   x ;  </span><br><span class="line">            <span class="comment">//   maximixing  </span></span><br><span class="line">            bestValue = Math. max (bestValue, min(board, depth-<span class="number">1</span>, Math. max (bestValue, alpha), beta));  </span><br><span class="line">            <span class="comment">// reset  </span></span><br><span class="line">            board[pos] =   empty ;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>   evalValue;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 对于'o'，估值越小对其越有利 </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span>   <span class="keyword">int</span>   <span class="title">min</span><span class="params">( <span class="keyword">char</span> [] board,   <span class="keyword">int</span>   depth,   <span class="keyword">int</span>   alpha,   <span class="keyword">int</span>   beta)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span>   evalValue =   gameState (board);  </span><br><span class="line">    <span class="keyword">boolean</span>   isGameOver = (evalValue== WIN   || evalValue== LOSE   || evalValue== DRAW );  </span><br><span class="line">    <span class="keyword">if</span> (alpha&gt;=beta)&#123;  </span><br><span class="line">        <span class="keyword">return</span>   evalValue;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// try  </span></span><br><span class="line">    <span class="keyword">if</span> (depth==<span class="number">0</span> || isGameOver || alpha&gt;=beta)&#123;  </span><br><span class="line">        <span class="keyword">return</span>   evalValue;  </span><br><span class="line">    &#125;  </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span>   bestValue = + INFINITY ;  </span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span>   pos=<span class="number">0</span>; pos&lt;<span class="number">9</span>; pos++)&#123;  </span><br><span class="line">        <span class="keyword">if</span> (board[pos]== empty )&#123;  </span><br><span class="line">            <span class="comment">// try  </span></span><br><span class="line">            board[pos] =   o ;  </span><br><span class="line">            <span class="comment">//   minimixing  </span></span><br><span class="line">            bestValue = Math.min(bestValue, max(board, depth-<span class="number">1</span>, alpha, Math.min(bestValue, beta)));  </span><br><span class="line">            <span class="comment">// reset  </span></span><br><span class="line">            board[pos] =   empty ;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>   evalValue;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode376-Wiggle-Subsequence"><a href="#Leetcode376-Wiggle-Subsequence" class="headerlink" title="Leetcode376. Wiggle Subsequence"></a>Leetcode376. Wiggle Subsequence</h1><p>A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.</p>
<p>For example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) alternate between positive and negative.<br>In contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.<br>A subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.</p>
<p>Given an integer array nums, return the length of the longest wiggle subsequence of nums.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,7,4,9,2,5]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: There are several subsequences that achieve this length.</span><br><span class="line">One is [1, 17, 10, 13, 10, 16, 8] with differences (16, -7, 3, -3, 6, -8).</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,4,5,6,7,8,9]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>一个整数序列，如果两个相邻元素的差恰好正负交替出现，则该序列被称为摇摆序列。一个小于2个元素的序列直接为摇摆序列。给一个随机序列，求这个序列满足摇摆序列定义的最长子序列的长度。</p>
<p>解法：记录序列中前后两个元素的状态。初始状态为begin，如果后一个元素大于前一个元素，则状态为up，反之状态为down。当状态转换时，摇摆序列的长度加1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dir = <span class="number">0</span>, res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dir == <span class="number">0</span> || dir == <span class="number">-1</span>) &#123;</span><br><span class="line">                    res ++;</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dir == <span class="number">0</span> || dir == <span class="number">1</span>) &#123;</span><br><span class="line">                    res ++;</span><br><span class="line">                    dir = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>状态转移方程</p>
<ul>
<li><code>dp[i][0]=max{dp[j][1]}+1  当nums[i]&gt;nums[j]</code></li>
<li><code>dp[i][1]=max{dp[j][0]}+1  当nums[i]&lt;nums[j]</code></li>
</ul>
<p>其中 <code>0&lt;=j&lt;i</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(len+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = INT_MIN;</span><br><span class="line">            <span class="keyword">int</span> b = INT_MIN;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i<span class="number">-1</span>; k &gt;= <span class="number">0</span>; k --) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[k])</span><br><span class="line">                    a = max(a, dp[k][<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt; nums[k])</span><br><span class="line">                    b = max(b, dp[k][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][<span class="number">1</span>] = a &gt; INT_MIN ? a+<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">			dp[i][<span class="number">0</span>] = b &gt; INT_MIN ? b+<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    	<span class="keyword">return</span> max(dp[len<span class="number">-1</span>][<span class="number">0</span>], dp[len<span class="number">-1</span>][<span class="number">1</span>]); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode377-Combination-Sum-IV"><a href="#Leetcode377-Combination-Sum-IV" class="headerlink" title="Leetcode377. Combination Sum IV"></a>Leetcode377. Combination Sum IV</h1><p>Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.</p>
<p>The answer is guaranteed to fit in a 32-bit integer.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3], target = 4</span><br><span class="line">Output: 7</span><br></pre></td></tr></table></figure></p>
<p>Explanation:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">The possible combination ways are:</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br></pre></td></tr></table></figure></p>
<p>Note that different sequences are counted as different combinations.</p>
<p>这里需要一个一维数组 dp，其中 dp[i] 表示目标数为i的解的个数，然后从1遍历到 target，对于每一个数i，遍历 nums 数组，如果 i&gt;=x, dp[i] += dp[i - x]。这个也很好理解，比如说对于 [1,2,3] 4，这个例子，当计算 dp[3] 的时候，3可以拆分为 1+x，而x即为 dp[2]，3也可以拆分为 2+x，此时x为 dp[1]，3同样可以拆为 3+x，此时x为 dp[0]，把所有的情况加起来就是组成3的所有情况了。</p>
<p>如果 target 远大于 nums 数组的个数的话，上面的算法可以做适当的优化，先给 nums 数组排个序，然后从1遍历到 target，对于i小于数组中的数字x时，直接 break 掉，因为后面的数更大，其余地方不变，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(target+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; target+<span class="number">1</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ii : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; ii)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">long</span>(dp[i]) + dp[i-ii] &gt; INT_MAX)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i] = dp[i] + dp[i - ii];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>中间可能会溢出，超过INT_MAX，需要处理一下，如果超过了INT_MAX以后也就不可能用到了，所以直接continue。</p>
<h1 id="Leetcode378-Kth-Smallest-Element-in-a-Sorted-Matrix"><a href="#Leetcode378-Kth-Smallest-Element-in-a-Sorted-Matrix" class="headerlink" title="Leetcode378. Kth Smallest Element in a Sorted Matrix"></a>Leetcode378. Kth Smallest Element in a Sorted Matrix</h1><p>Given an n x n matrix where each of the rows and columns are sorted in ascending order, return the kth smallest element in the matrix.</p>
<p>Note that it is the kth smallest element in the sorted order, not the kth distinct element.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8</span><br><span class="line">Output: 13</span><br><span class="line">Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix = [[-5]], k = 1</span><br><span class="line">Output: -5</span><br></pre></td></tr></table></figure></p>
<p>输入矩阵matrix，每一行可以看做是一个排序好的数组，可以将这几个小数组排序好之后取第k个数，即可。排序几个已经排序好的数组，可以参考leetcode23。时间复杂度O(klogn)。</p>
<p>因为同时每一列也是排序号的，考虑用二分查找实现。</p>
<h2 id="二分思路"><a href="#二分思路" class="headerlink" title="二分思路"></a>二分思路</h2><p>返回值一定在<code>matrix[0][0]</code>到<code>matrix[n-1][n-1]</code>之间。令函数g(x)={matrix中小于等于x的数量}={of(matrix[i][j]&lt;=x)}。g(x)是一个递增的函数，x越大，g(x)越大。返回值是满足g(x)&gt;=k，的最小值。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = matrix.size();</span><br><span class="line">    <span class="keyword">int</span> left = matrix[<span class="number">0</span>][<span class="number">0</span>], right = matrix[len<span class="number">-1</span>][len<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (count(matrix, middle, len) &gt;= k)</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="计算小于等于middle值的个数"><a href="#计算小于等于middle值的个数" class="headerlink" title="计算小于等于middle值的个数"></a>计算小于等于middle值的个数</h2><p>接下来的问题是如何数出&lt; = middle的数量。可以发现一个性质：任取一个数 mid 满足l &lt;= middle &lt;= r，那么矩阵中不大于 mid 的数，肯定全部分布在矩阵的左上角。</p>
<p>我们可以从左下角开始遍历。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countSmallerOrEqual</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> middle, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&lt;n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix[i][j]&lt;=middle)&#123;</span><br><span class="line">            num += i+<span class="number">1</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度O(nlog(r−l))。二分查找进行次数为O(log(r-l))，每次操作时间复杂度为 O(n)。</p>
<p>当然我们也可以每次遍历一个子数组，二分查找个数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countSmallerOrEqual</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> middle, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">           <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">               <span class="keyword">int</span> m = l + ((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">               <span class="keyword">if</span>(matrix[i][m]&gt;middle)&#123;</span><br><span class="line">                   r = m - <span class="number">1</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   l = m + <span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(l&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">               num += l;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">return</span> num;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode382-Linked-List-Random-Node"><a href="#Leetcode382-Linked-List-Random-Node" class="headerlink" title="Leetcode382. Linked List Random Node"></a>Leetcode382. Linked List Random Node</h1><p>Given a singly linked list, return a random node’s value from the linked list. Each node must have the same probability of being chosen.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;Solution&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;, &quot;getRandom&quot;]</span><br><span class="line">[[[1, 2, 3]], [], [], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, 1, 3, 2, 2, 3]</span><br></pre></td></tr></table></figure></p>
<p>Explanation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Solution solution = new Solution([1, 2, 3]);</span><br><span class="line">solution.getRandom(); // return 1</span><br><span class="line">solution.getRandom(); // return 3</span><br><span class="line">solution.getRandom(); // return 2</span><br><span class="line">solution.getRandom(); // return 2</span><br><span class="line">solution.getRandom(); // return 3</span><br><span class="line">// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一个链表，让随机返回一个节点，那么最直接的方法就是先统计出链表的长度，然后根据长度随机生成一个位置，然后从开头遍历到这个位置即可。</p>
<h1 id="Leetcode383-Ransom-Note"><a href="#Leetcode383-Ransom-Note" class="headerlink" title="Leetcode383. Ransom Note"></a>Leetcode383. Ransom Note</h1><p>Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.</p>
<p>Each letter in the magazine string can only be used once in your ransom note.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: ransomNote = &quot;a&quot;, magazine = &quot;b&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: ransomNote = &quot;aa&quot;, magazine = &quot;ab&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: ransomNote = &quot;aa&quot;, magazine = &quot;aab&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>判断给定字符串Ransom 能否由另一字符串magazine中字符中的某些字符组合生成。 显然，统计字符出现次数即可！<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(<span class="built_in">string</span> ransomNote, <span class="built_in">string</span> magazine)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re(<span class="number">27</span>, <span class="number">0</span>), ree(<span class="number">27</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; magazine.length(); i ++)</span><br><span class="line">            re[magazine[i]-<span class="string">'a'</span>] ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ransomNote.length(); i ++) &#123;</span><br><span class="line">            re[ransomNote[i]-<span class="string">'a'</span>] --;</span><br><span class="line">            <span class="keyword">if</span>(re[ransomNote[i]-<span class="string">'a'</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode384-Shuffle-an-Array"><a href="#Leetcode384-Shuffle-an-Array" class="headerlink" title="Leetcode384. Shuffle an Array"></a>Leetcode384. Shuffle an Array</h1><p>Given an integer array nums, design an algorithm to randomly shuffle the array.</p>
<p>Implement the Solution class:</p>
<ul>
<li>Solution(int[] nums) Initializes the object with the integer array nums.</li>
<li>int[] reset() Resets the array to its original configuration and returns it.</li>
<li>int[] shuffle() Returns a random shuffling of the array.</li>
</ul>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;Solution&quot;, &quot;shuffle&quot;, &quot;reset&quot;, &quot;shuffle&quot;]</span><br><span class="line">[[[1, 2, 3]], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]</span><br></pre></td></tr></table></figure></p>
<p>Explanation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Solution solution = new Solution([1, 2, 3]);</span><br><span class="line">solution.shuffle();    // Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must be equally likely to be returned. Example: return [3, 1, 2]</span><br><span class="line">solution.reset();      // Resets the array back to its original configuration [1,2,3]. Return [1, 2, 3]</span><br><span class="line">solution.shuffle();    // Returns the random shuffling of array [1,2,3]. Example: return [1, 3, 2]</span><br></pre></td></tr></table></figure></p>
<p>我们遍历数组每个位置，每次都随机生成一个坐标位置，然后交换当前遍历位置和随机生成的坐标位置的数字，这样如果数组有n个数字，那么我们也随机交换了n组位置，从而达到了洗牌的目的，这里需要注意的是i + rand() % (res.size() - i)不能写成rand() % res.size()，不是真正的随机分布，应该使用Knuth shuffle算法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums): v(nums) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Resets the array to its original configuration and return it. */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; reset() &#123;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns a random shuffling of the array. */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; shuffle() &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = i + rand() % (res.size() - i);</span><br><span class="line">            swap(res[i], res[t]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="洗牌的正确姿势-Knuth-shuffle算法"><a href="#洗牌的正确姿势-Knuth-shuffle算法" class="headerlink" title="洗牌的正确姿势-Knuth shuffle算法"></a>洗牌的正确姿势-Knuth shuffle算法</h2><p>怎样用计算机模拟出足够随机的洗牌结果，看似很简单，但其实它比给一副乱糟糟的牌排好序可能还更难一些。洗牌问题的描述很简单：即如何通过打乱顺序，让一副扑克牌变成随机的排列，而且每一种可能的排列有相同机会出现。关键点在于“相同机会”，即各种随机排列是等可能的。下面先简单介绍一个常见的错误做法，然后看看如何改进变成Knuth 洗牌算法。</p>
<p>先看看一个很直接的做法（一副牌在这里用一个数组表示）：</p>
<p>对数组从头到尾扫描一遍，扫描过程中，每次都从整个数组随机选一个元素，跟当前扫描到的元素交换位置。</p>
<p>也就是，先拿起第一张牌，把它跟从整副牌里随机挑出的另一张牌（把它叫做随机牌）交换位置（随机牌也可能是第一张牌自己，这个时候就相当于不交换位置）；接着拿起第二张牌，也把它跟随机选出的另一张牌交换位置；一直重复直到把最后一张牌跟随机牌交换位置。</p>
<p>用python实现起来也只有几行：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shuffleSort</span><span class="params">(a)</span>:</span></span><br><span class="line">  N = len(a)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">    j = random.randint(<span class="number">0</span>, N<span class="number">-1</span>)</span><br><span class="line">    a[j], a[i] = a[i], a[j]</span><br></pre></td></tr></table></figure></p>
<p>这样随机交换之后，每种排列出现的可能性会是等概率的吗？看起来好像会，但事实上，经过这样交换，总有一部分排列出现的概率更高一些，这个洗牌过程并没有很公平。</p>
<p>为什么不够公平？要从直觉上能够理解清楚还不是那么容易。我们用一个简单的例子来看看，假设这副牌只有三张，分别是{A，B， C}.</p>
<p>按照前面说的方法，第一轮把第一张牌A跟随机一张牌进行交换，会产生三个等可能的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">no change:      &#123;A, B,  C&#125;</span><br><span class="line">swap with B:    &#123;B,  A, C&#125;</span><br><span class="line">swap with C:   &#123;C, B,  A&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二轮从上述三种排列出发，把第二张牌跟随机的一张牌交换，得到九种（有重复）等可能的排列。第三轮也类似。用树状图表示可以看得直观些。<br><img src="/img/shuffle_v1.png" alt></p>
<p>可以看到，最后产生的27个结果里面，{A, B, C}, {C, A, B}, {C, B, A}都出现了4次，而{A, C, B}, {B, A, C}, {B, C, A}都出现了5次。也就是说有些排序出现的可能性是4/27，有些却是5/27. 而且，随着牌数目的增加，这个概率的不均衡会更加严重。</p>
<p>我们重新看看这个方法。A,B,C三张牌的全排列只有6种，但是在这个方法里，一共产生了27个结果（27个分支），它不是6的倍数，怎么都没法给6种排列平均分嘛。所以，要让结果够公平，一个必要条件就是产生的分支是6的整数倍，也就是N!的整数倍。</p>
<h3 id="Knuth洗牌算法"><a href="#Knuth洗牌算法" class="headerlink" title="Knuth洗牌算法"></a>Knuth洗牌算法</h3><p>所以牌该怎么洗呢？在上述方法的基础上，做一处修改，就能剪去一些分支，让分支数是N!的整数倍。这就是Knuth洗牌算法。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shuffleSort</span><span class="params">(a)</span>:</span></span><br><span class="line">  N = len(a)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">    j = random.randint(<span class="number">0</span>, i)</span><br><span class="line">    a[j], a[i] = a[i], a[j]</span><br></pre></td></tr></table></figure></p>
<p>唯一修改的就是随机牌j选取的方法，在拿起第i张牌时，只从它前面的牌随机选出j，而不是从整副牌里面随机选取。</p>
<p>Really? 就只是这样吗？</p>
<p>是的。就这么简单。</p>
<p>还是用{A, B, C}这三张牌作为例子看看。</p>
<p>第一轮拿起牌A， 现在随机牌只能是A，经过第一轮之后，其实没有发生变换，还是{A,B,C}; (这一步也可以省略)</p>
<p>第二轮拿起牌B， 从{A，B}里面随机选一张牌跟B交换，会得到两种等可能的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">swap with A: &#123;B, A, C&#125;</span><br><span class="line">no change: &#123;A, B, C&#125;</span><br></pre></td></tr></table></figure></p>
<p>第三轮从上面两种可能的排列出发，拿起最后一张牌（这里都是C）， 再从所有牌里面随机选一张跟它交换。树状图如下：<br><img src="/img/shuffle_v2.png" alt></p>
<p>最终得到的结果只有6个，正好是三张牌的所有6种排列结果，每种出现一次。所以，Knuth洗牌算法是公平的。</p>
<h1 id="Leetcode385-Mini-Parser"><a href="#Leetcode385-Mini-Parser" class="headerlink" title="Leetcode385. Mini Parser"></a>Leetcode385. Mini Parser</h1><p>Given a nested list of integers represented as a string, implement a parser to deserialize it.</p>
<p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p>
<p>Note: You may assume that the string is well-formed:</p>
<ul>
<li>String is non-empty.</li>
<li>String does not contain white spaces.</li>
<li>String contains only digits 0-9, [, - ,, ].</li>
</ul>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given s = &quot;324&quot;,</span><br><span class="line"></span><br><span class="line">You should return a NestedInteger object which contains a single integer 324.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Given s = &quot;[123,[456,[789]]]&quot;,</span><br><span class="line"></span><br><span class="line">Return a NestedInteger object containing a nested list with 2 elements:</span><br><span class="line">1. An integer containing value 123.</span><br><span class="line">2. A nested list containing two elements:</span><br><span class="line">    i.  An integer containing value 456.</span><br><span class="line">    ii. A nested list with one element:</span><br><span class="line">         a. An integer containing value 789.</span><br></pre></td></tr></table></figure></p>
<p>这道题让我们实现一个迷你解析器用来把一个字符串解析成NestInteger类，关于这个嵌套链表类的题我们之前做过三道，Nested List Weight Sum II，Flatten Nested List Iterator，和Nested List Weight Sum。应该对这个类并不陌生了，我们可以先用递归来做，思路是，首先判断s是否为空，为空直接返回，不为空的话看首字符是否为<code>[</code>，不是的话说明s为一个整数，我们直接返回结果。如果首字符是<code>[</code>，且s长度小于等于2，说明没有内容，直接返回结果。反之如果s长度大于2，我们从i=1开始遍历，我们需要一个变量start来记录某一层的其实位置，用cnt来记录跟其实位置是否为同一深度，cnt=0表示同一深度，由于中间每段都是由逗号隔开，所以当我们判断当cnt为0，且当前字符是逗号或者已经到字符串末尾了，我们把start到当前位置之间的字符串取出来递归调用函数，把返回结果加入res中，然后start更新为i+1。如果遇到<code>[</code>，计数器cnt自增1，若遇到<code>]</code>，计数器cnt自减1。参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">NestedInteger <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> NestedInteger();</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] != <span class="string">'['</span>) <span class="keyword">return</span> NestedInteger(stoi(s));</span><br><span class="line">        <span class="keyword">if</span> (s.size() &lt;= <span class="number">2</span>) <span class="keyword">return</span> NestedInteger();</span><br><span class="line">        NestedInteger res;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt == <span class="number">0</span> &amp;&amp; (s[i] == <span class="string">','</span> || i == s.size() - <span class="number">1</span>)) &#123;</span><br><span class="line">                res.add(deserialize(s.substr(start, i - start)));</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'['</span>) ++cnt;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">']'</span>) --cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode386-Lexicographical-Numbers"><a href="#Leetcode386-Lexicographical-Numbers" class="headerlink" title="Leetcode386. Lexicographical Numbers"></a>Leetcode386. Lexicographical Numbers</h1><p>Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.</p>
<p>You must write an algorithm that runs in O(n) time and uses O(1) extra space. </p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 13</span><br><span class="line">Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 2</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure></p>
<p>给出一个整数 n ，将 1 到 n 的所有整数按照字典顺序排列。例：给出13，返回[1,10,11,12,13,2,3,4,5,6,7,8,9]。注意：尽量使用少的时间和空间复杂度，输入整数大小可能接近5,000,000。</p>
<p>设数组ans，用来存放最后返回的结果，设temp，表示当前应该存入的数字，初始为1.<br>按照字典序的规则，尽可能先把位数少的，顺序靠前的先放进去，那么应该先放1，10，100，1000。。。<br>即if（temp <em> 10 &lt;= n ） temp </em>= 10;<br>然后当超出上限的时候，退回到上一位，开始每次加1，例如：1001，1002，1003。。。。一直到个位数到9为止，即1009，此时加1变成1100，把最右边连续的 0 去除，即回退到11，然后再开始乘10，再循环加个位，再回退。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lexicalOrder(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n);</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            res[i] = temp;</span><br><span class="line">            <span class="keyword">if</span> (temp * <span class="number">10</span> &lt;= n)</span><br><span class="line">                temp = temp * <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp &gt;= n)</span><br><span class="line">                    temp /= <span class="number">10</span>;</span><br><span class="line">                temp ++;</span><br><span class="line">                <span class="keyword">while</span>(temp % <span class="number">10</span> == <span class="number">0</span>)</span><br><span class="line">                    temp /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode387-First-Unique-Character-in-a-String"><a href="#Leetcode387-First-Unique-Character-in-a-String" class="headerlink" title="Leetcode387. First Unique Character in a String"></a>Leetcode387. First Unique Character in a String</h1><p>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</p>
<p>Examples:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;leetcode&quot;</span><br><span class="line">return 0.</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;loveleetcode&quot;,</span><br><span class="line">return 2.</span><br></pre></td></tr></table></figure>
<p>用哈希表建立每个字符和其出现次数的映射，然后按顺序遍历字符串，找到第一个出现次数为1的字符，返回其位置即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) ++m[c];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(m[s[i]] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode389-Find-the-Difference"><a href="#Leetcode389-Find-the-Difference" class="headerlink" title="Leetcode389. Find the Difference"></a>Leetcode389. Find the Difference</h1><p>Given two strings s and t which consist of only lowercase letters. String t is generated by random shuffling string s and then add one more letter at a random position. Find the letter that was added in t.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;abcd&quot;</span><br><span class="line">t = &quot;abcde&quot;</span><br><span class="line">Output: e</span><br><span class="line">Explanation:</span><br><span class="line">&apos;e&apos; is the letter that was added.</span><br></pre></td></tr></table></figure></p>
<p>一个hash表可以解决, 甚至可以用两个加起来然后异或<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">        <span class="keyword">char</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch: s) hash[ch]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch: t) </span><br><span class="line">            <span class="keyword">if</span>(--hash[ch]&lt;<span class="number">0</span>) ans = ch; </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode392-Is-Subsequence"><a href="#Leetcode392-Is-Subsequence" class="headerlink" title="Leetcode392. Is Subsequence"></a>Leetcode392. Is Subsequence</h1><p>Given a string s and a string t, check if s is subsequence of t.</p>
<p>You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (&lt;=100).</p>
<p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ace” is a subsequence of “abcde” while “aec” is not).</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">Return true.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;axc&quot;, t = &quot;ahbgdc&quot;</span><br><span class="line">Return false.</span><br></pre></td></tr></table></figure></p>
<p>Follow up:<br>If there are lots of incoming S, say S1, S2, … , Sk where k &gt;= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?</p>
<p>检查一个串是不是另一个串的子串，找两个指针即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ss,tt;</span><br><span class="line">        ss=<span class="number">0</span>;</span><br><span class="line">        tt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ss&lt;s.length() &amp;&amp; tt&lt;t.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[ss]==t[tt])&#123;</span><br><span class="line">                ss++;</span><br><span class="line">                tt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ss==s.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们可以用俩个指针i，j分别指向字符串s，t. 算法描述如下: j指针一直往后走，碰到t[j]==s[i]的时候，说明匹配上了一个，将i++，否则i不加1，当t都走完的时候，这个时候，我们判断一下i指针是否走完了s字符串，如果走完了，说明也匹配上了，如果没有走完，那么就是没有匹配上，中间的过程，i提前等于s.length()的时候，也可以退出！此时的时间复杂度就是扫描一遍t，s串的线性复杂度O(t_len+s_len)。</p>
<p>算法正确性：</p>
<p>我们算法的关键点就在于，当s[i]=t[j]的时候，i和j都需要加1，那么这俩个指针加1的过程是否一定是对的呢？我们可以这样理解，当s=”abc”,t=”ahbgdc”,i=1,j=1的时候，我们只需要判断s后面的子串bc是否是t的子串hbgdc的子集（相当于分解为子问题），如果s的子串bc满足是t的子串hbgdc的子集，我们就返回true，如果不满足，我们就返回false。这样一步一步贪心下去就能保证算法正确性。</p>
<p>下面举一个简单例子走一遍算法帮助理解: s=”abc”, t=“ahbgdc” 首先i，j都为0，分别指向s，t俩个串开头. 第一步，当<code>j=0&lt;t_len=6</code>的时候，进入循环，此时<code>t[0]=a,s[0]=a</code>,俩者相等，那么i,j都1，此时<code>i=1，j=1，i!=(s_len=3)</code>,不跳出, j还是小于<code>t_len</code>。 此时<code>t[1]=h</code> ,<code>s[1]=b</code>,它们不相等，那么只有j加1，此时<code>i=1,j=2，i!=3</code>，不跳出. j还是小于<code>t_len=6</code>，此时<code>t[2]=b,s[1]=b</code>,它们相等，那么i,j分别加1，此时<code>i=2，j=3,i!=3</code>不跳出. 那么<code>t[3]=g,s[2]=c</code>,它们不相等，那么之后j加1，此时<code>i=2,j=4，i!=3</code>不跳出. 此时<code>t[4]=d,s[2]=2</code>,它们不相等,此时j加1,<code>i=2,j=5,i!=3</code>不跳出. j还是小于6，<code>t[5]=c,s[2]=c</code>,此时它们相等，<code>i++</code>，<code>i=3</code>，此时等于<code>s_len</code>，<code>res=true</code>，跳出while循环，返回结果为true。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//俩个指针都往前走</span></span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;        <span class="comment">//空字符串是任何字符串的子串</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> s_len = s.length(),t_len = t.length();</span><br><span class="line">        <span class="keyword">while</span>(j &lt; t_len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t[j] == s[i])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">if</span>(i==s_len)</span><br><span class="line">                &#123;</span><br><span class="line">                    res = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;         <span class="comment">//无论t[j]是否等于s[i]，j都要加1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode393-UTF-8-Validation"><a href="#Leetcode393-UTF-8-Validation" class="headerlink" title="Leetcode393. UTF-8 Validation"></a>Leetcode393. UTF-8 Validation</h1><p>A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:</p>
<p>For 1-byte character, the first bit is a 0, followed by its unicode code.<br>For n-bytes character, the first n-bits are all one’s, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10.<br>This is how the UTF-8 encoding would work:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Char. number range  |        UTF-8 octet sequence</span><br><span class="line">   (hexadecimal)    |              (binary)</span><br><span class="line">--------------------+---------------------------------------------</span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure></p>
<p>Given an array of integers representing the data, return whether it is a valid utf-8 encoding.</p>
<p>Note:<br>The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.</p>
<p>Example 1: data = [197, 130, 1], which represents the octet sequence: <strong>11000101 10000010 00000001</strong>. Return <strong>true</strong>.It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.</p>
<p>Example 2: data = [235, 140, 4], which represented the octet sequence: <strong>11101011 10001100 00000100</strong>. Return <strong>false</strong>. The first 3 bits are all one’s and the 4th bit is 0 means it is a 3-bytes character. The next byte is a continuation byte which starts with 10 and that’s correct. But the second continuation byte does not start with 10, so it is invalid.</p>
<p>这道题考察我们 UTF-8 编码，这种互联网所采用的通用的编码格式的产生是为了解决ASCII只能表示英文字符的局限性，和统一 Unicode 的实现方式。下面这段摘自维基百科 UTF-8 编码：</p>
<p>对于 UTF-8 编码中的任意字节B，如果B的第一位为0，则B独立的表示一个字符(ASCII 码)；</p>
<ul>
<li>如果B的第一位为1，第二位为0，则B为一个多字节字符中的一个字节(非 ASCII 字符)；</li>
<li>如果B的前两位为1，第三位为0，则B为两个字节表示的字符中的第一个字节；</li>
<li>如果B的前三位为1，第四位为0，则B为三个字节表示的字符中的第一个字节；</li>
<li>如果B的前四位为1，第五位为0，则B为四个字节表示的字符中的第一个字节；</li>
</ul>
<p>因此，对 UTF-8 编码中的任意字节，根据第一位，可判断是否为 ASCII 字符；根据前二位，可判断该字节是否为一个字符编码的第一个字节；根据前四位（如果前两位均为1），可确定该字节为字符编码的第一个字节，并且可判断对应的字符由几个字节表示；根据前五位（如果前四位为1），可判断编码是否有错误或数据传输过程中是否有错误。</p>
<p>如果是标识字节，先将其向右平移五位，如果得到 110，则说明后面跟了一个字节，否则向右平移四位，如果得到 1110，则说明后面跟了两个字节，否则向右平移三位，如果得到 11110，则说明后面跟了三个字节，否则向右平移七位，如果为1的话，说明是 10000000 这种情况，不能当标识字节，直接返回 false。在非标识字节中，向右平移六位，如果得到的不是 10，则说明不是以 10 开头的，直接返回 false，否则 cnt 自减1，成功完成遍历返回 true。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validUtf8</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>((data[i] &gt;&gt; <span class="number">7</span>) == <span class="number">0</span>)</span><br><span class="line">                    cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((data[i] &gt;&gt; <span class="number">5</span>) == <span class="number">0b110</span>)</span><br><span class="line">                    cnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((data[i] &gt;&gt; <span class="number">4</span>) == <span class="number">0b1110</span>)</span><br><span class="line">                    cnt = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>((data[i] &gt;&gt; <span class="number">3</span>) == <span class="number">0b11110</span>)</span><br><span class="line">                    cnt = <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>((data[i] &gt;&gt; <span class="number">6</span>) != <span class="number">0b10</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                cnt --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode394-Decode-String"><a href="#Leetcode394-Decode-String" class="headerlink" title="Leetcode394. Decode String"></a>Leetcode394. Decode String</h1><p>Given an encoded string, return its decoded string.</p>
<p>The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.</p>
<p>You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc.</p>
<p>Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;3[a]2[bc]&quot;</span><br><span class="line">Output: &quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;3[a2[c]]&quot;</span><br><span class="line">Output: &quot;accaccacc&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;2[abc]3[cd]ef&quot;</span><br><span class="line">Output: &quot;abcabccdcdcdef&quot;</span><br></pre></td></tr></table></figure></p>
<p>这道题让我们把一个按一定规则编码后的字符串解码成其原来的模样，编码的方法很简单，就是把重复的字符串放在一个括号里，把重复的次数放在括号的前面，注意括号里面有可能会嵌套括号，这题可以用递归和迭代两种方法来解，我们首先来看递归的解法，把一个括号中的所有内容看做一个整体，一次递归函数返回一对括号中解码后的字符串。给定的编码字符串实际上只有四种字符，数字，字母，左括号，和右括号。那么我们开始用一个变量i从0开始遍历到字符串的末尾，由于左括号都是跟在数字后面，所以首先遇到的字符只能是数字或者字母，如果是字母，直接存入结果中，如果是数字，循环读入所有的数字，并正确转换，那么下一位非数字的字符一定是左括号，指针右移跳过左括号，对之后的内容调用递归函数求解，注意我们循环的停止条件是遍历到末尾和遇到右括号，由于递归调用的函数返回了子括号里解码后的字符串，而我们之前把次数也已经求出来了，那么循环添加到结果中即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> decode(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decode</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; s[i] != <span class="string">']'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &lt; <span class="string">'0'</span> || s[i] &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">                res += s[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                    cnt = cnt * <span class="number">10</span> + s[i++] - <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="built_in">string</span> t = decode(s, i);</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">while</span> (cnt-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res += t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们也可以用迭代的方法写出来，当然需要用 stack 来辅助运算，我们用两个 stack，一个用来保存个数，一个用来保存字符串，我们遍历输入字符串，如果遇到数字，我们更新计数变量 cnt；如果遇到左括号，我们把当前 cnt 压入数字栈中，把当前t压入字符串栈中；如果遇到右括号时，我们取出数字栈中顶元素，存入变量k，然后给字符串栈的顶元素循环加上k个t字符串，然后取出顶元素存入字符串t中；如果遇到字母，我们直接加入字符串t中即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> t = <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s_num;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; s_str;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                cnt = <span class="number">10</span> * cnt + s[i] - <span class="string">'0'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'['</span>) &#123;</span><br><span class="line">                s_num.push(cnt);</span><br><span class="line">                s_str.push(t);</span><br><span class="line">                cnt = <span class="number">0</span>; t.clear();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">']'</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> k = s_num.top(); s_num.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; ++j) s_str.top() += t;</span><br><span class="line">	                t = s_str.top(); s_str.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t += s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s_str.empty() ? t : s_str.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我自己的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_digit</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_char</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'z'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st1;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; st2;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is_digit(s[i])) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; len &amp;&amp; is_digit(s[i]))</span><br><span class="line">                    t = t*<span class="number">10</span> + s[i++] - <span class="string">'0'</span>;</span><br><span class="line">                st1.push(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'['</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">                i ++;</span><br><span class="line">                <span class="keyword">while</span>(i+t &lt; len &amp;&amp; is_char(s[i+t])) &#123;</span><br><span class="line">                    t ++;</span><br><span class="line">                &#125;</span><br><span class="line">                st2.push(s.substr(i, t));</span><br><span class="line">                i += t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">']'</span>) &#123;</span><br><span class="line">                <span class="built_in">string</span> temp;</span><br><span class="line">                <span class="keyword">int</span> t = st1.top(); st1.pop();</span><br><span class="line">                <span class="built_in">string</span> te = st2.top(); st2.pop();</span><br><span class="line">                <span class="keyword">while</span>(t--)</span><br><span class="line">                    temp = temp + te;</span><br><span class="line">                <span class="keyword">if</span> (!st2.empty()) &#123;te = st2.top(); st2.pop();st2.push(te + temp);&#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    st2.push(temp);</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">string</span> te;</span><br><span class="line">                <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(i+t &lt; len &amp;&amp; is_char(s[i+t])) &#123;</span><br><span class="line">                    t ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!st2.empty()) &#123;te = st2.top(); st2.pop();st2.push(te + s.substr(i, t));&#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    st2.push(s.substr(i, t));</span><br><span class="line">                i += t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st2.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode395-Longest-Substring-with-At-Least-K-Repeating-Characters"><a href="#Leetcode395-Longest-Substring-with-At-Least-K-Repeating-Characters" class="headerlink" title="Leetcode395. Longest Substring with At Least K Repeating Characters"></a>Leetcode395. Longest Substring with At Least K Repeating Characters</h1><p>Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;aaabb&quot;, k = 3</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">The longest substring is &quot;aaa&quot;, as &apos;a&apos; is repeated 3 times.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;ababbc&quot;, k = 2</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">The longest substring is &quot;ababb&quot;, as &apos;a&apos; is repeated 2 times and &apos;b&apos; is repeated 3 times.</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一个字符串s和一个正整数k，让求一个最大子字符串并且每个字符必须至少出现k次。用 mask 就很好的解决了判断是否出现这个问题，由于字母只有 26 个，而整型 mask 有 32 位，足够用了，每一位代表一个字母，如果为1，表示该字母不够k次，如果为0就表示已经出现了k次。遍历字符串，对于每一个字符，都将其视为起点，然后遍历到末尾，增加 HashMap 中字母的出现次数，如果其小于k，将 mask 的对应位改为1，如果大于等于k，将 mask 对应位改为0。然后看 mask 是否为0，是的话就更新 res 结果，然后把当前满足要求的子字符串的起始位置j保存到 max_idx 中，等内层循环结束后，将外层循环变量i赋值为 max_idx+1，继续循环直至结束，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, n = s.size();</span><br><span class="line">        <span class="keyword">while</span> (i + k &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">int</span> m[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;, mask = <span class="number">0</span>, max_idx = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = s[j] - <span class="string">'a'</span>;</span><br><span class="line">                ++m[t];</span><br><span class="line">                <span class="keyword">if</span> (m[t] &lt; k) mask |= (<span class="number">1</span> &lt;&lt; t);</span><br><span class="line">                <span class="keyword">else</span> mask &amp;= (~(<span class="number">1</span> &lt;&lt; t));</span><br><span class="line">                <span class="keyword">if</span> (mask == <span class="number">0</span>) &#123;</span><br><span class="line">                    res = max(res, j - i + <span class="number">1</span>);</span><br><span class="line">                    max_idx = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i = max_idx + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>虽然上面的方法很机智的使用了 mask 了标记某个子串的字母是否都超过了k，但仍然不是很高效，因为遍历了所有的子串，使得时间复杂度到达了平方级。来想想如何进行优化，因为题目中限定了字符串中只有字母，这意味着最多不同的字母数只有 26 个，最后满足题意的子串中的不同字母数一定是在 [1, 26] 的范围，这样就可以遍历这个范围，每次只找不同字母个数为 cnt，且每个字母至少重复k次的子串，来更新最终结果 res。这里让 cnt 从1遍历到 26，对于每个 cnt，都新建一个大小为 26 的数组 charCnt 来记录每个字母的出现次数，使用的思想其实还是滑动窗口 Sliding Window，使用两个变量 start 和 i 来分别标记窗口的左右边界，当右边界小于n时，进行 while 循环，需要一个变量 valid 来表示当前子串是否满足题意，初始化为 true，还需要一个变量 uniqueCnt 来记录子串中不同字母的个数。此时若 s[i] 这个字母在 charCnt 中的出现次数为0，说明遇到新字母了，uniqueCnt 自增1，同时把该字母的映射值加1。此时由于 uniqueCnt 变大了，有可能会超过之前限定了 cnt，所以这里用一个 while 循环，条件是当 uniqueCnt 大于 cnt ，此时应该收缩滑动窗口的左边界，那么对应的左边界上的字母的映射值要自减1，若减完后为0了，则 uniqueCnt 自减1，注意这里一会后加，一会先减的操作，不要搞晕了。当 uniqueCnt 没超过 cnt 的时候，此时还要看当前窗口中的每个字母的出现次数是否都大于等于k，遇到小于k的字母，则直接 valid 标记为 false 即可。最终若 valid 还是 true，则表示滑动窗口内的字符串是符合题意的，用其长度来更新结果 res 即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cnt = <span class="number">1</span>; cnt &lt;= <span class="number">26</span>; ++cnt) &#123;</span><br><span class="line">            <span class="keyword">int</span> start = <span class="number">0</span>, i = <span class="number">0</span>, uniqueCnt = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; charCnt(<span class="number">26</span>);</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">                <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (charCnt[s[i++] - <span class="string">'a'</span>]++ == <span class="number">0</span>) ++uniqueCnt;</span><br><span class="line">                <span class="keyword">while</span> (uniqueCnt &gt; cnt) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (--charCnt[s[start++] - <span class="string">'a'</span>] == <span class="number">0</span>) --uniqueCnt;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (charCnt[j] &gt; <span class="number">0</span> &amp;&amp; charCnt[j] &lt; k) valid = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (valid) res = max(res, i - start);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面这种解法用的分治法 Divide and Conquer 的思想，看起来简洁了不少，但是个人感觉比较难想，这里使用了一个变量 max_idx，是用来分割子串的，实现开始统计好了字符串s的每个字母出现的次数，然后再次遍历每个字母，若当前字母的出现次数小于k了，则从开头到前一个字母的范围内的子串可能是满足题意的，还需要对前面的子串进一步调用递归，用返回值来更新当前结果 res，此时变量 ok 标记为 false，表示当前整个字符串s是不符合题意的，因为有字母出现次数小于k，此时 max_idx 更新为 i+1，表示再从新的位置开始找下一个出现次数小于k的字母的位置，可以对新的范围的子串继续调用递归。当 for 循环结束后，若 ok 是 true，说明整个s串都是符合题意的，直接返回n，否则要对 [max_idx, n-1] 范围内的子串再次调用递归，因为这个区间的子串也可能是符合题意的，还是用返回值跟结果 res 比较，谁大就返回谁，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size(), max_idx = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) ++m[c];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[s[i]] &lt; k) &#123;</span><br><span class="line">                res = max(res, longestSubstring(s.substr(max_idx, i - max_idx), k));</span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">                max_idx = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ok ? n : max(res, longestSubstring(s.substr(max_idx, n - max_idx), k));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode397-Integer-Replacement"><a href="#Leetcode397-Integer-Replacement" class="headerlink" title="Leetcode397. Integer Replacement"></a>Leetcode397. Integer Replacement</h1><p>Given a positive integer  n  and you can do operations as follow:</p>
<ul>
<li>If  n  is even, replace  n  with  _n_ /2.</li>
<li>If  n  is odd, you can replace  n  with either  _n_  + 1 or  _n_  - 1.</li>
</ul>
<p>What is the minimum number of replacements needed for  n  to become 1?</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">8</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">8 -&gt; 4 -&gt; 2 -&gt; 1</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1</span><br><span class="line">or</span><br><span class="line">7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一个整数n，然后让我们通过变换变为1，如果n是偶数，我们变为n/2，如果是奇数，我们可以变为n+1或n-1，让我们求变为1的最少步骤。那么一看道题的要求，就会感觉应该用递归很合适，我们直接按照规则写出递归即可，注意由于有n+1的操作，所以当n为INT_MAX的时候，就有可能溢出，所以我们可以先将n转为长整型，然后再进行运算，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerReplacement</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span> + integerReplacement(n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> t = n;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> + min(integerReplacement((t + <span class="number">1</span>) / <span class="number">2</span>), integerReplacement((t - <span class="number">1</span>) / <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode398-Random-Pick-Index"><a href="#Leetcode398-Random-Pick-Index" class="headerlink" title="Leetcode398. Random Pick Index"></a>Leetcode398. Random Pick Index</h1><p>Given an integer array nums with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.</p>
<p>Implement the Solution class:</p>
<ul>
<li><code>Solution(int[] nums)</code> Initializes the object with the array nums.</li>
<li><code>int pick(int target)</code> Picks a random index i from nums where nums[i] == target. If there are multiple valid i’s, then each index should have an equal probability of returning.</li>
</ul>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;Solution&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;]</span><br><span class="line">[[[1, 2, 3, 3, 3]], [3], [1], [3]]</span><br><span class="line">Output</span><br><span class="line">[null, 4, 0, 2]</span><br></pre></td></tr></table></figure></p>
<p>Explanation<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Solution solution = new Solution([1, 2, 3, 3, 3]);</span><br><span class="line">solution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.</span><br><span class="line">solution.pick(1); // It should return 0. Since in the array only nums[0] is equal to 1.</span><br><span class="line">solution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.</span><br></pre></td></tr></table></figure></p>
<p>这道题指明了我们不能用太多的空间，那么省空间的随机方法只有水塘抽样Reservoir Sampling了，LeetCode之前有过两道需要用这种方法的题目Shuffle an Array和Linked List Random Node。那么如果了解了水塘抽样，这道题就不算一道难题了，我们定义两个变量，计数器cnt和返回结果res，我们遍历整个数组，如果数组的值不等于target，直接跳过；如果等于target，计数器加1，然后我们在[0,cnt)范围内随机生成一个数字，如果这个数字是0，我们将res赋值为i即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums): v(nums) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i] != target) <span class="keyword">continue</span>;</span><br><span class="line">            ++cnt;</span><br><span class="line">            <span class="keyword">if</span> (rand() % cnt == <span class="number">0</span>) res = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode399-Evaluate-Division"><a href="#Leetcode399-Evaluate-Division" class="headerlink" title="Leetcode399. Evaluate Division"></a>Leetcode399. Evaluate Division</h1><p>You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.</p>
<p>You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.</p>
<p>Return the answers to all queries. If a single answer cannot be determined, return -1.0.</p>
<p>Note: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]</span><br><span class="line">Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000]</span><br><span class="line">Explanation: </span><br><span class="line">Given: a / b = 2.0, b / c = 3.0</span><br><span class="line">queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?</span><br><span class="line">return: [6.0, 0.5, -1.0, 1.0, -1.0 ]</span><br></pre></td></tr></table></figure></p>
<p>这道题已知条件中给了一些除法等式，然后给了另外一些除法等式，问我们能不能根据已知条件求出结果，不能求出来的用-1表示。问题本身是很简单的数学问题，但是写代码来自动实现就需要我们用正确的数据结构和算法，通过观察题目中的例子，我们可以看出如果需要分析的除法式的除数和被除数如果其中任意一个没有在已知条件中出现过，那么返回结果-1，所以我们在分析已知条件的时候，可以使用set来记录所有出现过的字符串，然后我们在分析其他除法式的时候，可以使用递归来做。通过分析得出，不能直接由已知条件得到的情况主要有下面三种：</p>
<ul>
<li>已知: a / b = 2, b / c = 3， 求 a / c</li>
<li>已知: a / c = 2, b / c = 3， 求 a / b</li>
<li>已知: a / b = 2, a / c = 3， 求 b / c</li>
</ul>
<p>虽然有三种情况，但其实后两种情况都可以转换为第一种情况，对于每个已知条件，我们将其翻转一下也存起来，那么对于对于上面美中情况，就有四个已知条件了：</p>
<ul>
<li>已知: a / b = 2 ，b / a = 1/2， b / c = 3 ，c / b = 1/3，求 a / c</li>
<li>已知: a / c = 2 ，c / a = 1/2，b / c = 3， c / b = 1/3 ，求 a / b</li>
<li>已知: a / b = 2， b / a = 1/2 ， a / c = 3 ，c / a = 1/3，求 b / c</li>
</ul>
<p>我们发现，第二种和第三种情况也能转化为第一种情况，只需将上面加粗的两个条件相乘即可。对于每一个需要解析的表达式，我们需要一个HashSet来记录已经访问过的表达式，然后对其调用递归函数。在递归函数中，我们在HashMap中快速查找该表达式，如果跟某一个已知表达式相等，直接返回结果。如果没有的话，那么就需要间接寻找了，我们在HashMap中遍历跟解析式中分子相同的已知条件，跳过之前已经遍历过的，否则就加入visited数组，然后再对其调用递归函数，如果返回值是正数，则乘以当前已知条件的值返回，就类似上面的情况一，相乘以后b就消掉了。如果已知找不到解，最后就返回-1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; calcEquation(<span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; equations, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.size(); ++i) &#123;</span><br><span class="line">            m[equations[i].first][equations[i].second] = values[i];</span><br><span class="line">            m[equations[i].second][equations[i].first] = <span class="number">1.0</span> / values[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> query : queries) &#123;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line">            <span class="keyword">double</span> t = helper(query.first, query.second, visited);</span><br><span class="line">            res.push_back((t &gt; <span class="number">0.0</span>) ? t : <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">helper</span><span class="params">(<span class="built_in">string</span> up, <span class="built_in">string</span> down, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m[up].count(down)) <span class="keyword">return</span> m[up][down];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : m[up]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.count(a.first)) <span class="keyword">continue</span>;</span><br><span class="line">            visited.insert(a.first);</span><br><span class="line">            <span class="keyword">double</span> t = helper(a.first, down, visited);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; <span class="number">0.0</span>) <span class="keyword">return</span> t * a.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt;&gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode400-Nth-Digit"><a href="#Leetcode400-Nth-Digit" class="headerlink" title="Leetcode400. Nth Digit"></a>Leetcode400. Nth Digit</h1><p>Given an integer n, return the nth digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …].</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: n = 11</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.</span><br></pre></td></tr></table></figure></p>
<p>自然数序列看成一个长字符串，问我们第N位上的数字是什么。那么这道题的关键就是要找出第N位所在的数字，然后可以把数字转为字符串，这样直接可以访问任何一位。那么我们首先来分析自然数序列和其位数的关系，前九个数都是1位的，然后10到99总共90个数字都是两位的，100到999这900个数都是三位的，那么这就很有规律了，我们可以定义个变量cnt，初始化为9，然后每次循环扩大10倍，再用一个变量len记录当前循环区间数字的位数，另外再需要一个变量start用来记录当前循环区间的第一个数字，我们n每次循环都减去len*cnt (区间总位数)，当n落到某一个确定的区间里了，那么(n-1)/len就是目标数字在该区间里的坐标，加上start就是得到了目标数字，然后我们将目标数字start转为字符串，(n-1)%len就是所要求的目标位，最后别忘了考虑int溢出问题，我们干脆把所有变量都申请为长整型的好了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> digit = <span class="number">1</span>, start = <span class="number">1</span>, count = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; count) &#123;</span><br><span class="line">            n -= count;</span><br><span class="line">            digit += <span class="number">1</span>;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            count = <span class="number">9</span> * digit * start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = start + (n - <span class="number">1</span>) / digit;</span><br><span class="line">        <span class="keyword">return</span> (to_string(num))[(n<span class="number">-1</span>)%digit] - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/05/Linux文件系统详解/" rel="next" title="Linux文件系统详解">
                <i class="fa fa-chevron-left"></i> Linux文件系统详解
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/05/几道海量数据有关的算法问题/" rel="prev" title="几道和「黑洞照片」那种海量数据有关的算法问题">
                几道和「黑洞照片」那种海量数据有关的算法问题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">249</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode354-Russian-Doll-Envelopes"><span class="nav-number">1.</span> <span class="nav-text">Leetcode354. Russian Doll Envelopes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode355-Design-Twitter"><span class="nav-number">2.</span> <span class="nav-text">Leetcode355. Design Twitter</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode357-Count-Numbers-with-Unique-Digits"><span class="nav-number">3.</span> <span class="nav-text">Leetcode357. Count Numbers with Unique Digits</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode359-Logger-Rate-Limiter"><span class="nav-number">4.</span> <span class="nav-text">Leetcode359. Logger Rate Limiter</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode367-Valid-Perfect-Square"><span class="nav-number">5.</span> <span class="nav-text">Leetcode367. Valid Perfect Square</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode368-Largest-Divisible-Subset"><span class="nav-number">6.</span> <span class="nav-text">Leetcode368. Largest Divisible Subset</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode371-Sum-of-Two-Integers"><span class="nav-number">7.</span> <span class="nav-text">Leetcode371. Sum of Two Integers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode372-Super-Pow"><span class="nav-number">8.</span> <span class="nav-text">Leetcode372. Super Pow</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode373-Find-K-Pairs-with-Smallest-Sums"><span class="nav-number">9.</span> <span class="nav-text">Leetcode373. Find K Pairs with Smallest Sums</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode374-Guess-Number-Higher-or-Lower"><span class="nav-number">10.</span> <span class="nav-text">Leetcode374. Guess Number Higher or Lower</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode375-Guess-Number-Higher-or-Lower-II"><span class="nav-number">11.</span> <span class="nav-text">Leetcode375. Guess Number Higher or Lower II</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#极小极大的定义"><span class="nav-number">11.1.</span> <span class="nav-text">极小极大的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#以TIC-TAC-TOE为例"><span class="nav-number">11.2.</span> <span class="nav-text">以TIC-TAC-TOE为例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Alpha-beta剪枝"><span class="nav-number">11.3.</span> <span class="nav-text">Alpha-beta剪枝</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode376-Wiggle-Subsequence"><span class="nav-number">12.</span> <span class="nav-text">Leetcode376. Wiggle Subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode377-Combination-Sum-IV"><span class="nav-number">13.</span> <span class="nav-text">Leetcode377. Combination Sum IV</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode378-Kth-Smallest-Element-in-a-Sorted-Matrix"><span class="nav-number">14.</span> <span class="nav-text">Leetcode378. Kth Smallest Element in a Sorted Matrix</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#二分思路"><span class="nav-number">14.1.</span> <span class="nav-text">二分思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算小于等于middle值的个数"><span class="nav-number">14.2.</span> <span class="nav-text">计算小于等于middle值的个数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode382-Linked-List-Random-Node"><span class="nav-number">15.</span> <span class="nav-text">Leetcode382. Linked List Random Node</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode383-Ransom-Note"><span class="nav-number">16.</span> <span class="nav-text">Leetcode383. Ransom Note</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode384-Shuffle-an-Array"><span class="nav-number">17.</span> <span class="nav-text">Leetcode384. Shuffle an Array</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#洗牌的正确姿势-Knuth-shuffle算法"><span class="nav-number">17.1.</span> <span class="nav-text">洗牌的正确姿势-Knuth shuffle算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Knuth洗牌算法"><span class="nav-number">17.1.1.</span> <span class="nav-text">Knuth洗牌算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode385-Mini-Parser"><span class="nav-number">18.</span> <span class="nav-text">Leetcode385. Mini Parser</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode386-Lexicographical-Numbers"><span class="nav-number">19.</span> <span class="nav-text">Leetcode386. Lexicographical Numbers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode387-First-Unique-Character-in-a-String"><span class="nav-number">20.</span> <span class="nav-text">Leetcode387. First Unique Character in a String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode389-Find-the-Difference"><span class="nav-number">21.</span> <span class="nav-text">Leetcode389. Find the Difference</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode392-Is-Subsequence"><span class="nav-number">22.</span> <span class="nav-text">Leetcode392. Is Subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode393-UTF-8-Validation"><span class="nav-number">23.</span> <span class="nav-text">Leetcode393. UTF-8 Validation</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode394-Decode-String"><span class="nav-number">24.</span> <span class="nav-text">Leetcode394. Decode String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode395-Longest-Substring-with-At-Least-K-Repeating-Characters"><span class="nav-number">25.</span> <span class="nav-text">Leetcode395. Longest Substring with At Least K Repeating Characters</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode397-Integer-Replacement"><span class="nav-number">26.</span> <span class="nav-text">Leetcode397. Integer Replacement</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode398-Random-Pick-Index"><span class="nav-number">27.</span> <span class="nav-text">Leetcode398. Random Pick Index</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode399-Evaluate-Division"><span class="nav-number">28.</span> <span class="nav-text">Leetcode399. Evaluate Division</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode400-Nth-Digit"><span class="nav-number">29.</span> <span class="nav-text">Leetcode400. Nth Digit</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
