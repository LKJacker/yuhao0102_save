<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Leetcode,">










<meta name="description" content="Leetcode1051. Height CheckerStudents are asked to stand in non-decreasing order of heights for an annual photo. Return the minimum number of students not standing in the right positions.  (This is the">
<meta name="keywords" content="Leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode1051 - 1100">
<meta property="og:url" content="http://yoursite.com/2019/05/27/Leetcode1051_1100/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Leetcode1051. Height CheckerStudents are asked to stand in non-decreasing order of heights for an annual photo. Return the minimum number of students not standing in the right positions.  (This is the">
<meta property="og:locale" content="zn-ch">
<meta property="og:updated_time" content="2022-01-29T07:25:40.958Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode1051 - 1100">
<meta name="twitter:description" content="Leetcode1051. Height CheckerStudents are asked to stand in non-decreasing order of heights for an annual photo. Return the minimum number of students not standing in the right positions.  (This is the">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/27/Leetcode1051_1100/">





  <title>Leetcode1051 - 1100 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/27/Leetcode1051_1100/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode1051 - 1100</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-27T10:30:00+08:00">
                2019-05-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Leetcode1051-Height-Checker"><a href="#Leetcode1051-Height-Checker" class="headerlink" title="Leetcode1051. Height Checker"></a>Leetcode1051. Height Checker</h1><p>Students are asked to stand in non-decreasing order of heights for an annual photo.</p>
<p>Return the minimum number of students not standing in the right positions.  (This is the number of students that must move in order for all students to be standing in non-decreasing order of height.)</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,4,2,1,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Explanation:<br>Students with heights 4, 3 and the last 1 are not standing in the right positions.</p>
<p>Note:</p>
<ul>
<li>1 &lt;= heights.length &lt;= 100</li>
<li>1 &lt;= heights[i] &lt;= 100</li>
</ul>
<p>看上去比较简单的题，找到没有按照顺序排列的数，想用一种不需要排序的方法来做，但是失败了，因为如果其他数字有序，只有一个无序，是要移动很多的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*int heightChecker(vector&lt;int&gt;&amp; heights) &#123;</span></span><br><span class="line"><span class="comment">        int res=0;</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;heights.size()-1;i++)&#123;</span></span><br><span class="line"><span class="comment">            if(!(heights[i]&gt;=heights[i-1] &amp;&amp; heights[i]&lt;=heights[i+1]))</span></span><br><span class="line"><span class="comment">                res++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return res;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">heightChecker</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s = h;</span><br><span class="line">        sort(begin(s), end(s));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; h.size(); ++i) </span><br><span class="line">            res += h[i] != s[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1052-Grumpy-Bookstore-Owner"><a href="#Leetcode1052-Grumpy-Bookstore-Owner" class="headerlink" title="Leetcode1052. Grumpy Bookstore Owner"></a>Leetcode1052. Grumpy Bookstore Owner</h1><p>Today, the bookstore owner has a store open for customers.length minutes. Every minute, some number of customers (customers[i]) enter the store, and all those customers leave after the end of that minute.</p>
<p>On some minutes, the bookstore owner is grumpy. If the bookstore owner is grumpy on the i-th minute, grumpy[i] = 1, otherwise grumpy[i] = 0. When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise they are satisfied.</p>
<p>The bookstore owner knows a secret technique to keep themselves not grumpy for X minutes straight, but can only use it once.</p>
<p>Return the maximum number of customers that can be satisfied throughout the day.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3</span><br><span class="line">Output: 16</span><br><span class="line">Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. </span><br><span class="line">The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= X &lt;= customers.length == grumpy.length &lt;= 20000</li>
<li>0 &lt;= customers[i] &lt;= 1000</li>
<li>0 &lt;= grumpy[i] &lt;= 1</li>
</ul>
<p>滑动窗口. 统计在大小为 X 的窗口中, 有多少顾客刚好处在店主脾气不好的时刻, 即<code>grumpy[i] == 1</code>。其中<code>grumpy[i] == 0</code>对应的顾客始终是满意的, 使用 base 来统计. 而对于那些<code>grumpy[i] == 1</code>的顾客, 只有在他们刚好在滑动窗口中, 才能满意, 用 new_satisfied 统计在滑动窗口中新满意的顾客, 在窗口滑动过程中使用 max_satisfied 来记录最大值. 最后返回 base + max_satisfied.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSatisfied</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; customers, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; grumpy, <span class="keyword">int</span> minutes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, len = grumpy.size();</span><br><span class="line">        <span class="keyword">int</span> sat = <span class="number">0</span>, new_sat = <span class="number">0</span>, max_sat = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grumpy[i] == <span class="number">0</span>)</span><br><span class="line">                sat += customers[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                new_sat += customers[i];</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= minutes)</span><br><span class="line">                new_sat -= (customers[i-minutes] * grumpy[i-minutes]);</span><br><span class="line">            max_sat = max(max_sat, new_sat);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sat + max_sat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1053-Previous-Permutation-With-One-Swap"><a href="#Leetcode1053-Previous-Permutation-With-One-Swap" class="headerlink" title="Leetcode1053. Previous Permutation With One Swap"></a>Leetcode1053. Previous Permutation With One Swap</h1><p>Given an array of positive integers arr (not necessarily distinct), return  the lexicographically largest permutation that is smaller than  arr, that can be made with exactly one swap (A  swap  exchanges the positions of two numbers arr[i] and arr[j]). If it cannot be done, then return the same array.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [3,2,1]</span><br><span class="line">Output: [3,1,2]</span><br><span class="line">Explanation: Swapping 2 and 1.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,1,5]</span><br><span class="line">Output: [1,1,5]</span><br><span class="line">Explanation: This is already the smallest permutation.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,9,4,6,7]</span><br><span class="line">Output: [1,7,4,6,9]</span><br><span class="line">Explanation: Swapping 9 and 7.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [3,1,1,3]</span><br><span class="line">Output: [1,3,1,3]</span><br><span class="line">Explanation: Swapping 1 and 3.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= arr.length &lt;= 104</li>
<li>1 &lt;= arr[i] &lt;= 104</li>
</ul>
<p>这道题给了一个正整数的数组，说是让任意交换两个数字，使得变成字母顺序最大的一种全排列，但是需要小于原先的排列，若无法得到这样的全排列（说明当前已经是最小的全排列），则返回原数组。通过分析题目中给的例子不难理解题意，根据例子2来看，若给定的数组就是升序排列的，则无法得到更小的全排列，说明只有遇到降序的位置的时候，才有可能进行交换。但是假如有多个可以下降的地方呢，比如例子1，3到2下降，2到1下降，这里是需要交换2和1的，所以最好是从后往前检验，遇到前一个数字比当前数字大的情况时，前一个数字必定是交换方之一，而当前数字并不是。比如例子3，数字4的前面是9，正确结果是9和7交换，所以还要从4往后遍历一下，找到一个仅次于9的数字交换才行，而且数字相同的话，取坐标较小的那个，比如例子4就是这种情况。</p>
<p>首先从后往前遍历，假如当前数字大于等于前一个数字，直接跳过，否则说明需要交换的。从当前位置再向后遍历一遍，找到第一个仅次于拐点的数字交换即可，注意下面的代码虽然嵌套了两个 for 循环，其实是线性的时间复杂度，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prevPermOpt1(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size(), mx = <span class="number">0</span>, idx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt;= arr[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[i - <span class="number">1</span>] &amp;&amp; mx &lt; arr[j]) &#123;</span><br><span class="line">                    mx = arr[j];</span><br><span class="line">                    idx = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr[i - <span class="number">1</span>], arr[idx]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1054-Distant-Barcodes"><a href="#Leetcode1054-Distant-Barcodes" class="headerlink" title="Leetcode1054. Distant Barcodes"></a>Leetcode1054. Distant Barcodes</h1><p>In a warehouse, there is a row of barcodes, where the ith barcode is barcodes[i].</p>
<p>Rearrange the barcodes so that no two adjacent barcodes are equal. You may return any answer, and it is guaranteed an answer exists.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: barcodes = [1,1,1,2,2,2]</span><br><span class="line">Output: [2,1,2,1,2,1]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: barcodes = [1,1,1,1,2,2,3,3]</span><br><span class="line">Output: [1,3,1,3,1,2,1,2]</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= barcodes.length &lt;= 10000</li>
<li>1 &lt;= barcodes[i] &lt;= 10000</li>
</ul>
<p>这道题说在一个仓库，有一排条形码，这里用数字表示，现在让给数字重新排序，使得相邻的数字不相同，并且说了一定会有合理的答案。意思就是说最多的重复个数不会超过数组长度的一半，否则一定会有相邻的重复数字。那么来分析一下题目，既然是为了避免重复数字被排在相邻的位置，肯定是要优先关注出现次数多的数字，因为它们更有可能出现在相邻的位置。这道题是可以用贪婪算法来做的，每次取出出现次数最多的两个数字，将其先排列起来，然后再取下一对出现次数最多的两个数字，以此类推直至排完整个数组。这里为了快速知道出现次数最多的数字，可以使用优先队列来做，里面放一个 pair 对儿，由频率和数字组成，这样优先队列就可以根据频率由高到低来自动排序了。统计频率的话就使用一个 HashMap，然后将频率和数字组成的 pair 对儿加入优先队列。进行 while 循环，条件是队列中的 pair 对儿至少两个，这样才能每次取出两个，将其加入结果 res 中，然后其频率分别减1，只要没减到0，就都加回优先队列中。最后可能队列还有一个剩余，有的话将数字加入结果 res 中即可，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rearrangeBarcodes(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; barcodes) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; numCnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : barcodes) ++numCnt[num];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : numCnt) &#123;</span><br><span class="line">            pq.push(&#123;a.second, a.first&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> a = pq.top(); pq.pop();</span><br><span class="line">            <span class="keyword">auto</span> b = pq.top(); pq.pop();</span><br><span class="line">            res.push_back(a.second);</span><br><span class="line">            res.push_back(b.second);</span><br><span class="line">            <span class="keyword">if</span> (--a.first &gt; <span class="number">0</span>) pq.push(a);</span><br><span class="line">            <span class="keyword">if</span> (--b.first &gt; <span class="number">0</span>) pq.push(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!pq.empty()) </span><br><span class="line">            res.push_back(pq.top().second);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>论坛上的高分解法貌似没有用到优先队列，不过整个思路还是大体相同的，还是用 HashMap 来统计频率，这里将组成的频率和数字的 pair 对儿放到一个数组中，然后给数组按照从大到小的顺序来排列。接下里就要填充 res 数组了，方法是先填偶数坐标的位置，将频率最大的数字分别填进去，当偶数坐标填完了之后，再填奇数坐标的位置，这样保证不会有相连的重复数字。使用一个变量 pos，表示当前要填的坐标，初始化为0，之后来遍历这个频率和数字的 pair 对儿，从高到低，先填充所有偶数，若 pos 大于数组长度了，则切换为填充奇数即可，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rearrangeBarcodes(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; barcodes) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = barcodes.size(), pos = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; numCnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : barcodes) ++numCnt[num];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : numCnt) &#123;</span><br><span class="line">            vec.push_back(&#123;a.second, a.first&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(vec.rbegin(), vec.rend());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : vec) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.first; ++i, pos += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pos &gt;= n) pos = <span class="number">1</span>;</span><br><span class="line">                res[pos] = a.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1055-Shortest-Way-to-Form-String"><a href="#Leetcode1055-Shortest-Way-to-Form-String" class="headerlink" title="Leetcode1055. Shortest Way to Form String"></a>Leetcode1055. Shortest Way to Form String</h1><p>From any string, we can form a  subsequence  of that string by deleting some number of characters (possibly no deletions).</p>
<p>Given two strings source and target, return the minimum number of subsequences of source such that their concatenation equals target. If the task is impossible, return -1.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: source = &quot;abc&quot;, target = &quot;abcbc&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The target &quot;abcbc&quot; can be formed by &quot;abc&quot; and &quot;bc&quot;, which are subsequences of source &quot;abc&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: source = &quot;abc&quot;, target = &quot;acdbc&quot;</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: The target string cannot be constructed from the subsequences of source string due to the character &quot;d&quot; in target string.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: source = &quot;xyz&quot;, target = &quot;xzyxz&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The target string can be constructed as follows &quot;xz&quot; + &quot;y&quot; + &quot;xz&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>Both the source and target strings consist of only lowercase English letters from “a”-“z”.</li>
<li>The lengths of source and target string are between 1 and 1000.</li>
</ul>
<p>这道题说我们可以通过删除某些位置上的字母从而形成一个新的字符串，现在给了两个字符串 source 和 target，问最少需要删除多个字母，可以把 source 字母串拼接成为 target。注意这里的 target 字符串可能会远长于 source，所以需要多个 source 字符串 concatenate 到一起，然后再进行删除字母。对于 target 中的每个字母，都需要在 source 中匹配到，所以最外层循环肯定是遍历 target 中的每个字母，可以使用一个指针j，初始化赋值为0，接下来就要在 source 中匹配这个 target[j]，所以需要遍历一下 source 字符串，如果匹配上了 target[j]，则j自增1，继续匹配下一个，当循环退出后，此时有一种情况需要考虑，就是对于这个 target[j] 字母，整个 source 字符串都无法匹配，说明 target 中存在 source 中没有的字母，这种情况下是要返回 -1 的，如何判定这种情况呢？当然可以在最开始把 source 中所有的字母放到一个 HashSet 中，然后对于 target 中每个字母都检测看是否在集合中。但这里可以使用更简便的方法，就是在遍历 source 之前，用另一个变量 pre 记录当前j的位置，然后当遍历完 source 之后，若j没有变化，则说明有其他字母存在，直接返回 -1 即可，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestWay</span><span class="params">(<span class="built_in">string</span> source, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, j = <span class="number">0</span>, m = source.size(), n = target.size();</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> pre = j;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; n &amp;&amp; source[i] == target[j]) ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == pre) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面这种方法思路和上面基本一样，就是没有直接去遍历 source 数组，而是使用了 STL 的 find 函数。开始还是要遍历 target 字符串，对于每个字母，首先在 source 中调用 find 函数查找一下，假如找不到，直接返回 -1。有的话，就从 pos+1 位置开始再次查找该字母，且其位置赋值为 pos，注意这里 pos+1 的原因是因为其初始化为了 -1，需要从0开始找，或者 pos 已经赋值为上一个匹配位置了，所以要从下一个位置开始查找。假如 pos 为 -1 了，说明当前剩余字母中无法匹配了，需要新的一轮循环，此时将 res 自增1，并将 pos 赋值为新的 source 串中的第一个匹配位置，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestWay</span><span class="params">(<span class="built_in">string</span> source, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>, pos = <span class="number">-1</span>, n = target.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (source.find(target[i]) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            pos = source.find(target[i], pos + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">                pos = source.find(target[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1056-Confusing-Number"><a href="#Leetcode1056-Confusing-Number" class="headerlink" title="Leetcode1056. Confusing Number"></a>Leetcode1056. Confusing Number</h1><p>Given a number N, return true if and only if it is a  confusing number , which satisfies the following condition:</p>
<p>We can rotate digits by 180 degrees to form new digits. When 0, 1, 6, 8, 9 are rotated 180 degrees, they become 0, 1, 9, 8, 6 respectively. When 2, 3, 4, 5 and 7 are rotated 180 degrees, they become invalid. A  confusing number  is a number that when rotated 180 degrees becomes a different number with each digit valid.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 6</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">We get `9` after rotating `6`, `9` is a valid number and `9!=6`.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 89</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">We get `68` after rotating `89`, `86` is a valid number and `86!=89`.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 11</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">We get `11` after rotating `11`, `11` is a valid number but the value remains the same, thus `11` is not a confusing number.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 25</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">We get an invalid number after rotating `25`.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>0 &lt;= N &lt;= 10^9</li>
<li>After the rotation we can ignore leading zeros, for example if after rotation we have 0008 then this number is considered as just 8.</li>
</ul>
<p>这道题定义了一种迷惑数，将数字翻转 180 度，其中 0, 1, 8 旋转后保持不变，6变成9，9变成6，数字 2, 3, 4, 5, 和 7 旋转后变为非法数字。若能将某个数翻转后成为一个合法的新的数，就说这个数是迷惑数。这道题的难度并不大，就是考察的是遍历整数各个位上的数字，使用一个 while 循环，然后用 mod10 取出当前最低位上的数字，将不合法的数字放入一个 HashSet 中，这样直接在 HashSet 中查找一下当前数字是否存在，存在直接返回 false。不存在的话，则要进行翻转，因为只有6和9两个数字翻转后会得到不同的数字，所以单独判断一下，然后将当前数字拼到 num 的最低位即可，最终拼成的 num 就是原数字 N 的翻转，最后别忘了比较一下是否相同，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">confusingNumber</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>, oldN = N;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; invalid&#123;&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = N % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (invalid.count(digit)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (digit == <span class="number">6</span>) digit = <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (digit == <span class="number">9</span>) digit = <span class="number">6</span>;</span><br><span class="line">            num = num * <span class="number">10</span> + digit;</span><br><span class="line">            N /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num != oldN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这也可以用一个 HashMap 来建立所有的数字映射，然后还是用一个变量 oldN 来记录原来的数字，然后遍历N上的每一位数字，若其不在 HashMap 中，说明有数字无法翻转，直接返回 false，否则就把翻转后的数字加入 res，最后只要看 res 和 oldN 是否相等即可，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">confusingNumber</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m&#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">6</span>, <span class="number">9</span>&#125;, &#123;<span class="number">8</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">long</span> oldN = N, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!m.count(N % <span class="number">10</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + m[N % <span class="number">10</span>];</span><br><span class="line">            N /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res != oldN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面来看一种双指针的解法，这里先用一个数组 rotate 来按位记录每个数字翻转后得到的数字，用 -1 来表示非法情况，然后将数字 N 转为字符串，用两个指针 left 和 right 分别指向开头和末尾。用 while 循环进行遍历，假如此时 left 和 right 中有任何一个指向的数字翻转后是非法，直接返回 false。然后看 left 指向的数字翻转后跟 right 指向的数字是否相同，若不同，则将 res 标记为 true，然后移动 left 和 right 指针，最终返回 res 即可，参见代码如下：</p>
<p>解法三：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">confusingNumber</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotate&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">9</span>, <span class="number">-1</span>, <span class="number">8</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> str = to_string(N);</span><br><span class="line">        <span class="keyword">int</span> n = str.size(), left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rotate[str[left] - <span class="string">'0'</span>] == <span class="number">-1</span> || rotate[str[right] - <span class="string">'0'</span>] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (rotate[str[left] - <span class="string">'0'</span>] != (str[right] - <span class="string">'0'</span>)) res = <span class="literal">true</span>;</span><br><span class="line">            ++left; --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1057-Campus-Bikes"><a href="#Leetcode1057-Campus-Bikes" class="headerlink" title="Leetcode1057. Campus Bikes"></a>Leetcode1057. Campus Bikes</h1><p>On a campus represented as a 2D grid, there are N workers and M bikes, with N &lt;= M. Each worker and bike is a 2D coordinate on this grid.</p>
<p>Our goal is to assign a bike to each worker. Among the available bikes and workers, we choose the (worker, bike) pair with the shortest Manhattan distance between each other, and assign the bike to that worker. (If there are multiple (worker, bike) pairs with the same shortest Manhattan distance, we choose the pair with the smallest worker index; if there are multiple ways to do that, we choose the pair with the smallest bike index). We repeat this process until there are no available workers.</p>
<p>The Manhattan distance between two points p1 and p2 is Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|.</p>
<p>Return a vector ans of length N, where ans[i] is the index (0-indexed) of the bike that the i-th worker is assigned to.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: workers = [[0,0],[2,1]], bikes = [[1,2],[3,3]]</span><br><span class="line">Output: [1,0]</span><br><span class="line">Explanation:</span><br><span class="line">Worker 1 grabs Bike 0 as they are closest (without ties), and Worker 0 is assigned Bike 1. So the output is [1, 0].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: workers = [[0,0],[1,1],[2,0]], bikes = [[1,0],[2,2],[2,1]]</span><br><span class="line">Output: [0,2,1]</span><br><span class="line">Explanation:</span><br><span class="line">Worker 0 grabs Bike 0 at first. Worker 1 and Worker 2 share the same distance to Bike 2, thus Worker 1 is assigned to Bike 2, and Worker 2 will take Bike 1. So the output is [0,2,1].</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>0 &lt;= workers[i][j], bikes[i][j] &lt; 1000</li>
<li>All worker and bike locations are distinct.</li>
<li>1 &lt;= workers.length &lt;= bikes.length &lt;= 1000</li>
</ul>
<p>这道题用一个二维数组来表示一个校园坐标，上面有一些人和共享单车，人的数量不多余单车的数量，现在要让每一个人都分配一辆单车，人和单车的距离是用曼哈顿距离表示的。这里的分配方法其实是有一些 confuse 的，并不是每个人要拿离其距离最近的单车，也不是每辆单车要分配给距离其最近的人，而是要从所有的 单车-人 对儿中先挑出距离最短的一对儿，然后再挑出距离第二短的组合，以此类推，直到所有的人都被分配到单车了为止。这样的话就需要求出每一对人车距离，将所有的人车距离，和对应的人和车的标号都存到一个二维数组中。然后对这个二维数组进行排序，这里需要重写排序规则，将人车距离小的排前面，假如距离相等，则将人标号小的放前面，假如人的标号也相同，则就将车标号小的放前面。对人车距离数组排好序之后，此时需要两个数组来分别标记每个人被分配的车标号，和每个车的主人标号。现在从最小的人车距离开始取，若此时的人和车都没有分配，则进行分配，遍历完所有的人车距离之后，最终的结果就存在了标记每个人分配的车标号的数组中，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; assignBikes(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; workers, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; bikes) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = workers.size(), n = bikes.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; assignedWorker(m, <span class="number">-1</span>), assignedBike(n, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dist;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> d = <span class="built_in">abs</span>(workers[i][<span class="number">0</span>] - bikes[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(workers[i][<span class="number">1</span>] - bikes[j][<span class="number">1</span>]);</span><br><span class="line">                dist.push_back(&#123;d, i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(dist.begin(), dist.end(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b) &#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>] || (a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]) || (a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] == b[<span class="number">1</span>] &amp;&amp; a[<span class="number">2</span>] &lt; b[<span class="number">2</span>]);</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : dist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (assignedWorker[a[<span class="number">1</span>]] == <span class="number">-1</span> &amp;&amp; assignedBike[a[<span class="number">2</span>]] == <span class="number">-1</span>) &#123;</span><br><span class="line">                assignedWorker[a[<span class="number">1</span>]] = a[<span class="number">2</span>];</span><br><span class="line">                assignedBike[a[<span class="number">2</span>]] = a[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> assignedWorker;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面的解法虽然可以通过 OJ，但是并不是很高效，应该是排序的部分拖慢了速度。其实这道题的范围是有限的，因为车和人的坐标是有限的，最大的人车距离也不会超过 2000，那么利用桶排序来做就是个不错的选择，只需要 2001 个桶就行了，桶中放的是 pair 对儿，其中　buckets[i] 表示距离是i的人和车的标号组成的 pair 对儿。这样当计算出每个人车距离后，将其放入对应的桶中即可，就自动排好了序。然后开始遍历每个桶，由于每个桶中可能不止放了一个 pair 对儿，所以需要遍历每个桶中所有的组合，然后的操作就和上面的相同了，若此时的人和车都没有分配，则进行分配，遍历完所有的人车距离之后，最终的结果就存在了标记每个人分配的车标号的数组中，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; assignBikes(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; workers, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; bikes) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = workers.size(), n = bikes.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; assignedWorker(m, <span class="number">-1</span>), assignedBike(n, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; buckets(<span class="number">2001</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> dist = <span class="built_in">abs</span>(workers[i][<span class="number">0</span>] - bikes[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(workers[i][<span class="number">1</span>] - bikes[j][<span class="number">1</span>]);</span><br><span class="line">                buckets[dist].push_back(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dist = <span class="number">0</span>; dist &lt;= <span class="number">2000</span>; ++dist) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; buckets[dist].size(); ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (assignedWorker[buckets[dist][k].first] == <span class="number">-1</span> &amp;&amp; assignedBike[buckets[dist][k].second] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    assignedWorker[buckets[dist][k].first] = buckets[dist][k].second;</span><br><span class="line">                    assignedBike[buckets[dist][k].second] = buckets[dist][k].first;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> assignedWorker;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1058-Minimize-Rounding-Error-to-Meet-Target"><a href="#Leetcode1058-Minimize-Rounding-Error-to-Meet-Target" class="headerlink" title="Leetcode1058. Minimize Rounding Error to Meet Target"></a>Leetcode1058. Minimize Rounding Error to Meet Target</h1><p>Given an array of prices <code>[p1,p2…,pn]</code> and a target, round each price pi to Roundi(pi) so that the rounded array <code>[Round1(p1),Round2(p2)…,Roundn(pn)]</code> sums to the given target. Each operation Roundi(pi) could be either Floor(pi) or Ceil(pi).</p>
<p>Return the string “-1” if the rounded array is impossible to sum to target. Otherwise, return the smallest rounding error, which is defined as Σ |Roundi(pi) - (pi)| for i from 1 to n, as a string with three places after the decimal.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices = [“0.700”,”2.800”,”4.900”], target = 8</span><br><span class="line">Output: “1.000”</span><br><span class="line">Explanation: </span><br><span class="line">Use Floor, Ceil and Ceil operations to get (0.7 - 0) + (3 - 2.8) + (5 - 4.9) = 0.7 + 0.2 + 0.1 = 1.0 .</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: prices = [“1.500”,”2.500”,”3.500”], target = 10</span><br><span class="line">Output: “-1”</span><br><span class="line">Explanation: </span><br><span class="line">It is impossible to meet the target.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= prices.length &lt;= 500.</li>
<li>Each string of prices prices[i] represents a real number which is between 0 and 1000 and has exactly 3 decimal places.<br>target is between 0 and 1000000.</li>
</ul>
<p>如果一个数字是一个整数， 那么我们只能取floor，不能取ceil。这相当于一个无法调整的数字，否则就是一个可调整的数字。我们把所有可调整的数字的小数部分放入一个priority queue中，把priority queue的size记为pqsize。</p>
<p>然后我们先判断什么情况下无法得到target：</p>
<ul>
<li>如果取最小的可能的和，那么所有数字都要取floor。如果这个和仍然比target大，或者比target-pqsize小，那么就说明无论如何也不可能得到target。这样我们就返回 “-1”</li>
<li>若满足上述条件，我们一定可以取到满足题目条件的和。我们需要知道调整多少个数字，即把floor操作变成ceil操作。需要调整的数字个数等于target-pqsize。</li>
<li>为了的达到最小的rounding error，对于每个调整的操作，我们希望它们小数尽可能大，这可以由之前的priority queue得到。取那个数字的ceil。最后把所有不需要调整的小数也加上，就是最小的rounding error了。</li>
<li>注意最后返回字符串是，需要做些特殊处理，只保留最后3位小数即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minimizeError</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; prices, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">double</span>&gt; pq;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> price : prices) &#123;</span><br><span class="line">            sum += <span class="built_in">floor</span>(stod(price));</span><br><span class="line">            <span class="keyword">double</span> diffPrice = stod(price) - <span class="built_in">floor</span>(stod(price));</span><br><span class="line">            <span class="keyword">if</span> (diffPrice != <span class="number">0</span>) &#123;</span><br><span class="line">                pq.push(diffPrice);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target || sum &lt; target - pq.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"-1"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> diff = target - sum;</span><br><span class="line">        <span class="keyword">double</span> error = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">            <span class="keyword">double</span> fl = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            error += diff &gt; <span class="number">0</span> ? <span class="number">1</span> - fl : fl;</span><br><span class="line">            diff--;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="built_in">string</span> ans = to_string(error);</span><br><span class="line">        <span class="keyword">return</span> ans.substr(<span class="number">0</span>, ans.find(<span class="string">'.'</span>) + <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1059-从始点到终点的所有路径"><a href="#Leetcode1059-从始点到终点的所有路径" class="headerlink" title="Leetcode1059. 从始点到终点的所有路径"></a>Leetcode1059. 从始点到终点的所有路径</h1><p>给定有向图的边 edges，以及该图的始点 source 和目标终点 destination，确定从始点 source 出发的所有路径是否最终结束于目标终点 destination，即：</p>
<ul>
<li>从始点 source 到目标终点 destination 存在至少一条路径</li>
<li>如果存在从始点 source 到没有出边的节点的路径，则该节点就是路径终点。</li>
<li>从始点source到目标终点 destination 可能路径数是有限数字</li>
<li>当从始点 source 出发的所有路径都可以到达目标终点 destination 时返回 true，否则返回 false。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, edges = [[0,1],[0,2]], source = 0, destination = 2</span><br><span class="line">输出：false</span><br><span class="line">说明：节点 1 和节点 2 都可以到达，但也会卡在那里。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, edges = [[0,1],[0,3],[1,2],[2,1]], source = 0, destination = 3</span><br><span class="line">输出：false</span><br><span class="line">说明：有两种可能：在节点 3 处结束，或是在节点 1 和节点 2 之间无限循环。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, edges = [[0,1],[0,2],[1,3],[2,3]], source = 0, destination = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>简单dfs，搜索时不能搜索到非end的断头路或者有end在中间的路。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">leadToDestination</span><span class="params">(<span class="keyword">int</span> n,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edge,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m(m);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(n,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e:edge)&#123;</span><br><span class="line">            m[e[<span class="number">0</span>]].push_back(e[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!m[end].empty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DFS(m,visited,start,end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; m,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visitd,<span class="keyword">int</span> cur,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!m[cur].size()==<span class="number">0</span>&amp;&amp;cur!=end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> next:m[cur])&#123;</span><br><span class="line">            <span class="keyword">if</span>(visitd[next])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visitd[next]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(!DFS(m,visitd,cur,end))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visitd[next]=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1060-Missing-Element-in-Sorted-Array"><a href="#Leetcode1060-Missing-Element-in-Sorted-Array" class="headerlink" title="Leetcode1060. Missing Element in Sorted Array"></a>Leetcode1060. Missing Element in Sorted Array</h1><p>Given a sorted array A of unique numbers, find the K-th missing number starting from the leftmost number of the array.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [4,7,9,10], K = 1</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: </span><br><span class="line">The first missing number is 5.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [4,7,9,10], K = 3</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: </span><br><span class="line">The missing numbers are [5,6,8,...], hence the third missing number is 8.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2,4], K = 3</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: </span><br><span class="line">The missing numbers are [3,5,6,7,...], hence the third missing number is 6.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 50000</li>
<li>1 &lt;= A[i] &lt;= 1e7</li>
<li>1 &lt;= K &lt;= 1e8</li>
</ul>
<p>给出一个有序数组 A，数组中的每个数字都是 独一无二的，找出从数组最左边开始的第 K 个缺失数字。</p>
<p>拿到这个题之后，看了下Note中取值范围都比较大，因此如果想一个数字一个数字去判断的话肯定会超时。所以需要使用一个点小技巧，即跳过不需要判断的数字。直接计算出每两个相邻数字之间能满足多少个，从而更新k。</p>
<p>先对<code>nums</code>排序。然后开始遍历，计算<code>nums</code>相邻两个元素之间的数字数即<code>nums[i] - pre - 1</code>个，是否可以满足需要的k。如果能满足，那么直接找出要返回的数字<code>pre+k</code>。如果不能满足，把k去掉已能满足的数字<code>nums[i] - pre - 1</code>。最后如果所有的<code>nums</code>数字都已经用完，但是还不能满足k，则需要返回<code>nums[nums.size() - 1] + k</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &lt; nums[i] - pre) &#123;</span><br><span class="line">                <span class="keyword">return</span> pre + k;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= nums[i] - pre - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre + k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1061-按字典序排列最小的等效字符串"><a href="#Leetcode1061-按字典序排列最小的等效字符串" class="headerlink" title="Leetcode1061. 按字典序排列最小的等效字符串"></a>Leetcode1061. 按字典序排列最小的等效字符串</h1><p>给出长度相同的两个字符串：A 和 B，其中 A[i] 和 B[i] 是一组等价字符。举个例子，如果 A = “abc” 且 B = “cde”，那么就有 ‘a’ == ‘c’, ‘b’ == ‘d’, ‘c’ == ‘e’。</p>
<p>等价字符遵循任何等价关系的一般规则：</p>
<ul>
<li>自反性：’a’ == ‘a’</li>
<li>对称性：’a’ == ‘b’ 则必定有 ‘b’ == ‘a’</li>
<li>传递性：’a’ == ‘b’ 且 ‘b’ == ‘c’ 就表明 ‘a’ == ‘c’</li>
</ul>
<p>例如，A 和 B 的等价信息和之前的例子一样，那么 S = “eed”, “acd” 或 “aab”，这三个字符串都是等价的，而 “aab” 是 S 的按字典序最小的等价字符串。利用 A 和 B 的等价信息，找出并返回 S 的按字典序排列最小的等价字符串。</p>
<p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：A = &quot;parker&quot;, B = &quot;morris&quot;, S = &quot;parser&quot;</span><br><span class="line">输出：&quot;makkek&quot;</span><br><span class="line">解释：根据 A 和 B 中的等价信息，</span><br><span class="line">我们可以将这些字符分为 [m,p], [a,o], [k,r,s], [e,i] 共 4 组。</span><br><span class="line">每组中的字符都是等价的，并按字典序排列。所以答案是 &quot;makkek&quot;。</span><br></pre></td></tr></table></figure></p>
<p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：A = &quot;hello&quot;, B = &quot;world&quot;, S = &quot;hold&quot;</span><br><span class="line">输出：&quot;hdld&quot;</span><br><span class="line">解释：根据 A 和 B 中的等价信息，</span><br><span class="line">我们可以将这些字符分为 [h,w], [d,e,o], [l,r] 共 3 组。</span><br><span class="line">所以只有 S 中的第二个字符 &apos;o&apos; 变成 &apos;d&apos;，最后答案为 &quot;hdld&quot;。</span><br></pre></td></tr></table></figure></p>
<p>示例 3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：A = &quot;leetcode&quot;, B = &quot;programs&quot;, S = &quot;sourcecode&quot;</span><br><span class="line">输出：&quot;aauaaaaada&quot;</span><br><span class="line">解释：我们可以把 A 和 B 中的等价字符分为 </span><br><span class="line">[a,o,e,r,s,c], [l,p], [g,t] 和 [d,m] 共 4 组，</span><br><span class="line">因此 S 中除了 &apos;u&apos; 和 &apos;d&apos; 之外的所有字母都转化成了 &apos;a&apos;，最后答案为 &quot;aauaaaaada&quot;。</span><br></pre></td></tr></table></figure></p>
<p>并查集merge的时候，让祖先字符更小的作为代表<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dsu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; f;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	dsu(<span class="keyword">int</span> n)</span><br><span class="line">	&#123;</span><br><span class="line">		f.resize(n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">			f[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> fa = find(a), fb = find(b);</span><br><span class="line">        <span class="keyword">if</span>(fa &gt; fb)<span class="comment">//字母小的当代表，关键点</span></span><br><span class="line">		    f[fa] = fb;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f[fb] = fa;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> origin = a;</span><br><span class="line">		<span class="keyword">while</span>(a != f[a])</span><br><span class="line">			a = f[a];</span><br><span class="line">		<span class="keyword">return</span> f[origin] = a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestEquivalentString</span><span class="params">(<span class="built_in">string</span> A, <span class="built_in">string</span> B, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">    	<span class="function">dsu <span class="title">u</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i)</span><br><span class="line">    		u.merge(A[i]-<span class="string">'a'</span>, B[i]-<span class="string">'a'</span>);</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.size(); ++i)</span><br><span class="line">    		S[i] = u.find(S[i]-<span class="string">'a'</span>)+<span class="string">'a'</span>;</span><br><span class="line">    	<span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1062-Longest-Repeating-Substring"><a href="#Leetcode1062-Longest-Repeating-Substring" class="headerlink" title="Leetcode1062. Longest Repeating Substring"></a>Leetcode1062. Longest Repeating Substring</h1><p>Given a string S, find out the length of the longest repeating substring(s). Return 0 if no repeating substring exists.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: “abcd”</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: There is no repeating substring.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: “abbaba”</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The longest repeating substrings are “ab” and “ba”, each of which occurs twice.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: “aabcaabdaab”</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest repeating substring is “aab”, which occurs 3 times.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: “aaaaa”</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest repeating substring is “aaaa”, which occurs twice.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>The string S consists of only lowercase English letters from ‘a’ - ‘z’.</li>
<li>1 &lt;= S.length &lt;= 1500</li>
</ul>
<p>解题思路：这题我们采用动态规划的方法。我们先定义<code>dp[i][j]</code>为分别以第i个字符和第j个字符结尾的<code>substring</code>有相同共同后缀的最大长度。因此，我们也要求i&gt;j。我们注意到，当<code>S[i] != S[j]</code>，那么<code>dp[i][j] = 0</code>，否则<code>dp[i][j] = dp[i-1][j-1] + 1</code>。这就是我们的状态转移方程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i-1][j-1] + 1 ----------- S[i] == S[j]</span><br><span class="line">dp[i][j] = 0 -------------------------- S[i] != S[j]</span><br></pre></td></tr></table></figure></p>
<p>我们更新<code>dp[i][j]</code>的最大值，就可以得到最后的答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestRepeatingSubstring</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(S.size() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(S.size() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">1</span>; i &lt;= S.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (S[i<span class="number">-1</span>] == S[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = max(ans, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析</p>
<ul>
<li>N是字符串的长度。</li>
<li>时间复杂度: O(N^2)</li>
<li>空间复杂度: O(N^2)</li>
</ul>
<h1 id="Leetcode-1064-Fixed-Point"><a href="#Leetcode-1064-Fixed-Point" class="headerlink" title="Leetcode 1064. Fixed Point"></a>Leetcode 1064. Fixed Point</h1><p>Given an array A of distinct integers sorted in ascending order, return the smallest index i that satisfies A[i] == i.  Return -1 if no such i exists.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [-10,-5,0,3,7]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">For the given array, A[0] = -10, A[1] = -5, A[2] = 0, A[3] = 3, thus the output is 3.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,2,5,8,17]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: </span><br><span class="line">A[0] = 0, thus the output is 0.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [-10,-5,3,4,7,9]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: </span><br><span class="line">There is no such i that A[i] = i, thus the output is -1.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt; 10^4</li>
<li>-10^9 &lt;= A[i] &lt;= 10^9</li>
</ul>
<p>因为给出的是一个排序的array，而index也是自然从0到n-1的排序数组，因此本题采用二分法来查找<code>A[i] == i</code>的index。当<code>i &lt; A[i]</code>，我们往左边查找，当<code>i &gt;= A[i]</code>时， 我们往右边查找。需要注意的因为要求最小的index，我们更新右端点时，需要<code>i &gt;= A[i]</code>。如果是最大的index， 则应该是<code>i &gt; A[i]</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fixedPoint</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = A.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[mid] &gt;= mid) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == A[left]) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right == A[right]) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1065-Index-Pairs-of-a-String"><a href="#Leetcode1065-Index-Pairs-of-a-String" class="headerlink" title="Leetcode1065. Index Pairs of a String"></a>Leetcode1065. Index Pairs of a String</h1><p>Given a text string and words (a list of strings), return all index pairs [i, j] so that the substring text[i]…text[j] is in the list of words. </p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: text = “thestoryofleetcodeandme”, words = [“story”,”fleet”,”leetcode”]</span><br><span class="line">Output: [[3,7],[9,13],[10,17]]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: text = “ababa”, words = [“aba”,”ab”]</span><br><span class="line">Output: [[0,1],[0,2],[2,3],[2,4]]</span><br><span class="line">Explanation: </span><br><span class="line">Notice that matches can overlap, see “aba” is found in [0,2] and [2,4].</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>All strings contains only lowercase English letters.</li>
<li>It’s guaranteed that all strings in words are different.</li>
<li>1 &lt;= text.length &lt;= 100</li>
<li>1 &lt;= words.length &lt;= 20</li>
<li>1 &lt;= words[i].length &lt;= 50</li>
</ul>
<p>Return the pairs [i,j] in sorted order (i.e. sort them by their first coordinate in case of ties sort them by their second coordinate).</p>
<p>这道题可以直接用string find函数来做，但是需要分析一下时间复杂度。取决于具体的函数实现，比如CPP的find函数没有用KMP实现，所以最坏的情况复杂度是O(M <em> N)，这样带入本题，时间复杂度是`O(M </em> sum(len(word)))<code>。其中M是text的长度，</code>sum(len(word))`是words中word的长度之和。</p>
<p>如果用字典树Trie来实现，则当<code>M &lt; sum(len(word))</code>时，时间复杂度可以优化。首先建立基于words的字典树trie，然后在text中以每一个位置i为起点向后遍历，并判断往后每一个位置j是否在字典树中，若在则加入要返回的结果rets中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Trie*&gt; children = <span class="built_in">vector</span>&lt;Trie*&gt;(<span class="number">26</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">bool</span> is_find = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">Trie* <span class="title">constructTrie</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        Trie* trie = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            Trie* cur = trie;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> ch : word) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;children[ch - <span class="string">'a'</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    cur-&gt;children[ch - <span class="string">'a'</span>] = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;children[ch - <span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;is_find = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> trie;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; indexPairs(<span class="built_in">string</span> text, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="keyword">const</span> Trie* <span class="keyword">const</span> trie = constructTrie(words);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; rets;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> Trie* cur = trie;           </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; text.size() &amp;&amp; cur != <span class="literal">nullptr</span>; ++j) &#123;</span><br><span class="line">                cur = cur-&gt;children[text[j] - <span class="string">'a'</span>];</span><br><span class="line">                <span class="keyword">if</span> (cur &amp;&amp; cur-&gt;is_find) &#123;</span><br><span class="line">                    rets.push_back(&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1071-Greatest-Common-Divisor-of-Strings"><a href="#Leetcode1071-Greatest-Common-Divisor-of-Strings" class="headerlink" title="Leetcode1071. Greatest Common Divisor of Strings"></a>Leetcode1071. Greatest Common Divisor of Strings</h1><p>For strings S and T, we say “T divides S” if and only if S = T + … + T  (T concatenated with itself 1 or more times)</p>
<p>Return the largest string X such that X divides str1 and X divides str2.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: str1 = &quot;ABCABC&quot;, str2 = &quot;ABC&quot;</span><br><span class="line">Output: &quot;ABC&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: str1 = &quot;ABABAB&quot;, str2 = &quot;ABAB&quot;</span><br><span class="line">Output: &quot;AB&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: str1 = &quot;LEET&quot;, str2 = &quot;CODE&quot;</span><br><span class="line">Output: &quot;&quot;</span><br></pre></td></tr></table></figure></p>
<p>最长公共重复子串重复若干次之后能分别得到str1和str2，那么最明显地，该子串的长度一定是str1和str2长度的公因数。看了一下字符串的长度最多只有1000，所以我们完全可以对长度进行遍历，判断每个公因数是不是构成最长公共重复子串。因为要找最长的，所以找到最长之后，直接返回即可。时间复杂度O(N^2)。外部循环找到公因数，时间复杂度O(N)；内部要创建新的字符串和原先的字符串进行比较，时间复杂度也是O(N)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">gen</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">            res += str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">gcdOfStrings</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = str1.length(), l2 = str2.length();</span><br><span class="line">        <span class="keyword">int</span> length = min(l1, l2);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length; i &gt; <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1 % i == <span class="number">0</span> &amp;&amp; l2 % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> t1 = l1 / i;</span><br><span class="line">                <span class="keyword">int</span> t2 = l2 / i;</span><br><span class="line">                <span class="built_in">string</span> gcd = str1.substr(<span class="number">0</span>, i);</span><br><span class="line">                <span class="built_in">string</span> s1 = gen(gcd, t1);</span><br><span class="line">                <span class="built_in">string</span> s2 = gen(gcd, t2);</span><br><span class="line">                <span class="keyword">if</span> ((s1 == str1) &amp;&amp; (s2 == str2)) &#123;</span><br><span class="line">                    res = gcd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>题目要求 X 能除尽 str1 且 X 能除尽 str2，且 X 为最长。那么可以理解为 str1 由 m 个 X 连接而成， str2 由 n 个 X 连接而成。由此可知 str1 + str2 由 m + n 个 X 拼接而成，而且 str1 + str2 与 str2 + str1 在值上是相等的。然后此题就转化为了求最大公约数。str1 和 str2 长度的最大公约数，就是所求 X 的长度。</p>
<p>辗转相除法是递归算法，一句话概括这个算法就是：两个整数的最大公约数，等于其中较小的数 和两数相除余数 的最大公约数。比如 10 和 25，25 除以 10 商 2 余 5，那么 10 和 25 的最大公约数，等同于 10 和 5 的最大公约数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">gcdOfStrings</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 (str1 + str2) 和 (str2 + str1) 的值不相等</span></span><br><span class="line">        <span class="keyword">if</span> (!(str1 + str2).equals(str2 + str1)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两个字符串长度的最大公约数</span></span><br><span class="line">        <span class="keyword">int</span> maxCommonDivisor = gcd(str1.length(), str2.length());</span><br><span class="line">        <span class="keyword">return</span> str1.substring(<span class="number">0</span>, maxCommonDivisor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 辗转相除法求最大公约数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a % b == <span class="number">0</span>) ? b : gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1072-Flip-Columns-For-Maximum-Number-of-Equal-Rows"><a href="#Leetcode1072-Flip-Columns-For-Maximum-Number-of-Equal-Rows" class="headerlink" title="Leetcode1072. Flip Columns For Maximum Number of Equal Rows"></a>Leetcode1072. Flip Columns For Maximum Number of Equal Rows</h1><p>You are given an m x n binary matrix matrix.</p>
<p>You can choose any number of columns in the matrix and flip every cell in that column (i.e., Change the value of the cell from 0 to 1 or vice versa).</p>
<p>Return the maximum number of rows that have all values equal after some number of flips.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix = [[0,1],[1,1]]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: After flipping no values, 1 row has all values equal.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix = [[0,1],[1,0]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: After flipping values in the first column, both rows have equal values.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: matrix = [[0,0,0],[0,0,1],[1,1,0]]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: After flipping values in the first two columns, the last two rows have equal values.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>m == matrix.length</li>
<li>n == matrix[i].length</li>
<li>1 &lt;= m, n &lt;= 300</li>
<li>matrix[i][j] is either 0 or 1.</li>
</ul>
<p>其实按照列翻转没有什么用，把0开头的或者1开头的，选一种，全部翻转，用哈希表计数，找到最多出现的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEqualRowsAfterFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; mat : matrix) &#123;</span><br><span class="line">            <span class="keyword">int</span> length = mat.size();</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(length, <span class="string">' '</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (mat[<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i ++) &#123;</span><br><span class="line">                    mat[i] ^= <span class="number">1</span>;</span><br><span class="line">                    str[i] = mat[i] == <span class="number">1</span> ? <span class="string">'1'</span>: <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i ++) &#123;</span><br><span class="line">                    str[i] = mat[i] == <span class="number">1</span> ? <span class="string">'1'</span> : <span class="string">'0'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            m[str] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = m.begin(); it != m.end(); it ++)</span><br><span class="line">            res = max(res, it-&gt;second);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1073-Adding-Two-Negabinary-Numbers"><a href="#Leetcode1073-Adding-Two-Negabinary-Numbers" class="headerlink" title="Leetcode1073. Adding Two Negabinary Numbers"></a>Leetcode1073. Adding Two Negabinary Numbers</h1><p>Given two numbers arr1 and arr2 in base -2, return the result of adding them together.</p>
<p>Each number is given in array format:  as an array of 0s and 1s, from most significant bit to least significant bit.  For example, arr = [1,1,0,1] represents the number (-2)^3 + (-2)^2 + (-2)^0 = -3.  A number arr in array, format is also guaranteed to have no leading zeros: either arr == [0] or arr[0] == 1.</p>
<p>Return the result of adding arr1 and arr2 in the same format: as an array of 0s and 1s with no leading zeros.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr1 = [1,1,1,1,1], arr2 = [1,0,1]</span><br><span class="line">Output: [1,0,0,0,0]</span><br><span class="line">Explanation: arr1 represents 11, arr2 represents 5, the output represents 16.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr1 = [0], arr2 = [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: arr1 = [0], arr2 = [1]</span><br><span class="line">Output: [1]</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= arr1.length, arr2.length &lt;= 1000</li>
<li>arr1[i] and arr2[i] are 0 or 1</li>
<li>arr1 and arr2 have no leading zeros</li>
</ul>
<p>这道题说是有两个负二进制数是用数组来表示的，现在让返回它们相加后的结果，还是放在数组中来表示。这道题其实利用的方法跟那道很像，都是一位一位的处理的，直接加到结果 res 数组中的。这里使用两个指针i和j，分别指向数组 arr1 和 arr2 的末尾，然后用个变量 carry 表示进位，当i大于等于0时，carry 加上i指向的数字，并且i自减1，同理，当j大于等于0时，carry 加上j指向的数字，并且j自减1。由于数组中当每位上只能放一个数字，所以让 carry ‘与’上1，并加入到结果 res 数组后。然后需要再填充更高一位上的数字，对于二进制来说，直接右移1位即可，这里由于是负二进制，所以右移1位之后再取负。之后要移除所有的 leading zeros，因为这里高位是加到了 res 的后面，所以要去除末尾的零，使用个 while 去除。最后别忘了将 res 翻转一下返回即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; addNegabinary(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>, i = (<span class="keyword">int</span>)arr1.size() - <span class="number">1</span>, j = (<span class="keyword">int</span>)arr2.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) carry += arr1[i--];</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) carry += arr2[j--];</span><br><span class="line">            res.push_back(carry &amp; <span class="number">1</span>);</span><br><span class="line">            carry = -(carry &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (res.size() &gt; <span class="number">1</span> &amp;&amp; res.back() == <span class="number">0</span>) </span><br><span class="line">            res.pop_back();</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1078-Occurrences-After-Bigram"><a href="#Leetcode1078-Occurrences-After-Bigram" class="headerlink" title="Leetcode1078. Occurrences After Bigram"></a>Leetcode1078. Occurrences After Bigram</h1><p>Given words first and second, consider occurrences in some text of the form “first second third”, where second comes immediately after first, and third comes immediately after second.</p>
<p>For each such occurrence, add “third” to the answer, and return the answer.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: text = &quot;alice is a good girl she is a good student&quot;, first = &quot;a&quot;, second = &quot;good&quot;</span><br><span class="line">Output: [&quot;girl&quot;,&quot;student&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: text = &quot;we will we will rock you&quot;, first = &quot;we&quot;, second = &quot;will&quot;</span><br><span class="line">Output: [&quot;we&quot;,&quot;rock&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= text.length &lt;= 1000</li>
<li>text consists of space separated words, where each word consists of lowercase English letters.</li>
<li>1 &lt;= first.length, second.length &lt;= 10</li>
<li>first and second consist of lowercase English letters.</li>
</ul>
<p>第一种是先split，然后对比，运行时间较长但是内存占用小：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; split(<span class="built_in">string</span> text)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> begin=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> temp=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;text.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(text[i]==<span class="string">' '</span>)&#123;</span><br><span class="line">                res.push_back(temp); </span><br><span class="line">                temp=<span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp = temp + text[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(temp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findOcurrences(<span class="built_in">string</span> text, <span class="built_in">string</span> first, <span class="built_in">string</span> second) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; split_string = split(text);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;split_string.size()<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(split_string[i]==first &amp;&amp; split_string[i+<span class="number">1</span>]==second)</span><br><span class="line">                res.push_back(split_string[i+<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>人家有的大佬是用了流做的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findOcurrences(<span class="built_in">string</span> text, <span class="built_in">string</span> first, <span class="built_in">string</span> second) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;rst;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(text)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> s1,s2,cand;</span><br><span class="line">        ss&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">        <span class="keyword">while</span>(ss&gt;&gt;cand)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1==first &amp;&amp; s2==second)rst.push_back(cand);</span><br><span class="line">            s1=s2;</span><br><span class="line">            s2=cand;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1079-Letter-Tile-Possibilities"><a href="#Leetcode1079-Letter-Tile-Possibilities" class="headerlink" title="Leetcode1079. Letter Tile Possibilities"></a>Leetcode1079. Letter Tile Possibilities</h1><p>You have a set of tiles, where each tile has one letter tiles[i] printed on it.  Return the number of possible non-empty sequences of letters you can make.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;AAB&quot;</span><br><span class="line">Output: 8</span><br><span class="line">Explanation: The possible sequences are &quot;A&quot;, &quot;B&quot;, &quot;AA&quot;, &quot;AB&quot;, &quot;BA&quot;, &quot;AAB&quot;, &quot;ABA&quot;, &quot;BAA&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;AAABBC&quot;</span><br><span class="line">Output: 188</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= tiles.length &lt;= 7</li>
<li>tiles consists of uppercase English letters.</li>
</ul>
<p>求一个字符串的所有子串。第一想法优先使用全排列，即深度优先，但有一个核心问题：子串怎么办？全排列无法解决，子串的检索问题，这是我一开始苦思而不得解的地方。</p>
<p>解法一：</p>
<p>这是本题区别于普通全排列中，最隐蔽而又最有趣的一个点：字符串的全排列出来了，那字符串的所有不同子串，还会远吗？答案就是，全排列字符串的所有前缀子串里！检索全排列的全部不同子串（包含全排列本身），即为所求。</p>
<p>解法二：</p>
<p>因为问题的规模在7个字符内，解法一在时间和内存上均可接受。但当问题规模快速扩大时，基于解法一，如何优化？优化核心是，首先将字符串排序（排序大法好），一旦发生不同字符间的交换，则自字符串起始位置至交换发生的位置为前缀的子串，均发生变化！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> tiles, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; tiles.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j &amp;&amp; tiles[i]==tiles[j])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            swap(tiles[i], tiles[j]);</span><br><span class="line">            dfs(tiles, i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTilePossibilities</span><span class="params">(<span class="built_in">string</span> tiles)</span> </span>&#123;</span><br><span class="line">        sort(tiles.begin(),tiles.end());</span><br><span class="line">        dfs(tiles,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1080-Insufficient-Nodes-in-Root-to-Leaf-Paths"><a href="#Leetcode1080-Insufficient-Nodes-in-Root-to-Leaf-Paths" class="headerlink" title="Leetcode1080. Insufficient Nodes in Root to Leaf Paths"></a>Leetcode1080. Insufficient Nodes in Root to Leaf Paths</h1><p>Given the root of a binary tree, consider all root to leaf paths: paths from the root to any leaf.  (A leaf is a node with no children.)</p>
<p>A node is insufficient if every such root to leaf path intersecting this node has sum strictly less than limit.</p>
<p>Delete all insufficient nodes simultaneously, and return the root of the resulting binary tree.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1</span><br><span class="line">Output: [1,2,3,4,null,null,7,8,9,null,14]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22</span><br><span class="line">Output: [5,4,8,11,null,17,4,7,null,null,null,5]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,-3,-5,null,4,null], limit = -1</span><br><span class="line">Output: [1,null,-3,4]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>The given tree will have between 1 and 5000 nodes.</li>
<li>-10^5 &lt;= node.val &lt;= 10^5</li>
<li>-10^9 &lt;= limit &lt;= 10^9</li>
</ul>
<p>这道题定义了一种不足结点，就是说经过该结点的所有根到叶路径之和的都小于给定的 limit，现在让去除所有的这样的不足结点，返回剩下的结点组成的二叉树。这题好就好在给的例子都配了图，能够很好的帮助我们理解题意，给的例子很好的覆盖了大多数的情况，博主能想到的唯一没有覆盖的情况就是可能根结点也是不足结点，这样的话有可能会返回空树。这里首先处理一下 corner case，即根结点是叶结点的情况，这样只需要看根结点值是否小于 limit，是的话直接返回空指针，因为此时的根结点是个不足结点，需要被移除，否则直接返回根结点。一个比较快速的判断是否是叶结点的方法是看其左右子结点是否相等，因为只有均为空的时候才会相等。若根结点不为叶结点，且其左子结点存在的话，就对其左子结点调用递归，此时的 limit 需要减去根结点值，将返回的结点赋值给左子结点。同理，若其右子结点存在的话，就对其右子结点调用递归，此时的 limit 需要减去根结点值，将返回的结点赋值给右子结点。最后还需要判断一下，若此时的左右子结点都被赋值为空了，则当前结点也需要被移除，因为经过其左右子结点的根到叶路径就是经过该结点的所有路径，若其和均小于 limit，则当前结点也需要被移除，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sufficientSubset</span><span class="params">(TreeNode* root, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == root-&gt;right) &#123;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val &lt; limit ? <span class="literal">nullptr</span> : root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            root-&gt;left = sufficientSubset(root-&gt;left, limit - root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            root-&gt;right = sufficientSubset(root-&gt;right, limit - root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;left == root-&gt;right ? <span class="literal">nullptr</span> : root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1081-Smallest-Subsequence-of-Distinct-Characters"><a href="#Leetcode1081-Smallest-Subsequence-of-Distinct-Characters" class="headerlink" title="Leetcode1081. Smallest Subsequence of Distinct Characters"></a>Leetcode1081. Smallest Subsequence of Distinct Characters</h1><p>Given a string s, return the lexicographically smallest subsequence of s that contains all the distinct characters of s exactly once.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;bcabc&quot;</span><br><span class="line">Output: &quot;abc&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = &quot;cbacdcbc&quot;</span><br><span class="line">Output: &quot;acdb&quot;</span><br></pre></td></tr></table></figure></p>
<p>找出字典序最小的子序列。一次遍历，维护一个stack，存一个降序排列的堆，堆底是最小值，如果是之前出现过的字符，则跳过；否则遇到当前字符字典序小于之前最大值，并且最大值之后还会出现，那么就pop掉，直到之前的stack没有值或者比当前小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestSubsequence</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">int</span>* record = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">128</span>);</span><br><span class="line">        <span class="keyword">int</span>* visited = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">128</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i ++) &#123;</span><br><span class="line">            record[i] = <span class="number">0</span>;</span><br><span class="line">            visited[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) </span><br><span class="line">            record[c] ++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            -- record[c];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (visited[c])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(!st.empty() &amp;&amp; st.top() &gt; c &amp;&amp; record[st.top()] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                visited[st.top()] = <span class="number">0</span>;</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(c);</span><br><span class="line">            visited[c] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!st.empty()) &#123;</span><br><span class="line">            res += (<span class="keyword">char</span>)(st.top());</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这道题实际上需要用单调栈的思路来做，首先需要统计每个字母出现的次数，这里可以使用一个大小为 128 的数组 cnt 来表示，还需要一个数组 visited 来记录某个字母是否出现过。先遍历一遍字符串，统计每个字母出现的次数到 cnt 中。再遍历一遍给定的字符串，对于遍历到的字母，在 cnt 数组中减去一个，然后看该字母是否已经在 visited 数组中出现过，是的话直接跳过。否则需要进行一个 while 循环，这里的操作实际上是为了确保得到的结果是字母顺序最小的，若当前字母小于结果 res 中的最后一个字母，且该最后的字母在 cnt 中还存在，说明之后还会遇到这个字母，则可以在 res 中先去掉这个字母，以保证字母顺序最小，并且 visited 数组中标记为0，表示未访问。这里是尽可能的将 res 打造成单调递增的，但如果后面没有这个字母了，就不能移除，所以说并不能保证一定是单调递增的，但可以保证得到的结果是字母顺序最小的。while 循环退出后，将该字母加到结果 res 后，并且 visited 标记为1。这里还有个小 trick，结果 res 在初始化给个0，这样就不用判空了，而且0是小于所有字母的，不会影响这个逻辑，最后返回的时候去掉首位0就行了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestSubsequence</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">"0"</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">128</span>), visited(<span class="number">128</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) ++cnt[c];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s) &#123;</span><br><span class="line">            --cnt[c];</span><br><span class="line">            <span class="keyword">if</span> (visited[c]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (c &lt; res.back() &amp;&amp; cnt[res.back()]) &#123;</span><br><span class="line">                visited[res.back()] = <span class="number">0</span>;</span><br><span class="line">                res.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            res += c;</span><br><span class="line">            visited[c] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.substr(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1089-Duplicate-Zeros"><a href="#Leetcode1089-Duplicate-Zeros" class="headerlink" title="Leetcode1089. Duplicate Zeros"></a>Leetcode1089. Duplicate Zeros</h1><p>Given a fixed length array arr of integers, duplicate each occurrence of zero, shifting the remaining elements to the right. Note that elements beyond the length of the original array are not written. Do the above modifications to the input array in place, do not return anything from your function.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,2,3,0,4,5,0]</span><br><span class="line">Output: null</span><br><span class="line">Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: null</span><br><span class="line">Explanation: After calling your function, the input array is modified to: [1,2,3]</span><br></pre></td></tr></table></figure></p>
<p>双指针也许是本题的最优解法。具体思路是维护一个快指针和一个慢指针。快指针是遇到0就多进一步。这样遍历一遍数据后，快指针和慢指针会有一个差值。这个差值就是需要填充0的个数。</p>
<p>接下来，我们需要从后向前遍历数组。如果慢指针指向的元素不为0，则把快指针指向的元素替换为慢指针指向的元素；如果慢指针指向的元素为0，则把快指针和快指针之前指向的元素替换为0。</p>
<p>你可能会发现对于不同的数组，第一遍遍历之后fast指针的值是不一样的。区别在于数组末尾是否为0，如果末尾为0，则fast指针的值(数组索引)为数组长度+1。如果末尾不是0，则fast指针的值是数组长度。其实数组最后一位是0的话，其实是不用复制这个值的。因此从后向前遍历的时候需要判断fast指针的值是否小于n，这样就可以把数组末尾为0的时候就不会复制了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">duplicateZeros</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[slow] == <span class="number">0</span>)</span><br><span class="line">                fast ++;</span><br><span class="line">            fast ++;</span><br><span class="line">            slow ++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast --;</span><br><span class="line">        slow --;</span><br><span class="line">        <span class="keyword">while</span>(slow &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast &lt; n)</span><br><span class="line">                arr[fast] = arr[slow];</span><br><span class="line">            <span class="keyword">if</span>(arr[slow] == <span class="number">0</span>)</span><br><span class="line">                arr[--fast] = arr[slow];</span><br><span class="line">            fast --;</span><br><span class="line">            slow --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1090-Largest-Values-From-Labels"><a href="#Leetcode1090-Largest-Values-From-Labels" class="headerlink" title="Leetcode1090. Largest Values From Labels"></a>Leetcode1090. Largest Values From Labels</h1><p>We have a set of items: the i-th item has value values[i] and label labels[i].</p>
<p>Then, we choose a subset S of these items, such that:</p>
<ul>
<li>|S| &lt;= num_wanted</li>
<li>For every label L, the number of items in S with label L is &lt;= use_limit.</li>
</ul>
<p>Return the largest possible sum of the subset S.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: values = [5,4,3,2,1], labels = [1,1,2,2,3], `num_wanted` = 3, use_limit = 1</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: The subset chosen is the first, third, and fifth item.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: values = [5,4,3,2,1], labels = [1,3,3,3,2], `num_wanted` = 3, use_limit = 2</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: The subset chosen is the first, second, and third item.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: values = [9,8,8,7,6], labels = [0,0,0,1,1], `num_wanted` = 3, use_limit = 1</span><br><span class="line">Output: 16</span><br><span class="line">Explanation: The subset chosen is the first and fourth item.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: values = [9,8,8,7,6], labels = [0,0,0,1,1], `num_wanted` = 3, use_limit = 2</span><br><span class="line">Output: 24</span><br><span class="line">Explanation: The subset chosen is the first, second, and fourth item.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= values.length == labels.length &lt;= 20000</li>
<li>0 &lt;= values[i], labels[i] &lt;= 20000</li>
<li>1 &lt;= num_wanted, use_limit &lt;= values.length</li>
</ul>
<p>这道题说是给了一堆物品，每个物品有不同的价值和标签，分别放在 values 和 labels 数组中，现在让选不超过 num_wanted 个物品，且每个标签类别的物品不超过 use_limit，问能得到的最大价值是多少。说实话这道题博主研究了好久才弄懂题意，而且主要是看例子分析出来的，看了看踩比赞多，估计许多人跟博主一样吧。这道题可以用贪婪算法来做，因为需要尽可能的选价值高的物品，但同时要兼顾到物品的标签种类。所以可以将价值和标签种类组成一个 pair 对儿，放到一个优先队列中，这样就可以按照价值从高到低进行排列了。同时，由于每个种类的物品不能超过 use_limit 个，所以需要统计每个种类被使用了多少次，可以用一个 HashMap 来建立标签和其使用次数之间的映射。先遍历一遍所有物品，将价值和标签组成 pair 对儿加入优先队列中。然后进行循环，条件是 num_wanted 大于0，且队列不为空，此时取出队顶元素，将其标签映射值加1，若此时仍小于 use_limit，说明当前物品可以入选，将其价值加到 res 中，并且 num_wanted 自减1即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestValsFromLabels</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; values, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; labels, <span class="keyword">int</span> num_wanted, <span class="keyword">int</span> use_limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = values.size();</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; useMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            pq.push(&#123;values[i], labels[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (num_wanted &gt; <span class="number">0</span> &amp;&amp; !pq.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = pq.top().first, label = pq.top().second; pq.pop();</span><br><span class="line">            <span class="keyword">if</span> (++useMap[label] &lt;= use_limit) &#123;</span><br><span class="line">                res += value;</span><br><span class="line">                --num_wanted;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1091-Shortest-Path-in-Binary-Matrix"><a href="#Leetcode1091-Shortest-Path-in-Binary-Matrix" class="headerlink" title="Leetcode1091. Shortest Path in Binary Matrix"></a>Leetcode1091. Shortest Path in Binary Matrix</h1><p>Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.</p>
<p>A clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:</p>
<ul>
<li>All the visited cells of the path are 0.</li>
<li>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</li>
<li>The length of a clear path is the number of visited cells of this path.</li>
</ul>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[0,1],[1,0]]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[0,0,0],[1,1,0],[1,1,0]]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[1,0,0],[1,1,0],[1,1,0]]</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>n == grid.length</li>
<li>n == grid[i].length</li>
<li>1 &lt;= n &lt;= 100</li>
<li>grid[i][j] is 0 or 1</li>
</ul>
<p>这道题给了一个 nxn 的二维数组，里面都是0和1，让找出一条从左上角到右下角的干净路径，所谓的干净路径就是均由0组成，并且定义了相邻的位置是八个方向，不仅仅是通常的上下左右。例子中还给了图帮助理解，但是也有一丢丢的误导，博主最开始以为只需要往右，下，和右下三个方向走就行了，其实并不一定，任何方向都是可能的，说白了还是一道迷宫遍历的问题。既然是迷宫遍历求最少步数，那么广度优先遍历 Breadth-First Search 就是不二之选了，还是使用一个队列 queue 来做，初识时将 (0, 0) 放进去，再用一个 TreeSet 来标记访问过的位置。注意这里的方向数组要用到八个方向，while 循环中用的还是经典的层序遍历的写法，就是经典的写法，没有啥特殊的地方，博主感觉已经写了无数次了，在进行这一切之前，先判断一下起始点，若为1，直接返回 -1 即可，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = grid.size();</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; visited;</span><br><span class="line">        visited.insert(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.push(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs&#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">if</span> (t[<span class="number">0</span>] == n - <span class="number">1</span> &amp;&amp; t[<span class="number">1</span>] == n - <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> dir : dirs) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = t[<span class="number">0</span>] + dir[<span class="number">0</span>], y = t[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= n || grid[x][y] == <span class="number">1</span> || visited.count(&#123;x, y&#125;)) <span class="keyword">continue</span>;</span><br><span class="line">                    visited.insert(&#123;x, y&#125;);</span><br><span class="line">                    q.push(&#123;x, y&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1093-Statistics-from-a-Large-Sample"><a href="#Leetcode1093-Statistics-from-a-Large-Sample" class="headerlink" title="Leetcode1093. Statistics from a Large Sample"></a>Leetcode1093. Statistics from a Large Sample</h1><p>You are given a large sample of integers in the range [0, 255]. Since the sample is so large, it is represented by an array count where count[k] is the number of times that k appears in the sample.</p>
<p>Calculate the following statistics:</p>
<ul>
<li>minimum: The minimum element in the sample.</li>
<li>maximum: The maximum element in the sample.</li>
<li>mean: The average of the sample, calculated as the total sum of all elements divided by the total number of elements.</li>
<li>median:<ul>
<li>If the sample has an odd number of elements, then the median is the middle element once the sample is sorted.</li>
<li>If the sample has an even number of elements, then the median is the average of the two middle elements once the sample is sorted.</li>
</ul>
</li>
<li>mode: The number that appears the most in the sample. It is guaranteed to be unique.</li>
</ul>
<p>Return  the statistics of the sample as an array of floating-point numbers [minimum, maximum, mean, median, mode]. Answers within  10-5  of the actual answer will be accepted.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: count = [0,1,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">Output: [1.00000,3.00000,2.37500,2.50000,3.00000]</span><br><span class="line">Explanation: The sample represented by count is [1,2,2,2,3,3,3,3].</span><br><span class="line">The minimum and maximum are 1 and 3 respectively.</span><br><span class="line">The mean is (1+2+2+2+3+3+3+3) / 8 = 19 / 8 = 2.375.</span><br><span class="line">Since the size of the sample is even, the median is the average of the two middle elements 2 and 3, which is 2.5.</span><br><span class="line">The mode is 3 as it appears the most in the sample.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: count = [0,4,3,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]</span><br><span class="line">Output: [1.00000,4.00000,2.18182,2.00000,1.00000]</span><br><span class="line">Explanation: The sample represented by count is [1,1,1,1,2,2,2,3,3,4,4].</span><br><span class="line">The minimum and maximum are 1 and 4 respectively.</span><br><span class="line">The mean is (1+1+1+1+2+2+2+3+3+4+4) / 11 = 24 / 11 = 2.18181818... (for display purposes, the output shows the rounded number 2.18182).</span><br><span class="line">Since the size of the sample is odd, the median is the middle element 2.</span><br><span class="line">The mode is 1 as it appears the most in the sample.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>count.length == 256</li>
<li>0 &lt;= count[i] &lt;= 109</li>
<li>1 &lt;= sum(count) &lt;= 109</li>
<li>The mode of the sample that count represents is unique.</li>
</ul>
<p>这道题说是有很多在0到 255 中的整数，由于重复的数字太多了，所以这里采用的是统计每个数字出现的个数的方式，用数组 count 来表示，其中 count[i] 表示数字i出现的次数。现在让统计原始数组中的最大值，最小值，平均值，中位数，和众数。这里面的最大最小值很好求，最小值就是 count 数组中第一个不为0的位置，最大值就是 count 数组中最后一个不为0的位置。最小值 mn 初始化为 256，在遍历 count 数组的过程中，遇到不为0的数字时，若此时 mn 为 256，则更新为坐标i。最大值 mx 直接每次更新为值不为0的坐标i即可。平均值也好求，只要求出所有的数字之和，跟数字的个数相除就行了，注意由于数字之和可能很大，需要用 double 来表示。众数也不难求，只要找出 count 数组中的最大值，则其坐标就是众数。比较难就是中位数了，由于数组的个数可奇可偶，中位数的求法不同，这里为了统一，采用一个小 trick，比如数组 1，2，3 和 1，2，3，4，可以用坐标为 (n-1)/2 和 n/2 的两个数字求平均值得到，对于长度为奇数的数组，这两个坐标表示的是相同的数字。这里由于是统计数组，所以要找的两个位置是 (cnt+1)/2 和 (cnt+2)/2，其中 cnt 是所有数字的个数。再次遍历 count 数组，使用 cur 来累计当前经过的数字个数，若 cur 小于 first，且 cur 加上 count[i] 大于等于 first，说明当前数字i即为所求，加上其的一半到 median。同理，若 cur 小于 second，cur 加上 count[i] 大于等于 second，说明当前数字i即为所求，加上其的一半到 median 即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; sampleStats(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; count) &#123;</span><br><span class="line">        <span class="keyword">double</span> mn = <span class="number">256</span>, mx = <span class="number">0</span>, mean = <span class="number">0</span>, median = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, mode = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (mn == <span class="number">256</span>) mn = i;</span><br><span class="line">            mx = i;</span><br><span class="line">            sum += (<span class="keyword">double</span>)i * count[i];</span><br><span class="line">            cnt += count[i];</span><br><span class="line">            <span class="keyword">if</span> (count[i] &gt; count[mode]) mode = i;</span><br><span class="line">        &#125;</span><br><span class="line">        mean = sum / cnt;</span><br><span class="line">        <span class="keyword">int</span> first = (cnt + <span class="number">1</span>) / <span class="number">2</span>, second = (cnt + <span class="number">2</span>) / <span class="number">2</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur &lt; first &amp;&amp; cur + count[i] &gt;= first) median += i / <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur &lt; second &amp;&amp; cur + count[i] &gt;= second) median += i / <span class="number">2.0</span>;</span><br><span class="line">            cur += count[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;mn, mx, sum / cnt, median, (<span class="keyword">double</span>)mode&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1094-Car-Pooling"><a href="#Leetcode1094-Car-Pooling" class="headerlink" title="Leetcode1094. Car Pooling"></a>Leetcode1094. Car Pooling</h1><p>You are driving a vehicle that has capacity empty seats initially available for passengers.  The vehicle only drives east (ie. it cannot turn around and drive west.)</p>
<p>Given a list of trips, trip[i] = [num_passengers, start_location, end_location] contains information about the i-th trip: the number of passengers that must be picked up, and the locations to pick them up and drop them off.  The locations are given as the number of kilometers due east from your vehicle’s initial location.</p>
<p>Return true if and only if it is possible to pick up and drop off all passengers for all the given trips.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: trips = [[2,1,5],[3,3,7]], capacity = 4</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: trips = [[2,1,5],[3,3,7]], capacity = 5</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: trips = [[2,1,5],[3,5,7]], capacity = 3</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: trips = [[3,2,7],[3,7,9],[8,3,9]], capacity = 11</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>trips.length &lt;= 1000</li>
<li>trips[i].length == 3</li>
<li>1 &lt;= trips[i][0] &lt;= 100</li>
<li>0 &lt;= trips[i][1] &lt; trips[i][2] &lt;= 1000</li>
<li>1 &lt;= capacity &lt;= 100000</li>
</ul>
<p>这道题说的是拼车的那些事儿，给了一个数组，里面是很多三元对儿，分别包含乘客个数，上车时间和下车时间，还给了一个变量 capacity，说是任何时候的乘客总数不超过 capacity 的话，返回 true，否则就返回 false。这道题其实跟之前的 Meeting Rooms II 是一样，只不过那道题是求需要的房间的总个数，而这里是限定了乘客的总数，问是否会超载。使用的解题思想都是一样的，主要是需要将上车时间点和下车时间点拆分开，然后按时间顺序排列在同一条时间轴上，上车的时候就加上这些人数，下车的时候就减去这些人数。若某个时间点上的总人数超过了限定值，就直接返回 false 就行了，这里博主没有用 TreeMap，而是直接都放到一个数组中，然后对该数组按时间点进行排序，再遍历排序后的数组，进行累加元素之和即可，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">carPooling</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; trips, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; data;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> trip : trips) &#123;</span><br><span class="line">            data.push_back(&#123;trip[<span class="number">1</span>], trip[<span class="number">0</span>]&#125;);</span><br><span class="line">            data.push_back(&#123;trip[<span class="number">2</span>], -trip[<span class="number">0</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(data.begin(), data.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : data) &#123;</span><br><span class="line">            cur += a[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (cur &gt; capacity) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>接下来看一种更加高效的解法，并不用进行排序，那个太耗时了。题目限定了时间点不会超过 1000，所以这里就建立一个大小为 1001 的 cnt 数组，然后遍历 trips 数组，将对应的上车时间点加上乘客人数，下车时间点减去乘客人数，这样的话就相当于排序完成了，有点计数排序的感觉。之后再遍历这个 cnt 数组，累加当前的值，只要超过 capacity 了，就返回 false，否则最终返回 true 即可，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">carPooling</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; trips, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">1001</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;trip : trips) &#123;</span><br><span class="line">            cnt[trip[<span class="number">1</span>]] += trip[<span class="number">0</span>];</span><br><span class="line">            cnt[trip[<span class="number">2</span>]] -= trip[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">            cur += cnt[i];</span><br><span class="line">            <span class="keyword">if</span> (cur &gt; capacity) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/25/Merkle_Tree学习/" rel="next" title="Merkle Tree学习">
                <i class="fa fa-chevron-left"></i> Merkle Tree学习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/27/Leetcode501_550/" rel="prev" title="Leetcode501 - 550">
                Leetcode501 - 550 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">274</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1051-Height-Checker"><span class="nav-number">1.</span> <span class="nav-text">Leetcode1051. Height Checker</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1052-Grumpy-Bookstore-Owner"><span class="nav-number">2.</span> <span class="nav-text">Leetcode1052. Grumpy Bookstore Owner</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1053-Previous-Permutation-With-One-Swap"><span class="nav-number">3.</span> <span class="nav-text">Leetcode1053. Previous Permutation With One Swap</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1054-Distant-Barcodes"><span class="nav-number">4.</span> <span class="nav-text">Leetcode1054. Distant Barcodes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1055-Shortest-Way-to-Form-String"><span class="nav-number">5.</span> <span class="nav-text">Leetcode1055. Shortest Way to Form String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1056-Confusing-Number"><span class="nav-number">6.</span> <span class="nav-text">Leetcode1056. Confusing Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1057-Campus-Bikes"><span class="nav-number">7.</span> <span class="nav-text">Leetcode1057. Campus Bikes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1058-Minimize-Rounding-Error-to-Meet-Target"><span class="nav-number">8.</span> <span class="nav-text">Leetcode1058. Minimize Rounding Error to Meet Target</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1059-从始点到终点的所有路径"><span class="nav-number">9.</span> <span class="nav-text">Leetcode1059. 从始点到终点的所有路径</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1060-Missing-Element-in-Sorted-Array"><span class="nav-number">10.</span> <span class="nav-text">Leetcode1060. Missing Element in Sorted Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1061-按字典序排列最小的等效字符串"><span class="nav-number">11.</span> <span class="nav-text">Leetcode1061. 按字典序排列最小的等效字符串</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1062-Longest-Repeating-Substring"><span class="nav-number">12.</span> <span class="nav-text">Leetcode1062. Longest Repeating Substring</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode-1064-Fixed-Point"><span class="nav-number">13.</span> <span class="nav-text">Leetcode 1064. Fixed Point</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1065-Index-Pairs-of-a-String"><span class="nav-number">14.</span> <span class="nav-text">Leetcode1065. Index Pairs of a String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1071-Greatest-Common-Divisor-of-Strings"><span class="nav-number">15.</span> <span class="nav-text">Leetcode1071. Greatest Common Divisor of Strings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1072-Flip-Columns-For-Maximum-Number-of-Equal-Rows"><span class="nav-number">16.</span> <span class="nav-text">Leetcode1072. Flip Columns For Maximum Number of Equal Rows</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1073-Adding-Two-Negabinary-Numbers"><span class="nav-number">17.</span> <span class="nav-text">Leetcode1073. Adding Two Negabinary Numbers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1078-Occurrences-After-Bigram"><span class="nav-number">18.</span> <span class="nav-text">Leetcode1078. Occurrences After Bigram</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1079-Letter-Tile-Possibilities"><span class="nav-number">19.</span> <span class="nav-text">Leetcode1079. Letter Tile Possibilities</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1080-Insufficient-Nodes-in-Root-to-Leaf-Paths"><span class="nav-number">20.</span> <span class="nav-text">Leetcode1080. Insufficient Nodes in Root to Leaf Paths</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1081-Smallest-Subsequence-of-Distinct-Characters"><span class="nav-number">21.</span> <span class="nav-text">Leetcode1081. Smallest Subsequence of Distinct Characters</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1089-Duplicate-Zeros"><span class="nav-number">22.</span> <span class="nav-text">Leetcode1089. Duplicate Zeros</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1090-Largest-Values-From-Labels"><span class="nav-number">23.</span> <span class="nav-text">Leetcode1090. Largest Values From Labels</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1091-Shortest-Path-in-Binary-Matrix"><span class="nav-number">24.</span> <span class="nav-text">Leetcode1091. Shortest Path in Binary Matrix</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1093-Statistics-from-a-Large-Sample"><span class="nav-number">25.</span> <span class="nav-text">Leetcode1093. Statistics from a Large Sample</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1094-Car-Pooling"><span class="nav-number">26.</span> <span class="nav-text">Leetcode1094. Car Pooling</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
