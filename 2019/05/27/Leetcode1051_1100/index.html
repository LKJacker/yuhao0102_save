<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Leetcode,">










<meta name="description" content="Leetcode1051. Height CheckerStudents are asked to stand in non-decreasing order of heights for an annual photo. Return the minimum number of students not standing in the right positions.  (This is the">
<meta name="keywords" content="Leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode1051 - 1100">
<meta property="og:url" content="http://yoursite.com/2019/05/27/Leetcode1051_1100/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Leetcode1051. Height CheckerStudents are asked to stand in non-decreasing order of heights for an annual photo. Return the minimum number of students not standing in the right positions.  (This is the">
<meta property="og:locale" content="zn-ch">
<meta property="og:updated_time" content="2021-12-20T05:27:59.662Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode1051 - 1100">
<meta name="twitter:description" content="Leetcode1051. Height CheckerStudents are asked to stand in non-decreasing order of heights for an annual photo. Return the minimum number of students not standing in the right positions.  (This is the">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/27/Leetcode1051_1100/">





  <title>Leetcode1051 - 1100 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/27/Leetcode1051_1100/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode1051 - 1100</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-27T10:30:00+08:00">
                2019-05-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Leetcode1051-Height-Checker"><a href="#Leetcode1051-Height-Checker" class="headerlink" title="Leetcode1051. Height Checker"></a>Leetcode1051. Height Checker</h1><p>Students are asked to stand in non-decreasing order of heights for an annual photo.</p>
<p>Return the minimum number of students not standing in the right positions.  (This is the number of students that must move in order for all students to be standing in non-decreasing order of height.)</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,1,4,2,1,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Explanation:<br>Students with heights 4, 3 and the last 1 are not standing in the right positions.</p>
<p>Note:</p>
<p>1 &lt;= heights.length &lt;= 100<br>1 &lt;= heights[i] &lt;= 100</p>
<p>看上去比较简单的题，找到没有按照顺序排列的数，想用一种不需要排序的方法来做，但是失败了，因为如果其他数字有序，只有一个无序，是要移动很多的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*int heightChecker(vector&lt;int&gt;&amp; heights) &#123;</span></span><br><span class="line"><span class="comment">        int res=0;</span></span><br><span class="line"><span class="comment">        for(int i=1;i&lt;heights.size()-1;i++)&#123;</span></span><br><span class="line"><span class="comment">            if(!(heights[i]&gt;=heights[i-1] &amp;&amp; heights[i]&lt;=heights[i+1]))</span></span><br><span class="line"><span class="comment">                res++;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return res;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">heightChecker</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s = h;</span><br><span class="line">        sort(begin(s), end(s));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; h.size(); ++i) </span><br><span class="line">            res += h[i] != s[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1052-Grumpy-Bookstore-Owner"><a href="#Leetcode1052-Grumpy-Bookstore-Owner" class="headerlink" title="Leetcode1052. Grumpy Bookstore Owner"></a>Leetcode1052. Grumpy Bookstore Owner</h1><p>Today, the bookstore owner has a store open for customers.length minutes. Every minute, some number of customers (customers[i]) enter the store, and all those customers leave after the end of that minute.</p>
<p>On some minutes, the bookstore owner is grumpy. If the bookstore owner is grumpy on the i-th minute, grumpy[i] = 1, otherwise grumpy[i] = 0. When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise they are satisfied.</p>
<p>The bookstore owner knows a secret technique to keep themselves not grumpy for X minutes straight, but can only use it once.</p>
<p>Return the maximum number of customers that can be satisfied throughout the day.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3</span><br><span class="line">Output: 16</span><br><span class="line">Explanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. </span><br><span class="line">The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= X &lt;= customers.length == grumpy.length &lt;= 20000</li>
<li>0 &lt;= customers[i] &lt;= 1000</li>
<li>0 &lt;= grumpy[i] &lt;= 1</li>
</ul>
<p>滑动窗口. 统计在大小为 X 的窗口中, 有多少顾客刚好处在店主脾气不好的时刻, 即 grumpy[i] == 1. 其中 grumpy[i] == 0 对应的顾客始终是满意的, 使用 base 来统计. 而对于那些 grumpy[i] == 1 的顾客, 只有在他们刚好在滑动窗口中, 才能满意, 用 new_satisfied 统计在滑动窗口中新满意的顾客, 在窗口滑动过程中使用 max_satisfied 来记录最大值. 最后返回 base + max_satisfied.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSatisfied</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; customers, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; grumpy, <span class="keyword">int</span> minutes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, len = grumpy.size();</span><br><span class="line">        <span class="keyword">int</span> sat = <span class="number">0</span>, new_sat = <span class="number">0</span>, max_sat = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grumpy[i] == <span class="number">0</span>)</span><br><span class="line">                sat += customers[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                new_sat += customers[i];</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= minutes)</span><br><span class="line">                new_sat -= (customers[i-minutes] * grumpy[i-minutes]);</span><br><span class="line">            max_sat = max(max_sat, new_sat);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sat + max_sat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1053-Previous-Permutation-With-One-Swap"><a href="#Leetcode1053-Previous-Permutation-With-One-Swap" class="headerlink" title="Leetcode1053. Previous Permutation With One Swap"></a>Leetcode1053. Previous Permutation With One Swap</h1><p>Given an array of positive integers arr (not necessarily distinct), return  the lexicographically largest permutation that is smaller than  arr, that can be made with exactly one swap (A  swap  exchanges the positions of two numbers arr[i] and arr[j]). If it cannot be done, then return the same array.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [3,2,1]</span><br><span class="line">Output: [3,1,2]</span><br><span class="line">Explanation: Swapping 2 and 1.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,1,5]</span><br><span class="line">Output: [1,1,5]</span><br><span class="line">Explanation: This is already the smallest permutation.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,9,4,6,7]</span><br><span class="line">Output: [1,7,4,6,9]</span><br><span class="line">Explanation: Swapping 9 and 7.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [3,1,1,3]</span><br><span class="line">Output: [1,3,1,3]</span><br><span class="line">Explanation: Swapping 1 and 3.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= arr.length &lt;= 104</li>
<li>1 &lt;= arr[i] &lt;= 104</li>
</ul>
<p>这道题给了一个正整数的数组，说是让任意交换两个数字，使得变成字母顺序最大的一种全排列，但是需要小于原先的排列，若无法得到这样的全排列（说明当前已经是最小的全排列），则返回原数组。通过分析题目中给的例子不难理解题意，根据例子2来看，若给定的数组就是升序排列的，则无法得到更小的全排列，说明只有遇到降序的位置的时候，才有可能进行交换。但是假如有多个可以下降的地方呢，比如例子1，3到2下降，2到1下降，这里是需要交换2和1的，所以最好是从后往前检验，遇到前一个数字比当前数字大的情况时，前一个数字必定是交换方之一，而当前数字并不是。比如例子3，数字4的前面是9，正确结果是9和7交换，所以还要从4往后遍历一下，找到一个仅次于9的数字交换才行，而且数字相同的话，取坐标较小的那个，比如例子4就是这种情况。其实这道题的四个例子给的真不错，基本各种情况都 cover 到了，赞一个～ 分析到这里，代码就不难写了，首先从后往前遍历，假如当前数字大于等于前一个数字，直接跳过，否则说明需要交换的。从当前位置再向后遍历一遍，找到第一个仅次于拐点的数字交换即可，注意下面的代码虽然嵌套了两个 for 循环，其实是线性的时间复杂度，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prevPermOpt1(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size(), mx = <span class="number">0</span>, idx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt;= arr[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[i - <span class="number">1</span>] &amp;&amp; mx &lt; arr[j]) &#123;</span><br><span class="line">                    mx = arr[j];</span><br><span class="line">                    idx = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr[i - <span class="number">1</span>], arr[idx]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcoe1054-Distant-Barcodes"><a href="#Leetcoe1054-Distant-Barcodes" class="headerlink" title="Leetcoe1054. Distant Barcodes"></a>Leetcoe1054. Distant Barcodes</h1><p>In a warehouse, there is a row of barcodes, where the ith barcode is barcodes[i].</p>
<p>Rearrange the barcodes so that no two adjacent barcodes are equal. You may return any answer, and it is guaranteed an answer exists.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: barcodes = [1,1,1,2,2,2]</span><br><span class="line">Output: [2,1,2,1,2,1]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: barcodes = [1,1,1,1,2,2,3,3]</span><br><span class="line">Output: [1,3,1,3,1,2,1,2]</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>1 &lt;= barcodes.length &lt;= 10000</li>
<li>1 &lt;= barcodes[i] &lt;= 10000</li>
</ul>
<p>这道题说在一个仓库，有一排条形码，这里用数字表示，现在让给数字重新排序，使得相邻的数字不相同，并且说了一定会有合理的答案。意思就是说最多的重复个数不会超过数组长度的一半，否则一定会有相邻的重复数字。那么来分析一下题目，既然是为了避免重复数字被排在相邻的位置，肯定是要优先关注出现次数多的数字，因为它们更有可能出现在相邻的位置。这道题是可以用贪婪算法来做的，每次取出出现次数最多的两个数字，将其先排列起来，然后再取下一对出现次数最多的两个数字，以此类推直至排完整个数组。这里为了快速知道出现次数最多的数字，可以使用优先队列来做，里面放一个 pair 对儿，由频率和数字组成，这样优先队列就可以根据频率由高到低来自动排序了。统计频率的话就使用一个 HashMap，然后将频率和数字组成的 pair 对儿加入优先队列。进行 while 循环，条件是队列中的 pair 对儿至少两个，这样才能每次取出两个，将其加入结果 res 中，然后其频率分别减1，只要没减到0，就都加回优先队列中。最后可能队列还有一个剩余，有的话将数字加入结果 res 中即可，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rearrangeBarcodes(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; barcodes) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; numCnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : barcodes) ++numCnt[num];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : numCnt) &#123;</span><br><span class="line">            pq.push(&#123;a.second, a.first&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> a = pq.top(); pq.pop();</span><br><span class="line">            <span class="keyword">auto</span> b = pq.top(); pq.pop();</span><br><span class="line">            res.push_back(a.second);</span><br><span class="line">            res.push_back(b.second);</span><br><span class="line">            <span class="keyword">if</span> (--a.first &gt; <span class="number">0</span>) pq.push(a);</span><br><span class="line">            <span class="keyword">if</span> (--b.first &gt; <span class="number">0</span>) pq.push(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!pq.empty()) </span><br><span class="line">            res.push_back(pq.top().second);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>论坛上的高分解法貌似没有用到优先队列，不过整个思路还是大体相同的，还是用 HashMap 来统计频率，这里将组成的频率和数字的 pair 对儿放到一个数组中，然后给数组按照从大到小的顺序来排列。接下里就要填充 res 数组了，方法是先填偶数坐标的位置，将频率最大的数字分别填进去，当偶数坐标填完了之后，再填奇数坐标的位置，这样保证不会有相连的重复数字。使用一个变量 pos，表示当前要填的坐标，初始化为0，之后来遍历这个频率和数字的 pair 对儿，从高到低，先填充所有偶数，若 pos 大于数组长度了，则切换为填充奇数即可，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rearrangeBarcodes(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; barcodes) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = barcodes.size(), pos = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; numCnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : barcodes) ++numCnt[num];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : numCnt) &#123;</span><br><span class="line">            vec.push_back(&#123;a.second, a.first&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(vec.rbegin(), vec.rend());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : vec) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.first; ++i, pos += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pos &gt;= n) pos = <span class="number">1</span>;</span><br><span class="line">                res[pos] = a.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1055-Shortest-Way-to-Form-String"><a href="#Leetcode1055-Shortest-Way-to-Form-String" class="headerlink" title="Leetcode1055. Shortest Way to Form String"></a>Leetcode1055. Shortest Way to Form String</h1><p>From any string, we can form a  subsequence  of that string by deleting some number of characters (possibly no deletions).</p>
<p>Given two strings source and target, return the minimum number of subsequences of source such that their concatenation equals target. If the task is impossible, return -1.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: source = &quot;abc&quot;, target = &quot;abcbc&quot;</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The target &quot;abcbc&quot; can be formed by &quot;abc&quot; and &quot;bc&quot;, which are subsequences of source &quot;abc&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: source = &quot;abc&quot;, target = &quot;acdbc&quot;</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: The target string cannot be constructed from the subsequences of source string due to the character &quot;d&quot; in target string.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: source = &quot;xyz&quot;, target = &quot;xzyxz&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The target string can be constructed as follows &quot;xz&quot; + &quot;y&quot; + &quot;xz&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Constraints:</p>
<ul>
<li>Both the source and target strings consist of only lowercase English letters from “a”-“z”.</li>
<li>The lengths of source and target string are between 1 and 1000.</li>
</ul>
<p>这道题说我们可以通过删除某些位置上的字母从而形成一个新的字符串，现在给了两个字符串 source 和 target，问最少需要删除多个字母，可以把 source 字母串拼接成为 target。注意这里的 target 字符串可能会远长于 source，所以需要多个 source 字符串 concatenate 到一起，然后再进行删除字母。对于 target 中的每个字母，都需要在 source 中匹配到，所以最外层循环肯定是遍历 target 中的每个字母，可以使用一个指针j，初始化赋值为0，接下来就要在 source 中匹配这个 target[j]，所以需要遍历一下 source 字符串，如果匹配上了 target[j]，则j自增1，继续匹配下一个，当循环退出后，此时有一种情况需要考虑，就是对于这个 target[j] 字母，整个 source 字符串都无法匹配，说明 target 中存在 source 中没有的字母，这种情况下是要返回 -1 的，如何判定这种情况呢？当然可以在最开始把 source 中所有的字母放到一个 HashSet 中，然后对于 target 中每个字母都检测看是否在集合中。但这里可以使用更简便的方法，就是在遍历 source 之前，用另一个变量 pre 记录当前j的位置，然后当遍历完 source 之后，若j没有变化，则说明有其他字母存在，直接返回 -1 即可，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestWay</span><span class="params">(<span class="built_in">string</span> source, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, j = <span class="number">0</span>, m = source.size(), n = target.size();</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> pre = j;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; n &amp;&amp; source[i] == target[j]) ++j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == pre) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面这种方法思路和上面基本一样，就是没有直接去遍历 source 数组，而是使用了 STL 的 find 函数。开始还是要遍历 target 字符串，对于每个字母，首先在 source 中调用 find 函数查找一下，假如找不到，直接返回 -1。有的话，就从 pos+1 位置开始再次查找该字母，且其位置赋值为 pos，注意这里 pos+1 的原因是因为其初始化为了 -1，需要从0开始找，或者 pos 已经赋值为上一个匹配位置了，所以要从下一个位置开始查找。假如 pos 为 -1 了，说明当前剩余字母中无法匹配了，需要新的一轮循环，此时将 res 自增1，并将 pos 赋值为新的 source 串中的第一个匹配位置，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestWay</span><span class="params">(<span class="built_in">string</span> source, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>, pos = <span class="number">-1</span>, n = target.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (source.find(target[i]) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            pos = source.find(target[i], pos + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123;</span><br><span class="line">                ++res;</span><br><span class="line">                pos = source.find(target[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1056-Confusing-Number"><a href="#Leetcode1056-Confusing-Number" class="headerlink" title="Leetcode1056. Confusing Number"></a>Leetcode1056. Confusing Number</h1><p>Given a number N, return true if and only if it is a  confusing number , which satisfies the following condition:</p>
<p>We can rotate digits by 180 degrees to form new digits. When 0, 1, 6, 8, 9 are rotated 180 degrees, they become 0, 1, 9, 8, 6 respectively. When 2, 3, 4, 5 and 7 are rotated 180 degrees, they become invalid. A  confusing number  is a number that when rotated 180 degrees becomes a different number with each digit valid.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 6</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">We get `9` after rotating `6`, `9` is a valid number and `9!=6`.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 89</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">We get `68` after rotating `89`, `86` is a valid number and `86!=89`.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 11</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">We get `11` after rotating `11`, `11` is a valid number but the value remains the same, thus `11` is not a confusing number.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 25</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">We get an invalid number after rotating `25`.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>0 &lt;= N &lt;= 10^9</li>
<li>After the rotation we can ignore leading zeros, for example if after rotation we have 0008 then this number is considered as just 8.</li>
</ul>
<p>这道题定义了一种迷惑数，将数字翻转 180 度，其中 0, 1, 8 旋转后保持不变，6变成9，9变成6，数字 2, 3, 4, 5, 和 7 旋转后变为非法数字。若能将某个数翻转后成为一个合法的新的数，就说这个数是迷惑数。这道题的难度并不大，就是考察的是遍历整数各个位上的数字，使用一个 while 循环，然后用 mod10 取出当前最低位上的数字，将不合法的数字放入一个 HashSet 中，这样直接在 HashSet 中查找一下当前数字是否存在，存在直接返回 false。不存在的话，则要进行翻转，因为只有6和9两个数字翻转后会得到不同的数字，所以单独判断一下，然后将当前数字拼到 num 的最低位即可，最终拼成的 num 就是原数字 N 的翻转，最后别忘了比较一下是否相同，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">confusingNumber</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>, oldN = N;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; invalid&#123;&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit = N % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (invalid.count(digit)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (digit == <span class="number">6</span>) digit = <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (digit == <span class="number">9</span>) digit = <span class="number">6</span>;</span><br><span class="line">            num = num * <span class="number">10</span> + digit;</span><br><span class="line">            N /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num != oldN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这也可以用一个 HashMap 来建立所有的数字映射，然后还是用一个变量 oldN 来记录原来的数字，然后遍历N上的每一位数字，若其不在 HashMap 中，说明有数字无法翻转，直接返回 false，否则就把翻转后的数字加入 res，最后只要看 res 和 oldN 是否相等即可，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">confusingNumber</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m&#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">6</span>, <span class="number">9</span>&#125;, &#123;<span class="number">8</span>, <span class="number">8</span>&#125;, &#123;<span class="number">9</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">long</span> oldN = N, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!m.count(N % <span class="number">10</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            res = res * <span class="number">10</span> + m[N % <span class="number">10</span>];</span><br><span class="line">            N /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res != oldN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面来看一种双指针的解法，这里先用一个数组 rotate 来按位记录每个数字翻转后得到的数字，用 -1 来表示非法情况，然后将数字 N 转为字符串，用两个指针 left 和 right 分别指向开头和末尾。用 while 循环进行遍历，假如此时 left 和 right 中有任何一个指向的数字翻转后是非法，直接返回 false。然后看 left 指向的数字翻转后跟 right 指向的数字是否相同，若不同，则将 res 标记为 true，然后移动 left 和 right 指针，最终返回 res 即可，参见代码如下：</p>
<p>解法三：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">confusingNumber</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotate&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">9</span>, <span class="number">-1</span>, <span class="number">8</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> str = to_string(N);</span><br><span class="line">        <span class="keyword">int</span> n = str.size(), left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rotate[str[left] - <span class="string">'0'</span>] == <span class="number">-1</span> || rotate[str[right] - <span class="string">'0'</span>] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (rotate[str[left] - <span class="string">'0'</span>] != (str[right] - <span class="string">'0'</span>)) res = <span class="literal">true</span>;</span><br><span class="line">            ++left; --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1071-Greatest-Common-Divisor-of-Strings"><a href="#Leetcode1071-Greatest-Common-Divisor-of-Strings" class="headerlink" title="Leetcode1071. Greatest Common Divisor of Strings"></a>Leetcode1071. Greatest Common Divisor of Strings</h1><p>For strings S and T, we say “T divides S” if and only if S = T + … + T  (T concatenated with itself 1 or more times)</p>
<p>Return the largest string X such that X divides str1 and X divides str2.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: str1 = &quot;ABCABC&quot;, str2 = &quot;ABC&quot;</span><br><span class="line">Output: &quot;ABC&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: str1 = &quot;ABABAB&quot;, str2 = &quot;ABAB&quot;</span><br><span class="line">Output: &quot;AB&quot;</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: str1 = &quot;LEET&quot;, str2 = &quot;CODE&quot;</span><br><span class="line">Output: &quot;&quot;</span><br></pre></td></tr></table></figure></p>
<p>最长公共重复子串重复若干次之后能分别得到str1和str2，那么最明显地，该子串的长度一定是str1和str2长度的公因数。看了一下字符串的长度最多只有1000，所以我们完全可以对长度进行遍历，判断每个公因数是不是构成最长公共重复子串。因为要找最长的，所以找到最长之后，直接返回即可。时间复杂度O(N^2)。外部循环找到公因数，时间复杂度O(N)；内部要创建新的字符串和原先的字符串进行比较，时间复杂度也是O(N)。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">gen</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">            res += str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">gcdOfStrings</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l1 = str1.length(), l2 = str2.length();</span><br><span class="line">        <span class="keyword">int</span> length = min(l1, l2);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = length; i &gt; <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1 % i == <span class="number">0</span> &amp;&amp; l2 % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> t1 = l1 / i;</span><br><span class="line">                <span class="keyword">int</span> t2 = l2 / i;</span><br><span class="line">                <span class="built_in">string</span> gcd = str1.substr(<span class="number">0</span>, i);</span><br><span class="line">                <span class="built_in">string</span> s1 = gen(gcd, t1);</span><br><span class="line">                <span class="built_in">string</span> s2 = gen(gcd, t2);</span><br><span class="line">                <span class="keyword">if</span> ((s1 == str1) &amp;&amp; (s2 == str2)) &#123;</span><br><span class="line">                    res = gcd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1078-Occurrences-After-Bigram"><a href="#Leetcode1078-Occurrences-After-Bigram" class="headerlink" title="Leetcode1078. Occurrences After Bigram"></a>Leetcode1078. Occurrences After Bigram</h1><p>Given words first and second, consider occurrences in some text of the form “first second third”, where second comes immediately after first, and third comes immediately after second.</p>
<p>For each such occurrence, add “third” to the answer, and return the answer.</p>
<p>Example 1:</p>
<p>Input: text = “alice is a good girl she is a good student”, first = “a”, second = “good”<br>Output: [“girl”,”student”]<br>Example 2:</p>
<p>Input: text = “we will we will rock you”, first = “we”, second = “will”<br>Output: [“we”,”rock”]</p>
<p>Note:</p>
<p>1 &lt;= text.length &lt;= 1000<br>text consists of space separated words, where each word consists of lowercase English letters.<br>1 &lt;= first.length, second.length &lt;= 10<br>first and second consist of lowercase English letters.</p>
<p>第一种是先split，然后对比，运行时间较长但是内存占用小：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; split(<span class="built_in">string</span> text)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> begin=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> temp=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;text.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(text[i]==<span class="string">' '</span>)&#123;</span><br><span class="line">                res.push_back(temp); </span><br><span class="line">                temp=<span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp = temp + text[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(temp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findOcurrences(<span class="built_in">string</span> text, <span class="built_in">string</span> first, <span class="built_in">string</span> second) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; split_string = split(text);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;split_string.size()<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(split_string[i]==first &amp;&amp; split_string[i+<span class="number">1</span>]==second)</span><br><span class="line">                res.push_back(split_string[i+<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>人家有的大佬是用了流做的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findOcurrences(<span class="built_in">string</span> text, <span class="built_in">string</span> first, <span class="built_in">string</span> second) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;rst;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(text)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> s1,s2,cand;</span><br><span class="line">        ss&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line">        <span class="keyword">while</span>(ss&gt;&gt;cand)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1==first &amp;&amp; s2==second)rst.push_back(cand);</span><br><span class="line">            s1=s2;</span><br><span class="line">            s2=cand;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode1079-Letter-Tile-Possibilities"><a href="#Leetcode1079-Letter-Tile-Possibilities" class="headerlink" title="Leetcode1079. Letter Tile Possibilities"></a>Leetcode1079. Letter Tile Possibilities</h1><p>You have a set of tiles, where each tile has one letter tiles[i] printed on it.  Return the number of possible non-empty sequences of letters you can make.</p>
<p>Example 1:</p>
<p>Input: “AAB”<br>Output: 8<br>Explanation: The possible sequences are “A”, “B”, “AA”, “AB”, “BA”, “AAB”, “ABA”, “BAA”.<br>Example 2:</p>
<p>Input: “AAABBC”<br>Output: 188</p>
<p>Note:</p>
<p>1 &lt;= tiles.length &lt;= 7<br>tiles consists of uppercase English letters.</p>
<p>求一个字符串的所有子串。第一想法优先使用全排列，即深度优先，但有一个核心问题：子串怎么办？全排列无法解决，子串的检索问题，这是我一开始苦思而不得解的地方。</p>
<p>解法一：</p>
<p>这是本题区别于普通全排列中，最隐蔽而又最有趣的一个点：字符串的全排列出来了，那字符串的所有不同子串，还会远吗？</p>
<p>答案就是，全排列字符串的所有前缀子串里！检索全排列的全部不同子串（包含全排列本身），即为所求。</p>
<p>解法二：</p>
<p>因为问题的规模在7个字符内，解法一在时间和内存上均可接受。但当问题规模快速扩大时，基于解法一，如何优化？</p>
<p>优化核心是，首先将字符串排序（排序大法好），一旦发生不同字符间的交换，则自字符串起始位置至交换发生的位置为前缀的子串，均发生变化！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">string</span> tiles, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; tiles.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j &amp;&amp; tiles[i]==tiles[j])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            swap(tiles[i], tiles[j]);</span><br><span class="line">            dfs(tiles, i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTilePossibilities</span><span class="params">(<span class="built_in">string</span> tiles)</span> </span>&#123;</span><br><span class="line">        sort(tiles.begin(),tiles.end());</span><br><span class="line">        dfs(tiles,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode1089-Duplicate-Zeros"><a href="#Leetcode1089-Duplicate-Zeros" class="headerlink" title="Leetcode1089. Duplicate Zeros"></a>Leetcode1089. Duplicate Zeros</h1><p>Given a fixed length array arr of integers, duplicate each occurrence of zero, shifting the remaining elements to the right. Note that elements beyond the length of the original array are not written. Do the above modifications to the input array in place, do not return anything from your function.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,0,2,3,0,4,5,0]</span><br><span class="line">Output: null</span><br><span class="line">Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: null</span><br><span class="line">Explanation: After calling your function, the input array is modified to: [1,2,3]</span><br></pre></td></tr></table></figure></p>
<p>双指针也许是本题的最优解法。具体思路是维护一个快指针和一个慢指针。快指针是遇到0就多进一步。这样遍历一遍数据后，快指针和慢指针会有一个差值。这个差值就是需要填充0的个数。</p>
<p>接下来，我们需要从后向前遍历数组。如果慢指针指向的元素不为0，则把快指针指向的元素替换为慢指针指向的元素；如果慢指针指向的元素为0，则把快指针和快指针之前指向的元素替换为0。</p>
<p>你可能会发现对于不同的数组，第一遍遍历之后fast指针的值是不一样的。区别在于数组末尾是否为0，如果末尾为0，则fast指针的值(数组索引)为数组长度+1。如果末尾不是0，则fast指针的值是数组长度。其实数组最后一位是0的话，其实是不用复制这个值的。因此从后向前遍历的时候需要判断fast指针的值是否小于n，这样就可以把数组末尾为0的时候就不会复制了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">duplicateZeros</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[slow] == <span class="number">0</span>)</span><br><span class="line">                fast ++;</span><br><span class="line">            fast ++;</span><br><span class="line">            slow ++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast --;</span><br><span class="line">        slow --;</span><br><span class="line">        <span class="keyword">while</span>(slow &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast &lt; n)</span><br><span class="line">                arr[fast] = arr[slow];</span><br><span class="line">            <span class="keyword">if</span>(arr[slow] == <span class="number">0</span>)</span><br><span class="line">                arr[--fast] = arr[slow];</span><br><span class="line">            fast --;</span><br><span class="line">            slow --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/25/Merkle_Tree学习/" rel="next" title="Merkle Tree学习">
                <i class="fa fa-chevron-left"></i> Merkle Tree学习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/27/Leetcode501_550/" rel="prev" title="Leetcode501 - 550">
                Leetcode501 - 550 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">301</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1051-Height-Checker"><span class="nav-number">1.</span> <span class="nav-text">Leetcode1051. Height Checker</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1052-Grumpy-Bookstore-Owner"><span class="nav-number">2.</span> <span class="nav-text">Leetcode1052. Grumpy Bookstore Owner</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1053-Previous-Permutation-With-One-Swap"><span class="nav-number">3.</span> <span class="nav-text">Leetcode1053. Previous Permutation With One Swap</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcoe1054-Distant-Barcodes"><span class="nav-number">4.</span> <span class="nav-text">Leetcoe1054. Distant Barcodes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1055-Shortest-Way-to-Form-String"><span class="nav-number">5.</span> <span class="nav-text">Leetcode1055. Shortest Way to Form String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1056-Confusing-Number"><span class="nav-number">6.</span> <span class="nav-text">Leetcode1056. Confusing Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1071-Greatest-Common-Divisor-of-Strings"><span class="nav-number">7.</span> <span class="nav-text">Leetcode1071. Greatest Common Divisor of Strings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1078-Occurrences-After-Bigram"><span class="nav-number">8.</span> <span class="nav-text">Leetcode1078. Occurrences After Bigram</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1079-Letter-Tile-Possibilities"><span class="nav-number">9.</span> <span class="nav-text">Leetcode1079. Letter Tile Possibilities</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode1089-Duplicate-Zeros"><span class="nav-number">10.</span> <span class="nav-text">Leetcode1089. Duplicate Zeros</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  


  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
