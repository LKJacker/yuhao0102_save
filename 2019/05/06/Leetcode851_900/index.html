<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Leetcode,">










<meta name="description" content="Leetcode852. Peak Index in a Mountain ArrayLet’s call an array A a mountain if the following properties hold: A.length &amp;gt;= 3There exists some 0 &amp;lt; i &amp;lt; A.length - 1 such that A[0] &amp;lt; A[1] &amp;lt;">
<meta name="keywords" content="Leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode850 - 900">
<meta property="og:url" content="http://yoursite.com/2019/05/06/Leetcode851_900/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Leetcode852. Peak Index in a Mountain ArrayLet’s call an array A a mountain if the following properties hold: A.length &amp;gt;= 3There exists some 0 &amp;lt; i &amp;lt; A.length - 1 such that A[0] &amp;lt; A[1] &amp;lt;">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20200526000300.png">
<meta property="og:image" content="http://yoursite.com/img/20190825104.png">
<meta property="og:image" content="http://yoursite.com/img/20190827001.png">
<meta property="og:image" content="http://yoursite.com/img/20190827002.png">
<meta property="og:image" content="http://yoursite.com/img/fivetrees.png">
<meta property="og:updated_time" content="2020-05-25T15:34:03.298Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode850 - 900">
<meta name="twitter:description" content="Leetcode852. Peak Index in a Mountain ArrayLet’s call an array A a mountain if the following properties hold: A.length &amp;gt;= 3There exists some 0 &amp;lt; i &amp;lt; A.length - 1 such that A[0] &amp;lt; A[1] &amp;lt;">
<meta name="twitter:image" content="http://yoursite.com/img/20200526000300.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/06/Leetcode851_900/">





  <title>Leetcode850 - 900 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/06/Leetcode851_900/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode850 - 900</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-06T13:52:39+08:00">
                2019-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Leetcode852-Peak-Index-in-a-Mountain-Array"><a href="#Leetcode852-Peak-Index-in-a-Mountain-Array" class="headerlink" title="Leetcode852. Peak Index in a Mountain Array"></a>Leetcode852. Peak Index in a Mountain Array</h1><p>Let’s call an array A a mountain if the following properties hold:</p>
<p>A.length &gt;= 3<br>There exists some 0 &lt; i &lt; A.length - 1 such that A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]<br>Given an array that is definitely a mountain, return any i such that A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1].</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,2,1,0]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>3 &lt;= A.length &lt;= 10000<br>0 &lt;= A[i] &lt;= 10^6<br>A is a mountain, as defined above.</p>
<p>判断一个“山峰”数组的山峰在哪里，本来以为还要判断这个是不是山峰数组的，所以多写了一些，对结果没影响，懒得删了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int peakIndexInMountainArray(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        int res;</span><br><span class="line">        bool isreal=false;</span><br><span class="line">        if(A.size()&lt;3)</span><br><span class="line">            return false;</span><br><span class="line">        for(int i=1;i&lt;A.size();i++)&#123;</span><br><span class="line">            if(A[i]&gt;A[i-1])</span><br><span class="line">                if(!isreal)</span><br><span class="line">                    continue;</span><br><span class="line">            if(A[i]&lt;A[i-1])&#123;</span><br><span class="line">                if(!isreal)&#123;</span><br><span class="line">                    res=i-1;</span><br><span class="line">                    isreal=true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我这个做法不好，可以用二分查找。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int peakIndexInMountainArray(int[] A) &#123;</span><br><span class="line">        int lo = 0, hi = A.length - 1;</span><br><span class="line">        while (lo &lt; hi) &#123;</span><br><span class="line">            int mi = lo + (hi - lo) / 2;</span><br><span class="line">            if (A[mi] &lt; A[mi + 1])</span><br><span class="line">                lo = mi + 1;</span><br><span class="line">            else</span><br><span class="line">                hi = mi;</span><br><span class="line">        &#125;</span><br><span class="line">        return lo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode858-Mirror-Reflection"><a href="#Leetcode858-Mirror-Reflection" class="headerlink" title="Leetcode858. Mirror Reflection"></a>Leetcode858. Mirror Reflection</h1><p>There is a special square room with mirrors on each of the four walls.  Except for the southwest corner, there are receptors on each of the remaining corners, numbered 0, 1, and 2.</p>
<p>The square room has walls of length p, and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor.</p>
<p>Return the number of the receptor that the ray meets first.  (It is guaranteed that the ray will meet a receptor eventually.)<br><img src="/img/20200526000300.png" alt></p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: p = 2, q = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The ray meets receptor 2 the first time it gets reflected back to the left wall.</span><br></pre></td></tr></table></figure></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>存在一个方形空间，如上图所示，一束光从左下角射出，方形空间的四条边都会反射，在0,1,2处存在3个接收器，问，给定方形空间的边长 p 和第一次到达右边界时距离0号接收器的距离，这束光最终会落到哪个接收器上？</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先对于给定的p,q，如果我们把这两个数都同时放大N倍，光线的走法结果不会改变，因此，首先要找p,q得最大公约数，使得p,q互质；<br>然后，当p,q互质时，不可能两个都是偶数，因此分情况，当p为偶数，q为奇数时，光线会一直走右边界的奇数坐标（1,3,5,7….）,然后再走左边的偶数坐标，因此最终必定会走到左边界，即2号接收器；若p为奇数，q为偶数，那么光线射到右边界时是偶数坐标，射到左边界时也是偶数坐标，而由于边长p是奇数，因此最终是不会走到左边界或右边界，即不会到接收器1和2，而是经过1,2之间的边界进行反向，然后往下走，而下面只有接收器0，因此最终必定会走到0；若p是奇数，且q也是奇数，那么光线到右边界时是奇数坐标，到左边界时是偶数坐标，因此最终一定走到接收器1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    int gcd(int m, int n) &#123;</span><br><span class="line">        int temp;</span><br><span class="line">        while(n != 0) &#123;</span><br><span class="line">            temp = m % n;</span><br><span class="line">            m = n;</span><br><span class="line">            n = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return m;</span><br><span class="line">    &#125;</span><br><span class="line">    int mirrorReflection(int p, int q) &#123;</span><br><span class="line">        int temp = gcd(p, q);</span><br><span class="line">        p = p / temp;</span><br><span class="line">        q = q / temp;</span><br><span class="line">        if(p%2==0)</span><br><span class="line">		    return 2;</span><br><span class="line">	    else if(q%2==0)</span><br><span class="line">		    return 0;</span><br><span class="line">	    else</span><br><span class="line">		    return 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode859-Buddy-Strings"><a href="#Leetcode859-Buddy-Strings" class="headerlink" title="Leetcode859. Buddy Strings"></a>Leetcode859. Buddy Strings</h1><p>Given two strings A and B of lowercase letters, return true if and only if we can swap two letters in A so that the result equals B.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;ab&quot;, B = &quot;ba&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;ab&quot;, B = &quot;ab&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;aa&quot;, B = &quot;aa&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;aaaaaaabc&quot;, B = &quot;aaaaaaacb&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;&quot;, B = &quot;aa&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ol>
<li>0 &lt;= A.length &lt;= 20000</li>
<li>0 &lt;= B.length &lt;= 20000</li>
<li>A and B consist only of lowercase letters.</li>
</ol>
<ul>
<li>如果两个字符串长度不相等，则返回 false。</li>
<li>如果两个字符串有超过两处位置，其对应字符不一致，返回 false。</li>
<li>如果仅有两处位置字符不相同，则分别判断这两处位置交换后是否相同。</li>
<li>如果仅有一处位置字符不相同，则返回 false。</li>
<li>如果没有位置字符不相同，则根据题意，我们不得不找到两处位置交换。如果字符串中有两处位置字符相同，则返回 true；否则返回 false。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool buddyStrings(string A, string B) &#123;</span><br><span class="line">        int lengtha = A.length(), lengthb = B.length();</span><br><span class="line">        if(lengtha != lengthb)</span><br><span class="line">            return false;</span><br><span class="line">        int flag1 = -1, flag2 = -1;</span><br><span class="line">        for(int i = 0; i &lt; lengtha; i ++) &#123;</span><br><span class="line">            if(A[i] != B[i]) &#123;</span><br><span class="line">                if(flag1 != -1) &#123;</span><br><span class="line">                    if(flag2 != -1)</span><br><span class="line">                        return false;</span><br><span class="line">                    else</span><br><span class="line">                        flag2 = i;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    flag1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag1 == -1 &amp;&amp; flag2 == -1) &#123;</span><br><span class="line">            vector&lt;int&gt; aa = vector&lt;int&gt;(26, 0);</span><br><span class="line">            for(int i = 0; i &lt; lengtha; i ++) &#123;</span><br><span class="line">                aa[A[i] - &apos;a&apos;] ++;</span><br><span class="line">                if(aa[A[i] - &apos;a&apos;] &gt;= 2)</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(A[flag1] != B[flag2] || A[flag2] != B[flag1])</span><br><span class="line">            return false;</span><br><span class="line">        if(flag1 != -1 &amp;&amp; flag2 == -1)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode860-Lemonade-Change"><a href="#Leetcode860-Lemonade-Change" class="headerlink" title="Leetcode860. Lemonade Change"></a>Leetcode860. Lemonade Change</h1><p>At a lemonade stand, each lemonade costs $5. </p>
<p>Customers are standing in a queue to buy from you, and order one at a time (in the order specified by bills).</p>
<p>Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill.  You must provide the correct change to each customer, so that the net transaction is that the customer pays $5.</p>
<p>Note that you don’t have any change in hand at first.</p>
<p>Return true if and only if you can provide every customer with correct change.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,5,5,10,20]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Explanation: </p>
<ul>
<li>From the first 3 customers, we collect three $5 bills in order.</li>
<li>From the fourth customer, we collect a $10 bill and give back a $5.</li>
<li>From the fifth customer, we give a $10 bill and a $5 bill.</li>
<li>Since all customers got correct change, we output true.</li>
</ul>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,5,10]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [10,10]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,5,10,10,20]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Explanation: </p>
<ul>
<li>From the first two customers in order, we collect two $5 bills.</li>
<li>For the next two customers in order, we collect a $10 bill and give back a $5 bill.</li>
<li>For the last customer, we can’t give change of $15 back because we only have two $10 bills.</li>
<li>Since not every customer received correct change, the answer is false.</li>
</ul>
<p>Note:</p>
<ol>
<li>0 &lt;= bills.length &lt;= 10000</li>
<li>bills[i] will be either 5, 10, or 20.</li>
</ol>
<p>题目大意:卖lemon，5块钱一个，现在有3种面值的钞票分别为10，20，5，开始的时候没有找零的钱，问能否让每个人都有找零。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123;</span><br><span class="line">        int length = bills.size();</span><br><span class="line">        int cnt5 = 0, cnt10 = 0, cnt20 = 0;</span><br><span class="line">        for(int i = 0; i &lt; length; i ++) &#123;</span><br><span class="line">            if(bills[i] == 5)</span><br><span class="line">                cnt5 ++;</span><br><span class="line">            else if(bills[i] == 10) &#123;</span><br><span class="line">                if(cnt5 &lt;= 0)</span><br><span class="line">                    return false;</span><br><span class="line">                else &#123;</span><br><span class="line">                    cnt5 --;</span><br><span class="line">                    cnt10 ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(bills[i] == 20) &#123;</span><br><span class="line">                if(cnt10 &lt;= 0) &#123;</span><br><span class="line">                    if(cnt5&lt;3)</span><br><span class="line">                        return false;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        cnt5 -= 3;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    if(cnt5 &lt; 1)</span><br><span class="line">                        return false;</span><br><span class="line">                    cnt5 --;</span><br><span class="line">                    cnt10 --;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode861-Score-After-Flipping-Matrix"><a href="#Leetcode861-Score-After-Flipping-Matrix" class="headerlink" title="Leetcode861. Score After Flipping Matrix"></a>Leetcode861. Score After Flipping Matrix</h1><p>We have a two dimensional matrix A where each value is 0 or 1.</p>
<p>A move consists of choosing any row or column, and toggling each value in that row or column: changing all 0s to 1s, and all 1s to 0s.</p>
<p>After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.</p>
<p>Return the highest possible score.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]]</span><br><span class="line">Output: 39</span><br><span class="line">Explanation:</span><br><span class="line">Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]].</span><br><span class="line">0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= A.length &lt;= 20<br>1 &lt;= A[0].length &lt;= 20<br>A[i][j] is 0 or 1.</p>
<p>思路：对一个只有0和1的二维矩阵，移动是指选择任一行或任一列，将所有的0变成1，所有的1变成0，在作出任意次数的移动后，将该矩阵中的每一行都按照二进制数来解释，输出和的最大值。要注意的是行和列任意次移动，达到最大值。即以求出最优解为目标（可重复移动）。按二进制数来解释，注意数组[0-n]对应二进制“高位-低位”。</p>
<p>首先对行移动求最优解：二进制数，高位的有效值“1”大于后面所有位数之和，举个例子：10000=16   01010=10   00111=7。所以我们需要判断A[i]<a href="每行首元素">0</a>是否为“1”，将为“0”的进行移动操作，本行即达到最优。重复每行即为所有行最优</p>
<p>再对列移动求最优解：本题为矩阵，所以同一列的数字在二进制解释中位于相同的位置（2^n），当一列中”1”的数量最大时,结果值最大。即为列最优解，同理求出所有列最优解。</p>
<p>最后计算矩阵的总和，注意从低位（数组尾部开始计算）。</p>
<ol>
<li>若行最高位（数组行首元素）不为“1”，移动行。</li>
<li>若列“0”数量多于“1”，移动列。</li>
<li>从低位（行数组尾部）开始计算数组行值。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int matrixScore(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123;</span><br><span class="line">        for(int i=0;i&lt;A.size();i++)</span><br><span class="line">            if(A[i][0]==0)</span><br><span class="line">                for(int j=0;j&lt;A[i].size();j++)</span><br><span class="line">                    A[i][j]=1-A[i][j];</span><br><span class="line">        </span><br><span class="line">        for(int j=0;j&lt;A[0].size();j++)&#123;</span><br><span class="line">            int zero=0,one=0;</span><br><span class="line">            for(int i=0;i&lt;A.size();i++)&#123;</span><br><span class="line">                if(A[i][j]==0)</span><br><span class="line">                    zero++;</span><br><span class="line">                else</span><br><span class="line">                    one++;</span><br><span class="line">            &#125;</span><br><span class="line">            if(zero&gt;one)</span><br><span class="line">                for(int i=0;i&lt;A.size();i++)</span><br><span class="line">                    A[i][j]=1-A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        int sum=0;</span><br><span class="line">        for(int i=0;i&lt;A.size();i++)&#123;</span><br><span class="line">            int temp = 0,in=1;</span><br><span class="line">            for(int j=A[i].size()-1;j&gt;=0;j--)&#123;</span><br><span class="line">                temp+=A[i][j]*in;</span><br><span class="line">                in*=2;</span><br><span class="line">            &#125;</span><br><span class="line">            sum+=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>附上Solution：</p>
<p>Notice that a 1 in the i’th column from the right, contributes 2^i to the score.</p>
<p>Say we are finished toggling the rows in some configuration. Then for each column, (to maximize the score), we’ll toggle the column if it would increase the number of 1s.</p>
<p>We can brute force over every possible way to toggle rows.</p>
<p>Say the matrix has R rows and C columns.</p>
<p>For each state, the transition <code>trans = state ^ (state-1)</code> represents the rows that must be toggled to get into the state of toggled rows represented by (the bits of) state.</p>
<p>We’ll toggle them, and also maintain the correct column sums of the matrix on the side.</p>
<p>Afterwards, we’ll calculate the score. If for example the last column has a column sum of 3, then the score is max(3, R-3), where R-3 represents the score we get from toggling the last column.</p>
<p>In general, the score is increased by max(col_sum, R - col_sum) * (1 &lt;&lt; (C-1-c)), where the factor (1 &lt;&lt; (C-1-c)) is the power of 2 that each 1 contributes.</p>
<p>Note that this approach may not run in the time allotted.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int matrixScore(int[][] A) &#123;</span><br><span class="line">        int R = A.length, C = A[0].length;</span><br><span class="line">        int[] colsums = new int[C];</span><br><span class="line">        for (int r = 0; r &lt; R; ++r)</span><br><span class="line">            for (int c = 0; c &lt; C; ++c)</span><br><span class="line">                colsums[c] += A[r][c];</span><br><span class="line"></span><br><span class="line">        int ans = 0;</span><br><span class="line">        for (int state = 0; state &lt; (1&lt;&lt;R); ++state) &#123;</span><br><span class="line">            // Toggle the rows so that after, &apos;state&apos; represents</span><br><span class="line">            // the toggled rows.</span><br><span class="line">            if (state &gt; 0) &#123;</span><br><span class="line">                int trans = state ^ (state-1);</span><br><span class="line">                for (int r = 0; r &lt; R; ++r) &#123;</span><br><span class="line">                    if (((trans &gt;&gt; r) &amp; 1) &gt; 0) &#123;</span><br><span class="line">                        for (int c = 0; c &lt; C; ++c) &#123;</span><br><span class="line">                            colsums[c] += A[r][c] == 1 ? -1 : 1;</span><br><span class="line">                            A[r][c] ^= 1;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Calculate the score with the rows toggled by &apos;state&apos;</span><br><span class="line">            int score = 0;</span><br><span class="line">            for (int c = 0; c &lt; C; ++c)</span><br><span class="line">                score += Math.max(colsums[c], R - colsums[c]) * (1 &lt;&lt; (C-1-c));</span><br><span class="line">            ans = Math.max(ans, score);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode867-Transpose-Matrix"><a href="#Leetcode867-Transpose-Matrix" class="headerlink" title="Leetcode867. Transpose Matrix"></a>Leetcode867. Transpose Matrix</h1><p>Given a matrix A, return the transpose of A.</p>
<p>The transpose of a matrix is the matrix flipped over it’s main diagonal, switching the row and column indices of the matrix.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [[1,4,7],[2,5,8],[3,6,9]]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2,3],[4,5,6]]</span><br><span class="line">Output: [[1,4],[2,5],[3,6]]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ol>
<li>1 &lt;= A.length &lt;= 1000</li>
<li>1 &lt;= A[0].length &lt;= 1000</li>
</ol>
<p>Easy题目，矩阵转置基本操作，i,j下标对调<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; transpose(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123;</span><br><span class="line">        int m = A.size(), n = A[0].size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; result(n, vector&lt;int&gt;(m, 0));</span><br><span class="line">        for(int i = 0; i &lt; m; i ++)</span><br><span class="line">            for(int j = 0; j &lt; n; j ++)</span><br><span class="line">                result[j][i] = A[i][j];</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode874-Walking-Robot-Simulation"><a href="#Leetcode874-Walking-Robot-Simulation" class="headerlink" title="Leetcode874. Walking Robot Simulation"></a>Leetcode874. Walking Robot Simulation</h1><p>A robot on an infinite grid starts at point (0, 0) and faces north.  The robot can receive one of three possible types of commands:</p>
<ul>
<li>-2: turn left 90 degrees</li>
<li>-1: turn right 90 degrees</li>
<li>1 &lt;= x &lt;= 9: move forward x units</li>
<li>Some of the grid squares are obstacles. </li>
</ul>
<p>The i-th obstacle is at grid point (obstacles[i][0], obstacles[i][1])</p>
<p>If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.)</p>
<p>Return the square of the maximum Euclidean distance that the robot will be from the origin.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: commands = [4,-1,3], obstacles = []</span><br><span class="line">Output: 25</span><br><span class="line">Explanation: robot will go to (3, 4)</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]]</span><br><span class="line">Output: 65</span><br><span class="line">Explanation: robot will be stuck at (1, 4) before turning left and going to (1, 8)</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ol>
<li>0 &lt;= commands.length &lt;= 10000</li>
<li>0 &lt;= obstacles.length &lt;= 10000</li>
<li>-30000 &lt;= obstacle[i][0] &lt;= 30000</li>
<li>-30000 &lt;= obstacle[i][1] &lt;= 30000</li>
<li>The answer is guaranteed to be less than 2 ^ 31.</li>
</ol>
<p>把障碍存在一个set里，方便以后查找判断。每次计算目前最大的x^2 + y^2，用一个大小为2的数组来表示X、Y坐标，之后只需要用axis=0来表示X，axis=1来表示Y即可，不需要知道到底是哪个轴。在进行移动的时候，每次只走一格，计算max_square。值得注意的是，max_square的初始值为0，因为如果被障碍遮挡或者根本没有移动指令导致原地不动的情况下，最大值是0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int robotSim(vector&lt;int&gt;&amp; commands, vector&lt;vector&lt;int&gt;&gt;&amp; obstacles) &#123;</span><br><span class="line">        set&lt;pair&lt;int, int&gt;&gt; obs;</span><br><span class="line">        for(int i = 0; i &lt; obstacles.size(); i++)</span><br><span class="line">            obs.insert(make_pair(obstacles[i][0], obstacles[i][1]));</span><br><span class="line">        </span><br><span class="line">        int coord[2] = &#123;0, 0&#125;, dir = 1; // x-y coordinate 0: x, 1: y, 2: -x, 3: -y</span><br><span class="line">        int result = 0;</span><br><span class="line">        for(int i = 0; i &lt; commands.size(); i ++) &#123;</span><br><span class="line">            if(commands[i] == -2) </span><br><span class="line">                dir = (dir+1) % 4;</span><br><span class="line">            else if(commands[i] == -1) </span><br><span class="line">                dir = (dir+3) % 4;</span><br><span class="line">            else &#123;</span><br><span class="line">                int axis, forward;</span><br><span class="line">                switch(dir)</span><br><span class="line">                &#123;</span><br><span class="line">                    case 0:</span><br><span class="line">                        axis = 0;  forward = 1;</span><br><span class="line">                        break;</span><br><span class="line">                    case 1:</span><br><span class="line">                        axis = 1;  forward = 1;</span><br><span class="line">                        break;</span><br><span class="line">                    case 2:</span><br><span class="line">                        axis = 0;  forward = -1;</span><br><span class="line">                        break;</span><br><span class="line">                    case 3:</span><br><span class="line">                        axis = 1;  forward = -1;</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">                for(int m = 0; m &lt; commands[i]; m ++) &#123;</span><br><span class="line">                    coord[axis] += forward;</span><br><span class="line">                    if(obs.find(make_pair(coord[0], coord[1])) != obs.end()) &#123;</span><br><span class="line">                        coord[axis] -= forward;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    result = max(result, coord[0]*coord[0] + coord[1]*coord[1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode876-Middle-of-the-Linked-List"><a href="#Leetcode876-Middle-of-the-Linked-List" class="headerlink" title="Leetcode876. Middle of the Linked List"></a>Leetcode876. Middle of the Linked List</h1><p>Given a non-empty, singly linked list with head node head, return a middle node of linked list.</p>
<p>If there are two middle nodes, return the second middle node.</p>
<p>Example 1:</p>
<p>Input: [1,2,3,4,5]<br>Output: Node 3 from this list (Serialization: [3,4,5])<br>The returned node has value 3.  (The judge’s serialization of this node is [3,4,5]).<br>Note that we returned a ListNode object ans, such that:<br>ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.<br>Example 2:</p>
<p>Input: [1,2,3,4,5,6]<br>Output: Node 4 from this list (Serialization: [4,5,6])<br>Since the list has two middle nodes with values 3 and 4, we return the second one.</p>
<p>Note:</p>
<p>The number of nodes in the given list will be between 1 and 100.</p>
<p>题目大意：求链表的中间节点</p>
<p>思路：构造两个节点，遍历链接，一个每次走一步，另一个每次走两步，一个遍历完链表，另一个恰好在中间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* middleNode(ListNode* head) &#123;</span><br><span class="line">        if(head == NULL || head-&gt;next == NULL) </span><br><span class="line">            return head;</span><br><span class="line">        ListNode* p = head, *pp = head;</span><br><span class="line">        while(pp != NULL &amp;&amp; pp-&gt;next != NULL)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            pp = pp-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, p-&gt;val);</span><br><span class="line">        return p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>久仰大名的快慢指针做法，但是这里有坑，一定要注意while里的判断条件是两个，保证在有奇数个数和偶数个数的链表都不会访问空指针。</p>
<h1 id="Leetcode883-Projection-Area-of-3D-Shapes"><a href="#Leetcode883-Projection-Area-of-3D-Shapes" class="headerlink" title="Leetcode883. Projection Area of 3D Shapes"></a>Leetcode883. Projection Area of 3D Shapes</h1><p>On a N <em> N grid, we place some 1 </em> 1 * 1 cubes that are axis-aligned with the x, y, and z axes.</p>
<p>Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j).</p>
<p>Now we view the projection of these cubes onto the xy, yz, and zx planes.</p>
<p>A projection is like a shadow, that maps our 3 dimensional figure to a 2 dimensional plane. </p>
<p>Here, we are viewing the “shadow” when looking at the cubes from the top, the front, and the side.</p>
<p>Return the total area of all three projections.</p>
<p>Example 1:</p>
<p>Input: [[2]]<br>Output: 5<br>Example 2:<br><img src="/img/20190825104.png" alt></p>
<p>Input: [[1,2],[3,4]]<br>Output: 17<br>Explanation:<br>Here are the three projections (“shadows”) of the shape made with each axis-aligned plane.</p>
<p>Example 3:</p>
<p>Input: [[1,0],[0,2]]<br>Output: 8<br>Example 4:</p>
<p>Input: [[1,1,1],[1,0,1],[1,1,1]]<br>Output: 14<br>Example 5:</p>
<p>Input: [[2,2,2],[2,1,2],[2,2,2]]<br>Output: 21</p>
<p>Note:</p>
<p>1 &lt;= grid.length = grid[0].length &lt;= 50<br>0 &lt;= grid[i][j] &lt;= 50</p>
<p>投影题，之前做过类似的，从上往下看的数量是不为零的格子数，从左往右看和从右往左看是每行（或列）最高的，求和。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int projectionArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int x = grid.size();</span><br><span class="line">        int y = grid[0].size();</span><br><span class="line">        int res = 0;</span><br><span class="line">        int max;</span><br><span class="line">        for(int i = 0; i &lt; x; i ++)</span><br><span class="line">            for(int j = 0; j &lt; y; j ++)</span><br><span class="line">                if(grid[i][j] != 0)</span><br><span class="line">                    res ++;</span><br><span class="line">        for(int i = 0; i &lt; x; i ++)&#123;</span><br><span class="line">            max = -1;</span><br><span class="line">            for(int j = 0; j &lt; y; j ++)</span><br><span class="line">                if(grid[i][j] &gt; max)</span><br><span class="line">                    max = grid[i][j];</span><br><span class="line">            res += max;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; y; i ++)&#123;</span><br><span class="line">            max = -1;</span><br><span class="line">            for(int j = 0; j &lt; x; j ++)</span><br><span class="line">                if(grid[j][i] &gt; max)</span><br><span class="line">                    max = grid[j][i];</span><br><span class="line">            res += max;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int projectionArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int N = grid.size();</span><br><span class="line">        int ans = 0;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; N;  ++i) &#123;</span><br><span class="line">            int bestRow = 0;  // largest of grid[i][j]</span><br><span class="line">            int bestCol = 0;  // largest of grid[j][i]</span><br><span class="line">            for (int j = 0; j &lt; N; ++j) &#123;</span><br><span class="line">                if (grid[i][j] &gt; 0) ans++;  // top shadow</span><br><span class="line">                bestRow = max(bestRow, grid[i][j]);</span><br><span class="line">                bestCol = max(bestCol, grid[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans += bestRow + bestCol;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode884-Uncommon-Words-from-Two-Sentences"><a href="#Leetcode884-Uncommon-Words-from-Two-Sentences" class="headerlink" title="Leetcode884 Uncommon Words from Two Sentences"></a>Leetcode884 Uncommon Words from Two Sentences</h1><p>We are given two sentences A and B.  (A sentence is a string of space separated words.  Each word consists only of lowercase letters.)</p>
<p>A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.</p>
<p>Return a list of all uncommon words. </p>
<p>You may return the list in any order.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;this apple is sweet&quot;, B = &quot;this apple is sour&quot;</span><br><span class="line">Output: [&quot;sweet&quot;,&quot;sour&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;apple apple&quot;, B = &quot;banana&quot;</span><br><span class="line">Output: [&quot;banana&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ol>
<li>0 &lt;= A.length &lt;= 200</li>
<li>0 &lt;= B.length &lt;= 200</li>
<li>A and B both contain only spaces and lowercase letters.</li>
</ol>
<p>把单词合并然后找到只出现过一次的就好。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; uncommonFromSentences(string A, string B) &#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        map&lt;string, int&gt; mapp;</span><br><span class="line">        string temp;</span><br><span class="line">        for(int i = 0; i &lt; A.length(); i ++) &#123;</span><br><span class="line">            temp = &quot;&quot;;</span><br><span class="line">            while(i &lt; A.length() &amp;&amp; A[i] != &apos; &apos;)</span><br><span class="line">                temp += A[i++];</span><br><span class="line">            cout&lt;&lt;temp&lt;&lt;endl;</span><br><span class="line">            if(mapp.find(temp) == mapp.end())</span><br><span class="line">                mapp[temp] = 1;</span><br><span class="line">            else </span><br><span class="line">                mapp[temp] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0; i &lt; B.length(); i ++) &#123;</span><br><span class="line">            temp = &quot;&quot;;</span><br><span class="line">            while(i &lt; B.length() &amp;&amp; B[i] != &apos; &apos;)</span><br><span class="line">                temp += B[i++];</span><br><span class="line">            cout&lt;&lt;temp&lt;&lt;endl;</span><br><span class="line">            if(mapp.find(temp) == mapp.end())</span><br><span class="line">                mapp[temp] = 1;</span><br><span class="line">            else </span><br><span class="line">                mapp[temp] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(auto iter = mapp.begin(); iter != mapp.end(); iter ++) &#123;</span><br><span class="line">            if(iter-&gt;second == 1)</span><br><span class="line">                result.push_back(iter-&gt;first);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>简洁做法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; uncommonFromSentences(string A, string B) &#123;</span><br><span class="line">        unordered_map&lt;string, int&gt; count;</span><br><span class="line">        istringstream iss(A + &quot; &quot; + B);</span><br><span class="line">        while (iss &gt;&gt; A) count[A]++;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        for (auto w: count)</span><br><span class="line">            if (w.second == 1)</span><br><span class="line">                res.push_back(w.first);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode885-Spiral-Matrix-III"><a href="#Leetcode885-Spiral-Matrix-III" class="headerlink" title="Leetcode885. Spiral Matrix III"></a>Leetcode885. Spiral Matrix III</h1><p>On a 2 dimensional grid with R rows and C columns, we start at (r0, c0) facing east.</p>
<p>Here, the north-west corner of the grid is at the first row and column, and the south-east corner of the grid is at the last row and column.</p>
<p>Now, we walk in a clockwise spiral shape to visit every position in this grid. </p>
<p>Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) </p>
<p>Eventually, we reach all R * C spaces of the grid.</p>
<p>Return a list of coordinates representing the positions of the grid in the order they were visited.</p>
<p>Example 1:</p>
<p>Input: R = 1, C = 4, r0 = 0, c0 = 0<br>Output: [[0,0],[0,1],[0,2],[0,3]]<br><img src="/img/20190827001.png" alt></p>
<p>Example 2:</p>
<p>Input: R = 5, C = 6, r0 = 1, c0 = 4<br>Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]<br><img src="/img/20190827002.png" alt></p>
<p>给定起点（r0,c0），螺旋走路，输出经过的点坐标，简单，只是注意细节。按照顺序，先向右走，再向下走，再向左走，再向上走，经观察发现每个方向的步数依次为1,1,2,2,3,3,…，依次类推，按照步骤走即可，发现不在网格内就跳过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    int dir[4][4]=&#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; spiralMatrixIII(int R, int C, int r0, int c0) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        res.push_back(&#123;r0, c0&#125;);</span><br><span class="line">        </span><br><span class="line">        for(int i = 1; res.size() &lt; R * C; i += 2)&#123;</span><br><span class="line">            for(int j = 0; j &lt; 2; j ++)&#123;</span><br><span class="line">                for (int k = 0; k &lt; i; k++) &#123;</span><br><span class="line">                    r0 += dir[j][0];</span><br><span class="line">                    c0 += dir[j][1];</span><br><span class="line">                    if(0 &lt;= r0 &amp;&amp; r0 &lt; R &amp;&amp; 0 &lt;= c0 &amp;&amp; c0 &lt; C)</span><br><span class="line">                        res.push_back(&#123;r0,c0&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j = 2; j &lt; 4; j ++)&#123;</span><br><span class="line">                for (int k = 0; k &lt; i+1; k++) &#123;</span><br><span class="line">                    r0 += dir[j][0];</span><br><span class="line">                    c0 += dir[j][1];</span><br><span class="line">                    if(0 &lt;= r0 &amp;&amp; r0 &lt; R &amp;&amp; 0 &lt;= c0 &amp;&amp; c0 &lt; C)</span><br><span class="line">                        res.push_back(&#123;r0,c0&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个大佬给了三种做法：</p>
<p>这道题给了我们一个二维矩阵，还给了其中一个位置，让从这个位置开始螺旋打印矩阵。首先是打印给定的位置，然后向右走一位，打印出来，再向下方走一位打印，再向左边走两位打印，再向上方走三位打印，以此类推，螺旋打印。那仔细观察，可以发现，刚开始只是走一步，后来步子越来越大，若只看每个方向走的距离，可以得到如下数组 1,1,2,2,3,3… </p>
<p>步长有了，下面就是方向了，由于确定了起始是向右走，那么方向就是 右-&gt;下-&gt;左-&gt;上 这样的循环。方向和步长都分析清楚了，现在就可以尝试进行遍历了。由于最终是会遍历完所有的位置的，那么最后结果 res 里面的位置个数一定是等于 RxC 的，所以循环的条件就是当结果 res 中的位置数小于<code>R*C</code>。我们还需要一个变量 step 表示当前的步长，初始化为1。</p>
<p>在循环中，首先要向右走 step 步，一步一步走，走到一个新的位置上，要进行判断，若当前位置没有越界，才能加入结果 res 中，由于每次都要判断，所以把这部分抽取出来，放到一个子函数中。由于是向右走，每走一步之后，c0 都要自增1。右边走完了之后，再向下方走 step 步，同理，每走一步之后，要将 r0 自增1。再向左边走之前，要将步数增1，不然无法形成正确的螺旋，同理，再完成向上方走 step 步之后，step 要再增1，参见代码如下：</p>
<p>解法一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; spiralMatrixIII(int R, int C, int r0, int c0) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        int step = 1;</span><br><span class="line">        while (res.size() &lt; R * C) &#123;</span><br><span class="line">            for (int i = 0; i &lt; step; ++i) add(R, C, r0, c0++, res);</span><br><span class="line">            for (int i = 0; i &lt; step; ++i) add(R, C, r0++, c0, res);</span><br><span class="line">            ++step;</span><br><span class="line">            for (int i = 0; i &lt; step; ++i) add(R, C, r0, c0--, res);</span><br><span class="line">            for (int i = 0; i &lt; step; ++i) add(R, C, r0--, c0, res);</span><br><span class="line">            ++step;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void add(int R, int C, int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; res) &#123;</span><br><span class="line">        if (x &gt;= 0 &amp;&amp; x &lt; R &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; C) res.push_back(&#123;x, y&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以用两个数组 dirX 和 dirY 来控制下一个方向，就像迷宫遍历中的那样，这样只需要一个变量 cur，来分别到 dirX 和 dirY 中取值，初始化为0，表示向右的方向。从螺旋遍历的机制可以看出，每当向右或者向左前进时，步长就要加1，那么我们只要判断当 cur 为0或者2的时候，step 就自增1。由于 cur 初始化为0，所以刚开始 step 就会增1，那么就可以将 step 初始化为0，同时还需要把起始位置提前加入结果 res 中。此时在 while 循环中只需要一个 for 循环即可，朝当前的 cur 方向前进 step 步，r0 加上 dirX[cur]，c0 加上 dirY[cur]，若没有越界，则加入结果 res 中即可。之后记得 cur 要自增1，为了防止越界，对4取余，就像循环数组一样的操作，参见代码如下：</p>
<p>解法二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; spiralMatrixIII(int R, int C, int r0, int c0) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res&#123;&#123;r0, c0&#125;&#125;;</span><br><span class="line">        vector&lt;int&gt; dirX&#123;0, 1, 0, -1&#125;, dirY&#123;1, 0, -1, 0&#125;;</span><br><span class="line">        int step = 0, cur = 0;</span><br><span class="line">        while (res.size() &lt; R * C) &#123;</span><br><span class="line">            if (cur == 0 || cur == 2) ++step;</span><br><span class="line">            for (int i = 0; i &lt; step; ++i) &#123;</span><br><span class="line">                r0 += dirX[cur]; c0 += dirY[cur];</span><br><span class="line">                if (r0 &gt;= 0 &amp;&amp; r0 &lt; R &amp;&amp; c0 &gt;= 0 &amp;&amp; c0 &lt; C) res.push_back(&#123;r0, c0&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = (cur + 1) % 4;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们也可以不使用方向数组，若仔细观察 右-&gt;下-&gt;左-&gt;上 四个方向对应的值 (0, 1) -&gt; (1, 0) -&gt; (0, -1) -&gt; (-1, 0), 实际上，下一个位置的x值是当前的y值，下一个位置的y值是当前的-x值，因为两个方向是相邻的两个方向是垂直的，由向量的叉乘得到 (x, y, 0) × (0, 0, 1) = (y, -x, 0)。所以可以通过当前的x和y值，来计算出下一个位置的值。同理，根据之前的说的步长数组 1,1,2,2,3,3…，可以推出通项公式为 n/2 + 1，这样连步长变量 step 都省了，不过需要统计当前已经遍历的位置的个数，实在想偷懒，也可以用 res.size() 来代替，参见代码如下：</p>
<p>解法三：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; spiralMatrixIII(int R, int C, int r0, int c0) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; res&#123;&#123;r0, c0&#125;&#125;;</span><br><span class="line">        int x = 0, y = 1, t = 0;</span><br><span class="line">        for (int k = 0; res.size() &lt; R * C; ++k) &#123;</span><br><span class="line">            for (int i = 0; i &lt; k / 2 + 1; ++i) &#123;</span><br><span class="line">                r0 += x; c0 += y;</span><br><span class="line">                if (r0 &gt;= 0 &amp;&amp; r0 &lt; R &amp;&amp; c0 &gt;= 0 &amp;&amp; c0 &lt; C) res.push_back(&#123;r0, c0&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            t = x; x = y; y = -t;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode888-Fair-Candy-Swap"><a href="#Leetcode888-Fair-Candy-Swap" class="headerlink" title="Leetcode888. Fair Candy Swap"></a>Leetcode888. Fair Candy Swap</h1><p>Alice and Bob have candy bars of different sizes: A[i] is the size of the i-th bar of candy that Alice has, and B[j] is the size of the j-th bar of candy that Bob has.</p>
<p>Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy.  (The total amount of candy a person has is the sum of the sizes of candy bars they have.)</p>
<p>Return an integer array ans where ans[0] is the size of the candy bar that Alice must exchange, and ans[1] is the size of the candy bar that Bob must exchange.</p>
<p>If there are multiple answers, you may return any one of them.  It is guaranteed an answer exists.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,1], B = [2,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2], B = [2,3]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2], B = [1,3]</span><br><span class="line">Output: [2,3]</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2,5], B = [2,4]</span><br><span class="line">Output: [5,4]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 10000</li>
<li>1 &lt;= B.length &lt;= 10000</li>
<li>1 &lt;= A[i] &lt;= 100000</li>
<li>1 &lt;= B[i] &lt;= 100000</li>
<li>It is guaranteed that Alice and Bob have different total amounts of candy.</li>
<li>It is guaranteed there exists an answer.</li>
</ul>
<p>考虑到最终两个人的糖果总量相等，那么可以计算出最终这个相等的总量是多少。</p>
<p>比如1中的例子，A的总量是8，B的总量是6，那么平均下来每个人应该是7。</p>
<p>那么接下来就要在A中找到一个元素比B中某个元素大1的，逐个对比，可以发现交换5和4就可以达成目标。</p>
<p>其中逐个对比这个部分，难道我们要做一个双重循环吗？也没有必要。</p>
<p>我们先做一个升序排序，接着就是两个指针在A中和B中不断地移动就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; fairCandySwap(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B)</span><br><span class="line">&#123;</span><br><span class="line">    sort(A.begin(),A.end());//升序排序</span><br><span class="line">    sort(B.begin(),B.end());//升序排序</span><br><span class="line">    int sum1=0,sum2=0,sum3,cha,cha1;</span><br><span class="line">    for(int i:A)//sum1存储A中的总量</span><br><span class="line">        sum1+=i;</span><br><span class="line">    for(int i:B)//sum2存储B中的总量</span><br><span class="line">        sum2+=i;</span><br><span class="line">    sum3=(sum1+sum2)/2;//sum3是平均值</span><br><span class="line">    cha=sum1-sum3;//cha表示A和平均值之间的差，如果大于0，说明A要在B中找一个小cha这个数值的，如果小于0，同理</span><br><span class="line">    int i=0,j=0;</span><br><span class="line">    while(i&lt;A.size()&amp;&amp;j&lt;B.size())//i和j两个索引不断地向后走</span><br><span class="line">    &#123;</span><br><span class="line">        cha1=A[i]-B[j];</span><br><span class="line">        if(cha1==cha)//如果刚好等于，那么返回两个数值</span><br><span class="line">            return &#123;A[i],B[j]&#125;;</span><br><span class="line">        else if(cha1&lt;cha)//如果小于，那么说明A[i]数值太小，应该更大一点</span><br><span class="line">            i++;</span><br><span class="line">        else //如果大于，那么说明B[j]数值太小，应该更大一点</span><br><span class="line">            j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode890-Find-and-Replace-Pattern"><a href="#Leetcode890-Find-and-Replace-Pattern" class="headerlink" title="Leetcode890. Find and Replace Pattern"></a>Leetcode890. Find and Replace Pattern</h1><p>You have a list of words and a pattern, and you want to know which words in words matches the pattern.</p>
<p>A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.</p>
<p>(Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.)</p>
<p>Return a list of the words in words that match the given pattern. </p>
<p>You may return the answer in any order.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;], pattern = &quot;abb&quot;</span><br><span class="line">Output: [&quot;mee&quot;,&quot;aqq&quot;]</span><br><span class="line">Explanation: &quot;mee&quot; matches the pattern because there is a permutation &#123;a -&gt; m, b -&gt; e, ...&#125;. </span><br><span class="line">&quot;ccc&quot; does not match the pattern because &#123;a -&gt; c, b -&gt; c, ...&#125; is not a permutation,</span><br><span class="line">since a and b map to the same letter.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= words.length &lt;= 50<br>1 &lt;= pattern.length = words[i].length &lt;= 20</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    bool match(string word,string pattern)&#123;</span><br><span class="line">        int i,j;</span><br><span class="line">        bool seen[26];</span><br><span class="line">        map&lt;char,char&gt; table;</span><br><span class="line">        map&lt;char, char&gt;::iterator it;</span><br><span class="line">        for(i=0;i&lt;26;i++)</span><br><span class="line">            seen[i]=false;</span><br><span class="line">        for(j=0;j&lt;word.length();j++)&#123;</span><br><span class="line">            it = table.find(word[j]);</span><br><span class="line">            if(it==table.end())&#123;</span><br><span class="line">                table[word[j]]=pattern[j];</span><br><span class="line">            &#125;</span><br><span class="line">            if(table[word[j]]!=pattern[j] )</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for(i=0;i&lt;26;i++)</span><br><span class="line">            seen[i]=false;</span><br><span class="line">        for(it=table.begin();it!=table.end();it++)&#123;</span><br><span class="line">            if(seen[it-&gt;second-&apos;a&apos;])</span><br><span class="line">                return false;</span><br><span class="line">            seen[it-&gt;second-&apos;a&apos;]=true;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    vector&lt;string&gt; findAndReplacePattern(vector&lt;string&gt;&amp; words, string pattern) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        int i,j;</span><br><span class="line">       </span><br><span class="line">        for(i=0;i&lt;words.size();i++)&#123;</span><br><span class="line">            if(match(words[i],pattern))</span><br><span class="line">                res.push_back(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个题判断给定的字符串是不是符合pattern串的模式，很简单的题搞复杂了。用了一个map来匹配字符组合，用seen判断这个pattern字符是否出现过，如果出现过就是非法的了。</p>
<h1 id="Leetcode892-Surface-Area-of-3D-Shapes"><a href="#Leetcode892-Surface-Area-of-3D-Shapes" class="headerlink" title="Leetcode892. Surface Area of 3D Shapes"></a>Leetcode892. Surface Area of 3D Shapes</h1><p>On a N <em> N grid, we place some 1 </em> 1 * 1 cubes.</p>
<p>Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j).</p>
<p>Return the total surface area of the resulting shapes. </p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2]]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2],[3,4]]</span><br><span class="line">Output: 34</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,0],[0,2]]</span><br><span class="line">Output: 16</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">Output: 32</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2,2,2],[2,1,2],[2,2,2]]</span><br><span class="line">Output: 46</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= N &lt;= 50</li>
<li>0 &lt;= grid[i][j] &lt;= 50</li>
</ul>
<p>这道题给了我们一个二维数组 grid，其中 grid[i][j] 表示在位置 (i,j) 上累计的小正方体的个数，实际上就像搭积木一样，由这些小正方体来组成一个三维的物体，这里让我们求这个三维物体的表面积。我们知道每个小正方体的表面积是6，若在同一个位置累加两个，表面积就是10，三个累加到了一起就是14，其实是有规律的，n个小正方体累在一起，表面积是 4n+2。</p>
<p>现在不仅仅是累加在一个小正方体上，而是在 nxn 的区间，累加出一个三维物体。当中间的小方块缺失了之后，实际上缺失的地方会产生出四个新的面，而这四个面是应该算在表面积里的，但是用投影的方法是没法算进去的。无奈只能另辟蹊径，实际上这道题正确的思路是一个位置一个位置的累加表面积，就类似微积分的感觉，前面提到了当n个小正方体累到一起的表面积是 4n+2，而这个n就是每个位置的值 grid[i][j]，当你在旁边紧挨着再放一个累加的物体时，二者就会产生重叠，重叠的面数就是二者较矮的那堆正方体的个数再乘以2。</p>
<p>明白了这一点，我们就可以从 (0,0) 位置开始累加，先根据 grid[0][0] 的值算出若仅有该位置的三维物体的表面积，然后向 (0,1) 位置遍历，同样要先根据 grid[0][1] 的值算出若仅有该位置的三维物体的表面积，跟之前 grid[0][0] 的累加，然后再减去遮挡住的面积，通过 min(grid[0][0],grid[0][1])x2 来得到，这样每次可以计算出水平方向的遮挡面积，同时还需要减去竖直方向的遮挡面积 min(grid[i][j],grid[i-1][j])x2，这样才能算出正确的表面积.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    int surfaceArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int  n =grid.size(), res = 0;</span><br><span class="line">        for(int i = 0 ; i &lt; n; i ++)</span><br><span class="line">	        for(int j = 0; j &lt; n; j ++) &#123;</span><br><span class="line">		        if(grid[i][j] &gt; 0) &#123;</span><br><span class="line">                    res += 4 * grid[i][j] + 2;</span><br><span class="line">                    if(i &gt; 0) res -= min(grid[i][j], grid[i-1][j]) * 2;</span><br><span class="line">                    if(j &gt; 0) res -= min(grid[i][j], grid[i][j-1]) * 2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode894-All-Possible-Full-Binary-Trees"><a href="#Leetcode894-All-Possible-Full-Binary-Trees" class="headerlink" title="Leetcode894. All Possible Full Binary Trees"></a>Leetcode894. All Possible Full Binary Trees</h1><p>A full binary tree is a binary tree where each node has exactly 0 or 2 children.</p>
<p>Return a list of all possible full binary trees with N nodes.  Each element of the answer is the root node of one possible tree.</p>
<p>Each node of each tree in the answer must have node.val = 0.</p>
<p>You may return the final list of trees in any order.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 7</span><br><span class="line">Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]</span><br></pre></td></tr></table></figure></p>
<p>Explanation:<br><img src="/img/fivetrees.png" alt></p>
<p>给出了个N，代表一棵二叉树有N个节点，求所能构成的树。</p>
<p>解题方法<br>所有能构成的树，并且返回的不是数目，而是真正的树。所以一定会把所有的节点都求出来。一般就使用了递归。</p>
<p>这个题中，重点是返回一个列表，也就是说每个能够成的树的根节点都要放到这个列表里。而且当左子树、右子树的节点个数固定的时候，也会出现排列组合的情况，所以使用了两重for循环来完成所有的左右子树的组合。</p>
<p>另外的一个技巧就是，左右子树的个数一定是奇数个。</p>
<p>递归方法，虽然比较慢，但是容易理解，就是组成小的子树，一个个拼接，为啥要减1，是因为一定会有个根节点，先把这个减去再说。</p>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;TreeNode*&gt; allPossibleFBT(int N) &#123;</span><br><span class="line">        N--;</span><br><span class="line">        vector&lt;TreeNode*&gt; res;</span><br><span class="line">        if(N==0)&#123;</span><br><span class="line">            res.push_back(new TreeNode(0));</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; N; i += 2) &#123;</span><br><span class="line">            for (auto&amp; left : allPossibleFBT(i)) &#123;</span><br><span class="line">                for (auto&amp; right : allPossibleFBT(N - i)) &#123;</span><br><span class="line">                    TreeNode* root = new TreeNode(0);</span><br><span class="line">                    root-&gt;left = left;</span><br><span class="line">                    root-&gt;right = right;</span><br><span class="line">                    res.push_back(root);           </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode896-Monotonic-Array"><a href="#Leetcode896-Monotonic-Array" class="headerlink" title="Leetcode896. Monotonic Array"></a>Leetcode896. Monotonic Array</h1><p>An array is monotonic if it is either monotone increasing or monotone decreasing.</p>
<p>An array A is monotone increasing if for all i &lt;= j, A[i] &lt;= A[j].  An array A is monotone decreasing if for all i &lt;= j, A[i] &gt;= A[j].</p>
<p>Return true if and only if the given array A is monotonic.</p>
<p>判断数组是否单调。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    bool isMonotonic(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        bool inc=true, dec=true;</span><br><span class="line">        for(int i = 0; i &lt; A.size()-1; i ++) &#123;</span><br><span class="line">            if(A[i] &gt; A[i+1]) inc = false;</span><br><span class="line">            if(A[i] &lt; A[i+1]) dec = false;</span><br><span class="line">        &#125;</span><br><span class="line">        return inc || dec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode897-Increasing-Order-Search-Tree"><a href="#Leetcode897-Increasing-Order-Search-Tree" class="headerlink" title="Leetcode897. Increasing Order Search Tree"></a>Leetcode897. Increasing Order Search Tree</h1><p>Given a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child.</p>
<p>Example 1:<br>Input: [5,3,6,2,4,null,8,1,null,null,null,7,9]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">    3    6</span><br><span class="line">   / \    \</span><br><span class="line">  2   4    8</span><br><span class="line"> /        / \ </span><br><span class="line">1        7   9</span><br></pre></td></tr></table></figure></p>
<p>Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br><span class="line">           \</span><br><span class="line">            7</span><br><span class="line">             \</span><br><span class="line">              8</span><br><span class="line">               \</span><br><span class="line">                9</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>The number of nodes in the given tree will be between 1 and 100.<br>Each node will have a unique integer value from 0 to 1000.</p>
<p>本题要求把二叉树的结点重新排列，使其成为从小到大只有右孩子的二叉树。考虑使用中序遍历的迭代方法，对每个结点入栈，出栈时先访问左结点，然后中结点，最后把右指针和下一个入栈的结点链接起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    TreeNode* increasingBST(TreeNode* root) &#123;</span><br><span class="line">        if(root==NULL)</span><br><span class="line">            return NULL;</span><br><span class="line">        if(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            return root;</span><br><span class="line">        stack&lt;TreeNode*&gt; dst;</span><br><span class="line">        TreeNode *head = new TreeNode(0), *pre = head;</span><br><span class="line">        while(root || !dst.empty())&#123;</span><br><span class="line">            while(root)&#123;</span><br><span class="line">                dst.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = dst.top();</span><br><span class="line">            dst.pop();</span><br><span class="line">            pre-&gt;right=root;</span><br><span class="line">            pre = pre -&gt; right;</span><br><span class="line">            root -&gt; left = NULL;</span><br><span class="line">            root=root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        return head-&gt;right;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后朴素的中序遍历是这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Definition for a binary tree node.</span><br><span class="line">   * struct TreeNode &#123;</span><br><span class="line">   *     int val;</span><br><span class="line">   *     TreeNode *left;</span><br><span class="line">   *     TreeNode *right;</span><br><span class="line">   *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line">   * &#125;;</span><br><span class="line">   */</span><br><span class="line">class Solution &#123;</span><br><span class="line">	public:</span><br><span class="line">    </span><br><span class="line">    TreeNode *s=NULL,*p=NULL;</span><br><span class="line">    </span><br><span class="line">    void inorder(TreeNode* root)&#123;</span><br><span class="line">        if(root)&#123;</span><br><span class="line">            inorder(root-&gt;left);</span><br><span class="line">		            </span><br><span class="line">            if(s == NULL) &#123;</span><br><span class="line">                s = new TreeNode(root-&gt;val); </span><br><span class="line">                p = s;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                TreeNode* temp = new TreeNode(root-&gt;val);</span><br><span class="line">                s-&gt;right = temp;</span><br><span class="line">                s = s-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            inorder(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode* increasingBST(TreeNode* root) &#123;</span><br><span class="line">        if(root==NULL)</span><br><span class="line">            return NULL;</span><br><span class="line">        inorder(root);</span><br><span class="line">        </span><br><span class="line">        return p;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/06/Leetcode617/" rel="next" title="Leetcode617. Merge Two Binary Trees">
                <i class="fa fa-chevron-left"></i> Leetcode617. Merge Two Binary Trees
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/06/Cannon算法的原理实现/" rel="prev" title="Cannon算法的原理实现以及性能评测">
                Cannon算法的原理实现以及性能评测 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">236</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode852-Peak-Index-in-a-Mountain-Array"><span class="nav-number">1.</span> <span class="nav-text">Leetcode852. Peak Index in a Mountain Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode858-Mirror-Reflection"><span class="nav-number">2.</span> <span class="nav-text">Leetcode858. Mirror Reflection</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目大意："><span class="nav-number">2.1.</span> <span class="nav-text">题目大意：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路"><span class="nav-number">2.2.</span> <span class="nav-text">解题思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode859-Buddy-Strings"><span class="nav-number">3.</span> <span class="nav-text">Leetcode859. Buddy Strings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode860-Lemonade-Change"><span class="nav-number">4.</span> <span class="nav-text">Leetcode860. Lemonade Change</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode861-Score-After-Flipping-Matrix"><span class="nav-number">5.</span> <span class="nav-text">Leetcode861. Score After Flipping Matrix</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode867-Transpose-Matrix"><span class="nav-number">6.</span> <span class="nav-text">Leetcode867. Transpose Matrix</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode874-Walking-Robot-Simulation"><span class="nav-number">7.</span> <span class="nav-text">Leetcode874. Walking Robot Simulation</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode876-Middle-of-the-Linked-List"><span class="nav-number">8.</span> <span class="nav-text">Leetcode876. Middle of the Linked List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode883-Projection-Area-of-3D-Shapes"><span class="nav-number">9.</span> <span class="nav-text">Leetcode883. Projection Area of 3D Shapes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode884-Uncommon-Words-from-Two-Sentences"><span class="nav-number">10.</span> <span class="nav-text">Leetcode884 Uncommon Words from Two Sentences</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode885-Spiral-Matrix-III"><span class="nav-number">11.</span> <span class="nav-text">Leetcode885. Spiral Matrix III</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode888-Fair-Candy-Swap"><span class="nav-number">12.</span> <span class="nav-text">Leetcode888. Fair Candy Swap</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode890-Find-and-Replace-Pattern"><span class="nav-number">13.</span> <span class="nav-text">Leetcode890. Find and Replace Pattern</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode892-Surface-Area-of-3D-Shapes"><span class="nav-number">14.</span> <span class="nav-text">Leetcode892. Surface Area of 3D Shapes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode894-All-Possible-Full-Binary-Trees"><span class="nav-number">15.</span> <span class="nav-text">Leetcode894. All Possible Full Binary Trees</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode896-Monotonic-Array"><span class="nav-number">16.</span> <span class="nav-text">Leetcode896. Monotonic Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode897-Increasing-Order-Search-Tree"><span class="nav-number">17.</span> <span class="nav-text">Leetcode897. Increasing Order Search Tree</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
