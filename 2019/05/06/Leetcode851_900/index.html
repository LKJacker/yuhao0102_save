<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Leetcode,">










<meta name="description" content="Leetcode851. Loud and RichThere is a group of n people labeled from 0 to n - 1 where each person has a different amount of money and a different level of quietness. You are given an array richer where">
<meta name="keywords" content="Leetcode">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode850 - 900">
<meta property="og:url" content="http://yoursite.com/2019/05/06/Leetcode851_900/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="Leetcode851. Loud and RichThere is a group of n people labeled from 0 to n - 1 where each person has a different amount of money and a different level of quietness. You are given an array richer where">
<meta property="og:locale" content="zn-ch">
<meta property="og:image" content="http://yoursite.com/img/20200526000300.png">
<meta property="og:image" content="http://yoursite.com/img/20210921184300.png">
<meta property="og:image" content="http://yoursite.com/img/20210921184301.png">
<meta property="og:image" content="http://yoursite.com/img/20190825104.png">
<meta property="og:image" content="http://yoursite.com/img/20190827001.png">
<meta property="og:image" content="http://yoursite.com/img/20190827002.png">
<meta property="og:image" content="http://yoursite.com/img/fivetrees.png">
<meta property="og:updated_time" content="2021-09-26T02:31:28.427Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode850 - 900">
<meta name="twitter:description" content="Leetcode851. Loud and RichThere is a group of n people labeled from 0 to n - 1 where each person has a different amount of money and a different level of quietness. You are given an array richer where">
<meta name="twitter:image" content="http://yoursite.com/img/20200526000300.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/06/Leetcode851_900/">





  <title>Leetcode850 - 900 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/06/Leetcode851_900/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode850 - 900</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-06T13:52:39+08:00">
                2019-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Leetcode851-Loud-and-Rich"><a href="#Leetcode851-Loud-and-Rich" class="headerlink" title="Leetcode851. Loud and Rich"></a>Leetcode851. Loud and Rich</h1><p>There is a group of n people labeled from 0 to n - 1 where each person has a different amount of money and a different level of quietness.</p>
<p>You are given an array richer where <code>richer[i] = [ai, bi]</code> indicates that ai has more money than bi and an integer array quiet where <code>quiet[i]</code> is the quietness of the ith person. All the given data in richer are logically correct (i.e., the data will not lead you to a situation where x is richer than y and y is richer than x at the same time).</p>
<p>Return an integer array answer where <code>answer[x] = y</code> if <code>y</code> is the least quiet person (that is, the person <code>y</code> with the smallest value of <code>quiet[y]</code>) among all people who definitely have equal to or more money than the person x.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]</span><br><span class="line">Output: [5,5,2,5,4,5,6,7]</span><br><span class="line">Explanation: </span><br><span class="line">answer[0] = 5.</span><br><span class="line">Person 5 has more money than 3, which has more money than 1, which has more money than 0.</span><br><span class="line">The only person who is quieter (has lower quiet[x]) is person 7, but it is not clear if they have more money than person 0.</span><br><span class="line">answer[7] = 7.</span><br><span class="line">Among all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7.</span><br><span class="line">The other answers can be filled out with similar reasoning.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: richer = [], quiet = [0]</span><br><span class="line">Output: [0]</span><br></pre></td></tr></table></figure></p>
<p>有n 个人，编号0 ∼ n − 1 ，它们有两个属性，财富和安静，给定两个数组r和q，r里面的元素都是数对，<code>(a , b)</code>表示a比b财富严格更多，而q qq存的是每个人的安静值。要求返回一个数组c，使得<code>c[i]</code>表示对于编号i的这个人，财富不少于他的所有人里安静值最小的人的编号。题目保证财富比较的传递关系没有环。</p>
<p>思路是记忆化搜索。先建图，将这些人看成若干个点，从财富少的到多的人连一条边，然后从每个点开始DFS。DFS到顶点u uu的时候，先DFS所有u的邻接点，这样就求出了u的邻接点的c值，接着在这些邻接点的c值里找到q值最小的（即找的安静值最小的）即可。可以做记忆化，当某个点的c值已经算出了，则不必重复算。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; loudAndRich(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; richer, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; quiet) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = quiet.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(len, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : richer) </span><br><span class="line">            m[a[<span class="number">1</span>]].push_back(a[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">            helper(m, quiet, i, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; quiet, <span class="keyword">int</span> i, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (res[i] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        res[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ii : m[i]) &#123;</span><br><span class="line">            helper(m, quiet, ii, res);</span><br><span class="line">            <span class="keyword">if</span> (quiet[res[i]] &gt; quiet[res[ii]])</span><br><span class="line">                res[i] = res[ii];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode852-Peak-Index-in-a-Mountain-Array"><a href="#Leetcode852-Peak-Index-in-a-Mountain-Array" class="headerlink" title="Leetcode852. Peak Index in a Mountain Array"></a>Leetcode852. Peak Index in a Mountain Array</h1><p>Let’s call an array A a mountain if the following properties hold:</p>
<p>A.length &gt;= 3<br>There exists some 0 &lt; i &lt; A.length - 1 such that A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1]<br>Given an array that is definitely a mountain, return any i such that A[0] &lt; A[1] &lt; … A[i-1] &lt; A[i] &gt; A[i+1] &gt; … &gt; A[A.length - 1].</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,2,1,0]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>3 &lt;= A.length &lt;= 10000<br>0 &lt;= A[i] &lt;= 10^6<br>A is a mountain, as defined above.</p>
<p>判断一个“山峰”数组的山峰在哪里，本来以为还要判断这个是不是山峰数组的，所以多写了一些，对结果没影响，懒得删了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">bool</span> isreal=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(A.size()&lt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;A.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;A[i<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">if</span>(!isreal)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!isreal)&#123;</span><br><span class="line">                    res=i<span class="number">-1</span>;</span><br><span class="line">                    isreal=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我这个做法不好，可以用二分查找。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[mi] &lt; A[mi + <span class="number">1</span>])</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hi = mi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode853-Car-Fleet"><a href="#Leetcode853-Car-Fleet" class="headerlink" title="Leetcode853. Car Fleet"></a>Leetcode853. Car Fleet</h1><p><code>N</code> cars are going to the same destination along a one lane road.  The destination is <code>target</code> miles away.<br>Each car i has a constant speed speed[i] (in miles per hour), and initial position position[i] miles towards the target along the road.</p>
<p>A car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed.</p>
<p>The distance between these two cars is ignored - they are assumed to have the same position.</p>
<p>A car fleet is some non-empty set of cars driving at the same position and same speed.  Note that a single car is also a car fleet.</p>
<p>If a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.<br>How many car fleets will arrive at the destination?</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">The cars starting at 10 and 8 become a fleet, meeting each other at 12.</span><br><span class="line">The car starting at 0 doesn&apos;t catch up to any other car, so it is a fleet by itself.</span><br><span class="line">The cars starting at 5 and 3 become a fleet, meeting each other at 6.</span><br><span class="line">Note that no other cars meet these fleets before the destination, so the answer is 3.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>0 &lt;= N &lt;= 10 ^ 4</li>
<li>0 &lt; target &lt;= 10 ^ 6</li>
<li>0 &lt; speed[i] &lt;= 10 ^ 6</li>
<li>0 &lt;= position[i] &lt; target</li>
<li>All initial positions are different.</li>
</ul>
<p>这道题说是路上有一系列的车，车在不同的位置，且分别有着不同的速度，但行驶的方向都相同。如果后方的车在到达终点之前追上前面的车了，那么它就会如痴汉般尾随在其后，且速度降至和前面的车相同，可以看作是一个车队，当然，单独的一辆车也可以看作是一个车队，问我们共有多少个车队到达终点。这道题是小学时候的应用题的感觉，什么狗追人啊，人追狗啊之类的。这道题的正确解法的思路其实不太容易想，因为我们很容易把注意力都集中到每辆车，去计算其每个时刻所在的位置，以及跟前面的车相遇的位置，这其实把这道题想复杂了，其实并不需要知道车的相遇位置，只关心是否能组成车队一同经过终点线，那么如何才能知道是否能一起过线呢，最简单的方法就是看时间，假如车B在车A的后面，而车B到终点线的时间小于等于车A，那么就知道车A和B一定会组成车队一起过线。这样的话，就可以从离终点最近的一辆车开始，先算出其撞线的时间，然后再一次遍历身后的车，若后面的车撞线的时间小于等于前面的车的时间，则会组成车队。反之，若大于前面的车的时间，则说明无法追上前面的车，于是自己会形成一个新的车队，且是车头，则结果 res 自增1即可。<br>思路有了，就可以具体实现了，使用一个 TreeMap 来建立小车位置和其到达终点时间之间的映射，这里的时间使用 double 型，通过终点位置减去当前位置，并除以速度来获得。我们希望能从 position 大的小车开始处理，而 TreeMap 是把小的数字排在前面，这里使用了个小 trick，就是映射的时候使用的是 position 的负数，这样就能先处理原来 position 大的车，从而统计出正确的车队数量，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">carFleet</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; position, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; speed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>; <span class="keyword">double</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; pos2time;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; position.size(); ++i) &#123;</span><br><span class="line">            pos2time[-position[i]] = (<span class="keyword">double</span>)(target - position[i]) / speed[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : pos2time) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.second &lt;= cur) <span class="keyword">continue</span>;</span><br><span class="line">            cur = a.second;</span><br><span class="line">            ++res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode855-Exam-Room"><a href="#Leetcode855-Exam-Room" class="headerlink" title="Leetcode855. Exam Room"></a>Leetcode855. Exam Room</h1><p>In an exam room, there are N seats in a single row, numbered 0, 1, 2, …, N-1.</p>
<p>When a student enters the room, they must sit in the seat that maximizes the distance to the closest person.  If there are multiple such seats, they sit in the seat with the lowest number.  (Also, if no one is in the room, then the student sits at seat number 0.)</p>
<p>Return a class ExamRoom(int N) that exposes two functions: ExamRoom.seat() returning an int representing what seat the student sat in, and ExamRoom.leave(int p) representing that the student in seat number p now leaves the room.  It is guaranteed that any calls to ExamRoom.leave(p) have a student sitting in seat p.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;ExamRoom&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;seat&quot;,&quot;leave&quot;,&quot;seat&quot;], [[10],[],[],[],[],[4],[]]</span><br><span class="line">Output: [null,0,9,4,2,null,5]</span><br><span class="line">Explanation:</span><br><span class="line">ExamRoom(10) -&gt; null</span><br><span class="line">seat() -&gt; 0, no one is in the room, then the student sits at seat number 0.</span><br><span class="line">seat() -&gt; 9, the student sits at the last seat number 9.</span><br><span class="line">seat() -&gt; 4, the student sits at the last seat number 4.</span><br><span class="line">seat() -&gt; 2, the student sits at the last seat number 2.</span><br><span class="line">leave(4) -&gt; null</span><br><span class="line">seat() -&gt; 5, the student sits at the last seat number 5.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= N &lt;= 10^9</li>
<li>ExamRoom.seat() and ExamRoom.leave() will be called at most 10^4 times across all test cases.</li>
<li>Calls to ExamRoom.leave(p) are guaranteed to have a student currently sitting in seat number p.</li>
</ul>
<p>有个考场，每个考生入座的时候都要尽可能的跟左右两边的人距离保持最大，当最大距离相同的时候，考生坐在座位编号较小的那个位置。对于墙的处理跟之前那道是一样的，能靠墙就尽量靠墙，这样肯定离别人最远。</p>
<p>最先想的方法是用一个大小为N的数组来表示所有的座位，初始化为0，表示没有一个人，若有人入座了，则将该位置变为1，离开则变为0，那么对于 leave() 函数就十分简单了，直接将对应位置改为0即可。重点就是 seat() 函数了，采用双指针来做，主要就是找连续的0进行处理，还是要分 start 是否为0的情况，因为空位从墙的位置开始，跟空位在两人之间的处理情况是不同的，若空位从墙开始，肯定是坐墙边，而若是在两人之间，则需要坐在最中间，还要记得更新 start 为下一个空座位。最后在处理末尾空位连到墙的时候，跟之前稍有些不同，因为题目要求当最大距离相同的时候，需要选择座位号小的位置，而当此时 start 为0的时候，说明所有的位置都是空的，那么我们不需要再更新 idx 了，就用其初始值0，表示就坐在第一个位置，是符合题意的。最后别忘了将 idx 位置赋值为1，表示有人坐了。</p>
<p>那么比较直接的改进方法就是去掉那些0，我们只保存有人坐的位置，即所有1的位置。这样省去了遍历0的时间，大大提高了效率，此时我们就可以使用 TreeSet 来保存1的位置，其余部分并不怎么需要改变，在确定了座位 idx 时，将其加入 TreeSet 中。在 leave() 中，直接移除离开人的座位位置即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExamRoom</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    </span><br><span class="line">    ExamRoom(<span class="keyword">int</span> N) &#123;</span><br><span class="line">        n = N;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">seat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, pos = <span class="number">0</span>, left = <span class="number">-1</span>, dist = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist &lt; i - start) &#123;</span><br><span class="line">                    dist = i - start;</span><br><span class="line">                    pos = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (dist &lt; (i - start + <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">                    dist = (i - start + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                    pos = start + dist - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            start = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (start &gt; <span class="number">0</span> &amp;&amp; dist &lt; n - start)</span><br><span class="line">            pos = n<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        s.insert(pos);</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">leave</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        s.erase(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode856-Score-of-Parentheses"><a href="#Leetcode856-Score-of-Parentheses" class="headerlink" title="Leetcode856. Score of Parentheses"></a>Leetcode856. Score of Parentheses</h1><p>Given a balanced parentheses string <code>S</code>, compute the score of the string based on the following rule:</p>
<ul>
<li><code>()</code> has score 1</li>
<li><code>AB</code> has score A + B, where A and B are balanced parentheses strings.</li>
<li><code>(A)</code> has score 2 * A, where A is a balanced parentheses string.</li>
</ul>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()&quot;</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(())&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()()&quot;</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(()(()))&quot;</span><br><span class="line">Output: 6</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>S is a balanced parentheses string, containing only ( and ).</li>
<li>2 &lt;= S.length &lt;= 50</li>
</ul>
<p>这道题给了我们一个只有括号的字符串，一个简单的括号值1分，并排的括号是分值是相加的关系，包含的括号是乘的关系，每包含一层，都要乘以个2。题目中给的例子很好的说明了题意，博主最先尝试的方法是递归来做，思路是先找出每一个最外层的括号，再对其中间的整体部分调用递归，比如对于 “()(())” 来说，第一个最外边的括号是 “()”，其中间为空，对空串调用递归返回0，但是结果 res 还是加1，这个特殊的处理后面会讲到。第二个最外边的括号是 “(())” 的外层括号，对其中间的 “()” 调用递归，返回1，再乘以2，则得到 “(())” 的值，然后把二者相加，就是最终需要的结果了。找部分合法的括号字符串的方法就是使用一个计数器，遇到左括号，计数器自增1，反之右括号计数器自减1，那么当计数器为0的时候，就是一个合法的字符串了，我们对除去最外层的括号的中间内容调用递归，然后把返回值乘以2，并和1比较，取二者间的较大值加到结果 res 中，这是因为假如中间是空串，那么返回值是0，乘以2还是0，但是 “()” 的分值应该是1，所以累加的时候要跟1做比较。之后记得要更新i都正确的位置，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">scoreOfParentheses</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span> res = <span class="number">0</span>, n = S.size();</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    		<span class="keyword">if</span> (S[i] == <span class="string">')'</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">int</span> pos = i + <span class="number">1</span>, cnt = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (cnt != <span class="number">0</span>) &#123;</span><br><span class="line">    			(S[pos++] == <span class="string">'('</span>) ? ++cnt : --cnt;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">int</span> cur = scoreOfParentheses(S.substr(i + <span class="number">1</span>, pos - i - <span class="number">2</span>));</span><br><span class="line">    		res += max(<span class="number">2</span> * cur, <span class="number">1</span>);</span><br><span class="line">    		i = pos - <span class="number">1</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们也可以使用迭代来做，这里就要借助栈 stack 来做，因为递归在调用的时候，其实也是将当前状态压入栈中，等递归退出后再从栈中取出之前的状态。这里的实现思路是，遍历字符串S，当遇到左括号时，将当前的分数压入栈中，并把当前得分清0，若遇到的是右括号，说明此时已经形成了一个完整的合法的括号字符串了，而且除去外层的括号，内层的得分已经算出来了，就是当前的结果 res，此时就要乘以2，并且要跟1比较，取二者中的较大值，这样操作的原因已经在上面解法的讲解中解释过了。然后还要加上栈顶的值，因为栈顶的值是之前合法括号子串的值，跟当前的是并列关系，所以是相加的操作，最后不要忘了要将栈顶元素移除即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">scoreOfParentheses</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">                st.push(res);</span><br><span class="line">                res = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = st.top() + max(res * <span class="number">2</span>, <span class="number">1</span>); </span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们可以对空间复杂度进行进一步的优化，并不需要使用栈去保留所有的中间情况，可以只用一个变量 cnt 来记录当前在第几层括号之中，因为本题的括号累加值是有规律的，”()” 是1，因为最中间的括号在0层括号内，2^0 = 1。”(())” 是2，因为最中间的括号在1层括号内，2^1 = 2。”((()))” 是4，因为最中间的括号在2层括号内，2^2 = 4。因此类推，其实只需要统计出最中间那个括号外变有几个括号，就可以直接算出整个多重包含的括号字符串的值，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">scoreOfParentheses</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>, n = S.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            (S[i] == <span class="string">'('</span>) ? ++cnt : --cnt;</span><br><span class="line">            <span class="keyword">if</span> (S[i] == <span class="string">')'</span> &amp;&amp; S[i - <span class="number">1</span>] == <span class="string">'('</span>) res += (<span class="number">1</span> &lt;&lt; cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode858-Mirror-Reflection"><a href="#Leetcode858-Mirror-Reflection" class="headerlink" title="Leetcode858. Mirror Reflection"></a>Leetcode858. Mirror Reflection</h1><p>There is a special square room with mirrors on each of the four walls.  Except for the southwest corner, there are receptors on each of the remaining corners, numbered 0, 1, and 2.</p>
<p>The square room has walls of length p, and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor.</p>
<p>Return the number of the receptor that the ray meets first.  (It is guaranteed that the ray will meet a receptor eventually.)<br><img src="/img/20200526000300.png" alt></p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: p = 2, q = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The ray meets receptor 2 the first time it gets reflected back to the left wall.</span><br></pre></td></tr></table></figure></p>
<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>存在一个方形空间，如上图所示，一束光从左下角射出，方形空间的四条边都会反射，在0,1,2处存在3个接收器，问，给定方形空间的边长 p 和第一次到达右边界时距离0号接收器的距离，这束光最终会落到哪个接收器上？</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先对于给定的p,q，如果我们把这两个数都同时放大N倍，光线的走法结果不会改变，因此，首先要找p,q得最大公约数，使得p,q互质；<br>然后，当p,q互质时，不可能两个都是偶数，因此分情况，当p为偶数，q为奇数时，光线会一直走右边界的奇数坐标（1,3,5,7….）,然后再走左边的偶数坐标，因此最终必定会走到左边界，即2号接收器；若p为奇数，q为偶数，那么光线射到右边界时是偶数坐标，射到左边界时也是偶数坐标，而由于边长p是奇数，因此最终是不会走到左边界或右边界，即不会到接收器1和2，而是经过1,2之间的边界进行反向，然后往下走，而下面只有接收器0，因此最终必定会走到0；若p是奇数，且q也是奇数，那么光线到右边界时是奇数坐标，到左边界时是偶数坐标，因此最终一定走到接收器1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            temp = m % n;</span><br><span class="line">            m = n;</span><br><span class="line">            n = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mirrorReflection</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = gcd(p, q);</span><br><span class="line">        p = p / temp;</span><br><span class="line">        q = q / temp;</span><br><span class="line">        <span class="keyword">if</span>(p%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">		    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span>(q%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">		    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">		    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode859-Buddy-Strings"><a href="#Leetcode859-Buddy-Strings" class="headerlink" title="Leetcode859. Buddy Strings"></a>Leetcode859. Buddy Strings</h1><p>Given two strings A and B of lowercase letters, return true if and only if we can swap two letters in A so that the result equals B.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;ab&quot;, B = &quot;ba&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;ab&quot;, B = &quot;ab&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;aa&quot;, B = &quot;aa&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;aaaaaaabc&quot;, B = &quot;aaaaaaacb&quot;</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;&quot;, B = &quot;aa&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ol>
<li>0 &lt;= A.length &lt;= 20000</li>
<li>0 &lt;= B.length &lt;= 20000</li>
<li>A and B consist only of lowercase letters.</li>
</ol>
<ul>
<li>如果两个字符串长度不相等，则返回 false。</li>
<li>如果两个字符串有超过两处位置，其对应字符不一致，返回 false。</li>
<li>如果仅有两处位置字符不相同，则分别判断这两处位置交换后是否相同。</li>
<li>如果仅有一处位置字符不相同，则返回 false。</li>
<li>如果没有位置字符不相同，则根据题意，我们不得不找到两处位置交换。如果字符串中有两处位置字符相同，则返回 true；否则返回 false。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">buddyStrings</span><span class="params">(<span class="built_in">string</span> A, <span class="built_in">string</span> B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lengtha = A.length(), lengthb = B.length();</span><br><span class="line">        <span class="keyword">if</span>(lengtha != lengthb)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> flag1 = <span class="number">-1</span>, flag2 = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lengtha; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] != B[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(flag1 != <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(flag2 != <span class="number">-1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        flag2 = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    flag1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag1 == <span class="number">-1</span> &amp;&amp; flag2 == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; aa = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lengtha; i ++) &#123;</span><br><span class="line">                aa[A[i] - <span class="string">'a'</span>] ++;</span><br><span class="line">                <span class="keyword">if</span>(aa[A[i] - <span class="string">'a'</span>] &gt;= <span class="number">2</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(A[flag1] != B[flag2] || A[flag2] != B[flag1])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag1 != <span class="number">-1</span> &amp;&amp; flag2 == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode860-Lemonade-Change"><a href="#Leetcode860-Lemonade-Change" class="headerlink" title="Leetcode860. Lemonade Change"></a>Leetcode860. Lemonade Change</h1><p>At a lemonade stand, each lemonade costs $5. </p>
<p>Customers are standing in a queue to buy from you, and order one at a time (in the order specified by bills).</p>
<p>Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill.  You must provide the correct change to each customer, so that the net transaction is that the customer pays $5.</p>
<p>Note that you don’t have any change in hand at first.</p>
<p>Return true if and only if you can provide every customer with correct change.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,5,5,10,20]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Explanation: </p>
<ul>
<li>From the first 3 customers, we collect three $5 bills in order.</li>
<li>From the fourth customer, we collect a $10 bill and give back a $5.</li>
<li>From the fifth customer, we give a $10 bill and a $5 bill.</li>
<li>Since all customers got correct change, we output true.</li>
</ul>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,5,10]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [10,10]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,5,10,10,20]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Explanation: </p>
<ul>
<li>From the first two customers in order, we collect two $5 bills.</li>
<li>For the next two customers in order, we collect a $10 bill and give back a $5 bill.</li>
<li>For the last customer, we can’t give change of $15 back because we only have two $10 bills.</li>
<li>Since not every customer received correct change, the answer is false.</li>
</ul>
<p>Note:</p>
<ol>
<li>0 &lt;= bills.length &lt;= 10000</li>
<li>bills[i] will be either 5, 10, or 20.</li>
</ol>
<p>题目大意:卖lemon，5块钱一个，现在有3种面值的钞票分别为10，20，5，开始的时候没有找零的钱，问能否让每个人都有找零。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lemonadeChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = bills.size();</span><br><span class="line">        <span class="keyword">int</span> cnt5 = <span class="number">0</span>, cnt10 = <span class="number">0</span>, cnt20 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bills[i] == <span class="number">5</span>)</span><br><span class="line">                cnt5 ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(bills[i] == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt5 &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    cnt5 --;</span><br><span class="line">                    cnt10 ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(bills[i] == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(cnt10 &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt5&lt;<span class="number">3</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        cnt5 -= <span class="number">3</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt5 &lt; <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    cnt5 --;</span><br><span class="line">                    cnt10 --;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode861-Score-After-Flipping-Matrix"><a href="#Leetcode861-Score-After-Flipping-Matrix" class="headerlink" title="Leetcode861. Score After Flipping Matrix"></a>Leetcode861. Score After Flipping Matrix</h1><p>We have a two dimensional matrix A where each value is 0 or 1.</p>
<p>A move consists of choosing any row or column, and toggling each value in that row or column: changing all 0s to 1s, and all 1s to 0s.</p>
<p>After making any number of moves, every row of this matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.</p>
<p>Return the highest possible score.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [[0,0,1,1],[1,0,1,0],[1,1,0,0]]</span><br><span class="line">Output: 39</span><br><span class="line">Explanation:</span><br><span class="line">Toggled to [[1,1,1,1],[1,0,0,1],[1,1,1,1]].</span><br><span class="line">0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>1 &lt;= A.length &lt;= 20<br>1 &lt;= A[0].length &lt;= 20<br>A[i][j] is 0 or 1.</p>
<p>思路：对一个只有0和1的二维矩阵，移动是指选择任一行或任一列，将所有的0变成1，所有的1变成0，在作出任意次数的移动后，将该矩阵中的每一行都按照二进制数来解释，输出和的最大值。要注意的是行和列任意次移动，达到最大值。即以求出最优解为目标（可重复移动）。按二进制数来解释，注意数组[0-n]对应二进制“高位-低位”。</p>
<p>首先对行移动求最优解：二进制数，高位的有效值“1”大于后面所有位数之和，举个例子：10000=16   01010=10   00111=7。所以我们需要判断A[i]<a href="每行首元素">0</a>是否为“1”，将为“0”的进行移动操作，本行即达到最优。重复每行即为所有行最优</p>
<p>再对列移动求最优解：本题为矩阵，所以同一列的数字在二进制解释中位于相同的位置（2^n），当一列中”1”的数量最大时,结果值最大。即为列最优解，同理求出所有列最优解。</p>
<p>最后计算矩阵的总和，注意从低位（数组尾部开始计算）。</p>
<ol>
<li>若行最高位（数组行首元素）不为“1”，移动行。</li>
<li>若列“0”数量多于“1”，移动列。</li>
<li>从低位（行数组尾部）开始计算数组行值。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">matrixScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++)</span><br><span class="line">            <span class="keyword">if</span>(A[i][<span class="number">0</span>]==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;A[i].size();j++)</span><br><span class="line">                    A[i][j]=<span class="number">1</span>-A[i][j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;A[<span class="number">0</span>].size();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> zero=<span class="number">0</span>,one=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i][j]==<span class="number">0</span>)</span><br><span class="line">                    zero++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    one++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(zero&gt;one)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++)</span><br><span class="line">                    A[i][j]=<span class="number">1</span>-A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>,in=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=A[i].size()<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                temp+=A[i][j]*in;</span><br><span class="line">                in*=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum+=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>附上Solution：</p>
<p>Notice that a 1 in the i’th column from the right, contributes 2^i to the score.</p>
<p>Say we are finished toggling the rows in some configuration. Then for each column, (to maximize the score), we’ll toggle the column if it would increase the number of 1s.</p>
<p>We can brute force over every possible way to toggle rows.</p>
<p>Say the matrix has R rows and C columns.</p>
<p>For each state, the transition <code>trans = state ^ (state-1)</code> represents the rows that must be toggled to get into the state of toggled rows represented by (the bits of) state.</p>
<p>We’ll toggle them, and also maintain the correct column sums of the matrix on the side.</p>
<p>Afterwards, we’ll calculate the score. If for example the last column has a column sum of 3, then the score is max(3, R-3), where R-3 represents the score we get from toggling the last column.</p>
<p>In general, the score is increased by max(col_sum, R - col_sum) * (1 &lt;&lt; (C-1-c)), where the factor (1 &lt;&lt; (C-1-c)) is the power of 2 that each 1 contributes.</p>
<p>Note that this approach may not run in the time allotted.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">matrixScore</span><span class="params">(<span class="keyword">int</span>[][] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> R = A.length, C = A[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] colsums = <span class="keyword">new</span> <span class="keyword">int</span>[C];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; ++r)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; ++c)</span><br><span class="line">                colsums[c] += A[r][c];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> state = <span class="number">0</span>; state &lt; (<span class="number">1</span>&lt;&lt;R); ++state) &#123;</span><br><span class="line">            <span class="comment">// Toggle the rows so that after, 'state' represents</span></span><br><span class="line">            <span class="comment">// the toggled rows.</span></span><br><span class="line">            <span class="keyword">if</span> (state &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> trans = state ^ (state<span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; ++r) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (((trans &gt;&gt; r) &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; ++c) &#123;</span><br><span class="line">                            colsums[c] += A[r][c] == <span class="number">1</span> ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">                            A[r][c] ^= <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Calculate the score with the rows toggled by 'state'</span></span><br><span class="line">            <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; ++c)</span><br><span class="line">                score += Math.max(colsums[c], R - colsums[c]) * (<span class="number">1</span> &lt;&lt; (C<span class="number">-1</span>-c));</span><br><span class="line">            ans = Math.max(ans, score);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode863-All-Nodes-Distance-K-in-Binary-Tree"><a href="#Leetcode863-All-Nodes-Distance-K-in-Binary-Tree" class="headerlink" title="Leetcode863. All Nodes Distance K in Binary Tree"></a>Leetcode863. All Nodes Distance K in Binary Tree</h1><p>Given the root of a binary tree, the value of a target node target, and an integer k, return an array of the values of all nodes that have a distance k from the target node.</p>
<p>You can return the answer in any order.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2</span><br><span class="line">Output: [7,4,1]</span><br><span class="line">Explanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/20210921184300.png" alt></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1], target = 1, k = 3</span><br><span class="line">Output: []</span><br></pre></td></tr></table></figure></p>
<p>这道题给了我们一棵二叉树，一个目标结点 target，还有一个整数K，让返回所有跟目标结点 target 相距K的结点。我们知道在子树中寻找距离为K的结点很容易，因为只需要一层一层的向下遍历即可，难点就在于符合题意的结点有可能是祖先结点，或者是在旁边的兄弟子树中，这就比较麻烦了，因为二叉树只有从父结点到子结点的路径，反过来就不行。既然没有，我们就手动创建这样的反向连接即可，这样树的遍历问题就转为了图的遍历（其实树也是一种特殊的图）。建立反向连接就是用一个 HashMap 来来建立每个结点和其父结点之间的映射，使用先序遍历建立好所有的反向连接，然后再开始查找和目标结点距离K的所有结点，这里需要一个 HashSet 来记录所有已经访问过了的结点。</p>
<p>在递归函数中，首先判断当前结点是否已经访问过，是的话直接返回，否则就加入到 visited 中。再判断此时K是否为0，是的话说明当前结点已经是距离目标结点为K的点了，将其加入结果 res 中，然后直接返回。否则分别对当前结点的左右子结点调用递归函数，注意此时带入 K-1，这两步是对子树进行查找。之前说了，还得对父结点，以及兄弟子树进行查找，这是就体现出建立的反向连接 HashMap 的作用了，若当前结点的父结点存在，我们也要对其父结点调用递归函数，并同样带入 K-1，这样就能正确的找到所有满足题意的点了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; distanceK(TreeNode* root, TreeNode* target, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;TreeNode*, TreeNode*&gt; parents;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;TreeNode*&gt; visited;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        build_parent(root, parents);</span><br><span class="line">        find_res(target, k, visited, parents, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find_res</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k, <span class="built_in">unordered_set</span>&lt;TreeNode*&gt; visited, <span class="built_in">unordered_map</span>&lt;TreeNode*, TreeNode*&gt; parents, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.count(root))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        visited.insert(root);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">            res.push_back(root-&gt;val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) find_res(root-&gt;left, k<span class="number">-1</span>, visited, parents, res);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) find_res(root-&gt;right, k<span class="number">-1</span>, visited, parents, res);</span><br><span class="line">        <span class="keyword">if</span> (parents[root]) find_res(parents[root], k<span class="number">-1</span>, visited, parents,res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_parent</span><span class="params">(TreeNode* root, <span class="built_in">unordered_map</span>&lt;TreeNode*, TreeNode*&gt;&amp; parents)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) parents[root-&gt;left] = root;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) parents[root-&gt;right] = root;</span><br><span class="line">        build_parent(root-&gt;left, parents);</span><br><span class="line">        build_parent(root-&gt;right, parents);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>既然是图的遍历，那就也可以使用 BFS 来做，为了方便起见，我们直接建立一个邻接链表，即每个结点最多有三个跟其相连的结点，左右子结点和父结点，使用一个 HashMap 来建立每个结点和其相邻的结点数组之间的映射，这样就几乎完全将其当作图来对待了，建立好邻接链表之后，原来的树的结构都不需要用了。既然是 BFS 进行层序遍历，就要使用队列 queue，还要一个 HashSet 来记录访问过的结点。在 while 循环中，若K为0了，说明当前这层的结点都是符合题意的，就把当前队列中所有的结点加入结果 res，并返回即可。否则就进行层序遍历，取出当前层的每个结点，并在邻接链表中找到和其相邻的结点，若没有访问过，就加入 visited 和 queue 中即可。记得每层遍历完成之后，K要自减1，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; distanceK(TreeNode* root, TreeNode* target, <span class="keyword">int</span> K) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;TreeNode*, <span class="built_in">vector</span>&lt;TreeNode*&gt;&gt; m;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q&#123;&#123;target&#125;&#125;;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;TreeNode*&gt; visited&#123;&#123;target&#125;&#125;;</span><br><span class="line">        findParent(root, <span class="literal">NULL</span>, m);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line">        		<span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        			res.push_back(q.front()-&gt;val); q.pop();</span><br><span class="line">        		&#125;</span><br><span class="line">        		<span class="keyword">return</span> res;</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">for</span> (<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        		TreeNode *t = q.front(); q.pop();</span><br><span class="line">        		<span class="keyword">for</span> (TreeNode *node : m[t]) &#123;</span><br><span class="line">        			<span class="keyword">if</span> (visited.count(node)) <span class="keyword">continue</span>;</span><br><span class="line">        			visited.insert(node);</span><br><span class="line">        			q.push(node);</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        	--K;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findParent</span><span class="params">(TreeNode* node, TreeNode* pre, <span class="built_in">unordered_map</span>&lt;TreeNode*, <span class="built_in">vector</span>&lt;TreeNode*&gt;&gt;&amp; m)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">    	<span class="keyword">if</span> (m.count(node)) <span class="keyword">return</span>;</span><br><span class="line">    	<span class="keyword">if</span> (pre) &#123;</span><br><span class="line">    		m[node].push_back(pre);</span><br><span class="line">    		m[pre].push_back(node);</span><br><span class="line">    	&#125;</span><br><span class="line">    	findParent(node-&gt;left, node, m);</span><br><span class="line">    	findParent(node-&gt;right, node, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其实这道题也可以不用 HashMap，不建立邻接链表，直接在递归中完成所有的需求，真正体现了递归的博大精深。在进行递归之前，我们要先判断一个 corner case，那就是当 K==0 时，此时要返回的就是目标结点值本身，可以直接返回。否则就要进行递归了。这里的递归函数跟之前的有所不同，是需要返回值的，这个返回值表示的含义比较复杂，若为0，表示当前结点为空或者当前结点就是距离目标结点为K的点，此时返回值为0，是为了进行剪枝，使得不用对其左右子结点再次进行递归。当目标结点正好是当前结点的时候，递归函数返回值为1，其他的返回值为当前结点离目标结点的距离加1。还需要一个参数 dist，其含义为离目标结点的距离，注意和递归的返回值区别，这里不用加1，且其为0时候不是为了剪枝，而是真不知道离目标结点的距离。</p>
<p>在递归函数中，首先判断若当前结点为空，则直接返回0。然后判断 dist 是否为k，是的话，说目标结点距离当前结点的距离为K，是符合题意的，需要加入结果 res 中，并返回0，注意这里返回0是为了剪枝。否则判断，若当前结点正好就是目标结点，或者已经遍历过了目标结点（表现为 dist 大于0），那么对左右子树分别调用递归函数，并将返回值分别存入 left 和 right 两个变量中。注意此时应带入 dist+1，因为是先序遍历，若目标结点之前被遍历到了，那么说明目标结点肯定不在当前结点的子树中，当前要往子树遍历的话，肯定离目标结点又远了一些，需要加1。若当前结点不是目标结点，也还没见到目标结点时，同样也需要对左右子结点调用递归函数，但此时 dist 不加1，因为不确定目标结点的位置。若 left 或者 right 值等于K，则说明目标结点在子树中，且距离当前结点为K（为啥呢？因为目标结点本身是返回1，所以当左右子结点返回K时，和当前结点距离是K）。接下来判断，若当前结点是目标结点，直接返回1，这个前面解释过了。然后再看 left 和 right 的值是否大于0，若 left 值大于0，说明目标结点在左子树中，我们此时就要对右子结点再调用一次递归，并且 dist 带入 left+1，同理，若 right 值大于0，说明目标结点在右子树中，我们此时就要对左子结点再调用一次递归，并且 dist 带入 right+1。这两步很重要，是之所以能不建立邻接链表的关键所在。若 left 大于0，则返回 left+1，若 right 大于0，则返回 right+1，否则就返回0，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; distanceK(TreeNode* root, TreeNode* target, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">0</span>) <span class="keyword">return</span> &#123;target-&gt;val&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        helper(root, target, K, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode* node, TreeNode* target, <span class="keyword">int</span> k, <span class="keyword">int</span> dist, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">if</span> (dist == k) &#123;res.push_back(node-&gt;val); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    	<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">if</span> (node-&gt;val == target-&gt;val || dist &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    		left = helper(node-&gt;left, target, k, dist + <span class="number">1</span>, res);</span><br><span class="line">    		right = helper(node-&gt;right, target, k, dist + <span class="number">1</span>, res);</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		left = helper(node-&gt;left, target, k, dist, res);</span><br><span class="line">    		right = helper(node-&gt;right, target, k, dist, res);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span> (left == k || right == k) &#123;res.push_back(node-&gt;val); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    	<span class="keyword">if</span> (node-&gt;val == target-&gt;val) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">if</span> (left &gt; <span class="number">0</span>) helper(node-&gt;right, target, k, left + <span class="number">1</span>, res);</span><br><span class="line">    	<span class="keyword">if</span> (right &gt; <span class="number">0</span>) helper(node-&gt;left, target, k, right + <span class="number">1</span>, res);</span><br><span class="line">    	<span class="keyword">if</span> (left &gt; <span class="number">0</span> || right &gt; <span class="number">0</span>) <span class="keyword">return</span> left &gt; <span class="number">0</span> ? left + <span class="number">1</span> : right + <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode865-Smallest-Subtree-with-all-the-Deepest-Nodes"><a href="#Leetcode865-Smallest-Subtree-with-all-the-Deepest-Nodes" class="headerlink" title="Leetcode865. Smallest Subtree with all the Deepest Nodes"></a>Leetcode865. Smallest Subtree with all the Deepest Nodes</h1><p>Given the root of a binary tree, the depth of each node is the shortest distance to the root.</p>
<p>Return the smallest subtree such that it contains all the deepest nodes in the original tree.</p>
<p>A node is called the deepest if it has the largest depth possible among any node in the entire tree.</p>
<p>The subtree of a node is tree consisting of that node, plus the set of all descendants of that node.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4]</span><br><span class="line">Output: [2,7,4]</span><br><span class="line">Explanation: We return the node with value 2, colored in yellow in the diagram.</span><br><span class="line">The nodes coloured in blue are the deepest nodes of the tree.</span><br><span class="line">Notice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it.</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/20210921184301.png" alt></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1]</span><br><span class="line">Output: [1]</span><br><span class="line">Explanation: The root is the deepest node in the tree.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [0,1,3,null,2]</span><br><span class="line">Output: [2]</span><br><span class="line">Explanation: The deepest node in the tree is 2, the valid subtrees are the subtrees of nodes 2, 1 and 0 but the subtree of node 2 is the smallest.</span><br></pre></td></tr></table></figure></p>
<p>题目的意思是：给定一个根为 root 的二叉树，每个结点的深度是它到根的最短距离。如果一个结点在整个树的任意结点之间具有最大的深度，则该结点是最深的。一个结点的子树是该结点加上它的所有后代的集合。<br>返回能满足“以该结点为根的子树中包含所有最深的结点”这一条件的具有最大深度的结点。</p>
<p>二叉树一般就是递归，思路很直接，代码很简洁，用到pair把深度和root回传。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">subtreeWithAllDeepest</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> solve(root).second;   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pair&lt;<span class="keyword">int</span>, TreeNode*&gt; solve(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> make_pair(<span class="number">0</span>, root);</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, TreeNode*&gt; left = solve(root-&gt;left);</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, TreeNode*&gt; right = solve(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (left.first == right.first) <span class="keyword">return</span> make_pair(left.first+<span class="number">1</span>, root);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left.first &gt; right.first) <span class="keyword">return</span> make_pair(left.first+<span class="number">1</span>, left.second);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> make_pair(right.first+<span class="number">1</span>, right.second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode867-Transpose-Matrix"><a href="#Leetcode867-Transpose-Matrix" class="headerlink" title="Leetcode867. Transpose Matrix"></a>Leetcode867. Transpose Matrix</h1><p>Given a matrix A, return the transpose of A.</p>
<p>The transpose of a matrix is the matrix flipped over it’s main diagonal, switching the row and column indices of the matrix.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">Output: [[1,4,7],[2,5,8],[3,6,9]]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2,3],[4,5,6]]</span><br><span class="line">Output: [[1,4],[2,5],[3,6]]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ol>
<li>1 &lt;= A.length &lt;= 1000</li>
<li>1 &lt;= A[0].length &lt;= 1000</li>
</ol>
<p>Easy题目，矩阵转置基本操作，i,j下标对调<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; transpose(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = A.size(), n = A[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++)</span><br><span class="line">                result[j][i] = A[i][j];</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode868-Binary-Gap"><a href="#Leetcode868-Binary-Gap" class="headerlink" title="Leetcode868. Binary Gap"></a>Leetcode868. Binary Gap</h1><p>Given a positive integer N, find and return the longest distance between two consecutive 1’s in the binary representation of N.</p>
<p>If there aren’t two consecutive 1’s, return 0.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: 22</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">22 in binary is 0b10110.</span><br><span class="line">In the binary representation of 22, there are three ones, and two consecutive pairs of 1&apos;s.</span><br><span class="line">The first consecutive pair of 1&apos;s have distance 2.</span><br><span class="line">The second consecutive pair of 1&apos;s have distance 1.</span><br><span class="line">The answer is the largest of these two distances, which is 2.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 5</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">5 in binary is 0b101.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: 6</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">6 in binary is 0b110.</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 8</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: </span><br><span class="line">8 in binary is 0b1000.</span><br><span class="line">There aren&apos;t any consecutive pairs of 1&apos;s in the binary representation of 8, so we return 0.</span><br></pre></td></tr></table></figure></p>
<p>找到一个数的二进制表示中最远的两个1的距离。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binaryGap</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, prev = <span class="number">-1</span>, cur = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(N) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = N &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="number">1</span>) &#123;</span><br><span class="line">                prev = cur;</span><br><span class="line">                cur = count;</span><br><span class="line">                <span class="keyword">if</span>(prev != <span class="number">-1</span> &amp;&amp; cur != <span class="number">-1</span>) </span><br><span class="line">                    res = max(res, cur - prev);</span><br><span class="line">            &#125;</span><br><span class="line">            count ++;</span><br><span class="line">            N = N &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="LeetCode869-Reordered-Power-of-2"><a href="#LeetCode869-Reordered-Power-of-2" class="headerlink" title="LeetCode869. Reordered Power of 2"></a>LeetCode869. Reordered Power of 2</h1><p>Starting with a positive integer <code>N</code>, we reorder the digits in any order (including the original order) such that the leading digit is not zero.<br>Return true if and only if we can do this in a way such that the resulting number is a power of 2.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 16</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 24</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 46</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= N &lt;= 10^9</li>
</ul>
<p>这道题说是给了我们一个正整数N，让对各位上的数字进行重新排序，但是要保证最高位上不是0，问能否变为2的指数。刚开始的时候博主理解错了，以为是对N的二进制数的各位进行重排序，但除了2的指数本身，其他数字怎么也组不成2的指数啊，因为2的指数的二进制数只有最高位是1，其余都是0。后来才发现，是让对N的十进制数的各位上的数字进行重排序，比如 N=46，那么换个位置，变成 64，就是2的指数了。搞清了题意后，就可以开始解题了，由于N给定了范围，在 [1, 1e9] 之间，所以其调换位数能组成的二进制数也是有范围的，为 [2^0, 2^30] 之间，这样的话，一个比较直接的解法就是，现将整数N转为字符串，然后对字符串进行排序。然后遍历所有可能的2的指数，将每个2的指数也转为字符串并排序，这样只要某个排序后的字符串跟之前由N生成的字符串相等的话，则表明整数N是符合题意的，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">reorderedPowerOf2</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str = to_string(N);</span><br><span class="line">        sort(str.begin(), str.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">string</span> t = to_string(<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            sort(t.begin(), t.end());</span><br><span class="line">            <span class="keyword">if</span> (t == str) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面这种方法没有将数字转为字符串并排序，而是使用了另一种比较巧妙的方法来实现类似的功能，是通过对N的每位上的数字都变为10的倍数，并相加，这样相当于将N的各位的上的数字都加码到了10的指数空间，而对于所有的2的指数，进行相同的操作，只要某个加码后的数字跟之前整数N的处理后的数字相同，则说明N是符合题意的。需要注意的是，为了防止整型移除，加码后的数字用长整型来表示即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">reorderedPowerOf2</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = helper(N);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">31</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper(<span class="number">1</span> &lt;&lt; i) == sum) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; N; N /= <span class="number">10</span>) res += <span class="built_in">pow</span>(<span class="number">10</span>, N % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode870-Advantage-Shuffle"><a href="#Leetcode870-Advantage-Shuffle" class="headerlink" title="Leetcode870. Advantage Shuffle"></a>Leetcode870. Advantage Shuffle</h1><p>Given two arrays A and B of equal size, the advantage of A with respect to B is the number of indices i for which A[i] &gt; B[i].</p>
<p>Return any permutation of A that maximizes its advantage with respect to B.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2,7,11,15], B = [1,10,4,11]</span><br><span class="line">Output: [2,11,7,15]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [12,24,8,32], B = [13,25,32,11]</span><br><span class="line">Output: [24,32,8,12]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length = B.length &lt;= 10000</li>
<li>0 &lt;= A[i] &lt;= 10^9</li>
<li>0 &lt;= B[i] &lt;= 10^9</li>
</ul>
<p>这道题给了我们两个数组A和B，让对A进行重排序，使得每个对应对位置上A中的数字尽可能的大于B。这不就是大名鼎鼎的田忌赛马么，但想出高招并不是田忌，而是孙膑，就是孙子兵法的作者，但这 credit 好像都给了田忌，让人误以为是田忌的智慧，不禁想起了高富帅重金买科研成果的冠名权的故事。孙子原话是，“今以君之下驷与彼上驷，取君上驷与彼中驷，取君中驷与彼下驷”。就是自己的下马跟人上马比，稳输不用管，上马跟其中马跑，稳赢，中马跟其下马跑，还是稳赢。那我还全马跟其半马跑，能赢否？不过说的，今天博主所在的城市还真有马拉松比赛，而且博主还报了半马，但是由于身不由己的原因无法去跑，实在是可惜，没事，来日方长，总是有机会的。扯了这么久的犊子，赶紧拉回来做题吧。其实这道题的思路还真是田忌赛马的智慧一样，既然要想办法大过B中的数，那么对于B中的每个数（可以看作每匹马），先在A中找刚好大于该数的数字（这就是为啥中马跟其下马比，而不是上马跟其下马比），用太大的数字就浪费了，而如果A中没有比之大的数字，就用A中最小的数字（用下马跟其上马比，不过略有不同的是此时我们没有上马）。就用这种贪婪算法的思路就可以成功解题了，为了方便起见，就是用一个 MultiSet 来做，相当于一个允许重复的 TreeSet，既允许重复又自带排序功能，岂不美哉！那么遍历B中每个数字，在A进行二分搜索第一个大于的数字，这里使用了 STL 自带的 upper_bound 来做，当然想自己写二分也没问题。然后看，若不存在，则将A中最小的数字加到结果 res 中，否则就将第一个大于的数字加入结果 res 中，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span> <span class="title">advantageCount</span><span class="params">(<span class="built_in">vector</span>&amp; A, <span class="built_in">vector</span>&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; st(A.begin(), A.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = (*st.rbegin() &lt;= B[i]) ? st.begin() : st.upper_bound(B[i]);</span><br><span class="line">            res.push_back(*it);</span><br><span class="line">            st.erase(it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当两个数组都是有序的时候，我们就能快速的直到各自的最大值与最小值，问题就变得容易很多了。比如可以先从B的最大值开始，这是就看A的最大值能否大过B，能的话，就移动到对应位置，不能的话就用最小值，然后再看B的次大值，这样双指针就可以解决问题。所以可以先给A按从小到大的顺序，对于B的话，不能直接排序，因为这样的话原来的顺序就完全丢失了，所以将B中每个数字和其原始坐标位置组成一个 pair 对儿，加入到一个最大堆中，这样B中的最大值就会最先被取出来，再进行上述的操作，这时候就可以发现保存的原始坐标就发挥用处了，根据其坐标就可以直接更新结果 res 中对应的位置了，参见代码如下：<br>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span> <span class="title">advantageCount</span><span class="params">(<span class="built_in">vector</span>&amp; A, <span class="built_in">vector</span>&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size(), left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(n);</span><br><span class="line">        sort(A.begin(), A.end());</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">            q.push(&#123;B[i], i&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = q.top().first, idx = q.top().second; q.pop();</span><br><span class="line">            <span class="keyword">if</span> (A[right] &gt; val) res[idx] = A[right--];</span><br><span class="line">            <span class="keyword">else</span> res[idx] = A[left++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode872-Leaf-Similar-Trees"><a href="#Leetcode872-Leaf-Similar-Trees" class="headerlink" title="Leetcode872. Leaf-Similar Trees"></a>Leetcode872. Leaf-Similar Trees</h1><p>Consider all the leaves of a binary tree.  From left to right order, the values of those leaves form a leaf value sequence.</p>
<p>For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8). Two binary trees are considered leaf-similar if their leaf value sequence is the same. Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.</p>
<p>题目并不是很难，只不过利用dfs的方法对树进行遍历，并利用vector对叶子节点进行记录，最后再比较两个得到的vector是否相同就可以得到结果了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">leafSimilar</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1, v2;</span><br><span class="line">        dfs(root1, v1);</span><br><span class="line">        dfs(root2, v2);</span><br><span class="line">        <span class="keyword">return</span> issim(v1, v2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">issim</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v1.size() != v2.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(v1[i] != v2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">            v.push_back(root-&gt;val);</span><br><span class="line">        dfs(root-&gt;left, v);</span><br><span class="line">        dfs(root-&gt;right, v);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode873-Length-of-Longest-Fibonacci-Subsequence"><a href="#Leetcode873-Length-of-Longest-Fibonacci-Subsequence" class="headerlink" title="Leetcode873. Length of Longest Fibonacci Subsequence"></a>Leetcode873. Length of Longest Fibonacci Subsequence</h1><p>A sequence x1, x2, …, xn is Fibonacci-like if:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n &gt;= 3</span><br><span class="line">xi + xi+1 == xi+2 for all i + 2 &lt;= n</span><br></pre></td></tr></table></figure></p>
<p>Given a strictly increasing array arr of positive integers forming a sequence, return the length of the longest Fibonacci-like subsequence of arr. If one does not exist, return 0.</p>
<p>A subsequence is derived from another sequence arr by deleting any number of elements (including none) from arr, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,2,3,4,5,6,7,8]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: arr = [1,3,7,11,12,14,18]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18].</span><br></pre></td></tr></table></figure></p>
<p>这道题的 DP 定义式也是难点之一，一般来说，对于子数组子序列的问题，我们都会使用一个二维的 dp 数组，其中<code>dp[i][j]</code>表示范围 [i, j] 内的极值，但是在这道题不行，就算你知道了子区间 [i, j] 内的最长斐波那契数列的长度，还是无法更新其他区间。再回过头来看一下斐波那契数列的定义，从第三个数开始，每个数都是前两个数之和，所以若想增加数列的长度，这个条件一定要一直保持，比如对于数组 [1, 2, 3, 4, 7]，在子序列 [1, 2, 3] 中以3结尾的斐氏数列长度为3，虽然 [3, 4, 7] 也可以组成斐氏数列，但是以7结尾的斐氏数列长度更新的时候不能用以3结尾的斐氏数列长度的信息，因为 [1, 2, 3, 4, 7] 不是一个正确的斐氏数列，虽然 1+2=3, 3+4=7，但是 2+3!=4。所以每次只能增加一个长度，而且必须要知道前两个数字，正确的<code>dp[i][j]</code>应该是表示以<code>A[i]</code>和<code>A[j]</code>结尾的斐氏数列的长度。</p>
<p>接下来看该怎么更新 dp 数组，我们还是要确定两个数字，跟之前的解法不同的是，先确定一个数字，然后遍历之前比其小的所有数字，这样<code>A[i]</code>和<code>A[j]</code>两个数字确定了，此时要找一个比<code>A[i]</code>和<code>A[j]</code>都小的数，即<code>A[i]-A[j]</code>，若这个数字存在的话，说明斐氏数列存在，因为<code>[A[i]-A[j], A[j], A[i]]</code>是满足斐氏数列要求的。这样状态转移就有了，<code>dp[j][i] = dp[indexOf(A[i]-A[j])][j] + 1</code>，可能看的比较晕，但其实就是<code>A[i]</code>加到了以<code>A[j]</code>和<code>A[i]-A[j]</code>结尾的斐氏数列的后面，使得长度增加了1。不过前提是<code>A[i]-A[j]</code>必须要在原数组中存在，而且还需要知道某个数字在原数组中的坐标，那么就用 HashMap 来建立数字跟其坐标之间的映射。可以事先把所有数字都存在 HashMap 中，也可以在遍历i的时候建立，因为我们只关心位置i之前的数字。这样在算出<code>A[i]-A[j]</code>之后，在 HashMap 查找差值是否存在，不存在的话赋值为 -1。在更新<code>dp[j][i]</code>的时候，我们看<code>A[i]-A[j] &lt; A[j]</code>且 k&gt;=0 是否成立，因为<code>A[i]-A[j]</code>是斐氏数列中最小的数，且其位置k必须要存在才能更新。否则的话更新为2。最后还是要注意，若 res 小于3的时候，要返回0，因为斐波那契数列的最低消费是3个，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = arr.size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(len, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(len, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++)</span><br><span class="line">            m[arr[i]] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] - arr[j] &lt; arr[j] &amp;&amp; m.count(arr[i]-arr[j]))</span><br><span class="line">                        dp[j][i] = dp[m[arr[i]-arr[j]]][j] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[j][i] = <span class="number">2</span>;</span><br><span class="line">                res = max(res, dp[j][i]);        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res &gt; <span class="number">2</span> ? res : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode874-Walking-Robot-Simulation"><a href="#Leetcode874-Walking-Robot-Simulation" class="headerlink" title="Leetcode874. Walking Robot Simulation"></a>Leetcode874. Walking Robot Simulation</h1><p>A robot on an infinite grid starts at point (0, 0) and faces north.  The robot can receive one of three possible types of commands:</p>
<ul>
<li>-2: turn left 90 degrees</li>
<li>-1: turn right 90 degrees</li>
<li>1 &lt;= x &lt;= 9: move forward x units</li>
<li>Some of the grid squares are obstacles. </li>
</ul>
<p>The i-th obstacle is at grid point (obstacles[i][0], obstacles[i][1])</p>
<p>If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.)</p>
<p>Return the square of the maximum Euclidean distance that the robot will be from the origin.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: commands = [4,-1,3], obstacles = []</span><br><span class="line">Output: 25</span><br><span class="line">Explanation: robot will go to (3, 4)</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: commands = [4,-1,4,-2,4], obstacles = [[2,4]]</span><br><span class="line">Output: 65</span><br><span class="line">Explanation: robot will be stuck at (1, 4) before turning left and going to (1, 8)</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ol>
<li>0 &lt;= commands.length &lt;= 10000</li>
<li>0 &lt;= obstacles.length &lt;= 10000</li>
<li>-30000 &lt;= obstacle[i][0] &lt;= 30000</li>
<li>-30000 &lt;= obstacle[i][1] &lt;= 30000</li>
<li>The answer is guaranteed to be less than 2 ^ 31.</li>
</ol>
<p>把障碍存在一个set里，方便以后查找判断。每次计算目前最大的x^2 + y^2，用一个大小为2的数组来表示X、Y坐标，之后只需要用axis=0来表示X，axis=1来表示Y即可，不需要知道到底是哪个轴。在进行移动的时候，每次只走一格，计算max_square。值得注意的是，max_square的初始值为0，因为如果被障碍遮挡或者根本没有移动指令导致原地不动的情况下，最大值是0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">robotSim</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; commands, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacles)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; obs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obstacles.size(); i++)</span><br><span class="line">            obs.insert(make_pair(obstacles[i][<span class="number">0</span>], obstacles[i][<span class="number">1</span>]));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> coord[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, dir = <span class="number">1</span>; <span class="comment">// x-y coordinate 0: x, 1: y, 2: -x, 3: -y</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; commands.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(commands[i] == <span class="number">-2</span>) </span><br><span class="line">                dir = (dir+<span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(commands[i] == <span class="number">-1</span>) </span><br><span class="line">                dir = (dir+<span class="number">3</span>) % <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> axis, forward;</span><br><span class="line">                <span class="keyword">switch</span>(dir)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                        axis = <span class="number">0</span>;  forward = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        axis = <span class="number">1</span>;  forward = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        axis = <span class="number">0</span>;  forward = <span class="number">-1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        axis = <span class="number">1</span>;  forward = <span class="number">-1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; commands[i]; m ++) &#123;</span><br><span class="line">                    coord[axis] += forward;</span><br><span class="line">                    <span class="keyword">if</span>(obs.find(make_pair(coord[<span class="number">0</span>], coord[<span class="number">1</span>])) != obs.end()) &#123;</span><br><span class="line">                        coord[axis] -= forward;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    result = max(result, coord[<span class="number">0</span>]*coord[<span class="number">0</span>] + coord[<span class="number">1</span>]*coord[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode875-Koko-Eating-Bananas"><a href="#Leetcode875-Koko-Eating-Bananas" class="headerlink" title="Leetcode875. Koko Eating Bananas"></a>Leetcode875. Koko Eating Bananas</h1><p>Koko loves to eat bananas.  There are <code>N</code> piles of bananas, the <code>i</code>-th pile has <code>piles[i]</code> bananas.  The guards have gone and will come back in <code>H</code> hours.<br>Koko can decide her bananas-per-hour eating speed of K.  Each hour, she chooses some pile of bananas, and eats K bananas from that pile.  If the pile has less than K bananas, she eats all of them instead, and won’t eat any more bananas during this hour.</p>
<p>Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back.</p>
<p>Return the minimum integer K such that she can eat all the bananas within Hhours.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: piles = [3,6,7,11], H = 8</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: piles = [30,11,23,4,20], H = 5</span><br><span class="line">Output: 30</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: piles = [30,11,23,4,20], H = 6</span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= piles.length &lt;= 10^4</li>
<li>piles.length &lt;= H &lt;= 10^9</li>
<li>1 &lt;= piles[i] &lt;= 10^9</li>
</ul>
<p>这道题说有一只叫科科的猩猩，非常的喜欢吃香蕉，现在有N堆香蕉，每堆的个数可能不同，科科有H小时的时间来吃。要求是，每个小时内，科科只能选某一堆香蕉开始吃，若科科的吃速固定为K，即便在一小时内科科已经吃完了该堆的香蕉，也不能换堆，直到下一个小时才可以去另一堆吃。为了健康，科科想尽可能的吃慢一些，但同时也想在H小时内吃完所有的N堆香蕉，让我们找出一个最小的吃速K值。那么首先来想，既然每个小时只能吃一堆，总共要在H小时内吃完N堆，那么H一定要大于等于N，不然一定没法吃完N堆，这个条件题目中给了，所以就不用再 check 了。我们想一下K的可能的取值范围，当H无穷大的时候，科科有充足的时间去吃，那么就可以每小时只吃一根，也可以吃完，所以K的最小取值是1。那么当H最小，等于N时，那么一个小时内必须吃完任意一堆，那么K值就应该是香蕉最多的那一堆的个数，题目中限定了不超过 1e9，这就是最大值。所以要求的K值的范围就是 [1, 1e9]，固定的范围内查找数字，当然，最暴力的方法就是一个一个的试，凭博主多年与 OJ 抗衡的经验来说，基本可以不用考虑的。那么二分查找法就是不二之选了，我们知道经典的二分查找法，是要求数组有序的，而这里香蕉个数数组又不一定是有序的。这是一个很好的观察，但是要弄清楚到底是什么应该是有序的，要查找的K是吃速，跟香蕉堆的个数并没有直接的关系，而K所在的数组其实应该是 [1, 1e9] 这个数组，其本身就是有序的，所以二分查找没有问题。当求出了 mid 之后，需要统计用该速度吃完所有的香蕉堆所需要的时间，统计的方法就是遍历每堆的香蕉个数，然后算吃完该堆要的时间。比如 K=4，那么假如有3个香蕉，需要1个小时，有4香蕉，还是1个小时，有5个香蕉，就需要两个小时，如果将三种情况融合为一个式子呢，就是用吃速加上香蕉个数减去1，再除以吃速即可，即 (pile+mid-1)/mid，大家可以自行带数字检验，是没有问题的。算出需要的总时间后去跟H比较，若小于H，说明吃的速度慢了，需要加快速度，所以 left 更新为 mid+1，否则 right 更新为 mid，最后返回 right 即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> H)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>, cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> pile : piles) cnt += (pile + mid - <span class="number">1</span>) / mid;</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; H) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode876-Middle-of-the-Linked-List"><a href="#Leetcode876-Middle-of-the-Linked-List" class="headerlink" title="Leetcode876. Middle of the Linked List"></a>Leetcode876. Middle of the Linked List</h1><p>Given a non-empty, singly linked list with head node head, return a middle node of linked list.</p>
<p>If there are two middle nodes, return the second middle node.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: Node 3 from this list (Serialization: [3,4,5])</span><br><span class="line">The returned node has value 3.  (The judge&apos;s serialization of this node is [3,4,5]).</span><br><span class="line">Note that we returned a ListNode object ans, such that:</span><br><span class="line">ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6]</span><br><span class="line">Output: Node 4 from this list (Serialization: [4,5,6])</span><br><span class="line">Since the list has two middle nodes with values 3 and 4, we return the second one.</span><br></pre></td></tr></table></figure></p>
<p>Note: The number of nodes in the given list will be between 1 and 100.</p>
<p>题目大意：求链表的中间节点。思路：构造两个节点，遍历链接，一个每次走一步，另一个每次走两步，一个遍历完链表，另一个恰好在中间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p = head, *pp = head;</span><br><span class="line">        <span class="keyword">while</span>(pp != <span class="literal">NULL</span> &amp;&amp; pp-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            pp = pp-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>久仰大名的快慢指针做法，但是这里有坑，一定要注意while里的判断条件是两个，保证在有奇数个数和偶数个数的链表都不会访问空指针。</p>
<h1 id="Leetcode877-Stone-Game"><a href="#Leetcode877-Stone-Game" class="headerlink" title="Leetcode877. Stone Game"></a>Leetcode877. Stone Game</h1><p>Alex and Lee play a game with piles of stones.  There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].</p>
<p>The objective of the game is to end with the most stones.  The total number of stones is odd, so there are no ties.</p>
<p>Alex and Lee take turns, with Alex starting first.  Each turn, a player takes the entire pile of stones from either the beginning or the end of the row.  This continues until there are no more piles left, at which point the person with the most stones wins.</p>
<p>Assuming Alex and Lee play optimally, return True if and only if Alex wins the game.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,3,4,5]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">Alex starts first, and can only take the first 5 or the last 5.</span><br><span class="line">Say he takes the first 5, so that the row becomes [3, 4, 5].</span><br><span class="line">If Lee takes 3, then the board is [4, 5], and Alex takes 5 to win with 10 points.</span><br><span class="line">If Lee takes the last 5, then the board is [3, 4], and Alex takes 4 to win with 9 points.</span><br><span class="line">This demonstrated that taking the first 5 was a winning move for Alex, so we return true.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>2 &lt;= piles.length &lt;= 500</li>
<li>piles.length is even.</li>
<li>1 &lt;= piles[i] &lt;= 500</li>
<li>sum(piles) is odd.</li>
</ul>
<p>这道题说是有偶数堆的石子，每堆的石子个数可能不同，但石子总数是奇数个。现在 Alex 和 Lee （不应该是 Alice 和 Bob 么？？）两个人轮流选石子堆，规则是每次只能选开头和末尾中的一堆，最终获得石子总数多的人获胜。若 Alex 先选，两个人都会一直做最优选择，问我们最终 Alex 是否能获胜。博主最先想到的方法是像 Predict the Winner 中的那样，用个 player 变量来记录当前是哪个玩家在操作，若为0，表示 Alex 在选，那么他只有两种选择，要么拿首堆，要么拿尾堆，两种情况分别调用递归，两个递归函数只要有一个能返回 true，则表示 Alex 可以获胜，还需要用个变量 cur0 来记录当前 Alex 的石子总数。同理，若 Lee 在选，即 player 为1的时候，也是只有两种选择，分别调用递归，两个递归函数只要有一个能返回 true，则表示 Lee 可以获胜，用 cur1 来记录当前 Lee 的石子总数。需要注意的是，当首堆或尾堆被选走了后，我们需要标记，这里就有两种方法，一种是从原 piles 中删除选走的堆（或者是新建一个不包含选走堆的数组），但是这种方法会包括大量的拷贝运算，无法通过 OJ。另一种方法是用两个指针 left 和 right，分别指向首尾的位置。当选取了首堆时，则 left 自增1，若选了尾堆时，则 right 自减1。这样就不用执行删除操作，或是拷贝数组了，大大的提高了运行效率，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(piles, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">int</span>)piles.size() - <span class="number">1</span>, <span class="number">0</span>);     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> cur0, <span class="keyword">int</span> cur1, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> player)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> cur0 &gt; cur1;</span><br><span class="line">        <span class="keyword">if</span> (player == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> helper(piles, cur0 + piles[left], cur1, left + <span class="number">1</span>, right, <span class="number">1</span>) || helper(piles, cur0 + piles[right], cur1, left + <span class="number">1</span>, right, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> helper(piles, cur0, cur1 + piles[left], left, right - <span class="number">1</span>, <span class="number">0</span>) || helper(piles, cur0, cur1 + piles[right], left, right - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这道题也可以使用动态规划 Dynamic Programming 来做，由于玩家获胜的规则是拿到的石子数多，那么多的石子数就可以量化为 dp 值。所以我们用一个二维数组，其中<code>dp[i][j]</code>表示在区间<code>[i, j]</code>内 Alex 比 Lee 多拿的石子数，若为正数，说明 Alex 拿得多，若为负数，则表示 Lee 拿得多。则最终只要看<code>dp[0][n-1]</code>的值，若为正数，则 Alex 能获胜。现在就要找状态转移方程了，我们想，在区间<code>[i, j]</code>内要计算 Alex 比 Lee 多拿的石子数，在这个区间内，Alex 只能拿i或者j位置上的石子，那么当 Alex 拿了<code>piles[i]</code>的话，等于 Alex 多了<code>piles[i]</code>个石子，此时区间缩小成了<code>[i+1, j]</code>，此时应该 Lee 拿了，此时根据我们以往的 DP 经验，应该调用子区间的 dp 值，没错，但这里<code>dp[i+1][j]</code>表示是在区间<code>[i+1, j]</code>内 Alex 多拿的石子数，但是若区间<code>[i+1, j]</code>内 Lee 先拿的话，其多拿的石子数也应该是<code>dp[i+1][j]</code>，因为两个人都要最优化拿，那么<code>dp[i][j]</code>的值其实可以被<code>piles[i] - dp[i+1][j]</code>更新，因为 Alex 拿了<code>piles[i]</code>，减去 Lee 多出的<code>dp[i+1][j]</code>，就是区间<code>[i, j]</code>中 Alex 多拿的石子数。同理，假如 Alex 先拿<code>piles[j]</code>，那么就用<code>piles[j] - dp[i][j-1]</code>来更新<code>dp[i][j]</code>，则我们用二者的较大值来更新即可。注意开始的时候要把<code>dp[i][i]</code>都初始化为<code>piles[i]</code>，还需要注意的是，这里的更新顺序很重要，是从小区间开始更新<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = piles.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) dp[i][i] = piles[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt; n; ++len) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - len; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + len;</span><br><span class="line">                dp[i][j] = max(piles[i] - dp[i + <span class="number">1</span>][j], piles[j] - dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>] &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其实这道题是一道脑筋急转弯题，跟之前那道 Nim Game 有些像。原因就在于题目中的一个条件，那就是总共有偶数堆，那么就是可以分为堆数相等的两堆，比如我们按奇偶分为两堆。题目还说了石子总数为奇数个，那么分出的这两堆的石子总数一定是不相等的，那么我们只要每次一直取石子总数多的奇数堆或者偶数堆，Alex 就一定可以躺赢，所以最叼的方法就是直接返回 true。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stoneGame</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode881-Boats-to-Save-People"><a href="#Leetcode881-Boats-to-Save-People" class="headerlink" title="Leetcode881. Boats to Save People"></a>Leetcode881. Boats to Save People</h1><p>You are given an array people where people[i] is the weight of the ith person, and an infinite number of boats where each boat can carry a maximum weight of limit. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most limit.</p>
<p>Return the minimum number of boats to carry every given person.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: people = [1,2], limit = 3</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: 1 boat (1, 2)</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: people = [3,2,2,1], limit = 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 3 boats (1, 2), (2) and (3)</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: people = [3,5,3,4], limit = 5</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: 4 boats (3), (3), (4), (5)</span><br></pre></td></tr></table></figure></p>
<p>这道题让我们载人过河，说是每个人的体重不同，每条船承重有个限度 limit（限定了这个载重大于等于最重人的体重），同时要求每条船不能超过两人，问我们将所有人载到对岸最少需要多少条船。从题目中的例子2可以看出，最肥的人有可能一人占一条船，当然如果船的载量够大的话，可能还能挤上一个瘦子，那么最瘦的人是最可能挤上去的，所以策略就是胖子加瘦子的上船组合。那么这就是典型的贪婪算法的适用场景啊，首先要给所有人按体重排个序，从瘦子到胖子，这样我们才能快速的知道当前最重和最轻的人。然后使用双指针，left 指向最瘦的人，right 指向最胖的人，当 left 小于等于 right 的时候，进行 while 循环。在循环中，胖子是一定要上船的，所以 right 自减1是肯定有的，但是还是要看能否再带上一个瘦子，能的话 left 自增1。然后结果 res 一定要自增1，因为每次都要用一条船，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRescueBoats</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; people, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = people.size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n<span class="number">-1</span>;</span><br><span class="line">        sort(people.begin(), people.end());</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (people[left] + people[right] &gt; limit)</span><br><span class="line">                right --;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right --;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode883-Projection-Area-of-3D-Shapes"><a href="#Leetcode883-Projection-Area-of-3D-Shapes" class="headerlink" title="Leetcode883. Projection Area of 3D Shapes"></a>Leetcode883. Projection Area of 3D Shapes</h1><p>On a N <em> N grid, we place some 1 </em> 1 * 1 cubes that are axis-aligned with the x, y, and z axes. Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j). Now we view the projection of these cubes onto the xy, yz, and zx planes. A projection is like a shadow, that maps our 3 dimensional figure to a 2 dimensional plane. </p>
<p>Here, we are viewing the “shadow” when looking at the cubes from the top, the front, and the side. Return the total area of all three projections.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2]]</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><img src="/img/20190825104.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2],[3,4]]</span><br><span class="line">Output: 17</span><br><span class="line">Explanation: </span><br><span class="line">Here are the three projections (&quot;shadows&quot;) of the shape made with each axis-aligned plane.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,0],[0,2]]</span><br><span class="line">Output: 8</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">Output: 14</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2,2,2],[2,1,2],[2,2,2]]</span><br><span class="line">Output: 21</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= grid.length = grid[0].length &lt;= 50</li>
<li>0 &lt;= grid[i][j] &lt;= 50</li>
</ul>
<p>投影题，之前做过类似的，从上往下看的数量是不为零的格子数，从左往右看和从右往左看是每行（或列）最高的，求和。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">projectionArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = grid.size();</span><br><span class="line">        <span class="keyword">int</span> y = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; y; j ++)</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] != <span class="number">0</span>)</span><br><span class="line">                    res ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i ++)&#123;</span><br><span class="line">            max = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; y; j ++)</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] &gt; max)</span><br><span class="line">                    max = grid[i][j];</span><br><span class="line">            res += max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; y; i ++)&#123;</span><br><span class="line">            max = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; x; j ++)</span><br><span class="line">                <span class="keyword">if</span>(grid[j][i] &gt; max)</span><br><span class="line">                    max = grid[j][i];</span><br><span class="line">            res += max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">projectionArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = grid.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N;  ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> bestRow = <span class="number">0</span>;  <span class="comment">// largest of grid[i][j]</span></span><br><span class="line">            <span class="keyword">int</span> bestCol = <span class="number">0</span>;  <span class="comment">// largest of grid[j][i]</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] &gt; <span class="number">0</span>) ans++;  <span class="comment">// top shadow</span></span><br><span class="line">                bestRow = max(bestRow, grid[i][j]);</span><br><span class="line">                bestCol = max(bestCol, grid[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans += bestRow + bestCol;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode884-Uncommon-Words-from-Two-Sentences"><a href="#Leetcode884-Uncommon-Words-from-Two-Sentences" class="headerlink" title="Leetcode884. Uncommon Words from Two Sentences"></a>Leetcode884. Uncommon Words from Two Sentences</h1><p>We are given two sentences A and B.  (A sentence is a string of space separated words.  Each word consists only of lowercase letters.)</p>
<p>A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.</p>
<p>Return a list of all uncommon words. </p>
<p>You may return the list in any order.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;this apple is sweet&quot;, B = &quot;this apple is sour&quot;</span><br><span class="line">Output: [&quot;sweet&quot;,&quot;sour&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = &quot;apple apple&quot;, B = &quot;banana&quot;</span><br><span class="line">Output: [&quot;banana&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ol>
<li>0 &lt;= A.length &lt;= 200</li>
<li>0 &lt;= B.length &lt;= 200</li>
<li>A and B both contain only spaces and lowercase letters.</li>
</ol>
<p>把单词合并然后找到只出现过一次的就好。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; uncommonFromSentences(<span class="built_in">string</span> A, <span class="built_in">string</span> B) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mapp;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length(); i ++) &#123;</span><br><span class="line">            temp = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; A.length() &amp;&amp; A[i] != <span class="string">' '</span>)</span><br><span class="line">                temp += A[i++];</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;temp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(mapp.find(temp) == mapp.end())</span><br><span class="line">                mapp[temp] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                mapp[temp] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; B.length(); i ++) &#123;</span><br><span class="line">            temp = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; B.length() &amp;&amp; B[i] != <span class="string">' '</span>)</span><br><span class="line">                temp += B[i++];</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;temp&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(mapp.find(temp) == mapp.end())</span><br><span class="line">                mapp[temp] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                mapp[temp] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = mapp.begin(); iter != mapp.end(); iter ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(iter-&gt;second == <span class="number">1</span>)</span><br><span class="line">                result.push_back(iter-&gt;first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>简洁做法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; uncommonFromSentences(<span class="built_in">string</span> A, <span class="built_in">string</span> B) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(A + <span class="string">" "</span> + B)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (iss &gt;&gt; A) count[A]++;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> w: count)</span><br><span class="line">            <span class="keyword">if</span> (w.second == <span class="number">1</span>)</span><br><span class="line">                res.push_back(w.first);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode885-Spiral-Matrix-III"><a href="#Leetcode885-Spiral-Matrix-III" class="headerlink" title="Leetcode885. Spiral Matrix III"></a>Leetcode885. Spiral Matrix III</h1><p>On a 2 dimensional grid with R rows and C columns, we start at (r0, c0) facing east. Here, the north-west corner of the grid is at the first row and column, and the south-east corner of the grid is at the last row and column. Now, we walk in a clockwise spiral shape to visit every position in this grid. </p>
<p>Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) Eventually, we reach all R * C spaces of the grid. Return a list of coordinates representing the positions of the grid in the order they were visited.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: R = 1, C = 4, r0 = 0, c0 = 0</span><br><span class="line">Output: [[0,0],[0,1],[0,2],[0,3]]</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/20190827001.png" alt></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: R = 5, C = 6, r0 = 1, c0 = 4</span><br><span class="line">Output: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/20190827002.png" alt></p>
<p>给定起点（r0,c0），螺旋走路，输出经过的点坐标，简单，只是注意细节。按照顺序，先向右走，再向下走，再向左走，再向上走，经观察发现每个方向的步数依次为1,1,2,2,3,3,…，依次类推，按照步骤走即可，发现不在网格内就跳过。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">4</span>]=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; spiralMatrixIII(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        res.push_back(&#123;r0, c0&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; res.size() &lt; R * C; i += <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j ++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">                    r0 += dir[j][<span class="number">0</span>];</span><br><span class="line">                    c0 += dir[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(<span class="number">0</span> &lt;= r0 &amp;&amp; r0 &lt; R &amp;&amp; <span class="number">0</span> &lt;= c0 &amp;&amp; c0 &lt; C)</span><br><span class="line">                        res.push_back(&#123;r0,c0&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; <span class="number">4</span>; j ++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i+<span class="number">1</span>; k++) &#123;</span><br><span class="line">                    r0 += dir[j][<span class="number">0</span>];</span><br><span class="line">                    c0 += dir[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(<span class="number">0</span> &lt;= r0 &amp;&amp; r0 &lt; R &amp;&amp; <span class="number">0</span> &lt;= c0 &amp;&amp; c0 &lt; C)</span><br><span class="line">                        res.push_back(&#123;r0,c0&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一个大佬给了三种做法：</p>
<p>这道题给了我们一个二维矩阵，还给了其中一个位置，让从这个位置开始螺旋打印矩阵。首先是打印给定的位置，然后向右走一位，打印出来，再向下方走一位打印，再向左边走两位打印，再向上方走三位打印，以此类推，螺旋打印。那仔细观察，可以发现，刚开始只是走一步，后来步子越来越大，若只看每个方向走的距离，可以得到如下数组 1,1,2,2,3,3… </p>
<p>步长有了，下面就是方向了，由于确定了起始是向右走，那么方向就是 右-&gt;下-&gt;左-&gt;上 这样的循环。方向和步长都分析清楚了，现在就可以尝试进行遍历了。由于最终是会遍历完所有的位置的，那么最后结果 res 里面的位置个数一定是等于 RxC 的，所以循环的条件就是当结果 res 中的位置数小于<code>R*C</code>。我们还需要一个变量 step 表示当前的步长，初始化为1。</p>
<p>在循环中，首先要向右走 step 步，一步一步走，走到一个新的位置上，要进行判断，若当前位置没有越界，才能加入结果 res 中，由于每次都要判断，所以把这部分抽取出来，放到一个子函数中。由于是向右走，每走一步之后，c0 都要自增1。右边走完了之后，再向下方走 step 步，同理，每走一步之后，要将 r0 自增1。再向左边走之前，要将步数增1，不然无法形成正确的螺旋，同理，再完成向上方走 step 步之后，step 要再增1，参见代码如下：</p>
<p>解法一：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; spiralMatrixIII(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (res.size() &lt; R * C) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; step; ++i) add(R, C, r0, c0++, res);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; step; ++i) add(R, C, r0++, c0, res);</span><br><span class="line">            ++step;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; step; ++i) add(R, C, r0, c0--, res);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; step; ++i) add(R, C, r0--, c0, res);</span><br><span class="line">            ++step;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; R &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; C) res.push_back(&#123;x, y&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以用两个数组 dirX 和 dirY 来控制下一个方向，就像迷宫遍历中的那样，这样只需要一个变量 cur，来分别到 dirX 和 dirY 中取值，初始化为0，表示向右的方向。从螺旋遍历的机制可以看出，每当向右或者向左前进时，步长就要加1，那么我们只要判断当 cur 为0或者2的时候，step 就自增1。由于 cur 初始化为0，所以刚开始 step 就会增1，那么就可以将 step 初始化为0，同时还需要把起始位置提前加入结果 res 中。此时在 while 循环中只需要一个 for 循环即可，朝当前的 cur 方向前进 step 步，r0 加上 dirX[cur]，c0 加上 dirY[cur]，若没有越界，则加入结果 res 中即可。之后记得 cur 要自增1，为了防止越界，对4取余，就像循环数组一样的操作，参见代码如下：</p>
<p>解法二：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; spiralMatrixIII(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res&#123;&#123;r0, c0&#125;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dirX&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, dirY&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (res.size() &lt; R * C) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="number">0</span> || cur == <span class="number">2</span>) ++step;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; step; ++i) &#123;</span><br><span class="line">                r0 += dirX[cur]; c0 += dirY[cur];</span><br><span class="line">                <span class="keyword">if</span> (r0 &gt;= <span class="number">0</span> &amp;&amp; r0 &lt; R &amp;&amp; c0 &gt;= <span class="number">0</span> &amp;&amp; c0 &lt; C) res.push_back(&#123;r0, c0&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = (cur + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们也可以不使用方向数组，若仔细观察 右-&gt;下-&gt;左-&gt;上 四个方向对应的值 (0, 1) -&gt; (1, 0) -&gt; (0, -1) -&gt; (-1, 0), 实际上，下一个位置的x值是当前的y值，下一个位置的y值是当前的-x值，因为两个方向是相邻的两个方向是垂直的，由向量的叉乘得到 (x, y, 0) × (0, 0, 1) = (y, -x, 0)。所以可以通过当前的x和y值，来计算出下一个位置的值。同理，根据之前的说的步长数组 1,1,2,2,3,3…，可以推出通项公式为 n/2 + 1，这样连步长变量 step 都省了，不过需要统计当前已经遍历的位置的个数，实在想偷懒，也可以用 res.size() 来代替，参见代码如下：</p>
<p>解法三：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; spiralMatrixIII(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res&#123;&#123;r0, c0&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; res.size() &lt; R * C; ++k) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k / <span class="number">2</span> + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                r0 += x; c0 += y;</span><br><span class="line">                <span class="keyword">if</span> (r0 &gt;= <span class="number">0</span> &amp;&amp; r0 &lt; R &amp;&amp; c0 &gt;= <span class="number">0</span> &amp;&amp; c0 &lt; C) res.push_back(&#123;r0, c0&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            t = x; x = y; y = -t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="LeetCode886-Possible-Bipartition"><a href="#LeetCode886-Possible-Bipartition" class="headerlink" title="LeetCode886. Possible Bipartition"></a>LeetCode886. Possible Bipartition</h1><p>Given a set of N people (numbered 1, 2, …, N), we would like to split everyone into two groups of any size.</p>
<p>Each person may dislike some other people, and they should not go into the same group. </p>
<p>Formally, if dislikes[i] = [a, b], it means it is not allowed to put the people numbered a and b into the same group.</p>
<p>Return true if and only if it is possible to split everyone into two groups in this way.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 4, dislikes = [[1,2],[1,3],[2,4]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: group1 [1,4], group2 [2,3]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 3, dislikes = [[1,2],[1,3],[2,3]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= N &lt;= 2000</li>
<li>0 &lt;= dislikes.length &lt;= 10000</li>
<li>1 &lt;= dislikes[i][j] &lt;= N</li>
<li>dislikes[i][0] &lt; dislikes[i][1]</li>
<li>There does not exist i != j for which dislikes[i] == dislikes[j].</li>
</ul>
<p>这道题又是关于二分图的题，第一次接触的时候是 Is Graph Bipartite?，那道题给的是建好的邻接链表（虽然是用数组实现的），但是本质上和这道题是一样的，同一条边上的两点是不能在同一个集合中的，那么这就相当于本题中的 dislike 的关系，也可以把每个 dislike 看作是一条边，那么两端的两个人不能在同一个集合中。看透了题目的本质后，就不难做了，跟之前的题相比，这里唯一不同的就是邻接链表没有给我们建好，需要自己去建。不管是建邻接链表，还是邻接矩阵都行，反正是要先把图建起来才能遍历。那么这里我们先建立一个邻接矩阵好了，建一个大小为 (N+1) x (N+1) 的二维数组g，其中若 g[i][j] 为1，说明i和j互相不鸟。那么先根据 dislikes 的情况，把二维数组先赋上值，注意这里 g[i][j] 和 g[j][i] 都要更新，因为是互相不鸟，而并不是某一方热脸贴冷屁股。下面就要开始遍历了，还是使用染色法，使用一个一维的 colors 数组，大小为 N+1，初始化是0，由于只有两组，可以用1和 -1 来区分。那么开始遍历图中的结点，对于每个遍历到的结点，如果其还未被染色，还是一张白纸的时候，调用递归函数对其用颜色1进行尝试染色。在递归函数中，现将该结点染色，然后就要遍历所有跟其合不来的人，这里就发现邻接矩阵的好处了吧，不然每次还得遍历 dislikes 数组。由于这里是邻接矩阵，所以只有在其值为1的时候才处理，当找到一个跟其合不来的人，首先检测其染色情况，如果此时两个人颜色相同了，说明已经在一个组里了，这就矛盾了，直接返回 false。如果那个人还是白纸一张，我们尝试用相反的颜色去染他，如果无法成功染色，则返回 false。循环顺序退出后，返回 true，参见代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">possibleBipartition</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dislikes)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; g(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; color(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dislikes.size(); i ++) &#123;</span><br><span class="line">            g[dislikes[i][<span class="number">0</span>]][dislikes[i][<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">            g[dislikes[i][<span class="number">1</span>]][dislikes[i][<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) </span><br><span class="line">            <span class="keyword">if</span> (color[i] == <span class="number">0</span> &amp;&amp; !helper(g, i, color, <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; g, <span class="keyword">int</span> cur, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; color, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        color[cur] = col;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.size(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[cur][i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (color[i] == col)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (color[i] == <span class="number">0</span> &amp;&amp; !helper(g, i, color, -col))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode888-Fair-Candy-Swap"><a href="#Leetcode888-Fair-Candy-Swap" class="headerlink" title="Leetcode888. Fair Candy Swap"></a>Leetcode888. Fair Candy Swap</h1><p>Alice and Bob have candy bars of different sizes: A[i] is the size of the i-th bar of candy that Alice has, and B[j] is the size of the j-th bar of candy that Bob has.</p>
<p>Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy.  (The total amount of candy a person has is the sum of the sizes of candy bars they have.)</p>
<p>Return an integer array ans where ans[0] is the size of the candy bar that Alice must exchange, and ans[1] is the size of the candy bar that Bob must exchange.</p>
<p>If there are multiple answers, you may return any one of them.  It is guaranteed an answer exists.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,1], B = [2,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2], B = [2,3]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [2], B = [1,3]</span><br><span class="line">Output: [2,3]</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: A = [1,2,5], B = [2,4]</span><br><span class="line">Output: [5,4]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= A.length &lt;= 10000</li>
<li>1 &lt;= B.length &lt;= 10000</li>
<li>1 &lt;= A[i] &lt;= 100000</li>
<li>1 &lt;= B[i] &lt;= 100000</li>
<li>It is guaranteed that Alice and Bob have different total amounts of candy.</li>
<li>It is guaranteed there exists an answer.</li>
</ul>
<p>考虑到最终两个人的糖果总量相等，那么可以计算出最终这个相等的总量是多少。</p>
<p>比如1中的例子，A的总量是8，B的总量是6，那么平均下来每个人应该是7。</p>
<p>那么接下来就要在A中找到一个元素比B中某个元素大1的，逐个对比，可以发现交换5和4就可以达成目标。</p>
<p>其中逐个对比这个部分，难道我们要做一个双重循环吗？也没有必要。</p>
<p>我们先做一个升序排序，接着就是两个指针在A中和B中不断地移动就可以了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fairCandySwap(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span><br><span class="line">&#123;</span><br><span class="line">    sort(A.begin(),A.end());<span class="comment">//升序排序</span></span><br><span class="line">    sort(B.begin(),B.end());<span class="comment">//升序排序</span></span><br><span class="line">    <span class="keyword">int</span> sum1=<span class="number">0</span>,sum2=<span class="number">0</span>,sum3,cha,cha1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:A)<span class="comment">//sum1存储A中的总量</span></span><br><span class="line">        sum1+=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i:B)<span class="comment">//sum2存储B中的总量</span></span><br><span class="line">        sum2+=i;</span><br><span class="line">    sum3=(sum1+sum2)/<span class="number">2</span>;<span class="comment">//sum3是平均值</span></span><br><span class="line">    cha=sum1-sum3;<span class="comment">//cha表示A和平均值之间的差，如果大于0，说明A要在B中找一个小cha这个数值的，如果小于0，同理</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;A.size()&amp;&amp;j&lt;B.size())<span class="comment">//i和j两个索引不断地向后走</span></span><br><span class="line">    &#123;</span><br><span class="line">        cha1=A[i]-B[j];</span><br><span class="line">        <span class="keyword">if</span>(cha1==cha)<span class="comment">//如果刚好等于，那么返回两个数值</span></span><br><span class="line">            <span class="keyword">return</span> &#123;A[i],B[j]&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cha1&lt;cha)<span class="comment">//如果小于，那么说明A[i]数值太小，应该更大一点</span></span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//如果大于，那么说明B[j]数值太小，应该更大一点</span></span><br><span class="line">            j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Leetcode889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal"><a href="#Leetcode889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal" class="headerlink" title="Leetcode889. Construct Binary Tree from Preorder and Postorder Traversal"></a>Leetcode889. Construct Binary Tree from Preorder and Postorder Traversal</h1><p>Return any binary tree that matches the given preorder and postorder traversals.</p>
<p>Values in the traversals pre and post are distinct positive integers.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]</span><br><span class="line">Output: [1,2,3,4,5,6,7]</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= pre.length == post.length &lt;= 30</li>
<li>pre[] and post[] are both permutations of 1, 2, …, pre.length.</li>
<li>It is guaranteed an answer exists. If there exists multiple answers, you can return any of them.</li>
</ul>
<p>这道题给了一棵树的先序遍历和后序遍历的数组，让我们根据这两个数组来重建出原来的二叉树。之前也做过二叉树的先序遍历 Binary Tree Preorder Traversal 和 后序遍历 Binary Tree Postorder Traversal，所以应该对其遍历的顺序并不陌生。其实二叉树最常用的三种遍历方式，先序，中序，和后序遍历，只要知道其中的任意两种遍历得到的数组，就可以重建出原始的二叉树，而且正好都在 LeetCode 中有出现，其他两道分别是 Construct Binary Tree from Inorder and Postorder Traversal 和 Construct Binary Tree from Preorder and Inorder Traversal。如果做过之前两道题，那么这道题就没有什么难度了，若没有的话，可能还是有些 tricky 的，虽然这仅仅只是一道 Medium 的题。</p>
<p>我们知道，先序遍历的顺序是 根-&gt;左-&gt;右，而后序遍历的顺序是 左-&gt;右-&gt;根，既然要建立树，那么肯定要从根结点开始创建，然后再创建左右子结点，若你做过很多树相关的题目的话，就会知道大多数都是用递归才做，那么创建的时候也是对左右子结点调用递归来创建。心中有这么个概念就好，可以继续来找这个重复的 pattern。由于先序和后序各自的特点，根结点的位置是固定的，既是先序遍历数组的第一个，又是后序遍历数组的最后一个，而如果给我们的是中序遍历的数组，那么根结点的位置就只能从另一个先序或者后序的数组中来找了，但中序也有中序的好处，其根结点正好分割了左右子树，就不在这里细讲了，还是回到本题吧。知道了根结点的位置后，我们需要分隔左右子树的区间，先序和后序的各个区间表示如下：</p>
<ul>
<li>preorder -&gt; [root] [left subtree] [right subtree]</li>
<li>postorder -&gt; [left subtree] [right substree] [root]</li>
</ul>
<p>具体到题目中的例子就是：</p>
<ul>
<li>preorder -&gt; [1] [2,4,5] [3,6,7]</li>
<li>postorder -&gt; [4,5,2] [6,7,3] [root]</li>
</ul>
<p>先序和后序中各自的左子树区间的长度肯定是相等的，但是其数字顺序可能是不同的，但是我们仔细观察的话，可以发现先序左子树区间的第一个数字2，在后序左右子树区间的最后一个位置，而且这个规律对右子树区间同样适用，这是为啥呢，这就要回到各自遍历的顺序了，先序遍历的顺序是 根-&gt;左-&gt;右，而后序遍历的顺序是 左-&gt;右-&gt;根，其实这个2就是左子树的根结点，当然会一个在开头，一个在末尾了。发现了这个规律，就可以根据其来定位左右子树区间的位置范围了。既然要拆分数组，那么就有两种方式，一种是真的拆分成小的子数组，另一种是用双指针来指向子区间的开头和末尾。前一种方法无疑会有大量的数组拷贝，不是很高效，所以我们这里采用第二种方法来做。用 preL 和 preR 分别表示左子树区间的开头和结尾位置，postL 和 postR 表示右子树区间的开头和结尾位置，那么若 preL 大于 preR 或者 postL 大于 postR 的时候，说明已经不存在子树区间，直接返回空指针。然后要先新建当前树的根结点，就通过 pre[preL] 取到即可，接下来要找左子树的根结点在 post 中的位置，最简单的方法就是遍历 post 中的区间 [postL, postR]，找到其位置 idx，然后根据这个 idx，就可以算出左子树区间长度为 len = (idx-postL)+1，那么 pre 数组中左子树区间为 [preL+1, preL+len]，右子树区间为 [preL+1+len, preR]，同理，post 数组中左子树区间为 [postL, idx]，右子树区间为 [idx+1, postR-1]。知道了这些信息，就可以分别调用递归函数了，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructFromPrePost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; post)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(pre, <span class="number">0</span>, (<span class="keyword">int</span>)pre.size() - <span class="number">1</span>, post, <span class="number">0</span>, (<span class="keyword">int</span>)post.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre, <span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; post, <span class="keyword">int</span> postL, <span class="keyword">int</span> postR)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preL &gt; preR || postL &gt; postR) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> TreeNode(pre[preL]);</span><br><span class="line">        <span class="keyword">if</span> (preL == preR) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (idx = postL; idx &lt;= postR; ++idx) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre[preL + <span class="number">1</span>] == post[idx]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;left = helper(pre, preL + <span class="number">1</span>, preL + <span class="number">1</span> + (idx - postL), post, postL, idx);</span><br><span class="line">        node-&gt;right = helper(pre, preL + <span class="number">1</span> + (idx - postL) + <span class="number">1</span>, preR, post, idx + <span class="number">1</span>, postR - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode890-Find-and-Replace-Pattern"><a href="#Leetcode890-Find-and-Replace-Pattern" class="headerlink" title="Leetcode890. Find and Replace Pattern"></a>Leetcode890. Find and Replace Pattern</h1><p>You have a list of words and a pattern, and you want to know which words in words matches the pattern.</p>
<p>A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.</p>
<p>(Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.)</p>
<p>Return a list of the words in words that match the given pattern. </p>
<p>You may return the answer in any order.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: words = [&quot;abc&quot;,&quot;deq&quot;,&quot;mee&quot;,&quot;aqq&quot;,&quot;dkd&quot;,&quot;ccc&quot;], pattern = &quot;abb&quot;</span><br><span class="line">Output: [&quot;mee&quot;,&quot;aqq&quot;]</span><br><span class="line">Explanation: &quot;mee&quot; matches the pattern because there is a permutation &#123;a -&gt; m, b -&gt; e, ...&#125;. </span><br><span class="line">&quot;ccc&quot; does not match the pattern because &#123;a -&gt; c, b -&gt; c, ...&#125; is not a permutation,</span><br><span class="line">since a and b map to the same letter.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= words.length &lt;= 50</li>
<li>1 &lt;= pattern.length = words[i].length &lt;= 20</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="built_in">string</span> word,<span class="built_in">string</span> pattern)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">bool</span> seen[<span class="number">26</span>];</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt; table;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            seen[i]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;word.length();j++)&#123;</span><br><span class="line">            it = table.find(word[j]);</span><br><span class="line">            <span class="keyword">if</span>(it==table.end())&#123;</span><br><span class="line">                table[word[j]]=pattern[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(table[word[j]]!=pattern[j] )</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">            seen[i]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(it=table.begin();it!=table.end();it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(seen[it-&gt;second-<span class="string">'a'</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            seen[it-&gt;second-<span class="string">'a'</span>]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findAndReplacePattern(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">string</span> pattern) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;words.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(match(words[i],pattern))</span><br><span class="line">                res.push_back(words[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个题判断给定的字符串是不是符合pattern串的模式，很简单的题搞复杂了。用了一个map来匹配字符组合，用seen判断这个pattern字符是否出现过，如果出现过就是非法的了。</p>
<h1 id="Leetcode892-Surface-Area-of-3D-Shapes"><a href="#Leetcode892-Surface-Area-of-3D-Shapes" class="headerlink" title="Leetcode892. Surface Area of 3D Shapes"></a>Leetcode892. Surface Area of 3D Shapes</h1><p>On a N <em> N grid, we place some 1 </em> 1 * 1 cubes.</p>
<p>Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j).</p>
<p>Return the total surface area of the resulting shapes. </p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2]]</span><br><span class="line">Output: 10</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,2],[3,4]]</span><br><span class="line">Output: 34</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,0],[0,2]]</span><br><span class="line">Output: 16</span><br></pre></td></tr></table></figure></p>
<p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">Output: 32</span><br></pre></td></tr></table></figure></p>
<p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [[2,2,2],[2,1,2],[2,2,2]]</span><br><span class="line">Output: 46</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>1 &lt;= N &lt;= 50</li>
<li>0 &lt;= grid[i][j] &lt;= 50</li>
</ul>
<p>这道题给了我们一个二维数组 grid，其中 grid[i][j] 表示在位置 (i,j) 上累计的小正方体的个数，实际上就像搭积木一样，由这些小正方体来组成一个三维的物体，这里让我们求这个三维物体的表面积。我们知道每个小正方体的表面积是6，若在同一个位置累加两个，表面积就是10，三个累加到了一起就是14，其实是有规律的，n个小正方体累在一起，表面积是 4n+2。</p>
<p>现在不仅仅是累加在一个小正方体上，而是在 nxn 的区间，累加出一个三维物体。当中间的小方块缺失了之后，实际上缺失的地方会产生出四个新的面，而这四个面是应该算在表面积里的，但是用投影的方法是没法算进去的。无奈只能另辟蹊径，实际上这道题正确的思路是一个位置一个位置的累加表面积，就类似微积分的感觉，前面提到了当n个小正方体累到一起的表面积是 4n+2，而这个n就是每个位置的值 grid[i][j]，当你在旁边紧挨着再放一个累加的物体时，二者就会产生重叠，重叠的面数就是二者较矮的那堆正方体的个数再乘以2。</p>
<p>明白了这一点，我们就可以从 (0,0) 位置开始累加，先根据 grid[0][0] 的值算出若仅有该位置的三维物体的表面积，然后向 (0,1) 位置遍历，同样要先根据 grid[0][1] 的值算出若仅有该位置的三维物体的表面积，跟之前 grid[0][0] 的累加，然后再减去遮挡住的面积，通过 min(grid[0][0],grid[0][1])x2 来得到，这样每次可以计算出水平方向的遮挡面积，同时还需要减去竖直方向的遮挡面积 min(grid[i][j],grid[i-1][j])x2，这样才能算出正确的表面积.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">surfaceArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>  n =grid.size(), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; i ++)</span><br><span class="line">	        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">		        <span class="keyword">if</span>(grid[i][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res += <span class="number">4</span> * grid[i][j] + <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i &gt; <span class="number">0</span>) res -= min(grid[i][j], grid[i<span class="number">-1</span>][j]) * <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>(j &gt; <span class="number">0</span>) res -= min(grid[i][j], grid[i][j<span class="number">-1</span>]) * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode893-Groups-of-Special-Equivalent-Strings"><a href="#Leetcode893-Groups-of-Special-Equivalent-Strings" class="headerlink" title="Leetcode893. Groups of Special-Equivalent Strings"></a>Leetcode893. Groups of Special-Equivalent Strings</h1><p>You are given an array A of strings.</p>
<p>A move onto S consists of swapping any two even indexed characters of S, or any two odd indexed characters of S.</p>
<p>Two strings S and T are special-equivalent if after any number of moves onto S, S == T.</p>
<p>For example, S = “zzxy” and T = “xyzz” are special-equivalent because we may make the moves “zzxy” -&gt; “xzzy” -&gt; “xyzz” that swap S[0] and S[2], then S[1] and S[3].</p>
<p>Now, a group of special-equivalent strings from A is a non-empty subset of A such that:</p>
<p>Every pair of strings in the group are special equivalent, and;<br>The group is the largest size possible (ie., there isn’t a string S not in the group such that S is special equivalent to every string in the group)<br>Return the number of groups of special-equivalent strings from A.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;abcd&quot;,&quot;cdab&quot;,&quot;cbad&quot;,&quot;xyzz&quot;,&quot;zzxy&quot;,&quot;zzyx&quot;]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: </span><br><span class="line">One group is [&quot;abcd&quot;, &quot;cdab&quot;, &quot;cbad&quot;], since they are all pairwise special equivalent, and none of the other strings are all pairwise special equivalent to these.</span><br><span class="line"></span><br><span class="line">The other two groups are [&quot;xyzz&quot;, &quot;zzxy&quot;] and [&quot;zzyx&quot;].  Note that in particular, &quot;zzxy&quot; is not special equivalent to &quot;zzyx&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>对于一个字符串，假如其偶数位字符之间可以互相交换，且其奇数位字符之间可以互相交换，交换后若能跟另一个字符串相等，则这两个字符串是特殊相等的关系。现在给了我们一个字符串数组，将所有特殊相等的字符串放到一个群组中，问最终能有几个不同的群组。最开始的时候博主没仔细审题，以为是随意交换字母，就直接对每个单词进行排序，然后扔到一个 HashSet 中就行了。后来发现只能是奇偶位上互相交换，于是只能现先将奇偶位上的字母分别抽离出来，然后再进行分别排序，之后再合并起来组成一个新的字符串，再丢到 HashSet 中即可，利用 HashSet 的自动去重复功能，这样最终留下来的就是不同的群组了<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSpecialEquivGroups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> word : A) &#123;</span><br><span class="line">            <span class="built_in">string</span> even, odd;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); ++i) </span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) even += word[i];</span><br><span class="line">                <span class="keyword">else</span> odd += word[i];</span><br><span class="line">            </span><br><span class="line">            sort(even.begin(), even.end());</span><br><span class="line">            sort(odd.begin(), odd.end());</span><br><span class="line">            st.insert(even + odd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode894-All-Possible-Full-Binary-Trees"><a href="#Leetcode894-All-Possible-Full-Binary-Trees" class="headerlink" title="Leetcode894. All Possible Full Binary Trees"></a>Leetcode894. All Possible Full Binary Trees</h1><p>A full binary tree is a binary tree where each node has exactly 0 or 2 children.</p>
<p>Return a list of all possible full binary trees with N nodes.  Each element of the answer is the root node of one possible tree.</p>
<p>Each node of each tree in the answer must have node.val = 0.</p>
<p>You may return the final list of trees in any order.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 7</span><br><span class="line">Output: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]</span><br></pre></td></tr></table></figure></p>
<p>Explanation:<br><img src="/img/fivetrees.png" alt></p>
<p>给出了个N，代表一棵二叉树有N个节点，求所能构成的树。</p>
<p>解题方法<br>所有能构成的树，并且返回的不是数目，而是真正的树。所以一定会把所有的节点都求出来。一般就使用了递归。</p>
<p>这个题中，重点是返回一个列表，也就是说每个能够成的树的根节点都要放到这个列表里。而且当左子树、右子树的节点个数固定的时候，也会出现排列组合的情况，所以使用了两重for循环来完成所有的左右子树的组合。</p>
<p>另外的一个技巧就是，左右子树的个数一定是奇数个。</p>
<p>递归方法，虽然比较慢，但是容易理解，就是组成小的子树，一个个拼接，为啥要减1，是因为一定会有个根节点，先把这个减去再说。</p>
<p>代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; allPossibleFBT(<span class="keyword">int</span> N) &#123;</span><br><span class="line">        N--;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(N==<span class="number">0</span>)&#123;</span><br><span class="line">            res.push_back(<span class="keyword">new</span> TreeNode(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; left : allPossibleFBT(i)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; right : allPossibleFBT(N - i)) &#123;</span><br><span class="line">                    TreeNode* root = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                    root-&gt;left = left;</span><br><span class="line">                    root-&gt;right = right;</span><br><span class="line">                    res.push_back(root);           </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode896-Monotonic-Array"><a href="#Leetcode896-Monotonic-Array" class="headerlink" title="Leetcode896. Monotonic Array"></a>Leetcode896. Monotonic Array</h1><p>An array is monotonic if it is either monotone increasing or monotone decreasing.</p>
<p>An array A is monotone increasing if for all i &lt;= j, A[i] &lt;= A[j].  An array A is monotone decreasing if for all i &lt;= j, A[i] &gt;= A[j].</p>
<p>Return true if and only if the given array A is monotonic.</p>
<p>判断数组是否单调。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMonotonic</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> inc=<span class="literal">true</span>, dec=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size()<span class="number">-1</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt; A[i+<span class="number">1</span>]) inc = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &lt; A[i+<span class="number">1</span>]) dec = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inc || dec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode897-Increasing-Order-Search-Tree"><a href="#Leetcode897-Increasing-Order-Search-Tree" class="headerlink" title="Leetcode897. Increasing Order Search Tree"></a>Leetcode897. Increasing Order Search Tree</h1><p>Given a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child.</p>
<p>Example 1:<br>Input: [5,3,6,2,4,null,8,1,null,null,null,7,9]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">    3    6</span><br><span class="line">   / \    \</span><br><span class="line">  2   4    8</span><br><span class="line"> /        / \ </span><br><span class="line">1        7   9</span><br></pre></td></tr></table></figure></p>
<p>Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br><span class="line">           \</span><br><span class="line">            7</span><br><span class="line">             \</span><br><span class="line">              8</span><br><span class="line">               \</span><br><span class="line">                9</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<p>The number of nodes in the given tree will be between 1 and 100.<br>Each node will have a unique integer value from 0 to 1000.</p>
<p>本题要求把二叉树的结点重新排列，使其成为从小到大只有右孩子的二叉树。考虑使用中序遍历的迭代方法，对每个结点入栈，出栈时先访问左结点，然后中结点，最后把右指针和下一个入栈的结点链接起来。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">increasingBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; dst;</span><br><span class="line">        TreeNode *head = <span class="keyword">new</span> TreeNode(<span class="number">0</span>), *pre = head;</span><br><span class="line">        <span class="keyword">while</span>(root || !dst.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                dst.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = dst.top();</span><br><span class="line">            dst.pop();</span><br><span class="line">            pre-&gt;right=root;</span><br><span class="line">            pre = pre -&gt; right;</span><br><span class="line">            root -&gt; left = <span class="literal">NULL</span>;</span><br><span class="line">            root=root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;right;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后朴素的中序遍历是这样<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    TreeNode *s=<span class="literal">NULL</span>,*p=<span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            inorder(root-&gt;left);</span><br><span class="line">		            </span><br><span class="line">            <span class="keyword">if</span>(s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                s = <span class="keyword">new</span> TreeNode(root-&gt;val); </span><br><span class="line">                p = s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode* temp = <span class="keyword">new</span> TreeNode(root-&gt;val);</span><br><span class="line">                s-&gt;right = temp;</span><br><span class="line">                s = s-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            inorder(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">increasingBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        inorder(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="Leetcode900-RLE-Iterator"><a href="#Leetcode900-RLE-Iterator" class="headerlink" title="Leetcode900. RLE Iterator"></a>Leetcode900. RLE Iterator</h1><p>Write an iterator that iterates through a run-length encoded sequence.</p>
<p>The iterator is initialized by RLEIterator(int[] A), where A is a run-length encoding of some sequence.  More specifically, for all even i, A[i] tells us the number of times that the non-negative integer value A[i+1] is repeated in the sequence.</p>
<p>The iterator supports one function: next(int n), which exhausts the next n elements (n &gt;= 1) and returns the last element exhausted in this way.  If there is no element left to exhaust, next returns -1instead.</p>
<p>For example, we start with A = [3,8,0,9,2,5], which is a run-length encoding of the sequence [8,8,8,5,5].  This is because the sequence can be read as “three eights, zero nines, two fives”.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: [&quot;RLEIterator&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;,&quot;next&quot;], [[[3,8,0,9,2,5]],[2],[1],[1],[2]]</span><br><span class="line">Output: [null,8,8,5,-1]</span><br><span class="line">Explanation:</span><br><span class="line">RLEIterator is initialized with RLEIterator([3,8,0,9,2,5]).</span><br><span class="line">This maps to the sequence [8,8,8,5,5].</span><br><span class="line">RLEIterator.next is then called 4 times:</span><br><span class="line"></span><br><span class="line">.next(2) exhausts 2 terms of the sequence, returning 8.  The remaining sequence is now [8, 5, 5].</span><br><span class="line">.next(1) exhausts 1 term of the sequence, returning 8.  The remaining sequence is now [5, 5].</span><br><span class="line">.next(1) exhausts 1 term of the sequence, returning 5.  The remaining sequence is now [5].</span><br><span class="line">.next(2) exhausts 2 terms, returning -1.  This is because the first term exhausted was 5, but the second term did not exist.  Since the last term exhausted does not exist, we return -1.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ul>
<li>0 &lt;= A.length &lt;= 1000</li>
<li>A.length is an even integer.</li>
<li>0 &lt;= A[i] &lt;= 10^9</li>
</ul>
<p>这道题给了我们一种 Run-Length Encoded 的数组，就是每两个数字组成一个数字对儿，前一个数字表示后面的一个数字重复出现的次数。然后有一个 next 函数，让我们返回数组的第n个数字，题目中给的例子也很好的说明了题意。将每个数字对儿抽离出来，放到一个新的数组中。这样我们就只要遍历这个只有数字对儿的数组，当出现次数是0的时候，直接跳过当前数字对儿。若出现次数大于等于n，那么现将次数减去n，然后再返回该数字。否则用n减去次数，并将次数赋值为0，继续遍历下一个数字对儿。若循环退出了，直接返回 -1 即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RLEIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> pointer_en, pointer_m;</span><br><span class="line">    RLEIterator(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; encoding) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = encoding.size();</span><br><span class="line">        pointer_en = <span class="number">0</span>;</span><br><span class="line">        pointer_m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> (encoding[i] &gt; <span class="number">0</span>)</span><br><span class="line">                m.push_back(make_pair(encoding[i], encoding[i+<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = m.size();</span><br><span class="line">        <span class="keyword">while</span>(pointer_m &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[pointer_m].first &lt; n) &#123;</span><br><span class="line">                n -= m[pointer_m].first;</span><br><span class="line">                pointer_m ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                m[pointer_m].first -= n;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pointer_m &lt; len)</span><br><span class="line">            <span class="keyword">return</span> m[pointer_m].second;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其实我们根本不用将数字对儿抽离出来，直接用输入数组的形式就可以，再用一个指针 cur，指向当前数字对儿的次数即可。那么在 next 函数中，我们首先来个 while 循环，判读假如 cur 没有越界，且当n大于当前当次数了，则n减去当前次数，cur 自增2，移动到下一个数字对儿的次数上。当 while 循环结束后，判断若此时 cur 已经越界了，则返回 -1，否则当前次数减去n，并且返回当前数字即可，参见代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RLEIterator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RLEIterator(<span class="built_in">vector</span>&amp; A): nums(A), cur(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; nums.size() &amp;&amp; n &gt; nums[cur]) &#123;</span><br><span class="line">            n -= nums[cur];</span><br><span class="line">            cur += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur &gt;= nums.size()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        nums[cur] -= n;</span><br><span class="line">        <span class="keyword">return</span> nums[cur + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cur;</span><br><span class="line">    <span class="built_in">vector</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/06/Leetcode601_650/" rel="next" title="Leetcode601 - 650">
                <i class="fa fa-chevron-left"></i> Leetcode601 - 650
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/06/Cannon算法的原理实现/" rel="prev" title="Cannon算法的原理实现以及性能评测">
                Cannon算法的原理实现以及性能评测 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">334</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode851-Loud-and-Rich"><span class="nav-number">1.</span> <span class="nav-text">Leetcode851. Loud and Rich</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode852-Peak-Index-in-a-Mountain-Array"><span class="nav-number">2.</span> <span class="nav-text">Leetcode852. Peak Index in a Mountain Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode853-Car-Fleet"><span class="nav-number">3.</span> <span class="nav-text">Leetcode853. Car Fleet</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode855-Exam-Room"><span class="nav-number">4.</span> <span class="nav-text">Leetcode855. Exam Room</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode856-Score-of-Parentheses"><span class="nav-number">5.</span> <span class="nav-text">Leetcode856. Score of Parentheses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode858-Mirror-Reflection"><span class="nav-number">6.</span> <span class="nav-text">Leetcode858. Mirror Reflection</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题目大意："><span class="nav-number">6.1.</span> <span class="nav-text">题目大意：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解题思路"><span class="nav-number">6.2.</span> <span class="nav-text">解题思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode859-Buddy-Strings"><span class="nav-number">7.</span> <span class="nav-text">Leetcode859. Buddy Strings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode860-Lemonade-Change"><span class="nav-number">8.</span> <span class="nav-text">Leetcode860. Lemonade Change</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode861-Score-After-Flipping-Matrix"><span class="nav-number">9.</span> <span class="nav-text">Leetcode861. Score After Flipping Matrix</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode863-All-Nodes-Distance-K-in-Binary-Tree"><span class="nav-number">10.</span> <span class="nav-text">Leetcode863. All Nodes Distance K in Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode865-Smallest-Subtree-with-all-the-Deepest-Nodes"><span class="nav-number">11.</span> <span class="nav-text">Leetcode865. Smallest Subtree with all the Deepest Nodes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode867-Transpose-Matrix"><span class="nav-number">12.</span> <span class="nav-text">Leetcode867. Transpose Matrix</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode868-Binary-Gap"><span class="nav-number">13.</span> <span class="nav-text">Leetcode868. Binary Gap</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LeetCode869-Reordered-Power-of-2"><span class="nav-number">14.</span> <span class="nav-text">LeetCode869. Reordered Power of 2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode870-Advantage-Shuffle"><span class="nav-number">15.</span> <span class="nav-text">Leetcode870. Advantage Shuffle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode872-Leaf-Similar-Trees"><span class="nav-number">16.</span> <span class="nav-text">Leetcode872. Leaf-Similar Trees</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode873-Length-of-Longest-Fibonacci-Subsequence"><span class="nav-number">17.</span> <span class="nav-text">Leetcode873. Length of Longest Fibonacci Subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode874-Walking-Robot-Simulation"><span class="nav-number">18.</span> <span class="nav-text">Leetcode874. Walking Robot Simulation</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode875-Koko-Eating-Bananas"><span class="nav-number">19.</span> <span class="nav-text">Leetcode875. Koko Eating Bananas</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode876-Middle-of-the-Linked-List"><span class="nav-number">20.</span> <span class="nav-text">Leetcode876. Middle of the Linked List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode877-Stone-Game"><span class="nav-number">21.</span> <span class="nav-text">Leetcode877. Stone Game</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode881-Boats-to-Save-People"><span class="nav-number">22.</span> <span class="nav-text">Leetcode881. Boats to Save People</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode883-Projection-Area-of-3D-Shapes"><span class="nav-number">23.</span> <span class="nav-text">Leetcode883. Projection Area of 3D Shapes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode884-Uncommon-Words-from-Two-Sentences"><span class="nav-number">24.</span> <span class="nav-text">Leetcode884. Uncommon Words from Two Sentences</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode885-Spiral-Matrix-III"><span class="nav-number">25.</span> <span class="nav-text">Leetcode885. Spiral Matrix III</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#LeetCode886-Possible-Bipartition"><span class="nav-number">26.</span> <span class="nav-text">LeetCode886. Possible Bipartition</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode888-Fair-Candy-Swap"><span class="nav-number">27.</span> <span class="nav-text">Leetcode888. Fair Candy Swap</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal"><span class="nav-number">28.</span> <span class="nav-text">Leetcode889. Construct Binary Tree from Preorder and Postorder Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode890-Find-and-Replace-Pattern"><span class="nav-number">29.</span> <span class="nav-text">Leetcode890. Find and Replace Pattern</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode892-Surface-Area-of-3D-Shapes"><span class="nav-number">30.</span> <span class="nav-text">Leetcode892. Surface Area of 3D Shapes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode893-Groups-of-Special-Equivalent-Strings"><span class="nav-number">31.</span> <span class="nav-text">Leetcode893. Groups of Special-Equivalent Strings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode894-All-Possible-Full-Binary-Trees"><span class="nav-number">32.</span> <span class="nav-text">Leetcode894. All Possible Full Binary Trees</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode896-Monotonic-Array"><span class="nav-number">33.</span> <span class="nav-text">Leetcode896. Monotonic Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode897-Increasing-Order-Search-Tree"><span class="nav-number">34.</span> <span class="nav-text">Leetcode897. Increasing Order Search Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Leetcode900-RLE-Iterator"><span class="nav-number">35.</span> <span class="nav-text">Leetcode900. RLE Iterator</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
