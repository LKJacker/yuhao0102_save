<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zn-ch">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Linux,">










<meta name="description" content="【版权声明：尊重原创，转载请保留出处：blog.csdn.net/shallnet，文章仅供学习交流，请勿用于商业用途】 进程其实就是程序的执行时的实例，是处于执行期的程序。在linux内核中，进程列表被存放在一个双向循环链表中，链表中每一项都是类型为task_struct的结构，该结构称作进程描述符，进程描述符包含一个具体进程的所有信息，这个结构就是我们在操作系统中所说的PCB（Process">
<meta name="keywords" content="Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="把握linux内核设计思想（八）：进程管理分析">
<meta property="og:url" content="http://yoursite.com/2019/05/14/把握linux内核设计思想（八）：进程管理分析/index.html">
<meta property="og:site_name" content="Hao Yu&#39;s blog">
<meta property="og:description" content="【版权声明：尊重原创，转载请保留出处：blog.csdn.net/shallnet，文章仅供学习交流，请勿用于商业用途】 进程其实就是程序的执行时的实例，是处于执行期的程序。在linux内核中，进程列表被存放在一个双向循环链表中，链表中每一项都是类型为task_struct的结构，该结构称作进程描述符，进程描述符包含一个具体进程的所有信息，这个结构就是我们在操作系统中所说的PCB（Process">
<meta property="og:locale" content="zn-ch">
<meta property="og:updated_time" content="2019-05-14T03:22:24.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="把握linux内核设计思想（八）：进程管理分析">
<meta name="twitter:description" content="【版权声明：尊重原创，转载请保留出处：blog.csdn.net/shallnet，文章仅供学习交流，请勿用于商业用途】 进程其实就是程序的执行时的实例，是处于执行期的程序。在linux内核中，进程列表被存放在一个双向循环链表中，链表中每一项都是类型为task_struct的结构，该结构称作进程描述符，进程描述符包含一个具体进程的所有信息，这个结构就是我们在操作系统中所说的PCB（Process">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/14/把握linux内核设计思想（八）：进程管理分析/">





  <title>把握linux内核设计思想（八）：进程管理分析 | Hao Yu's blog</title>
  








 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zn-ch">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hao Yu's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">The program monkey was eaten by the siege lion.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/resume.pdf" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-mybetterhalf">
          <a href="/mybetterhalf/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>
            
            mybetterhalf
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/14/把握linux内核设计思想（八）：进程管理分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hao Yu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hao Yu's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">把握linux内核设计思想（八）：进程管理分析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-14T10:52:22+08:00">
                2019-05-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>【版权声明：尊重原创，转载请保留出处：blog.csdn.net/shallnet，文章仅供学习交流，请勿用于商业用途】</p>
<p>进程其实就是程序的执行时的实例，是处于执行期的程序。在linux内核中，进程列表被存放在一个双向循环链表中，链表中每一项都是类型为task_struct的结构，该结构称作进程描述符，进程描述符包含一个具体进程的所有信息，这个结构就是我们在操作系统中所说的PCB（Process Control Block）。该结构定义于<code>&lt;include/linux/sched.h&gt;</code>文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> struct task_struct &#123;                                                                                        </span><br><span class="line">    volatile long state;    /* -1 unrunnable, 0 runnable, &gt;0 stopped */</span><br><span class="line">    void *stack;</span><br><span class="line">    atomic_t usage;</span><br><span class="line">    unsigned int flags; /* per process flags, defined below */</span><br><span class="line">    unsigned int ptrace;</span><br><span class="line"> </span><br><span class="line">    int lock_depth;     /* BKL lock depth */</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">    int prio, static_prio, normal_prio;</span><br><span class="line">    unsigned int rt_priority;</span><br><span class="line">    const struct sched_class *sched_class;</span><br><span class="line">    struct sched_entity se;</span><br><span class="line">    struct sched_rt_entity rt;</span><br><span class="line">    ......</span><br><span class="line">    struct task_struct *parent; /* recipient of SIGCHLD, wait4() reports */</span><br><span class="line">    struct list_head children;  /* list of my children */</span><br><span class="line">    struct list_head sibling;   /* linkage in my parent&apos;s children list */</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>该结构体中包含的数据可以完整的描述一个正在执行的程序：打开的文件、进程的地址空间、挂起的信号、进程的状态、以及其他很多信息。\</p>
<p>在系统运行过程中，进程频繁切换，所以我们需要一种方式能够快速获得当前进程的task_struct，于是进程内核堆栈底部存放着struct thread_info。该结构中有一个成员指向当前进程的task_struct。在x86上，<code>struct thread_info</code>在文件<code>&lt;arch/x86/include/asm/thread_info.h&gt;</code>中定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> struct thread_info &#123;</span><br><span class="line">    struct task_struct  *task;      /* 该指针存放的是指向该任务实际task_struct的指针 */</span><br><span class="line">    struct exec_domain  *exec_domain;   /* execution domain */</span><br><span class="line">    __u32           flags;      /* low level flags */</span><br><span class="line">    __u32           status;     /* thread synchronous flags */</span><br><span class="line">    __u32           cpu;        /* current CPU */</span><br><span class="line">    int         preempt_count;  /* 0 =&gt; preemptable,</span><br><span class="line">                           &lt;0 =&gt; BUG */</span><br><span class="line">    mm_segment_t        addr_limit;</span><br><span class="line">    struct restart_block    restart_block;</span><br><span class="line">    void __user     *sysenter_return;</span><br><span class="line">#ifdef CONFIG_X86_32</span><br><span class="line">    unsigned long           previous_esp;   /* ESP of the previous stack in</span><br><span class="line">                           case of nested (IRQ) stacks</span><br><span class="line">                        */</span><br><span class="line">    __u8            supervisor_stack[0];</span><br><span class="line">#endif</span><br><span class="line">    int         uaccess_err;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>使用current宏就可以获得当前进程的进程描述符。</p>
<p>每一个进程都有一个父进程，每个进程管理自己的子进程。每个进程都是init进程的子进程，init进程在内 核系统启动的最后阶段启动init进程，该进程读取系统的初始化脚本并执行其他相关程序，最终完成系统启动的整个过程。每个进程有0个或多个子进程，进程间的关系存放在进程描述符中。task_struct中有一个parent的指针，指向其父进程；还有个children的指针指向其子进程的链表。所以，对于当前进程，可以通过current宏来获得父进程和子进程的进程描述符。<br>下面程序打印当前进程、父进程信息和所有子进程信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;                                                              </span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/version.h&gt;</span><br><span class="line"> </span><br><span class="line">#include &lt;linux/sched.h&gt;</span><br><span class="line"> </span><br><span class="line">void sln_taskstruct_do(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct task_struct  *cur,</span><br><span class="line">                        *parent,</span><br><span class="line">                        *task;</span><br><span class="line">    struct list_head    *first_child,</span><br><span class="line">                        *child_list,</span><br><span class="line">                        *cur_chd;</span><br><span class="line"> </span><br><span class="line">//获取当前进程信息</span><br><span class="line">    cur = current;</span><br><span class="line"> </span><br><span class="line">    printk(KERN_ALERT&quot;Current: %s[%d]\n&quot;,</span><br><span class="line">            cur-&gt;comm, cur-&gt;pid);</span><br><span class="line"> </span><br><span class="line">//获取父进程信息</span><br><span class="line">    parent = current-&gt;parent;</span><br><span class="line">    printk(KERN_ALERT&quot;Parent: %s[%d]\n&quot;,</span><br><span class="line">            parent-&gt;comm, parent-&gt;pid);</span><br><span class="line"> </span><br><span class="line">//获取所有祖先进程信息</span><br><span class="line">    for (task = cur; task != &amp;init_task; task = task-&gt;parent) &#123;</span><br><span class="line">        printk(KERN_ALERT&quot;ancestor: %s[%d]\n&quot;,                                          </span><br><span class="line">            task-&gt;comm, task-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">//获取所有子进程信息</span><br><span class="line">    child_list = &amp;cur-&gt;children;</span><br><span class="line">    first_child = &amp;cur-&gt;children;</span><br><span class="line">    for (cur_chd = child_list-&gt;next;</span><br><span class="line">            cur_chd != first_child;</span><br><span class="line">            cur_chd = cur_chd-&gt;next) &#123;</span><br><span class="line">        task = list_entry(child_list, struct task_struct, sibling);</span><br><span class="line"> </span><br><span class="line">        printk(KERN_ALERT&quot;Children: %s[%d]\n&quot;,</span><br><span class="line">            task-&gt;comm, task-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static int __init sln_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT&quot;===%s===\n&quot;, __func__);</span><br><span class="line"> </span><br><span class="line">    sln_taskstruct_do();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static void __exit sln_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT&quot;===%s===\n&quot;, __func__);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(sln_init);</span><br><span class="line">module_exit(sln_exit);</span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;shallnet&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;blog.csdn.net/shallnet&quot;);</span><br></pre></td></tr></table></figure></p>
<p>执行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> # insmod task.ko</span><br><span class="line">===sln_init===</span><br><span class="line">Current: insmod[4315]</span><br><span class="line">Parent: bash[4032]</span><br><span class="line">ancestor: insmod[4315]</span><br><span class="line">ancestor: bash[4032]</span><br><span class="line">ancestor: login[2563]</span><br><span class="line">ancestor: init[1]</span><br></pre></td></tr></table></figure></p>
<p>linux操作系统提供产生进程的机制，在Linux下的<code>fork()</code>使用<strong>写时拷贝(copy-on-write)</strong>页实现。这种技术原理是：内存并不复制整个进程地址空间，而是让父进程和子进程共享同一拷贝，只有在需要写入的时候，数据才会被复制。也就是资源的复制只是发生在需要写入的时候才进行，在此之前都是以只读的方式共享。</p>
<p>linux通过clone()系统调用实现fork()，然后clone()去调用do_fork()，do_fork()完成创建中大部分工作。库函数<code>vfork()</code>、<code>__clone()</code>都根据各自需要的参数标志去调用<code>clone()</code>。<code>fork()</code>的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。<br>用户空间的<code>fork()</code>经过系统调用进入内核，在内核中对应的处理函数为<code>sys_fork()</code>，定义于<code>&lt;arch/x86/kernel/process.c&gt;</code>文件中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br></pre></td><td class="code"><pre><span class="line">int sys_fork(struct pt_regs *regs)                                                      </span><br><span class="line">&#123;</span><br><span class="line">    return do_fork(SIGCHLD, regs-&gt;sp, regs, 0, NULL, NULL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">long do_fork(unsigned long clone_flags,</span><br><span class="line">       unsigned long stack_start,</span><br><span class="line">       struct pt_regs *regs,</span><br><span class="line">       unsigned long stack_size,</span><br><span class="line">       int __user *parent_tidptr,</span><br><span class="line">       int __user *child_tidptr)</span><br><span class="line">&#123;</span><br><span class="line"> struct task_struct *p;</span><br><span class="line"> int trace = 0;</span><br><span class="line"> long nr;</span><br><span class="line"> ......</span><br><span class="line"> p = copy_process(clone_flags, stack_start, regs, stack_size,</span><br><span class="line">    child_tidptr, NULL, trace);</span><br><span class="line"> ......</span><br><span class="line"> return nr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">static struct task_struct *copy_process(unsigned long clone_flags,</span><br><span class="line">                    unsigned long stack_start,</span><br><span class="line">                    struct pt_regs *regs,</span><br><span class="line">                    unsigned long stack_size,</span><br><span class="line">                    int __user *child_tidptr,</span><br><span class="line">                    struct pid *pid,</span><br><span class="line">                    int trace)</span><br><span class="line">&#123;</span><br><span class="line">    int retval;</span><br><span class="line">    struct task_struct *p;</span><br><span class="line">    int cgroup_callbacks_done = 0;</span><br><span class="line">    if ((clone_flags &amp; (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))</span><br><span class="line">        return ERR_PTR(-EINVAL);</span><br><span class="line">    /*</span><br><span class="line">     * Thread groups must share signals as well, and detached threads</span><br><span class="line">     * can only be started up within the thread group.</span><br><span class="line">     */</span><br><span class="line">    if ((clone_flags &amp; CLONE_THREAD) &amp;&amp; !(clone_flags &amp; CLONE_SIGHAND))</span><br><span class="line">        return ERR_PTR(-EINVAL);</span><br><span class="line">    /*</span><br><span class="line">     * Shared signal handlers imply shared VM. By way of the above,</span><br><span class="line">     * thread groups also imply shared VM. Blocking this case allows</span><br><span class="line">     * for various simplifications in other code.</span><br><span class="line">     */</span><br><span class="line">    if ((clone_flags &amp; CLONE_SIGHAND) &amp;&amp; !(clone_flags &amp; CLONE_VM))</span><br><span class="line">        return ERR_PTR(-EINVAL);</span><br><span class="line">    /*</span><br><span class="line">     * Siblings of global init remain as zombies on exit since they are</span><br><span class="line">     * not reaped by their parent (swapper). To solve this and to avoid</span><br><span class="line">     * multi-rooted process trees, prevent global and container-inits</span><br><span class="line">     * from creating siblings.</span><br><span class="line">     */</span><br><span class="line">    if ((clone_flags &amp; CLONE_PARENT) &amp;&amp;</span><br><span class="line">                current-&gt;signal-&gt;flags &amp; SIGNAL_UNKILLABLE)</span><br><span class="line">        return ERR_PTR(-EINVAL);</span><br><span class="line">    retval = security_task_create(clone_flags);</span><br><span class="line">    if (retval)</span><br><span class="line">        goto fork_out;</span><br><span class="line">    retval = -ENOMEM;</span><br><span class="line">    p = dup_task_struct(current);</span><br><span class="line">    if (!p)</span><br><span class="line">        goto fork_out;</span><br><span class="line">    ftrace_graph_init_task(p);</span><br><span class="line">    rt_mutex_init_task(p);</span><br><span class="line">#ifdef CONFIG_PROVE_LOCKING</span><br><span class="line">    DEBUG_LOCKS_WARN_ON(!p-&gt;hardirqs_enabled);</span><br><span class="line">    DEBUG_LOCKS_WARN_ON(!p-&gt;softirqs_enabled);</span><br><span class="line">#endif</span><br><span class="line">    retval = -EAGAIN;</span><br><span class="line">    if (atomic_read(&amp;p-&gt;real_cred-&gt;user-&gt;processes) &gt;=</span><br><span class="line">            p-&gt;signal-&gt;rlim[RLIMIT_NPROC].rlim_cur) &#123;</span><br><span class="line">        if (!capable(CAP_SYS_ADMIN) &amp;&amp; !capable(CAP_SYS_RESOURCE) &amp;&amp;</span><br><span class="line">            p-&gt;real_cred-&gt;user != INIT_USER)</span><br><span class="line">            goto bad_fork_free;</span><br><span class="line">    &#125;</span><br><span class="line">    retval = copy_creds(p, clone_flags);</span><br><span class="line">    if (retval &lt; 0)</span><br><span class="line">        goto bad_fork_free;</span><br><span class="line">    /*</span><br><span class="line">     * If multiple threads are within copy_process(), then this check</span><br><span class="line">     * triggers too late. This doesn&apos;t hurt, the check is only there</span><br><span class="line">     * to stop root fork bombs.</span><br><span class="line">     */</span><br><span class="line">    retval = -EAGAIN;</span><br><span class="line">    if (nr_threads &gt;= max_threads)</span><br><span class="line">        goto bad_fork_cleanup_count;</span><br><span class="line">    if (!try_module_get(task_thread_info(p)-&gt;exec_domain-&gt;module))</span><br><span class="line">        goto bad_fork_cleanup_count;</span><br><span class="line">    p-&gt;did_exec = 0;</span><br><span class="line">    delayacct_tsk_init(p);  /* Must remain after dup_task_struct() */</span><br><span class="line">    copy_flags(clone_flags, p);</span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;children);</span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;sibling);</span><br><span class="line">    rcu_copy_process(p);</span><br><span class="line">    p-&gt;vfork_done = NULL;</span><br><span class="line">    spin_lock_init(&amp;p-&gt;alloc_lock);</span><br><span class="line">    init_sigpending(&amp;p-&gt;pending);</span><br><span class="line">    p-&gt;utime = cputime_zero;</span><br><span class="line">    p-&gt;stime = cputime_zero;</span><br><span class="line">    p-&gt;gtime = cputime_zero;</span><br><span class="line">    p-&gt;utimescaled = cputime_zero;</span><br><span class="line">    p-&gt;stimescaled = cputime_zero;</span><br><span class="line">    p-&gt;prev_utime = cputime_zero;</span><br><span class="line">    p-&gt;prev_stime = cputime_zero;</span><br><span class="line">    p-&gt;default_timer_slack_ns = current-&gt;timer_slack_ns;</span><br><span class="line">    task_io_accounting_init(&amp;p-&gt;ioac);</span><br><span class="line">    acct_clear_integrals(p);</span><br><span class="line">    posix_cpu_timers_init(p);</span><br><span class="line">    p-&gt;lock_depth = -1;     /* -1 = no lock */</span><br><span class="line">    do_posix_clock_monotonic_gettime(&amp;p-&gt;start_time);</span><br><span class="line">    p-&gt;real_start_time = p-&gt;start_time;</span><br><span class="line">    monotonic_to_bootbased(&amp;p-&gt;real_start_time);</span><br><span class="line">    p-&gt;io_context = NULL;</span><br><span class="line">    p-&gt;audit_context = NULL;</span><br><span class="line">    cgroup_fork(p);</span><br><span class="line">#ifdef CONFIG_NUMA</span><br><span class="line">    p-&gt;mempolicy = mpol_dup(p-&gt;mempolicy);</span><br><span class="line">    if (IS_ERR(p-&gt;mempolicy)) &#123;</span><br><span class="line">        retval = PTR_ERR(p-&gt;mempolicy);</span><br><span class="line">        p-&gt;mempolicy = NULL;</span><br><span class="line">        goto bad_fork_cleanup_cgroup;</span><br><span class="line">    &#125;</span><br><span class="line">    mpol_fix_fork_child_flag(p);</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_TRACE_IRQFLAGS</span><br><span class="line">    p-&gt;irq_events = 0;</span><br><span class="line">#ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW</span><br><span class="line">    p-&gt;hardirqs_enabled = 1;</span><br><span class="line">#else</span><br><span class="line">    p-&gt;hardirqs_enabled = 0;</span><br><span class="line">#endif</span><br><span class="line">    p-&gt;hardirq_enable_ip = 0;</span><br><span class="line">    p-&gt;hardirq_enable_event = 0;</span><br><span class="line">    p-&gt;hardirq_disable_ip = _THIS_IP_;</span><br><span class="line">    p-&gt;hardirq_disable_event = 0;</span><br><span class="line">    p-&gt;softirqs_enabled = 1;</span><br><span class="line">    p-&gt;softirq_enable_ip = _THIS_IP_;</span><br><span class="line">    p-&gt;softirq_enable_event = 0;</span><br><span class="line">    p-&gt;softirq_disable_ip = 0;</span><br><span class="line">    p-&gt;softirq_disable_event = 0;</span><br><span class="line">    p-&gt;hardirq_context = 0;</span><br><span class="line">    p-&gt;softirq_context = 0;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_LOCKDEP</span><br><span class="line">    p-&gt;lockdep_depth = 0; /* no locks held yet */</span><br><span class="line">    p-&gt;curr_chain_key = 0;</span><br><span class="line">    p-&gt;lockdep_recursion = 0;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_DEBUG_MUTEXES</span><br><span class="line">    p-&gt;blocked_on = NULL; /* not blocked yet */</span><br><span class="line">#endif</span><br><span class="line">    p-&gt;bts = NULL;</span><br><span class="line">    p-&gt;stack_start = stack_start;</span><br><span class="line">    /* Perform scheduler related setup. Assign this task to a CPU. */</span><br><span class="line">    sched_fork(p, clone_flags);</span><br><span class="line">    retval = perf_event_init_task(p);</span><br><span class="line">    if (retval)</span><br><span class="line">        goto bad_fork_cleanup_policy;</span><br><span class="line">    if ((retval = audit_alloc(p)))</span><br><span class="line">        goto bad_fork_cleanup_policy;</span><br><span class="line">    /* copy all the process information */</span><br><span class="line">    if ((retval = copy_semundo(clone_flags, p)))</span><br><span class="line">        goto bad_fork_cleanup_audit;</span><br><span class="line">    if ((retval = copy_files(clone_flags, p)))</span><br><span class="line">        goto bad_fork_cleanup_semundo;</span><br><span class="line">    if ((retval = copy_fs(clone_flags, p)))</span><br><span class="line">        goto bad_fork_cleanup_files;</span><br><span class="line">    if ((retval = copy_sighand(clone_flags, p)))</span><br><span class="line">        goto bad_fork_cleanup_fs;</span><br><span class="line">    if ((retval = copy_signal(clone_flags, p)))</span><br><span class="line">        goto bad_fork_cleanup_sighand;</span><br><span class="line">    if ((retval = copy_mm(clone_flags, p)))</span><br><span class="line">        goto bad_fork_cleanup_signal;</span><br><span class="line">    if ((retval = copy_namespaces(clone_flags, p)))</span><br><span class="line">        goto bad_fork_cleanup_mm;</span><br><span class="line">    if ((retval = copy_io(clone_flags, p)))</span><br><span class="line">        goto bad_fork_cleanup_namespaces;</span><br><span class="line">    retval = copy_thread(clone_flags, stack_start, stack_size, p, regs);</span><br><span class="line">    if (retval)</span><br><span class="line">        goto bad_fork_cleanup_io;</span><br><span class="line">    if (pid != &amp;init_struct_pid) &#123;</span><br><span class="line">        retval = -ENOMEM;</span><br><span class="line">        pid = alloc_pid(p-&gt;nsproxy-&gt;pid_ns);</span><br><span class="line">        if (!pid)</span><br><span class="line">            goto bad_fork_cleanup_io;</span><br><span class="line">        if (clone_flags &amp; CLONE_NEWPID) &#123;</span><br><span class="line">            retval = pid_ns_prepare_proc(p-&gt;nsproxy-&gt;pid_ns);</span><br><span class="line">            if (retval &lt; 0)</span><br><span class="line">                goto bad_fork_free_pid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;pid = pid_nr(pid);</span><br><span class="line">    p-&gt;tgid = p-&gt;pid;</span><br><span class="line">    if (clone_flags &amp; CLONE_THREAD)</span><br><span class="line">        p-&gt;tgid = current-&gt;tgid;</span><br><span class="line">    if (current-&gt;nsproxy != p-&gt;nsproxy) &#123;</span><br><span class="line">        retval = ns_cgroup_clone(p, pid);</span><br><span class="line">        if (retval)</span><br><span class="line">            goto bad_fork_free_pid;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;set_child_tid = (clone_flags &amp; CLONE_CHILD_SETTID) ? child_tidptr : NULL;</span><br><span class="line">    /*</span><br><span class="line">     * Clear TID on mm_release()?</span><br><span class="line">     */</span><br><span class="line">    p-&gt;clear_child_tid = (clone_flags &amp; CLONE_CHILD_CLEARTID) ? child_tidptr: NULL;</span><br><span class="line">#ifdef CONFIG_FUTEX</span><br><span class="line">    p-&gt;robust_list = NULL;</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">    p-&gt;compat_robust_list = NULL;</span><br><span class="line">#endif</span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;pi_state_list);</span><br><span class="line">    p-&gt;pi_state_cache = NULL;</span><br><span class="line">#endif</span><br><span class="line">    /*</span><br><span class="line">     * sigaltstack should be cleared when sharing the same VM</span><br><span class="line">     */</span><br><span class="line">    if ((clone_flags &amp; (CLONE_VM|CLONE_VFORK)) == CLONE_VM)</span><br><span class="line">        p-&gt;sas_ss_sp = p-&gt;sas_ss_size = 0;</span><br><span class="line">    /*</span><br><span class="line">     * Syscall tracing should be turned off in the child regardless</span><br><span class="line">     * of CLONE_PTRACE.</span><br><span class="line">     */</span><br><span class="line">    clear_tsk_thread_flag(p, TIF_SYSCALL_TRACE);</span><br><span class="line">#ifdef TIF_SYSCALL_EMU</span><br><span class="line">    clear_tsk_thread_flag(p, TIF_SYSCALL_EMU);</span><br><span class="line">#endif</span><br><span class="line">    clear_all_latency_tracing(p);</span><br><span class="line">    /* ok, now we should be set up.. */</span><br><span class="line">    p-&gt;exit_signal = (clone_flags &amp; CLONE_THREAD) ? -1 : (clone_flags &amp; CSIGNAL);</span><br><span class="line">    p-&gt;pdeath_signal = 0;</span><br><span class="line">    p-&gt;exit_state = 0;</span><br><span class="line">    /*</span><br><span class="line">     * Ok, make it visible to the rest of the system.</span><br><span class="line">     * We dont wake it up yet.</span><br><span class="line">     */</span><br><span class="line">    p-&gt;group_leader = p;</span><br><span class="line">    INIT_LIST_HEAD(&amp;p-&gt;thread_group);</span><br><span class="line">    /* Now that the task is set up, run cgroup callbacks if</span><br><span class="line">     * necessary. We need to run them before the task is visible</span><br><span class="line">     * on the tasklist. */</span><br><span class="line">    cgroup_fork_callbacks(p);</span><br><span class="line">    cgroup_callbacks_done = 1;</span><br><span class="line">    /* Need tasklist lock for parent etc handling! */</span><br><span class="line">    write_lock_irq(&amp;tasklist_lock);</span><br><span class="line">    /*</span><br><span class="line">     * The task hasn&apos;t been attached yet, so its cpus_allowed mask will</span><br><span class="line">     * not be changed, nor will its assigned CPU.</span><br><span class="line">     *</span><br><span class="line">     * The cpus_allowed mask of the parent may have changed after it was</span><br><span class="line">     * copied first time - so re-copy it here, then check the child&apos;s CPU</span><br><span class="line">     * to ensure it is on a valid CPU (and if not, just force it back to</span><br><span class="line">     * parent&apos;s CPU). This avoids alot of nasty races.</span><br><span class="line">     */</span><br><span class="line">    p-&gt;cpus_allowed = current-&gt;cpus_allowed;</span><br><span class="line">    p-&gt;rt.nr_cpus_allowed = current-&gt;rt.nr_cpus_allowed;</span><br><span class="line">    if (unlikely(!cpu_isset(task_cpu(p), p-&gt;cpus_allowed) ||</span><br><span class="line">            !cpu_online(task_cpu(p))))</span><br><span class="line">        set_task_cpu(p, smp_processor_id());</span><br><span class="line">    /* CLONE_PARENT re-uses the old parent */</span><br><span class="line">    if (clone_flags &amp; (CLONE_PARENT|CLONE_THREAD)) &#123;</span><br><span class="line">        p-&gt;real_parent = current-&gt;real_parent;</span><br><span class="line">        p-&gt;parent_exec_id = current-&gt;parent_exec_id;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        p-&gt;real_parent = current;</span><br><span class="line">        p-&gt;parent_exec_id = current-&gt;self_exec_id;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_lock(¤t-&gt;sighand-&gt;siglock);</span><br><span class="line">    /*</span><br><span class="line">     * Process group and session signals need to be delivered to just the</span><br><span class="line">     * parent before the fork or both the parent and the child after the</span><br><span class="line">     * fork. Restart if a signal comes in before we add the new process to</span><br><span class="line">     * it&apos;s process group.</span><br><span class="line">     * A fatal signal pending means that current will exit, so the new</span><br><span class="line">     * thread can&apos;t slip out of an OOM kill (or normal SIGKILL).</span><br><span class="line">     */</span><br><span class="line">    recalc_sigpending();</span><br><span class="line">    if (signal_pending(current)) &#123;</span><br><span class="line">        spin_unlock(¤t-&gt;sighand-&gt;siglock);</span><br><span class="line">        write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line">        retval = -ERESTARTNOINTR;</span><br><span class="line">        goto bad_fork_free_pid;</span><br><span class="line">    &#125;</span><br><span class="line">    if (clone_flags &amp; CLONE_THREAD) &#123;</span><br><span class="line">        atomic_inc(¤t-&gt;signal-&gt;count);</span><br><span class="line">        atomic_inc(¤t-&gt;signal-&gt;live);</span><br><span class="line">        p-&gt;group_leader = current-&gt;group_leader;</span><br><span class="line">        list_add_tail_rcu(&amp;p-&gt;thread_group, &amp;p-&gt;group_leader-&gt;thread_group);</span><br><span class="line">    &#125;</span><br><span class="line">    if (likely(p-&gt;pid)) &#123;</span><br><span class="line">        list_add_tail(&amp;p-&gt;sibling, &amp;p-&gt;real_parent-&gt;children);</span><br><span class="line">        tracehook_finish_clone(p, clone_flags, trace);</span><br><span class="line">        if (thread_group_leader(p)) &#123;</span><br><span class="line">            if (clone_flags &amp; CLONE_NEWPID)</span><br><span class="line">                p-&gt;nsproxy-&gt;pid_ns-&gt;child_reaper = p;</span><br><span class="line">            p-&gt;signal-&gt;leader_pid = pid;</span><br><span class="line">            tty_kref_put(p-&gt;signal-&gt;tty);</span><br><span class="line">            p-&gt;signal-&gt;tty = tty_kref_get(current-&gt;signal-&gt;tty);</span><br><span class="line">            attach_pid(p, PIDTYPE_PGID, task_pgrp(current));</span><br><span class="line">            attach_pid(p, PIDTYPE_SID, task_session(current));</span><br><span class="line">            list_add_tail_rcu(&amp;p-&gt;tasks, &amp;init_task.tasks);</span><br><span class="line">            __get_cpu_var(process_counts)++;</span><br><span class="line">        &#125;</span><br><span class="line">        attach_pid(p, PIDTYPE_PID, pid);</span><br><span class="line">        nr_threads++;</span><br><span class="line">    &#125;</span><br><span class="line">    total_forks++;</span><br><span class="line">    spin_unlock(¤t-&gt;sighand-&gt;siglock);</span><br><span class="line">    write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line">    proc_fork_connector(p);</span><br><span class="line">    cgroup_post_fork(p);</span><br><span class="line">    perf_event_fork(p);</span><br><span class="line">    return p;</span><br><span class="line">bad_fork_free_pid:</span><br><span class="line">    if (pid != &amp;init_struct_pid)</span><br><span class="line">        free_pid(pid);</span><br><span class="line">bad_fork_cleanup_io:</span><br><span class="line">    put_io_context(p-&gt;io_context);</span><br><span class="line">bad_fork_cleanup_namespaces:</span><br><span class="line">    exit_task_namespaces(p);</span><br><span class="line">bad_fork_cleanup_mm:</span><br><span class="line">    if (p-&gt;mm)</span><br><span class="line">        mmput(p-&gt;mm);</span><br><span class="line">bad_fork_cleanup_signal:</span><br><span class="line">    if (!(clone_flags &amp; CLONE_THREAD))</span><br><span class="line">        __cleanup_signal(p-&gt;signal);</span><br><span class="line">bad_fork_cleanup_sighand:</span><br><span class="line">    __cleanup_sighand(p-&gt;sighand);</span><br><span class="line">bad_fork_cleanup_fs:</span><br><span class="line">    exit_fs(p); /* blocking */</span><br><span class="line">bad_fork_cleanup_files:</span><br><span class="line">    exit_files(p); /* blocking */</span><br><span class="line">bad_fork_cleanup_semundo:</span><br><span class="line">    exit_sem(p);</span><br><span class="line">bad_fork_cleanup_audit:</span><br><span class="line">    audit_free(p);</span><br><span class="line">bad_fork_cleanup_policy:</span><br><span class="line">    perf_event_free_task(p);</span><br><span class="line">#ifdef CONFIG_NUMA</span><br><span class="line">    mpol_put(p-&gt;mempolicy);</span><br><span class="line">bad_fork_cleanup_cgroup:</span><br><span class="line">#endif</span><br><span class="line">    cgroup_exit(p, cgroup_callbacks_done);</span><br><span class="line">    delayacct_tsk_free(p);</span><br><span class="line">    module_put(task_thread_info(p)-&gt;exec_domain-&gt;module);</span><br><span class="line">bad_fork_cleanup_count:</span><br><span class="line">    atomic_dec(&amp;p-&gt;cred-&gt;user-&gt;processes);</span><br><span class="line">    exit_creds(p);</span><br><span class="line">bad_fork_free:</span><br><span class="line">    free_task(p);</span><br><span class="line">fork_out:</span><br><span class="line">    return ERR_PTR(retval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面执行完以后，回到<code>do_fork()</code>函数，如果<code>copy_process()</code>函数成功返回。新创建的子进程被唤醒并让其投入运行。内核有意选择子进程先运行。因为一般子进程都会马上调用exec()函数，这样可以避免写时拷贝的额外开销。如果父进程首先执行的话，有可能会开始向地址空间写入。</p>
<p>线程机制提供了在同一程序内共享内存地址空间运行的一组线程。线程机制支持并发程序设计技术，可以共享打开的文件和其他资源。如果你的系统是多核心的，那多线程技术可保证系统的真正并行。在linux中，并没有线程这个概念，linux中所有的线程都当作进程来处理，换句话说就是在内核中并没有什么特殊的结构和算法来表示线程。在linux中，线程仅仅是一个使用共享资源的进程。每个线程都拥有一个隶属于自己的task_struct。所以说线程本质上还是进程，只不过该进程可以和其他一些进程共享某些资源信息。</p>
<p>内核有时需要在后台执行一些操作，这种任务可以通过内核线程完成，内核线程独立运行在内核空间的标准进程。内核线程和普通的进程间的区别在于内核线程没有独立的地址空间。它们只在讷河空间运行，从来不切换到用户空间去。内核进程和普通进程一样，可以被调度，也可以被抢占。内核线程也只能由其它内核线程创建，内核是通过从kthreadd内核进程中衍生出所有新的内核线程来自动处理这一点的。在内核中创建一个的内核线程方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct *kthread_create(int (*threadfn)(void *data),</span><br><span class="line">                   void *data,                                                          </span><br><span class="line">                   const char namefmt[], ...)</span><br></pre></td></tr></table></figure></p>
<p>该函数实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct *kthread_create(int (*threadfn)(void *data),</span><br><span class="line">                   void *data,</span><br><span class="line">                   const char namefmt[],</span><br><span class="line">                   ...)</span><br><span class="line">&#123;</span><br><span class="line">    struct kthread_create_info create;</span><br><span class="line">    create.threadfn = threadfn;</span><br><span class="line">    create.data = data;</span><br><span class="line">    init_completion(&amp;create.done);</span><br><span class="line">    spin_lock(&amp;kthread_create_lock);</span><br><span class="line">    list_add_tail(&amp;create.list, &amp;kthread_create_list);</span><br><span class="line">    spin_unlock(&amp;kthread_create_lock);</span><br><span class="line">    wake_up_process(kthreadd_task);</span><br><span class="line">    wait_for_completion(&amp;create.done);</span><br><span class="line">    if (!IS_ERR(create.result)) &#123;</span><br><span class="line">        struct sched_param param = &#123; .sched_priority = 0 &#125;;</span><br><span class="line">        va_list args;</span><br><span class="line">        va_start(args, namefmt);</span><br><span class="line">        vsnprintf(create.result-&gt;comm, sizeof(create.result-&gt;comm),</span><br><span class="line">              namefmt, args);</span><br><span class="line">        va_end(args);</span><br><span class="line">        /*  </span><br><span class="line">         * root may have changed our (kthreadd&apos;s) priority or CPU mask.</span><br><span class="line">         * The kernel thread should not inherit these properties.</span><br><span class="line">         */</span><br><span class="line">        sched_setscheduler_nocheck(create.result, SCHED_NORMAL, ¶m);</span><br><span class="line">        set_cpus_allowed_ptr(create.result, cpu_all_mask);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>新的任务是由kthread内核进程通过clone()系统调用而创建的。新的进程将运行threadfn函数，给其传递参数data，新的进程名称为namefmt，新创建的进程处于不可运行状态，需要调用wake_up_process()明确的唤醒它，否则它不会主动运行。也可以通过调用kthread_run()来创建一个进程并让它运行起来。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define kthread_run(threadfn, data, namefmt, ...)              \                        </span><br><span class="line">(&#123;                                     \</span><br><span class="line">    struct task_struct *__k                        \</span><br><span class="line">        = kthread_create(threadfn, data, namefmt, ## __VA_ARGS__); \</span><br><span class="line">    if (!IS_ERR(__k))                          \</span><br><span class="line">        wake_up_process(__k);                      \</span><br><span class="line">    __k;                                   \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>kthread_run其实就是创建了一个内核线程并且唤醒了。内核线程启动后就一直运行直到调用<code>do_exit()</code>退出或者内核的其他部分调用<code>kthread_stop()</code>退出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int kthread_stop(struct task_struct *k);</span><br></pre></td></tr></table></figure></p>
<p>下面为一个使用内核线程的示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;</span><br><span class="line">#include &lt;linux/init.h&gt;</span><br><span class="line">#include &lt;linux/version.h&gt;</span><br><span class="line">#include &lt;linux/sched.h&gt;  //schdule_timeout()</span><br><span class="line">#include &lt;linux/kthread.h&gt;</span><br><span class="line">struct task_struct  *sln_task;</span><br><span class="line">int sln_kthread_func(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    while (!kthread_should_stop()) &#123;</span><br><span class="line">        printk(KERN_ALERT&quot;===%s===\n&quot;, __func__);</span><br><span class="line">        set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">        schedule_timeout(2*HZ);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">void sln_init_do(void)</span><br><span class="line">&#123;</span><br><span class="line">    int data = 9527;</span><br><span class="line">    sln_task = kthread_create(sln_kthread_func,</span><br><span class="line">            &amp;data,</span><br><span class="line">            &quot;sln_kthread_task&quot;);</span><br><span class="line">    if (IS_ERR(sln_task)) &#123;</span><br><span class="line">        printk(KERN_ALERT&quot;kthread_create() failed!\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    wake_up_process(sln_task);</span><br><span class="line">&#125;</span><br><span class="line">void sln_exit_do(void)</span><br><span class="line">&#123;</span><br><span class="line">    if (NULL != sln_task) &#123;</span><br><span class="line">        kthread_stop(sln_task);</span><br><span class="line">        sln_task = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">static int __init sln_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT&quot;===%s===\n&quot;, __func__);</span><br><span class="line">    sln_init_do();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">static void __exit sln_exit(void)</span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT&quot;===%s===\n&quot;, __func__);</span><br><span class="line">    sln_exit_do();</span><br><span class="line">&#125;</span><br><span class="line">module_init(sln_init);</span><br><span class="line">module_exit(sln_exit);</span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;shallnet&quot;);</span><br><span class="line">MODULE_DESCRIPTION(&quot;blog.csdn.net/shallnet&quot;);</span><br></pre></td></tr></table></figure></p>
<p>既然有进程的创建，那就有进程的终结，终结时内核必须释放它所占有的资源。内核终结时，大部分任务都是靠do_exit()（定义于）来完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">NORET_TYPE void do_exit(long code)</span><br><span class="line">&#123;</span><br><span class="line">    struct task_struct *tsk = current;</span><br><span class="line">    int group_dead;</span><br><span class="line">    profile_task_exit(tsk);</span><br><span class="line">    WARN_ON(atomic_read(&amp;tsk-&gt;fs_excl));</span><br><span class="line">   //不可在中断上下文中使用该函数</span><br><span class="line">    if (unlikely(in_interrupt()))</span><br><span class="line">        panic(&quot;Aiee, killing interrupt handler!&quot;);</span><br><span class="line">    if (unlikely(!tsk-&gt;pid))</span><br><span class="line">        panic(&quot;Attempted to kill the idle task!&quot;);</span><br><span class="line">    tracehook_report_exit(&amp;code);</span><br><span class="line">    validate_creds_for_do_exit(tsk);</span><br><span class="line">    /*</span><br><span class="line">     * We&apos;re taking recursive faults here in do_exit. Safest is to just</span><br><span class="line">     * leave this task alone and wait for reboot.</span><br><span class="line">     */</span><br><span class="line">    if (unlikely(tsk-&gt;flags &amp; PF_EXITING)) &#123;</span><br><span class="line">        printk(KERN_ALERT</span><br><span class="line">            &quot;Fixing recursive fault but reboot is needed!\n&quot;);</span><br><span class="line"> </span><br><span class="line">        //设置PF_EXITING:表示进程正在退出</span><br><span class="line">        tsk-&gt;flags |= PF_EXITPIDONE;</span><br><span class="line">        set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">    exit_irq_thread();</span><br><span class="line">    exit_signals(tsk);  /* sets PF_EXITING */</span><br><span class="line">    /*</span><br><span class="line">     * tsk-&gt;flags are checked in the futex code to protect against</span><br><span class="line">     * an exiting task cleaning up the robust pi futexes.</span><br><span class="line">     */</span><br><span class="line">    smp_mb();</span><br><span class="line">    spin_unlock_wait(&amp;tsk-&gt;pi_lock);</span><br><span class="line">    if (unlikely(in_atomic()))</span><br><span class="line">        printk(KERN_INFO &quot;note: %s[%d] exited with preempt_count %d\n&quot;,</span><br><span class="line">                current-&gt;comm, task_pid_nr(current),</span><br><span class="line">                preempt_count());</span><br><span class="line">    acct_update_integrals(tsk);</span><br><span class="line">    group_dead = atomic_dec_and_test(&amp;tsk-&gt;signal-&gt;live);</span><br><span class="line">    if (group_dead) &#123;</span><br><span class="line">        hrtimer_cancel(&amp;tsk-&gt;signal-&gt;real_timer);</span><br><span class="line">        exit_itimers(tsk-&gt;signal);</span><br><span class="line">        if (tsk-&gt;mm)</span><br><span class="line">            setmax_mm_hiwater_rss(&amp;tsk-&gt;signal-&gt;maxrss, tsk-&gt;mm);</span><br><span class="line">    &#125;</span><br><span class="line">    acct_collect(code, group_dead);</span><br><span class="line">    if (group_dead)</span><br><span class="line">        tty_audit_exit();</span><br><span class="line">    if (unlikely(tsk-&gt;audit_context))</span><br><span class="line">        audit_free(tsk);</span><br><span class="line">    tsk-&gt;exit_code = code;</span><br><span class="line">    taskstats_exit(tsk, group_dead);</span><br><span class="line">       //调用__exit_mm()函数放弃进程占用的mm_struct,如果没有别的进程使用它们即没被共享，就彻底释放它们</span><br><span class="line">    exit_mm(tsk);</span><br><span class="line">    if (group_dead)</span><br><span class="line">        acct_process();</span><br><span class="line">    trace_sched_process_exit(tsk);</span><br><span class="line">    exit_sem(tsk);    //调用sem_exit()函数。如果进程排队等候IPC信号，它则离开队列</span><br><span class="line">     //分别递减文件描述符，文件系统数据等的引用计数。当引用计数的值为0时，就代表没有进程在使用这些资源，此时就释放</span><br><span class="line">    exit_files(tsk);</span><br><span class="line">    exit_fs(tsk);</span><br><span class="line">    check_stack_usage();</span><br><span class="line">    exit_thread();</span><br><span class="line">    cgroup_exit(tsk, 1);</span><br><span class="line">    if (group_dead &amp;&amp; tsk-&gt;signal-&gt;leader)</span><br><span class="line">        disassociate_ctty(1);</span><br><span class="line">    module_put(task_thread_info(tsk)-&gt;exec_domain-&gt;module);</span><br><span class="line">    proc_exit_connector(tsk);</span><br><span class="line">    /*</span><br><span class="line">     * Flush inherited counters to the parent - before the parent</span><br><span class="line">     * gets woken up by child-exit notifications.</span><br><span class="line">     */</span><br><span class="line">    perf_event_exit_task(tsk);</span><br><span class="line">//调用exit_notify()向父进程发送信号，将子进程的父进程重新设置为线程组中的其他线程或init进程，并把进程状态设为TASK_ZOMBIE.</span><br><span class="line">    exit_notify(tsk, group_dead);</span><br><span class="line">#ifdef CONFIG_NUMA</span><br><span class="line">    mpol_put(tsk-&gt;mempolicy);</span><br><span class="line">    tsk-&gt;mempolicy = NULL;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_FUTEX</span><br><span class="line">    if (unlikely(current-&gt;pi_state_cache))</span><br><span class="line">        kfree(current-&gt;pi_state_cache);</span><br><span class="line">#endif</span><br><span class="line">    /*</span><br><span class="line">     * Make sure we are holding no locks:</span><br><span class="line">     */</span><br><span class="line">    debug_check_no_locks_held(tsk);</span><br><span class="line">    /*</span><br><span class="line">     * We can do this unlocked here. The futex code uses this flag</span><br><span class="line">     * just to verify whether the pi state cleanup has been done</span><br><span class="line">     * or not. In the worst case it loops once more.</span><br><span class="line">     */</span><br><span class="line">    tsk-&gt;flags |= PF_EXITPIDONE;</span><br><span class="line">    if (tsk-&gt;io_context)</span><br><span class="line">        exit_io_context();</span><br><span class="line">    if (tsk-&gt;splice_pipe)</span><br><span class="line">        __free_pipe_info(tsk-&gt;splice_pipe);</span><br><span class="line">    validate_creds_for_do_exit(tsk);</span><br><span class="line">    preempt_disable();</span><br><span class="line">    exit_rcu();</span><br><span class="line">    /* causes final put_task_struct in finish_task_switch(). */</span><br><span class="line">    tsk-&gt;state = TASK_DEAD;</span><br><span class="line">    schedule();    //调用schedule()切换到其他进程</span><br><span class="line">    BUG();</span><br><span class="line">    /* Avoid &quot;noreturn function does return&quot;.  */</span><br><span class="line">    for (;;)</span><br><span class="line">        cpu_relax();    /* For when BUG is null */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>进程终结时所需的清理工作和进程描述符的删除被分开执行，这样尽管在调用了do_exit()之后，线程已经僵死不能允许情况下，系统还是保留了它的进程描述符。在父进程获得已经终结的子进程信息后，子进程的task_struct结构才被释放。linux中有一系列wait()函数，这些函数都是基于系统调用wait4()实现的。它的动作就是挂起调用它的进程直到其中的一个子进程退出，此时函数会返回该退出子进程的PID。 最终释放进程描述符时，会调用<code>release_task()</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void release_task(struct task_struct * p)</span><br><span class="line">&#123;</span><br><span class="line">    struct task_struct *leader;</span><br><span class="line">    int zap_leader;</span><br><span class="line">repeat:</span><br><span class="line">    tracehook_prepare_release_task(p);</span><br><span class="line">    /* don&apos;t need to get the RCU readlock here - the process is dead and</span><br><span class="line">     * can&apos;t be modifying its own credentials */</span><br><span class="line">    atomic_dec(&amp;__task_cred(p)-&gt;user-&gt;processes);</span><br><span class="line">    proc_flush_task(p);</span><br><span class="line">    write_lock_irq(&amp;tasklist_lock);</span><br><span class="line">    tracehook_finish_release_task(p);</span><br><span class="line">    __exit_signal(p);    //释放目前僵死进程所使用的所有剩余资源，并进行统计记录</span><br><span class="line">    </span><br><span class="line">    zap_leader = 0;</span><br><span class="line">    leader = p-&gt;group_leader;</span><br><span class="line">    //如果进程是线程组最后一个进程，并且领头进程已经死掉，那么就通知僵死的领头进程的父进程</span><br><span class="line">    if (leader != p &amp;&amp; thread_group_empty(leader) &amp;&amp; leader-&gt;exit_state == EXIT_ZOMBIE)</span><br><span class="line">&#123;</span><br><span class="line">        BUG_ON(task_detached(leader));</span><br><span class="line">        do_notify_parent(leader, leader-&gt;exit_signal);</span><br><span class="line">        zap_leader = task_detached(leader);</span><br><span class="line">       </span><br><span class="line">        if (zap_leader)</span><br><span class="line">            leader-&gt;exit_state = EXIT_DEAD;</span><br><span class="line">    &#125;</span><br><span class="line">    write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line">    release_thread(p);</span><br><span class="line">    call_rcu(&amp;p-&gt;rcu, delayed_put_task_struct);</span><br><span class="line">    p = leader;</span><br><span class="line">    if (unlikely(zap_leader))</span><br><span class="line">        goto repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>子进程不一定能保证在父进程前边退出，所以必须要有机制来保证子进程在这种情况下能找到一个新的父进程。否则的话，这些成为孤儿的进程就会在退出时永远处于僵死状态，白白的耗费内存。解决这个问题的办法，就是给子进程在当前线程组内找一个线程作为父亲。一旦系统给进程成功地找到和设置了新的父进程，就不会再有出现驻留僵死进程的危险了，init进程会例行调用wait()来等待子进程，清除所有与其相关的僵死进程。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/14/把握linux内核设计思想（七）：内核定时器和定时执行/" rel="next" title="把握linux内核设计思想（七）：内核定时器和定时执行">
                <i class="fa fa-chevron-left"></i> 把握linux内核设计思想（七）：内核定时器和定时执行
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/14/把握linux内核设计思想（九）：进程调度/" rel="prev" title="把握linux内核设计思想（九）：进程调度">
                把握linux内核设计思想（九）：进程调度 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="Hao Yu">
            
              <p class="site-author-name" itemprop="name">Hao Yu</p>
              <p class="site-description motion-element" itemprop="description">Introduce something interesting and recode learning process, some articles are written by others, the original link has been given as much as possible, thanks to the original author</p>
          </div>
          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">323</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
        	<audio controls="controls" loop="loop" preload="auto" src="/resource/xiaomeihao.mp3">
	        </audio>
	

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yuhao0102" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:yuh18@mails.tsinghua.edu.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>
  <div id="DvelopmentTarget">     
  </div>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart" aria-hidden="false"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao Yu</span>

  
</div>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_uv"> 
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
</span>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  <script type="text/javascript" src="/js/src/love.js"></script>

</body>
</html>
