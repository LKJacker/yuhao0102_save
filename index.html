<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Hao Yu&#39;s blog</title>
  <meta name="author" content="Hao Yu">
  
  <meta name="description" content="Introduce something interesting">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Hao Yu&#39;s blog">

  
    <meta property="og:image" content>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Hao Yu&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>
</html>

<body>
  <header id="header"><div class="meta inner">
  <h1><a href="/">Hao Yu&#39;s blog</a></h1>
  <h2><a href="/">The program monkey was eaten by the siege lion.</a></h2>
  <nav id="main-nav">
    <ul>
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about">About</a></li>
      
      <li><a href="/archives">Archives</a></li>
      
      <li><a href="/atom.xml">RSS</a></li>
      
    </ul>
    <div class="clearfix"></div>
  </nav>
</div>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2019/04/09/Leetcode56-Merge-Intervals/">56. Merge Intervals</a></h1>
  

      
        <time datetime="2019-04-09T06:03:31.000Z">2019-04-09</time>
      
    </header>
    <div class="entry">
      
        <ol start="56">
<li>Merge Intervals<br>Medium</li>
</ol>
<p>Given a collection of intervals, merge all overlapping intervals.<br>一些区间，要求合并重叠的区间，返回一个vector保存结果。</p>
<p>Example 1:<br>·<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure></p>
<p>贪心思路，将初始区间序列ins按照左端点的从小到大排序，接着遍历ins。 一开始将第一个区间ins[0]放入结果区间序列res，接着每次遍历到一个新的区间[l,r]，将其与当前合并后的最后一个区间[L,R]比较：</p>
<blockquote>
<p>若l &lt;= R，说明新区间与当前最有一个区间有重叠，应该将这两个区间合并，也就需要修改当前最后一个区间为[L，max(r,R)]。<br>若l &gt; R，说明新区间与当前最后一个区间没有重叠，所以不需要合并，直接将新区间加入结果序列res，成为新的最后一个区间。</p>
</blockquote>
<p>算法正确性：</p>
<p>在上述贪心思路中，只考虑了新区间的左端点与最后一个区间的右端点的大小比较，最后只会对最后区间的右端点进行修改，却不会修改左端点。之所以不考虑左端点，是因为初始化时已经将ins按照左端点排序，保证后遍历的左端点l &gt;= 之前遍历过的左端点L。 算法复杂度为O(nlogn)。</p>
<p>我的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for an interval.</span><br><span class="line"> * struct Interval &#123;</span><br><span class="line"> *     int start;</span><br><span class="line"> *     int end;</span><br><span class="line"> *     Interval() : start(0), end(0) &#123;&#125;</span><br><span class="line"> *     Interval(int s, int e) : start(s), end(e) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    static bool comp(const Interval &amp;a, const Interval &amp;b) &#123;</span><br><span class="line">        return a.start &lt; b.start;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;Interval&gt; answer;</span><br><span class="line">        if(intervals.size()==0)</span><br><span class="line">            return answer;</span><br><span class="line">        sort(intervals.begin(),intervals.end(),comp);</span><br><span class="line">        Interval ttt(intervals[0].start,intervals[0].end);</span><br><span class="line">        vector&lt;Interval&gt;::iterator it = intervals.begin();</span><br><span class="line">        it++;</span><br><span class="line">        for(; it != intervals.end(); it++)&#123;</span><br><span class="line">            if(ttt.end&gt;=it-&gt;start)&#123;</span><br><span class="line">                if(ttt.end&lt;it-&gt;end)</span><br><span class="line">                    ttt.end=it-&gt;end;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(ttt.end&lt;it-&gt;start)&#123;</span><br><span class="line">                answer.push_back(ttt);</span><br><span class="line">                ttt.start=it-&gt;start;</span><br><span class="line">                ttt.end = it-&gt;end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        answer.push_back(ttt);</span><br><span class="line">        return answer;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>题解的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public:</span><br><span class="line">        static bool cmp(const Interval &amp;a, const Interval &amp;b) &#123;</span><br><span class="line">            return a.start &lt; b.start;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;Interval&gt; merge(vector&lt;Interval&gt;&amp; ins) &#123;</span><br><span class="line">            vector &lt;Interval&gt; res;</span><br><span class="line">            if (ins.empty()) return res;</span><br><span class="line">            sort(ins.begin(), ins.end(), cmp);</span><br><span class="line">            res.push_back(ins[0]);</span><br><span class="line">            int cnt = ins.size();</span><br><span class="line">            for (int i = 1; i &lt; cnt; i++) &#123;</span><br><span class="line">                if (ins[i].start &lt;= res.back().end) &#123;</span><br><span class="line">                    res.back().end = max(res.back().end, ins[i].end);</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    res.push_back(ins[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Solution<br>Approach 1: Connected Components<br>Intuition</p>
<p>If we draw a graph (with intervals as nodes) that contains undirected edges between all pairs of intervals that overlap, then all intervals in each connected component of the graph can be merged into a single interval.</p>
<p>Algorithm</p>
<p>With the above intuition in mind, we can represent the graph as an adjacency list, inserting directed edges in both directions to simulate undirected edges. Then, to determine which connected component each node is it, we perform graph traversals from arbitrary unvisited nodes until all nodes have been visited. To do this efficiently, we store visited nodes in a Set, allowing for constant time containment checks and insertion. Finally, we consider each connected component, merging all of its intervals by constructing a new Interval with start equal to the minimum start among them and end equal to the maximum end.</p>
<p>This algorithm is correct simply because it is basically the brute force solution. We compare every interval to every other interval, so we know exactly which intervals overlap. The reason for the connected component search is that two intervals may not directly overlap, but might overlap indirectly via a third interval. See the example below to see this more clearly.</p>
<p>Components Example</p>
<p>Although (1, 5) and (6, 10) do not directly overlap, either would overlap with the other if first merged with (4, 7). There are two connected components, so if we merge their nodes, we expect to get the following two merged intervals:</p>
<p>(1, 10), (15, 20)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private Map&lt;Interval, List&lt;Interval&gt; &gt; graph;</span><br><span class="line">    private Map&lt;Integer, List&lt;Interval&gt; &gt; nodesInComp;</span><br><span class="line">    private Set&lt;Interval&gt; visited;</span><br><span class="line"></span><br><span class="line">    // return whether two intervals overlap (inclusive)</span><br><span class="line">    private boolean overlap(Interval a, Interval b) &#123;</span><br><span class="line">        return a.start &lt;= b.end &amp;&amp; b.start &lt;= a.end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // build a graph where an undirected edge between intervals u and v exists</span><br><span class="line">    // iff u and v overlap.</span><br><span class="line">    private void buildGraph(List&lt;Interval&gt; intervals) &#123;</span><br><span class="line">        graph = new HashMap&lt;&gt;();</span><br><span class="line">        for (Interval interval : intervals) &#123;</span><br><span class="line">            graph.put(interval, new LinkedList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (Interval interval1 : intervals) &#123;</span><br><span class="line">            for (Interval interval2 : intervals) &#123;</span><br><span class="line">                if (overlap(interval1, interval2)) &#123;</span><br><span class="line">                    graph.get(interval1).add(interval2);</span><br><span class="line">                    graph.get(interval2).add(interval1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def merge(self, intervals):</span><br><span class="line">        intervals.sort(key=lambda x: x.start)</span><br><span class="line"></span><br><span class="line">        merged = []</span><br><span class="line">        for interval in intervals:</span><br><span class="line">            # if the list of merged intervals is empty or if the current</span><br><span class="line">            # interval does not overlap with the previous, simply append it.</span><br><span class="line">            if not merged or merged[-1].end &lt; interval.start:</span><br><span class="line">                merged.append(interval)</span><br><span class="line">            else:</span><br><span class="line">            # otherwise, there is overlap, so we merge the current and previous</span><br><span class="line">            # intervals.</span><br><span class="line">                merged[-1].end = max(merged[-1].end, interval.end)</span><br><span class="line"></span><br><span class="line">        return merged</span><br></pre></td></tr></table></figure>
      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2019/04/09/二叉树高频面试题和答案/">二叉树高频面试题和答案</a></h1>
  

      
        <time datetime="2019-04-09T05:24:05.000Z">2019-04-09</time>
      
    </header>
    <div class="entry">
      
        <p>先上二叉树的数据结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    //左孩子</span><br><span class="line">    TreeNode left;</span><br><span class="line">    //右孩子</span><br><span class="line">    TreeNode right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>二叉树的题目普遍可以用递归和迭代的方式来解</p>
<ol>
<li><p>求二叉树的最大深度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int maxDeath(TreeNode node)&#123;</span><br><span class="line">    if(node==null)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int left = maxDeath(node.left);</span><br><span class="line">    int right = maxDeath(node.right);</span><br><span class="line">    return Math.max(left,right) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求二叉树的最小深度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int getMinDepth(TreeNode root)&#123;</span><br><span class="line">      if(root == null)&#123;</span><br><span class="line">          return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      return getMin(root);</span><br><span class="line">  &#125;</span><br><span class="line">  int getMin(TreeNode root)&#123;</span><br><span class="line">      if(root == null)&#123;</span><br><span class="line">          return Integer.MAX_VALUE;</span><br><span class="line">      &#125;</span><br><span class="line">      if(root.left == null&amp;&amp;root.right == null)&#123;</span><br><span class="line">          return 1;</span><br><span class="line">      &#125;</span><br><span class="line">      return Math.min(getMin(root.left),getMin(root.right)) + 1;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求二叉树中节点的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int numOfTreeNode(TreeNode root)&#123;</span><br><span class="line">      if(root == null)&#123;</span><br><span class="line">          return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      int left = numOfTreeNode(root.left);</span><br><span class="line">      int right = numOfTreeNode(root.right);</span><br><span class="line">      return left + right + 1;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求二叉树中叶子节点的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> int numsOfNoChildNode(TreeNode root)&#123;</span><br><span class="line">    if(root == null)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(root.left==null&amp;&amp;root.right==null)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return numsOfNodeTreeNode(root.left)+numsOfNodeTreeNode(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求二叉树中第k层节点的个数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int numsOfkLevelTreeNode(TreeNode root,int k)&#123;</span><br><span class="line">      if(root == null||k&lt;1)&#123;</span><br><span class="line">          return 0;</span><br><span class="line">      &#125;</span><br><span class="line">      if(k==1)&#123;</span><br><span class="line">          return 1;</span><br><span class="line">      &#125;</span><br><span class="line">      int numsLeft = numsOfkLevelTreeNode(root.left,k-1);</span><br><span class="line">      int numsRight = numsOfkLevelTreeNode(root.right,k-1);</span><br><span class="line">      return numsLeft + numsRight;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断二叉树是否是平衡二叉树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">boolean isBalanced(TreeNode node)&#123;</span><br><span class="line">       return maxDeath2(node)!=-1;</span><br><span class="line">   &#125;</span><br><span class="line">   int maxDeath2(TreeNode node)&#123;</span><br><span class="line">       if(node == null)&#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">       int left = maxDeath2(node.left);</span><br><span class="line">       int right = maxDeath2(node.right);</span><br><span class="line">       if(left==-1||right==-1||Math.abs(left-right)&gt;1)&#123;</span><br><span class="line">           return -1;</span><br><span class="line">       &#125;</span><br><span class="line">       return Math.max(left, right) + 1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>7.判断二叉树是否是完全二叉树<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">boolean isCompleteTreeNode(TreeNode root)&#123;</span><br><span class="line">     if(root == null)&#123;</span><br><span class="line">         return false;</span><br><span class="line">     &#125;</span><br><span class="line">     Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">     queue.add(root);</span><br><span class="line">     boolean result = true;</span><br><span class="line">     boolean hasNoChild = false;</span><br><span class="line">     while(!queue.isEmpty())&#123;</span><br><span class="line">         TreeNode current = queue.remove();</span><br><span class="line">         if(hasNoChild)&#123;</span><br><span class="line">             if(current.left!=null||current.right!=null)&#123;</span><br><span class="line">                 result = false;</span><br><span class="line">                 break;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;else&#123;</span><br><span class="line">             if(current.left!=null&amp;&amp;current.right!=null)&#123;</span><br><span class="line">                 queue.add(current.left);</span><br><span class="line">                 queue.add(current.right);</span><br><span class="line">             &#125;else if(current.left!=null&amp;&amp;current.right==null)&#123;</span><br><span class="line">                 queue.add(current.left);</span><br><span class="line">                 hasNoChild = true;</span><br><span class="line">             &#125;else if(current.left==null&amp;&amp;current.right!=null)&#123;</span><br><span class="line">                 result = false;</span><br><span class="line">                 break;</span><br><span class="line">             &#125;else&#123;</span><br><span class="line">                 hasNoChild = true;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<ol start="8">
<li><p>两个二叉树是否完全相同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">boolean isSameTreeNode(TreeNode t1,TreeNode t2)&#123;</span><br><span class="line">    if(t1==null&amp;&amp;t2==null)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(t1==null||t2==null)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(t1.val != t2.val)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean left = isSameTreeNode(t1.left,t2.left);</span><br><span class="line">    boolean right = isSameTreeNode(t1.right,t2.right);</span><br><span class="line">    return left&amp;&amp;right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>两个二叉树是否互为镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> boolean isMirror(TreeNode t1,TreeNode t2)&#123;</span><br><span class="line">    if(t1==null&amp;&amp;t2==null)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if(t1==null||t2==null)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(t1.val != t2.val)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return isMirror(t1.left,t2.right)&amp;&amp;isMirror(t1.right,t2.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>翻转二叉树or镜像二叉树</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  TreeNode mirrorTreeNode(TreeNode root)&#123;</span><br><span class="line">    if(root == null)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode left = mirrorTreeNode(root.left);</span><br><span class="line">    TreeNode right = mirrorTreeNode(root.right);</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求两个二叉树的最低公共祖先节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">TreeNode getLastCommonParent(TreeNode root,TreeNode t1,TreeNode t2)&#123;</span><br><span class="line">    if(findNode(root.left,t1))&#123;</span><br><span class="line">        if(findNode(root.right,t2))&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return getLastCommonParent(root.left,t1,t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        if(findNode(root.left,t2))&#123;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return getLastCommonParent(root.right,t1,t2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 查找节点node是否在当前 二叉树中</span><br><span class="line">boolean findNode(TreeNode root,TreeNode node)&#123;</span><br><span class="line">    if(root == null || node == null)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if(root == node)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    boolean found = findNode(root.left,node);</span><br><span class="line">    if(!found)&#123;</span><br><span class="line">        found = findNode(root.right,node);</span><br><span class="line">    &#125;</span><br><span class="line">    return found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二叉树的前序遍历</p>
</li>
</ol>
<p>迭代解法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; preOrder(TreeNode root)&#123;</span><br><span class="line">      Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();</span><br><span class="line">      ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">      if(root == null)&#123;</span><br><span class="line">          return list;</span><br><span class="line">      &#125;</span><br><span class="line">      stack.push(root);</span><br><span class="line">      while(!stack.empty())&#123;</span><br><span class="line">          TreeNode node = stack.pop();</span><br><span class="line">          list.add(node.val);</span><br><span class="line">          if(node.right!=null)&#123;</span><br><span class="line">              stack.push(node.right);</span><br><span class="line">          &#125;</span><br><span class="line">          if(node.left != null)&#123;</span><br><span class="line">              stack.push(node.left);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>递归解法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; preOrderReverse(TreeNode root)&#123;</span><br><span class="line">      ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();</span><br><span class="line">      preOrder2(root,result);</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line">  void preOrder2(TreeNode root,ArrayList&lt;Integer&gt; result)&#123;</span><br><span class="line">      if(root == null)&#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      result.add(root.val);</span><br><span class="line">      preOrder2(root.left,result);</span><br><span class="line">      preOrder2(root.right,result);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<ol start="13">
<li>二叉树的中序遍历<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; inOrder(TreeNode root)&#123;</span><br><span class="line">      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&lt;Integer&gt;();</span><br><span class="line">      Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();</span><br><span class="line">      TreeNode current = root;</span><br><span class="line">      while(current != null|| !stack.empty())&#123;</span><br><span class="line">          while(current != null)&#123;</span><br><span class="line">              stack.add(current);</span><br><span class="line">              current = current.left;</span><br><span class="line">          &#125;</span><br><span class="line">          current = stack.peek();</span><br><span class="line">          stack.pop();</span><br><span class="line">          list.add(current.val);</span><br><span class="line">          current = current.right;</span><br><span class="line">      &#125;</span><br><span class="line">      return list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>14.二叉树的后序遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; postOrder(TreeNode root)&#123;</span><br><span class="line">      ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span><br><span class="line">      if(root == null)&#123;</span><br><span class="line">          return list;</span><br><span class="line">      &#125;</span><br><span class="line">      list.addAll(postOrder(root.left));</span><br><span class="line">      list.addAll(postOrder(root.right));</span><br><span class="line">      list.add(root.val);</span><br><span class="line">      return list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>15.前序遍历和后序遍历构造二叉树<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TreeNode buildTreeNode(int[] preorder,int[] inorder)&#123;</span><br><span class="line">      if(preorder.length!=inorder.length)&#123;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">      return myBuildTree(inorder,0,inorder.length-1,preorder,0,preorder.length-1);</span><br><span class="line">  &#125;</span><br><span class="line">  TreeNode myBuildTree(int[] inorder,int instart,int inend,int[] preorder,int prestart,int preend)&#123;</span><br><span class="line">      if(instart&gt;inend)&#123;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">      TreeNode root = new TreeNode(preorder[prestart]);</span><br><span class="line">      int position = findPosition(inorder,instart,inend,preorder[start]);</span><br><span class="line">      root.left = myBuildTree(inorder,instart,position-1,preorder,prestart+1,prestart+position-instart);</span><br><span class="line">      root.right = myBuildTree(inorder,position+1,inend,preorder,position-inend+preend+1,preend);</span><br><span class="line">      return root;</span><br><span class="line">  &#125;</span><br><span class="line">  int findPosition(int[] arr,int start,int end,int key)&#123;</span><br><span class="line">      int i;</span><br><span class="line">      for(i = start;i&lt;=end;i++)&#123;</span><br><span class="line">          if(arr[i] == key)&#123;</span><br><span class="line">              return i;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return -1;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>16.在二叉树中插入节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">TreeNode insertNode(TreeNode root,TreeNode node)&#123;</span><br><span class="line">     if(root == node)&#123;</span><br><span class="line">         return node;</span><br><span class="line">     &#125;</span><br><span class="line">     TreeNode tmp = new TreeNode();</span><br><span class="line">     tmp = root;</span><br><span class="line">     TreeNode last = null;</span><br><span class="line">     while(tmp!=null)&#123;</span><br><span class="line">         last = tmp;</span><br><span class="line">         if(tmp.val&gt;node.val)&#123;</span><br><span class="line">             tmp = tmp.left;</span><br><span class="line">         &#125;else&#123;</span><br><span class="line">             tmp = tmp.right;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     if(last!=null)&#123;</span><br><span class="line">         if(last.val&gt;node.val)&#123;</span><br><span class="line">             last.left = node;</span><br><span class="line">         &#125;else&#123;</span><br><span class="line">             last.right = node;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return root;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>17.输入一个二叉树和一个整数，打印出二叉树中节点值的和等于输入整数所有的路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void findPath(TreeNode r,int i)&#123;</span><br><span class="line">     if(root == null)&#123;</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line">     Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</span><br><span class="line">     int currentSum = 0;</span><br><span class="line">     findPath(r, i, stack, currentSum);</span><br><span class="line"> &#125;</span><br><span class="line"> void findPath(TreeNode r,int i,Stack&lt;Integer&gt; stack,int currentSum)&#123;</span><br><span class="line">     currentSum+=r.val;</span><br><span class="line">     stack.push(r.val);</span><br><span class="line">     if(r.left==null&amp;&amp;r.right==null)&#123;</span><br><span class="line">         if(currentSum==i)&#123;</span><br><span class="line">             for(int path:stack)&#123;</span><br><span class="line">                 System.out.println(path);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     if(r.left!=null)&#123;</span><br><span class="line">         findPath(r.left, i, stack, currentSum);</span><br><span class="line">     &#125;</span><br><span class="line">     if(r.right!=null)&#123;</span><br><span class="line">         findPath(r.right, i, stack, currentSum);</span><br><span class="line">     &#125;</span><br><span class="line">     stack.pop();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>18.二叉树的搜索区间<br>给定两个值 k1 和 k2（k1 &lt; k2）和一个二叉查找树的根节点。找到树中所有值在 k1 到 k2 范围内的节点。即打印所有x (k1 &lt;= x &lt;= k2) 其中 x 是二叉查找树的中的节点值。返回所有升序的节点值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; result;</span><br><span class="line">  ArrayList&lt;Integer&gt; searchRange(TreeNode root,int k1,int k2)&#123;</span><br><span class="line">      result = new ArrayList&lt;Integer&gt;();</span><br><span class="line">      searchHelper(root,k1,k2);</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br><span class="line">  void searchHelper(TreeNode root,int k1,int k2)&#123;</span><br><span class="line">      if(root == null)&#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      if(root.val&gt;k1)&#123;</span><br><span class="line">          searchHelper(root.left,k1,k2);</span><br><span class="line">      &#125;</span><br><span class="line">      if(root.val&gt;=k1&amp;&amp;root.val&lt;=k2)&#123;</span><br><span class="line">          result.add(root.val);</span><br><span class="line">      &#125;</span><br><span class="line">      if(root.val&lt;k2)&#123;</span><br><span class="line">          searchHelper(root.right,k1,k2);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>19.二叉树的层次遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder(TreeNode root)&#123;</span><br><span class="line">      ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">      if(root == null)&#123;</span><br><span class="line">          return result;</span><br><span class="line">      &#125;</span><br><span class="line">      Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">      queue.offer(root);</span><br><span class="line">      while(!queue.isEmpty())&#123;</span><br><span class="line">          int size = queue.size();</span><br><span class="line">          ArrayList&lt;&lt;Integer&gt; level = new ArrayList&lt;Integer&gt;():</span><br><span class="line">          for(int i = 0;i &lt; size ;i++)&#123;</span><br><span class="line">              TreeNode node = queue.poll();</span><br><span class="line">              level.add(node.val);</span><br><span class="line">              if(node.left != null)&#123;</span><br><span class="line">                  queue.offer(node.left);</span><br><span class="line">              &#125;</span><br><span class="line">              if(node.right != null)&#123;</span><br><span class="line">                  queue.offer(node.right);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; </span><br><span class="line">          result.add(Level);</span><br><span class="line">      &#125;</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>20.二叉树内两个节点的最长距离<br>二叉树中两个节点的最长距离可能有三种情况：</p>
<ul>
<li>左子树的最大深度+右子树的最大深度为二叉树的最长距离</li>
<li>左子树中的最长距离即为二叉树的最长距离</li>
<li>右子树种的最长距离即为二叉树的最长距离</li>
</ul>
<p>因此，递归求解即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> private static class Result&#123;  </span><br><span class="line">    int maxDistance;  </span><br><span class="line">    int maxDepth;  </span><br><span class="line">    public Result() &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public Result(int maxDistance, int maxDepth) &#123;  </span><br><span class="line">        this.maxDistance = maxDistance;  </span><br><span class="line">        this.maxDepth = maxDepth;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">    int getMaxDistance(TreeNode root)&#123;</span><br><span class="line">      return getMaxDistanceResult(root).maxDistance;</span><br><span class="line">    &#125;</span><br><span class="line">    Result getMaxDistanceResult(TreeNode root)&#123;</span><br><span class="line">        if(root == null)&#123;</span><br><span class="line">            Result empty = new Result(0,-1);</span><br><span class="line">            return empty;</span><br><span class="line">        &#125;</span><br><span class="line">        Result lmd = getMaxDistanceResult(root.left);</span><br><span class="line">        Result rmd = getMaxDistanceResult(root.right);</span><br><span class="line">        Result result = new Result();</span><br><span class="line">        result.maxDepth = Math.max(lmd.maxDepth,rmd.maxDepth) + 1;</span><br><span class="line">        result.maxDistance = Math.max(lmd.maxDepth + rmd.maxDepth,Math.max(lmd.maxDistance,rmd.maxDistance));</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>21.不同的二叉树<br>给出 n，问由 1…n 为节点组成的不同的二叉查找树有多少种？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int numTrees(int n )&#123;</span><br><span class="line">      int[] counts = new int[n+2];</span><br><span class="line">      counts[0] = 1;</span><br><span class="line">      counts[1] = 1;</span><br><span class="line">      for(int i = 2;i&lt;=n;i++)&#123;</span><br><span class="line">          for(int j = 0;j&lt;i;j++)&#123;</span><br><span class="line">              counts[i] += counts[j] * counts[i-j-1];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return counts[n];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>22.判断二叉树是否是合法的二叉查找树(BST)<br>一棵BST定义为：</p>
<ul>
<li>节点的左子树中的值要严格小于该节点的值。</li>
<li>节点的右子树中的值要严格大于该节点的值。</li>
<li>左右子树也必须是二叉查找树。</li>
</ul>
<p>一个节点的树也是二叉查找树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int lastVal = Integer.MAX_VALUE;</span><br><span class="line">   public boolean firstNode = true;</span><br><span class="line">   public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">       // write your code here</span><br><span class="line">       if(root==null)&#123;</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">       if(!isValidBST(root.left))&#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       if(!firstNode&amp;&amp;lastVal &gt;= root.val)&#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       firstNode = false;</span><br><span class="line">       lastVal = root.val;</span><br><span class="line">       if (!isValidBST(root.right)) &#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2019/04/09/gdb调试相关/">gdb调试相关</a></h1>
  

      
        <time datetime="2019-04-09T04:47:34.000Z">2019-04-09</time>
      
    </header>
    <div class="entry">
      
        <p>给师兄debug测试的时候深深觉得自己太垃圾了，gdb用的不熟，所以去找了一篇gdb的博文搬过来整理好，纯当复习了。<br>贴原文链接：<a href="https://blog.csdn.net/zb872676223/article/details/37906049" target="_blank" rel="noopener">https://blog.csdn.net/zb872676223/article/details/37906049</a></p>
<h1 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h1><p>我们先看看我们的测试程序:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/* in eg1.c */</span><br><span class="line">int wib(int no1, int no2)</span><br><span class="line">&#123;</span><br><span class="line">    int result, diff;</span><br><span class="line">    diff = no1 - no2;</span><br><span class="line">    result = no1 / diff;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    if (pid &lt;0) &#123;</span><br><span class="line">        printf(&quot;fork err\n&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125; else if (pid == 0) &#123;</span><br><span class="line">        /* in child process */</span><br><span class="line">        sleep(60); ------------------ (!)</span><br><span class="line"></span><br><span class="line">        int value = 10;</span><br><span class="line">        int div = 6;</span><br><span class="line">        int total = 0;</span><br><span class="line">        int i     = 0;</span><br><span class="line">        int result = 0;</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">                result = wib(value, div);</span><br><span class="line">                total += result;</span><br><span class="line">                div++;</span><br><span class="line">                value--;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d wibed by %d equals %d\n&quot;, value, div, total);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">         /* in parent process */</span><br><span class="line">         sleep(4);</span><br><span class="line">         wait(-1);</span><br><span class="line">         exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该测试程序中子进程运行过程中会在wib函数中出现一个’除0’异常。现在我们就要调试该子进程。</p>
<h1 id="调试原理"><a href="#调试原理" class="headerlink" title="调试原理"></a>调试原理</h1><p>不知道大家发现没有，在(!)处在我们的测试程序在父进程fork后，子进程调用sleep睡了60秒。这就是关键，这个sleep本来是不该存在于子进程代码中的，而是而了使用GDB调试后加入的，它是我们调试的一个关键点。为什么要让子进程刚刚运行就开始sleep呢？因为我们要在子进程睡眠期间，利用 shell命令获取其process id，然后再利用gdb调试外部进程的方法attach到该process id上，调试该进程。<br>我们现在调试的是mpi程序，intel的mpiexec可以直接-gdb进行调试，但是用gnu的话就不行了，只能gdb attach来调试，下述。</p>
<h1 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h1><p>GDB 调试程序的前提条件就是你编译程序时必须加入调试符号信息，即使用’-g’编译选项。首先编译我们的源程序<code>gcc -g -o eg1 eg1.c</code>。编译好之后，我们就有了我们的调试目标eg1。由于我们在调试过程中需要多个工具配合，所以你最好多打开几个终端窗口，另外一点需要注意的是最好在eg1的working directory下执行gdb程序，否则gdb回提示’No symbol table is loaded’。你还得手工load symbol table。好了，下面我们就’按部就班’的开始调试我们的eg1。</p>
<p>执行eg1:<code>eg1 &amp;   --- 让eg1后台运行</code></p>
<p>查找进程id:<code>ps -fu YOUR_USER_NAME</code><br>或在linux下使用<code>getpid()</code>函数</p>
<p>运行gdb:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">gdb</span><br><span class="line">(gdb) attach xxxxx --- xxxxx为利用ps命令获得的子进程process id</span><br><span class="line">(gdb) stop --- 这点很重要，你需要先暂停那个子进程，然后设置一些断点和一些Watch</span><br><span class="line">(gdb) break 37 -- 在result = wib(value, div);这行设置一个断点,可以使用list命令察看源代码</span><br><span class="line">Breakpoint 1 at 0x10808: file eg1.c, line 37.</span><br><span class="line">(gdb) continue</span><br><span class="line">Continuing.</span><br><span class="line">这里一定要continue，要不的话。。。。。。傻呼呼的等那么久还不运行。</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at eg1.c:37</span><br><span class="line">37                              result = wib(value, div);</span><br><span class="line">(gdb) step</span><br><span class="line">wib (no1=10, no2=6) at eg1.c:13</span><br><span class="line">13              diff = no1 - no2;</span><br><span class="line">(gdb) continue</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at eg1.c:37</span><br><span class="line">37                              result = wib(value, div);</span><br><span class="line">(gdb) step</span><br><span class="line">wib (no1=9, no2=7) at eg1.c:13</span><br><span class="line">13              diff = no1 - no2;</span><br><span class="line">(gdb) continue</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at eg1.c:37</span><br><span class="line">37                              result = wib(value, div);</span><br><span class="line">(gdb) step</span><br><span class="line">wib (no1=8, no2=8) at eg1.c:13</span><br><span class="line">13              diff = no1 - no2;</span><br><span class="line">(gdb) next</span><br><span class="line">14              result = no1 / diff;</span><br><span class="line">(gdb) print diff</span><br><span class="line">$6 = 0        ------- 除数为0，我们找到罪魁祸首了。</span><br><span class="line">(gdb) next</span><br><span class="line">Program received signal SIGFPE, Arithmetic exception.</span><br><span class="line">0xff29d830 in .div () from /usr/lib/libc.so.1</span><br></pre></td></tr></table></figure></p>
<p>至此，我们调试完毕。</p>
<h1 id="GDB调试精粹"><a href="#GDB调试精粹" class="headerlink" title="GDB调试精粹"></a>GDB调试精粹</h1><h2 id="一、列文件清单"><a href="#一、列文件清单" class="headerlink" title="一、列文件清单"></a>一、列文件清单</h2><p><code>list / l</code><br>列出产生执行文件的源代码的一部分</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//列出 line1 到 line2 行之间的源代码  </span><br><span class="line">(gdb) list line1, line2  </span><br><span class="line">  </span><br><span class="line">//输出从上次调用list命令开始往后的10行程序代码  </span><br><span class="line">(gdb) list  </span><br><span class="line">  </span><br><span class="line">//输出第 n 行附近的10行程序代码  </span><br><span class="line">(gdb) list n  </span><br><span class="line">  </span><br><span class="line">//输出函数function前后的10行程序代码  </span><br><span class="line">(gdb) list function</span><br></pre></td></tr></table></figure>
<h2 id="二、执行程序"><a href="#二、执行程序" class="headerlink" title="二、执行程序"></a>二、执行程序</h2><p><code>run / r</code><br>运行准备调试的程序，在它后面可以跟随发给该程序的任何参数，包括标准输入和标准输出说明符(&lt;和&gt;)和shell通配符（*、？、[、]）在内。<br>如果你使用不带参数的run命令，gdb就再次使用你给予前一条run命令的参数，这是很有用的。</p>
<p><code>set args</code><br>命令就可以修改发送给程序的参数，而使用</p>
<p><code>show args</code><br>命令就可以查看其缺省参数的列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set args –b –x  </span><br><span class="line">(gdb) show args</span><br></pre></td></tr></table></figure>
<h2 id="三、显示数据"><a href="#三、显示数据" class="headerlink" title="三、显示数据"></a>三、显示数据</h2><p><code>print / p</code><br>查看变量的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//利用print 命令可以检查各个变量的值。  </span><br><span class="line">(gdb) print p (p为变量名)  </span><br><span class="line">print 是 gdb 的一个功能很强的命令，利用它可以显示被调试的语言中任何有效的表达式。表达式除了包含你程序中的变量外，还可以包含以下内容：</span><br><span class="line"></span><br><span class="line">//对程序中函数的调用  </span><br><span class="line">(gdb) print find_entry(1, 0)  </span><br><span class="line">  </span><br><span class="line">//数据结构和其他复杂对象  </span><br><span class="line">(gdb) print *table_start  </span><br><span class="line">$8=&#123;e=reference=’\000’,location=0x0,next=0x0&#125;  </span><br><span class="line">  </span><br><span class="line">//值的历史成分  </span><br><span class="line">(gdb)print $1 ($1为历史记录变量,在以后可以直接引用 $1 的值)  </span><br><span class="line">whatis </span><br><span class="line"></span><br><span class="line">查看变量的类型</span><br><span class="line"></span><br><span class="line">//whatis 命令可以显示某个变量的类型  </span><br><span class="line">(gdb) whatis p  </span><br><span class="line">type = int *</span><br></pre></td></tr></table></figure>
<p>四、设置与清除断点</p>
<p><code>break / b</code><br>可以用来在调试的程序中设置断点，该命令有如下四种形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//使程序恰好在执行给定行之前停止  </span><br><span class="line">break line-number  </span><br><span class="line">  </span><br><span class="line">//使程序恰好在进入指定的函数之前停止  </span><br><span class="line">  </span><br><span class="line">break function-name  </span><br><span class="line">  </span><br><span class="line">//如果condition（条件）是真，程序到达指定行或函数时停止  </span><br><span class="line">break line-or-function if condition  </span><br><span class="line">   </span><br><span class="line">//在指定例程的入口处设置断点  </span><br><span class="line">break routine-name</span><br></pre></td></tr></table></figure></p>
<p>如果该程序是由很多原文件构成的，你可以在各个原文件中设置断点，而不是在当前的原文件中设置断点，其方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break filename:line-number  </span><br><span class="line">  </span><br><span class="line">(gdb) break filename:function-name  </span><br><span class="line">break  if</span><br></pre></td></tr></table></figure></p>
<p>要想设置一个条件断点，可以利用break if命令，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break line-or-function if expr  </span><br><span class="line">  </span><br><span class="line">(gdb) break 46 if testsize==100  </span><br><span class="line">clean number</span><br></pre></td></tr></table></figure></p>
<p>清除原文件中某一代码行上的所有断点</p>
<p>注：number 为原文件的某个代码行的行号</p>
<h2 id="五、断点的管理"><a href="#五、断点的管理" class="headerlink" title="五、断点的管理"></a>五、断点的管理</h2><ol>
<li><p>显示当前gdb的断点信息<br><code>info break</code></p>
</li>
<li><p>delete 删除指定的某个断点<br><code>delete breakpoint</code></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//该命令将会删除编号为1的断点  </span><br><span class="line">(gdb) delete breakpoint 1  </span><br><span class="line">  </span><br><span class="line">//如果不带编号参数，将删除所有的断点  </span><br><span class="line">(gdb) delete breakpoint</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>禁止、允许使用某个断点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disable breakpoint 1</span><br><span class="line">enable breakpoint 1</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>该命令将禁止、允许断点 1，同时断点信息的 (Enb)域将变为 n、y</p>
<h2 id="六、单步执行"><a href="#六、单步执行" class="headerlink" title="六、单步执行"></a>六、单步执行</h2><p><code>next / n</code><br>不进入的单步执行</p>
<p><code>step</code><br>进入的单步执行</p>
<p><code>finish</code><br>如果已经进入了某函数，而想退出该函数返回到它的调用函数中，可使用命令finish</p>
<p><code>until</code><br>结束当前循环</p>
<h2 id="七、函数的调用"><a href="#七、函数的调用" class="headerlink" title="七、函数的调用"></a>七、函数的调用</h2><p><code>call name</code><br>调用和执行一个函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) call gen_and_sork( 1234,1,0 )  </span><br><span class="line">(gdb) call printf(“abcd”)  </span><br><span class="line">$1=4</span><br></pre></td></tr></table></figure></p>
<h2 id="八、-原文件的搜索"><a href="#八、-原文件的搜索" class="headerlink" title="八、 原文件的搜索"></a>八、 原文件的搜索</h2><p>search text</p>
<p>该命令可显示在当前文件中包含text串的下一行。</p>
<p>reverse-search text</p>
<p>该命令可以显示包含text 的前一行。</p>
<p>小结：常用的 gdb 命令</p>
<p>backtrace / bt 显示程序中的当前位置和表示如何到达当前位置的栈跟踪（同义词：where）</p>
<p>breakpoint / b 在程序中设置一个断点</p>
<p>cd 改变当前工作目录</p>
<p>clear 删除刚才停止处的断点</p>
<p>commands 命中断点时，列出将要执行的命令</p>
<p>continue 从断点开始继续执行</p>
<p>delete 删除一个断点或监测点；也可与其他命令一起使用</p>
<p>display 程序停止时显示变量和表达时</p>
<p>down 下移栈帧，使得另一个函数成为当前函数</p>
<p>frame 选择下一条continue命令的帧</p>
<p>info 显示与该程序有关的各种信息</p>
<p>jump 在源程序中的另一点开始运行</p>
<p>kill 异常终止在gdb 控制下运行的程序</p>
<p>list 列出相应于正在执行的程序的原文件内容</p>
<p>next 执行下一个源程序行，从而执行其整体中的一个函数</p>
<p>print 显示变量或表达式的值</p>
<p>pwd 显示当前工作目录</p>
<p>ptype 显示一个数据结构（如一个结构或C++类）的内容</p>
<p>quit 退出gdb</p>
<p>reverse-search 在源文件中反向搜索正规表达式</p>
<p>run 执行该程序</p>
<p>search 在源文件中搜索正规表达式</p>
<p>set variable 给变量赋值</p>
<p>signal 将一个信号发送到正在运行的进程</p>
<p>step 执行下一个源程序行，必要时进入下一个函数</p>
<p>undisplay display 命令的反命令，不要显示表达式</p>
<p>until 结束当前循环</p>
<p>up 上移栈帧，使另一函数成为当前函数</p>
<p>watch 在程序中设置一个监测点（即数据断点）</p>
<p>whatis 显示变量或函数类型</p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2019/04/09/由Leetcode807引发的memset问题/">由Leetcode807引发的memset问题</a></h1>
  

      
        <time datetime="2019-04-09T02:41:26.000Z">2019-04-09</time>
      
    </header>
    <div class="entry">
      
        <p>做Leetcode807时遇到了memset初始化整个数组的问题，好久不用memset了，有些生疏了。</p>
<p>对数组来说，只能初始化为0，或者-1，其他的时候数字是不正确的。而对于字符数组来说，任意字符都可以。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 1. 字符数组初始化为&apos;A&apos;</span><br><span class="line">char a[5];</span><br><span class="line">memset(a, &apos;A&apos;, 5);  // OK!</span><br><span class="line">memset(a, 0, sizeof(char) * 5);  // OK!</span><br><span class="line"> </span><br><span class="line">// 2. 整数数组初始化为0</span><br><span class="line">int a[5];</span><br><span class="line">memset(a, 0, sizeof(int) * 5);  // OK!</span><br><span class="line">memset(a, 0, 20);  // OK!</span><br><span class="line"> </span><br><span class="line">// 3. 动态字符数组初始化为&apos;A&apos;</span><br><span class="line">char* a = new char[5];</span><br><span class="line">memset(a, &apos;A&apos;, 5);  // OK!</span><br><span class="line">memset(a, 0, sizeof(char) * 5);  // OK!</span><br><span class="line"> </span><br><span class="line">// 错误用法及改正用法示例：</span><br><span class="line">memset(a, &apos;A&apos;, sizeof(a));  // wrong! sizeof(a)相当于sizeof(char*)</span><br><span class="line">memset(a, &apos;A&apos;, sizeof(a[0]) * 5);  // OK!</span><br><span class="line"> </span><br><span class="line">// 4. 整数数组初始化为非0</span><br><span class="line">int a[5];</span><br><span class="line">fill(a, a+5, 1);  // OK!</span><br><span class="line">fill_n(a, 5, 1);  // OK!</span><br><span class="line"> </span><br><span class="line">// 错误用法示例：</span><br><span class="line">memset(a, 1, 5);  // wrong!</span><br><span class="line">memset(a, 1, sizeof(int) * 5)  // wrong!</span><br></pre></td></tr></table></figure>
<p>字符数组是字符型的，字符型占据内存大小是1Byte，而memset函数也是以字节为单位进行赋值的，所以你输出没有问题。而int数组是整型的，使用 memset还是按字节赋值，这样赋值完以后，每个数组元素的值实际上是0x01010101即十进制的16843009</p>
<p>memset主要用于字符型数组的初始化，整数型数组初始化为0时可以用memset。</p>
<p>memset在初始化动态数组时不能sizeof(数组名)，而应该sizeof(元素)*元素个数。</p>
<p>fill (fill_n)是超级大法，万物皆可fill。</p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2019/04/09/Leetcode807-Max-Increase-to-Keep-City-Skyline/">Leetcode807. Max Increase to Keep City Skyline</a></h1>
  

      
        <time datetime="2019-04-09T02:37:05.000Z">2019-04-09</time>
      
    </header>
    <div class="entry">
      
        <ol start="807">
<li>Max Increase to Keep City Skyline<br>Medium</li>
</ol>
<p>In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well. </p>
<p>At the end, the “skyline” when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city’s skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example.</p>
<p>What is the maximum total sum that the height of the buildings can be increased?</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]</span><br><span class="line">Output: 35</span><br><span class="line">Explanation: </span><br><span class="line">The grid is:</span><br><span class="line">[ [3, 0, 8, 4], </span><br><span class="line">  [2, 4, 5, 7],</span><br><span class="line">  [9, 2, 6, 3],</span><br><span class="line">  [0, 3, 1, 0] ]</span><br><span class="line"></span><br><span class="line">The skyline viewed from top or bottom is: [9, 4, 8, 7]</span><br><span class="line">The skyline viewed from left or right is: [8, 7, 9, 3]</span><br><span class="line"></span><br><span class="line">The grid after increasing the height of buildings without affecting skylines is:</span><br><span class="line"></span><br><span class="line">gridNew = [ [8, 4, 8, 7],</span><br><span class="line">            [7, 4, 7, 7],</span><br><span class="line">            [9, 4, 8, 7],</span><br><span class="line">            [3, 3, 3, 3] ]</span><br></pre></td></tr></table></figure></p>
<p>Notes:</p>
<ol>
<li>1 &lt; grid.length = grid[0].length &lt;= 50.</li>
<li>All heights grid[i][j] are in the range [0, 100].</li>
<li>All buildings in grid[i][j] occupy the entire grid cell: that is, they are a 1 x 1 x grid[i][j] rectangular prism.</li>
</ol>
<p>这道题非常简单，首先找到每行每列的最大值，然后每个元素要小于对应的最大值中的小者，比如grid[0][0]要小于topmax[0]和leftmax[0]之中的最小值，grid[0][1]要小于topmax[0]和leftmax[1]之中的最小值。为什么花了这么长时间呢，是因为傻逼了，max数组设成了4爆了。。。煞笔。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:  </span><br><span class="line">    int maxIncreaseKeepingSkyline(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;</span><br><span class="line">        int length = grid[0].size();</span><br><span class="line">        int* topmax,*leftmax;</span><br><span class="line">        topmax=(int*)malloc(sizeof(int)*length);</span><br><span class="line">        leftmax=(int*)malloc(sizeof(int)*length);</span><br><span class="line">        for(int i=0;i&lt;length;i++)</span><br><span class="line">            topmax[i]=leftmax[i]=0;</span><br><span class="line">        for(int i=0;i&lt;length;i++)</span><br><span class="line">            for(int j=0;j&lt;length;j++)&#123;</span><br><span class="line">                if(grid[i][j]&gt;topmax[i])</span><br><span class="line">                    topmax[i]=grid[i][j];</span><br><span class="line">                if(grid[i][j]&gt;leftmax[j])</span><br><span class="line">                    leftmax[j]=grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        int result=0;</span><br><span class="line">        for(int i=0;i&lt;length;i++)</span><br><span class="line">            for(int j=0;j&lt;length;j++)</span><br><span class="line">                result += ((leftmax[j]&gt;topmax[i]?topmax[i]:leftmax[j])-grid[i][j]);</span><br><span class="line">    return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2019/04/09/C-标准库之stack/">C++标准库之stack</a></h1>
  

      
        <time datetime="2019-04-09T02:08:40.000Z">2019-04-09</time>
      
    </header>
    <div class="entry">
      
        <table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
<th>复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>size()</td>
<td>返回栈的元素数</td>
<td>O(1)</td>
</tr>
<tr>
<td>top()</td>
<td>返回栈顶的元素</td>
<td>O(1)</td>
</tr>
<tr>
<td>pop()</td>
<td>从栈中取出并删除元素</td>
<td>O(1)</td>
</tr>
<tr>
<td>push(x)</td>
<td>向栈中添加元素x</td>
<td>O(1)</td>
</tr>
<tr>
<td>empty()</td>
<td>在栈为空时返回true</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p>贴一些代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    stack&lt;int&gt; S;</span><br><span class="line">    S.push(3);</span><br><span class="line">    S.push(7);</span><br><span class="line">    S.push(1);</span><br><span class="line">    cout &lt;&lt; S.size() &lt;&lt; &quot; &quot;;</span><br><span class="line">    cout &lt;&lt; S.top() &lt;&lt; &quot; &quot;;</span><br><span class="line">    S.pop();</span><br><span class="line">    cout &lt;&lt; S.top() &lt;&lt; &quot; &quot;;</span><br><span class="line">    S.pop();</span><br><span class="line">    cout &lt;&lt; S.top() &lt;&lt; &quot; &quot;;</span><br><span class="line">    S.push(5);</span><br><span class="line">    cout &lt;&lt; S.top() &lt;&lt; &quot; &quot;;</span><br><span class="line">    S.pop();</span><br><span class="line">    cout &lt;&lt; S.top() &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2019/04/09/Leetcode1021-Remove-Outermost-Parentheses/">Leetcode1021. Remove Outermost Parentheses</a></h1>
  

      
        <time datetime="2019-04-09T01:59:26.000Z">2019-04-09</time>
      
    </header>
    <div class="entry">
      
        <ol start="1021">
<li>Remove Outermost Parentheses<br>Easy</li>
</ol>
<p>A valid parentheses string is either empty (“”), “(“ + A + “)”, or A + B, where A and B are valid parentheses strings, and + represents string concatenation.  For example, “”, “()”, “(())()”, and “(()(()))” are all valid parentheses strings.</p>
<p>A valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.</p>
<p>Given a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + … + P_k, where P_i are primitive valid parentheses strings.</p>
<p>Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(()())(())&quot;</span><br><span class="line">Output: &quot;()()()&quot;</span><br><span class="line">Explanation: </span><br><span class="line">The input string is &quot;(()())(())&quot;, with primitive decomposition &quot;(()())&quot; + &quot;(())&quot;.</span><br><span class="line">After removing outer parentheses of each part, this is &quot;()()&quot; + &quot;()&quot; = &quot;()()()&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;(()())(())(()(()))&quot;</span><br><span class="line">Output: &quot;()()()()(())&quot;</span><br><span class="line">Explanation: </span><br><span class="line">The input string is &quot;(()())(())(()(()))&quot;, with primitive decomposition &quot;(()())&quot; + &quot;(())&quot; + &quot;(()(()))&quot;.</span><br><span class="line">After removing outer parentheses of each part, this is &quot;()()&quot; + &quot;()&quot; + &quot;()(())&quot; = &quot;()()()()(())&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: &quot;()()&quot;</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: </span><br><span class="line">The input string is &quot;()()&quot;, with primitive decomposition &quot;()&quot; + &quot;()&quot;.</span><br><span class="line">After removing outer parentheses of each part, this is &quot;&quot; + &quot;&quot; = &quot;&quot;.</span><br></pre></td></tr></table></figure></p>
<p>Note:</p>
<ol>
<li>S.length &lt;= 10000</li>
<li>S[i] is “(“ or “)”</li>
<li>S is a valid parentheses string</li>
</ol>
<p>比较简单，把最外边的一层括号移走，可以用栈，也可以用计数器。如果遇到左括号且栈不空说明这个左括号不是外边的括号，加到结果中，再把这个左括号压栈；如果是右括号，就先弹出栈，再判断如果栈不空则说明这个右括号也不是外边的括号，加到结果中。</p>
<p>不知道为啥我这个这么慢，反正过了就行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string removeOuterParentheses(string S) &#123;</span><br><span class="line">        string result=&quot;&quot;;</span><br><span class="line">        int length = S.length();</span><br><span class="line">        int ss=0;</span><br><span class="line">        for(int i=0;i&lt;length;i++)&#123;</span><br><span class="line">            if(S[i]==&apos;(&apos;)&#123;</span><br><span class="line">                if(ss!=0)</span><br><span class="line">                    result=result+&apos;(&apos;;</span><br><span class="line">                ss++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(S[i]==&apos;)&apos;)&#123;</span><br><span class="line">                ss--;</span><br><span class="line">                if(ss!=0)</span><br><span class="line">                    result=result+&quot;)&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2019/04/07/Leetcode9-Palindrome-Number/">Leetcode9. Palindrome Number</a></h1>
  

      
        <time datetime="2019-04-07T14:59:13.000Z">2019-04-07</time>
      
    </header>
    <div class="entry">
      
        <ol start="9">
<li>Palindrome Number<br>Easy</li>
</ol>
<p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 121</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: 10</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</span><br></pre></td></tr></table></figure></p>
<p>Follow up:</p>
<p>Could you solve it without converting the integer to a string?</p>
<p>回文数，如果是负数直接返回false，正数的话转成string再判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isPalindrome(int x) &#123;</span><br><span class="line">        int i=0;</span><br><span class="line">        if(x&lt;0)</span><br><span class="line">            return false;</span><br><span class="line">        int length = 0;</span><br><span class="line">        int str[100000];</span><br><span class="line">        while(x&gt;0)&#123;</span><br><span class="line">            str[i++]=(x%10);</span><br><span class="line">            x/=10;</span><br><span class="line">        &#125;</span><br><span class="line">        int middle = i/2;</span><br><span class="line">        int j=0;</span><br><span class="line">        while(j&lt;middle)&#123;</span><br><span class="line">            if(str[j]!=str[i-1-j])</span><br><span class="line">                return false;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2019/04/07/Leetcode26-Remove-Duplicates-from-Sorted-Array/">Leetcode26. Remove Duplicates from Sorted Array</a></h1>
  

      
        <time datetime="2019-04-07T14:07:04.000Z">2019-04-07</time>
      
    </header>
    <div class="entry">
      
        <ol start="26">
<li>Remove Duplicates from Sorted Array<br>Easy</li>
</ol>
<p>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [1,1,2],</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what you leave beyond the returned length.</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</span><br><span class="line"></span><br><span class="line">It doesn&apos;t matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure></p>
<p>Clarification:</p>
<p>Confused why the returned value is an integer but your answer is an array?</p>
<p>Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.</p>
<p>Internally you can think of this:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>真的是非常简单的一道题，但是因为某种原因WA了好几次。。。去掉重复的数并返回去重之后的长度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int length=nums.size();</span><br><span class="line">        if(length==0)</span><br><span class="line">            return 0;</span><br><span class="line">        int j=0;</span><br><span class="line">        for(int i=1;i&lt;length;i++)&#123;</span><br><span class="line">           if(nums[i]!=nums[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">                nums[j]=nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return j+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      
  </div>
</article>





  <article class="post">
  <div class="post-content">
    <header>
      
  
    <h1 class="title"><a href="/2019/04/07/Leetcode1-Two-Sum/">Leetcode1.Two Sum</a></h1>
  

      
        <time datetime="2019-04-07T13:47:36.000Z">2019-04-07</time>
      
    </header>
    <div class="entry">
      
        <ol>
<li>Two Sum<br>Easy</li>
</ol>
<p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>Example:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line"></span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure></p>
<p>也十分简单，不知道啥时候做的了，现在补上。就是找一对数，使二者之和等于target，可以暴力，也可以用巧妙的方法，下边有巧妙方法，是从solution中找的。</p>
<p>我的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        int length = nums.size(),j=-1;</span><br><span class="line">        for(int i=0;i&lt;length;i++)&#123;</span><br><span class="line">            for(j=i+1;j&lt;length;j++)</span><br><span class="line">                if(nums[j]==target-nums[i])&#123;</span><br><span class="line">                    result.push_back(i);</span><br><span class="line">                    result.push_back(j);</span><br><span class="line">                    return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>跟我一样的方法，用java实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        int complement = target - nums[i];</span><br><span class="line">        if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class="line">            return new int[] &#123; i, map.get(complement) &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    throw new IllegalArgumentException(&quot;No two sum solution&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第三种方法：One-pass Hash Table<br>It turns out we can do it in one-pass. While we iterate and inserting elements into the table, we also look back to check if current element’s complement already exists in the table. If it exists, we have found a solution and return immediately.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        int complement = target - nums[i];</span><br><span class="line">        if (map.containsKey(complement)) &#123;</span><br><span class="line">            return new int[] &#123; map.get(complement), i &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    throw new IllegalArgumentException(&quot;No two sum solution&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>反正都是很简单的。。。</p>

      
    </div>
      
        
        
      
      <div class="clearfix"></div>
      
  </div>
</article>






<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  

  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Recent Posts</h3>
  <ul class="entry">
    
      <li>
        <a href="/2019/04/09/Leetcode56-Merge-Intervals/">56. Merge Intervals</a>
      </li>
    
      <li>
        <a href="/2019/04/09/二叉树高频面试题和答案/">二叉树高频面试题和答案</a>
      </li>
    
      <li>
        <a href="/2019/04/09/gdb调试相关/">gdb调试相关</a>
      </li>
    
      <li>
        <a href="/2019/04/09/由Leetcode807引发的memset问题/">由Leetcode807引发的memset问题</a>
      </li>
    
      <li>
        <a href="/2019/04/09/Leetcode807-Max-Increase-to-Keep-City-Skyline/">Leetcode807. Max Increase to Keep City Skyline</a>
      </li>
    
  </ul>
</div>


  

  
<div class="widget tagcloud">
  <h3 class="title">Tag Cloud</h3>
  <div class="entry">
    <a href="/tags/Leetcode/" style="font-size: 20px;">Leetcode</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/日常/" style="font-size: 10px;">日常</a> <a href="/tags/积累/" style="font-size: 15px;">积累</a>
  </div>
</div>


</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2019 Hao Yu
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>



</body>
</html>

